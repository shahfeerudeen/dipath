"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// packages/ag-charts-community/src/main-modules.ts
var main_modules_exports = {};
__export(main_modules_exports, {
  AllCartesianCommunityModules: () => AllCartesianCommunityModules,
  AllCommunityModules: () => AllCommunityModules,
  AllPolarCommunityModules: () => AllPolarCommunityModules,
  CartesianChartModule: () => CartesianChartModule,
  CategoryAxisModule: () => CategoryAxisModule,
  GroupedCategoryAxisModule: () => GroupedCategoryAxisModule,
  LogAxisModule: () => LogAxisModule,
  ModuleRegistry: () => import_ag_charts_core146.ModuleRegistry,
  NewAreaSeriesModule: () => NewAreaSeriesModule,
  NewBarSeriesModule: () => NewBarSeriesModule,
  NewBubbleSeriesModule: () => NewBubbleSeriesModule,
  NewDonutSeriesModule: () => NewDonutSeriesModule,
  NewHistogramSeriesModule: () => NewHistogramSeriesModule,
  NewLineSeriesModule: () => NewLineSeriesModule,
  NewPieSeriesModule: () => NewPieSeriesModule,
  NewScatterSeriesModule: () => NewScatterSeriesModule,
  NumberAxisModule: () => NumberAxisModule,
  PolarChartModule: () => PolarChartModule,
  TimeAxisModule: () => TimeAxisModule,
  UnitTimeAxisModule: () => UnitTimeAxisModule
});
module.exports = __toCommonJS(main_modules_exports);

// packages/ag-charts-community/src/api/preset/presetModules.ts
var import_ag_charts_core11 = require("ag-charts-core");

// packages/ag-charts-community/src/chart/commonOptionsDefs.ts
var import_ag_charts_core3 = require("ag-charts-core");

// packages/ag-charts-community/src/chart/axesOptionsDefs.ts
var import_ag_charts_core2 = require("ag-charts-core");

// packages/ag-charts-community/src/util/time/index.ts
var time_exports = {};
__export(time_exports, {
  TimeInterval: () => TimeInterval,
  day: () => day,
  friday: () => friday,
  hour: () => hour,
  millisecond: () => millisecond,
  minute: () => minute,
  monday: () => monday,
  month: () => month,
  saturday: () => saturday,
  second: () => second,
  sunday: () => sunday,
  thursday: () => thursday,
  tuesday: () => tuesday,
  utcDay: () => utcDay,
  utcHour: () => utcHour,
  utcMinute: () => utcMinute,
  utcMonth: () => utcMonth,
  utcYear: () => utcYear,
  wednesday: () => wednesday,
  year: () => year
});

// packages/ag-charts-community/src/util/time/duration.ts
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// packages/ag-charts-community/src/util/time/interval.ts
var import_ag_charts_core = require("ag-charts-core");
var TimeInterval = class _TimeInterval {
  constructor(unit, milliseconds, hierarchy, _encode, _decode, step = 1, _rangeCallback) {
    this.unit = unit;
    this.milliseconds = milliseconds;
    this.hierarchy = hierarchy;
    this._encode = _encode;
    this._decode = _decode;
    this.step = step;
    this._rangeCallback = _rangeCallback;
  }
  static extent(start2, stop, visibleRange) {
    if (start2.getTime() > stop.getTime()) {
      [start2, stop] = [stop, start2];
      if (visibleRange != null) {
        visibleRange = [1 - visibleRange[1], 1 - visibleRange[0]];
      }
    }
    if (visibleRange != null) {
      const delta3 = stop.getTime() - start2.getTime();
      const t0 = start2.getTime();
      start2 = new Date(t0 + visibleRange[0] * delta3);
      stop = new Date(t0 + visibleRange[1] * delta3);
    }
    return [start2, stop];
  }
  getOffset(snapTo, step) {
    return Math.floor(this._encode(new Date(snapTo))) % step;
  }
  /**
   * Returns a new date representing the latest interval boundary date before or equal to date.
   * For example, `day.floor(date)` typically returns 12:00 AM local time on the given date.
   * @param date
   */
  floor(date5) {
    const d = new Date(date5);
    const e = this._encode(d);
    return this._decode(e);
  }
  /**
   * Returns a new date representing the earliest interval boundary date after or equal to date.
   * @param date
   */
  ceil(date5) {
    const d = new Date(Number(date5) - 1);
    const e = this._encode(d);
    return this._decode(e + 1);
  }
  rangeIndices(start2, stop, { extend = false, visibleRange = [0, 1], limit }) {
    [start2, stop] = _TimeInterval.extent(start2, stop, visibleRange);
    const e0 = this._encode(extend ? this.floor(start2) : this.ceil(start2));
    let e1 = this._encode(extend ? this.ceil(stop) : this.floor(stop));
    if (limit != null && e1 - e0 > limit) {
      e1 = e0 + limit;
    }
    return [e0, e1];
  }
  /**
   * Returns an array of dates representing every interval boundary after or equal to start (inclusive) and before stop (exclusive).
   * @param start Range start.
   * @param stop Range end.
   * @param extend If specified, the requested range will be extended to the closest "nice" values.
   */
  range(start2, stop, params = {}) {
    let rangeCallback;
    if (start2.getTime() > stop.getTime()) {
      rangeCallback = this._rangeCallback?.(stop, start2);
    } else {
      rangeCallback = this._rangeCallback?.(start2, stop);
    }
    const [e0, e1] = this.rangeIndices(start2, stop, params);
    const range3 = [];
    for (let e = e0; e <= e1; e++) {
      const d = this._decode(e);
      range3.push(d);
    }
    rangeCallback?.();
    return range3;
  }
  previous(date5) {
    return this._decode(this._encode(this.ceil(date5)) - 1);
  }
  next(date5) {
    return this._decode(this._encode(this.floor(date5)) + 1);
  }
  rangeCount(start2, stop, params = {}) {
    const [e0, e1] = this.rangeIndices(start2, stop, params);
    return e1 - e0;
  }
  /**
   * Returns a filtered view of this interval representing every step'th date.
   * It can be a number of minutes, hours, days etc.
   * Must be a positive integer.
   * @param step
   */
  every(step, options) {
    if (step === 1 && options?.snapTo != null)
      return this;
    const { unit, milliseconds, hierarchy, step: baseStep } = this;
    let offset4 = 0;
    let rangeCallback;
    const unsafeStep = step;
    step = Math.max(1, Math.round(step));
    if (unsafeStep !== step) {
      import_ag_charts_core.Logger.warnOnce(`interval step of [${unsafeStep}] rounded to [${step}].`);
    }
    const { snapTo = "start" } = options ?? {};
    if (typeof snapTo === "string") {
      const initialOffset = offset4;
      rangeCallback = (start2, stop) => {
        const s = snapTo === "start" ? start2 : stop;
        offset4 = this.getOffset(s, step);
        return () => offset4 = initialOffset;
      };
    } else if (typeof snapTo === "number") {
      offset4 = this.getOffset(new Date(snapTo), step);
    } else if (snapTo instanceof Date) {
      offset4 = this.getOffset(snapTo, step);
    }
    const encode13 = (date5) => Math.floor((this._encode(date5) - offset4) / step);
    const decode13 = (encoded) => this._decode(encoded * step + offset4);
    return new _TimeInterval(unit, milliseconds * step, hierarchy, encode13, decode13, baseStep * step, rangeCallback);
  }
};

// packages/ag-charts-community/src/util/time/year.ts
function encode(date5) {
  return date5.getFullYear();
}
function decode(encoded) {
  const d = /* @__PURE__ */ new Date();
  d.setFullYear(encoded);
  d.setMonth(0, 1);
  d.setHours(0, 0, 0, 0);
  return d;
}
var yearMs = (365 + 1 / 4 - 1 / 100 + 1 / 400) * 24 * 60 * 60 * 1e3;
var year = new TimeInterval("year", yearMs, void 0, encode, decode);

// packages/ag-charts-community/src/util/time/month.ts
function encode2(date5) {
  return date5.getFullYear() * 12 + date5.getMonth();
}
function decode2(encoded) {
  const y = Math.floor(encoded / 12);
  const month2 = encoded - y * 12;
  return new Date(y, month2, 1);
}
var month = new TimeInterval("month", year.milliseconds / 12, year, encode2, decode2);

// packages/ag-charts-community/src/util/time/day.ts
function encode3(date5) {
  const tzOffsetMs = date5.getTimezoneOffset() * durationMinute;
  return Math.floor((date5.getTime() - tzOffsetMs) / durationDay);
}
function decode3(encoded) {
  const d = new Date(1970, 0, 1);
  d.setDate(d.getDate() + encoded);
  return d;
}
var day = new TimeInterval("day", 24 * 60 * 60 * 1e3, month, encode3, decode3);

// packages/ag-charts-community/src/util/time/millisecond.ts
function encode4(date5) {
  return date5.getTime();
}
function decode4(encoded) {
  return new Date(encoded);
}
var millisecond = new TimeInterval("millisecond", 1, day, encode4, decode4);

// packages/ag-charts-community/src/util/time/second.ts
var offset = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;
function encode5(date5) {
  return Math.floor((date5.getTime() - offset) / durationSecond);
}
function decode5(encoded) {
  return new Date(offset + encoded * durationSecond);
}
var second = new TimeInterval("second", 1e3, day, encode5, decode5);

// packages/ag-charts-community/src/util/time/minute.ts
var offset2 = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;
function encode6(date5) {
  return Math.floor((date5.getTime() - offset2) / durationMinute);
}
function decode6(encoded) {
  return new Date(offset2 + encoded * durationMinute);
}
var minute = new TimeInterval("minute", 60 * 1e3, day, encode6, decode6);

// packages/ag-charts-community/src/util/time/hour.ts
var offset3 = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;
function encode7(date5) {
  return Math.floor((date5.getTime() - offset3) / durationHour);
}
function decode7(encoded) {
  return new Date(offset3 + encoded * durationHour);
}
var hour = new TimeInterval("hour", 60 * 60 * 1e3, day, encode7, decode7);

// packages/ag-charts-community/src/util/time/week.ts
function weekday(weekStart) {
  const thursday2 = 4;
  const dayShift = (7 + weekStart - thursday2) % 7;
  function encode13(date5) {
    const tzOffsetMs = date5.getTimezoneOffset() * durationMinute;
    return Math.floor((date5.getTime() - tzOffsetMs) / durationWeek - dayShift / 7);
  }
  function decode13(encoded) {
    const d = new Date(1970, 0, 1);
    d.setDate(d.getDate() + encoded * 7 + dayShift);
    return d;
  }
  return new TimeInterval("day", 7 * 24 * 60 * 60 * 1e3, month, encode13, decode13, 7);
}
var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

// packages/ag-charts-community/src/util/time/utcYear.ts
function encode8(date5) {
  return date5.getUTCFullYear();
}
function decode8(encoded) {
  const d = /* @__PURE__ */ new Date();
  d.setUTCFullYear(encoded);
  d.setUTCMonth(0, 1);
  d.setUTCHours(0, 0, 0, 0);
  return d;
}
var utcYear = new TimeInterval("year", year.milliseconds, void 0, encode8, decode8);

// packages/ag-charts-community/src/util/time/utcMonth.ts
function encode9(date5) {
  return date5.getUTCFullYear() * 12 + date5.getUTCMonth();
}
function decode9(encoded) {
  const year2 = Math.floor(encoded / 12);
  const m = encoded - year2 * 12;
  return new Date(Date.UTC(year2, m, 1));
}
var utcMonth = new TimeInterval("month", month.milliseconds, utcYear, encode9, decode9);

// packages/ag-charts-community/src/util/time/utcDay.ts
function encode10(date5) {
  return Math.floor(date5.getTime() / durationDay);
}
function decode10(encoded) {
  const d = /* @__PURE__ */ new Date(0);
  d.setUTCDate(d.getUTCDate() + encoded);
  d.setUTCHours(0, 0, 0, 0);
  return d;
}
var utcDay = new TimeInterval("day", 24 * 60 * 60 * 1e3, utcMonth, encode10, decode10);

// packages/ag-charts-community/src/util/time/utcMinute.ts
function encode11(date5) {
  return Math.floor(date5.getTime() / durationMinute);
}
function decode11(encoded) {
  return new Date(encoded * durationMinute);
}
var utcMinute = new TimeInterval("minute", 60 * 1e3, utcDay, encode11, decode11);

// packages/ag-charts-community/src/util/time/utcHour.ts
function encode12(date5) {
  return Math.floor(date5.getTime() / durationHour);
}
function decode12(encoded) {
  return new Date(encoded * durationHour);
}
var utcHour = new TimeInterval("hour", 60 * 60 * 1e3, utcDay, encode12, decode12);

// packages/ag-charts-community/src/chart/axesOptionsDefs.ts
var timeIntervalUnit = (0, import_ag_charts_core2.union)("millisecond", "second", "minute", "hour", "day", "month", "year");
var numberFormatValidator = (0, import_ag_charts_core2.attachDescription)(import_ag_charts_core2.isValidNumberFormat, "a valid number format string");
var commonCrossLineLabelOptionsDefs = {
  enabled: import_ag_charts_core2.boolean,
  text: import_ag_charts_core2.string,
  padding: import_ag_charts_core2.number,
  ...import_ag_charts_core2.fontOptionsDef
};
var commonCrossLineOptionsDefs = (0, import_ag_charts_core2.attachDescription)(
  {
    enabled: import_ag_charts_core2.boolean,
    type: (0, import_ag_charts_core2.required)((0, import_ag_charts_core2.union)("line", "range")),
    range: (0, import_ag_charts_core2.and)(
      (0, import_ag_charts_core2.attachDescription)((_, { options }) => options.type === "range", "crossLine type to be 'range'"),
      (0, import_ag_charts_core2.arrayOf)(import_ag_charts_core2.defined),
      (0, import_ag_charts_core2.arrayLength)(2, 2)
    ),
    value: (0, import_ag_charts_core2.and)(
      (0, import_ag_charts_core2.attachDescription)((_, { options }) => options.type === "line", "crossLine type to be 'line'"),
      import_ag_charts_core2.defined
    ),
    label: commonCrossLineLabelOptionsDefs,
    fill: import_ag_charts_core2.string,
    fillOpacity: import_ag_charts_core2.ratio,
    ...import_ag_charts_core2.strokeOptionsDef,
    ...import_ag_charts_core2.lineDashOptionsDef
  },
  "cross-line options"
);
var cartesianCrossLineOptionsDefs = {
  ...commonCrossLineOptionsDefs,
  label: {
    ...commonCrossLineLabelOptionsDefs,
    position: (0, import_ag_charts_core2.union)(
      "top",
      "left",
      "right",
      "bottom",
      "top-left",
      "top-right",
      "bottom-left",
      "bottom-right",
      "inside",
      "inside-left",
      "inside-right",
      "inside-top",
      "inside-bottom",
      "inside-top-left",
      "inside-bottom-left",
      "inside-top-right",
      "inside-bottom-right"
    ),
    rotation: import_ag_charts_core2.number
  }
};
var commonAxisLabelOptionsDefs = {
  enabled: import_ag_charts_core2.boolean,
  rotation: import_ag_charts_core2.number,
  avoidCollisions: import_ag_charts_core2.boolean,
  minSpacing: import_ag_charts_core2.positiveNumber,
  spacing: import_ag_charts_core2.positiveNumber,
  formatter: import_ag_charts_core2.callback,
  itemStyler: (0, import_ag_charts_core2.callbackDefs)({
    ...import_ag_charts_core2.fontOptionsDef,
    spacing: import_ag_charts_core2.number
  }),
  ...import_ag_charts_core2.fontOptionsDef
};
var cartesianAxisLabelOptionsDefs = {
  autoRotate: import_ag_charts_core2.boolean,
  autoRotateAngle: import_ag_charts_core2.number,
  ...commonAxisLabelOptionsDefs
};
var cartesianNumericAxisLabel = {
  format: numberFormatValidator,
  ...cartesianAxisLabelOptionsDefs
};
var cartesianTimeAxisLabel = {
  format: (0, import_ag_charts_core2.or)(import_ag_charts_core2.string, import_ag_charts_core2.object),
  ...cartesianAxisLabelOptionsDefs
};
var cartesianAxisTick = {
  enabled: import_ag_charts_core2.boolean,
  width: import_ag_charts_core2.positiveNumber,
  size: import_ag_charts_core2.positiveNumber,
  stroke: import_ag_charts_core2.color
};
var cartesianTimeAxisParentLevel = {
  enabled: import_ag_charts_core2.boolean,
  label: cartesianTimeAxisLabel,
  tick: cartesianAxisTick
};
var commonAxisOptionsDefs = {
  reverse: import_ag_charts_core2.boolean,
  gridLine: {
    enabled: import_ag_charts_core2.boolean,
    width: import_ag_charts_core2.positiveNumber,
    style: (0, import_ag_charts_core2.arrayOfDefs)(
      {
        stroke: (0, import_ag_charts_core2.or)(import_ag_charts_core2.color, import_ag_charts_core2.themeOperator),
        lineDash: (0, import_ag_charts_core2.arrayOf)(import_ag_charts_core2.positiveNumber)
      },
      "a grid-line style object array"
    )
  },
  interval: {
    values: (0, import_ag_charts_core2.arrayOf)(import_ag_charts_core2.defined),
    minSpacing: import_ag_charts_core2.positiveNumber
  },
  label: commonAxisLabelOptionsDefs,
  line: {
    enabled: import_ag_charts_core2.boolean,
    width: import_ag_charts_core2.positiveNumber,
    stroke: import_ag_charts_core2.color
  },
  tick: cartesianAxisTick
};
commonAxisOptionsDefs.context = (0, import_ag_charts_core2.undocumented)(() => true);
commonAxisOptionsDefs.layoutConstraints = (0, import_ag_charts_core2.undocumented)({
  stacked: (0, import_ag_charts_core2.required)(import_ag_charts_core2.boolean),
  align: (0, import_ag_charts_core2.required)((0, import_ag_charts_core2.union)("start", "end")),
  unit: (0, import_ag_charts_core2.required)((0, import_ag_charts_core2.union)("percent", "px")),
  width: (0, import_ag_charts_core2.required)(import_ag_charts_core2.positiveNumber)
});
var cartesianAxisOptionsDefs = {
  ...commonAxisOptionsDefs,
  keys: (0, import_ag_charts_core2.arrayOf)(import_ag_charts_core2.string),
  crossLines: (0, import_ag_charts_core2.arrayOfDefs)(cartesianCrossLineOptionsDefs, "a cross-line options array"),
  position: (0, import_ag_charts_core2.union)("top", "right", "bottom", "left"),
  thickness: import_ag_charts_core2.positiveNumber,
  title: {
    enabled: import_ag_charts_core2.boolean,
    text: import_ag_charts_core2.string,
    spacing: import_ag_charts_core2.positiveNumber,
    formatter: import_ag_charts_core2.callback,
    ...import_ag_charts_core2.fontOptionsDef
  }
};
cartesianAxisOptionsDefs.title._enabledFromTheme = (0, import_ag_charts_core2.undocumented)(import_ag_charts_core2.boolean);
function cartesianAxisCrosshairOptions(canFormat) {
  const crosshairLabel = {
    enabled: import_ag_charts_core2.boolean,
    xOffset: import_ag_charts_core2.number,
    yOffset: import_ag_charts_core2.number,
    renderer: (0, import_ag_charts_core2.callbackOf)(
      (0, import_ag_charts_core2.or)(
        import_ag_charts_core2.string,
        (0, import_ag_charts_core2.optionsDefs)(
          {
            text: import_ag_charts_core2.string,
            color: import_ag_charts_core2.color,
            backgroundColor: import_ag_charts_core2.color,
            opacity: import_ag_charts_core2.ratio
          },
          "crosshair label renderer result object"
        )
      )
    )
  };
  if (canFormat) {
    crosshairLabel.format = import_ag_charts_core2.string;
  }
  return {
    enabled: import_ag_charts_core2.boolean,
    snap: import_ag_charts_core2.boolean,
    label: crosshairLabel,
    ...import_ag_charts_core2.strokeOptionsDef,
    ...import_ag_charts_core2.lineDashOptionsDef
  };
}
function continuousAxisOptions(validDatum, supportTimeInterval) {
  return {
    min: (0, import_ag_charts_core2.and)(validDatum, (0, import_ag_charts_core2.lessThan)("max")),
    max: (0, import_ag_charts_core2.and)(validDatum, (0, import_ag_charts_core2.greaterThan)("min")),
    nice: import_ag_charts_core2.boolean,
    interval: {
      step: supportTimeInterval ? (0, import_ag_charts_core2.or)(import_ag_charts_core2.positiveNumberNonZero, timeIntervalUnit, (0, import_ag_charts_core2.instanceOf)(TimeInterval)) : import_ag_charts_core2.positiveNumberNonZero,
      values: (0, import_ag_charts_core2.arrayOf)(validDatum),
      minSpacing: (0, import_ag_charts_core2.and)(import_ag_charts_core2.positiveNumber, (0, import_ag_charts_core2.lessThan)("maxSpacing")),
      maxSpacing: (0, import_ag_charts_core2.and)(import_ag_charts_core2.positiveNumber, (0, import_ag_charts_core2.greaterThan)("minSpacing"))
    }
  };
}

// packages/ag-charts-community/src/chart/commonOptionsDefs.ts
var shapeValidator = (0, import_ag_charts_core3.or)(
  (0, import_ag_charts_core3.union)("circle", "cross", "diamond", "heart", "plus", "pin", "square", "star", "triangle"),
  import_ag_charts_core3.callback
);
var textWrapValidator = (0, import_ag_charts_core3.union)("never", "always", "hyphenate", "on-space");
var tooltipPlacementValidator = (0, import_ag_charts_core3.union)(
  "top",
  "right",
  "bottom",
  "left",
  "top-right",
  "bottom-right",
  "bottom-left",
  "top-left",
  "center"
);
var tooltipDeprecatedTypeValidator = (0, import_ag_charts_core3.union)(
  "pointer",
  "node",
  "top",
  "right",
  "bottom",
  "left",
  "top-left",
  "top-right",
  "bottom-left",
  "bottom-right"
);
var rangeValidator = (0, import_ag_charts_core3.or)(import_ag_charts_core3.positiveNumber, (0, import_ag_charts_core3.union)("exact", "nearest"));
var zoomAnchorPoint = (0, import_ag_charts_core3.union)("pointer", "start", "middle", "end");
var chartCaptionOptionsDefs = {
  enabled: import_ag_charts_core3.boolean,
  text: import_ag_charts_core3.string,
  textAlign: (0, import_ag_charts_core3.union)("left", "center", "right"),
  wrapping: (0, import_ag_charts_core3.union)("never", "always", "hyphenate", "on-space"),
  spacing: import_ag_charts_core3.positiveNumber,
  maxWidth: import_ag_charts_core3.positiveNumber,
  maxHeight: import_ag_charts_core3.positiveNumber,
  ...import_ag_charts_core3.fontOptionsDef
};
chartCaptionOptionsDefs.padding = (0, import_ag_charts_core3.undocumented)(import_ag_charts_core3.positiveNumber);
var chartOverlayOptionsDefs = {
  enabled: import_ag_charts_core3.boolean,
  text: import_ag_charts_core3.string,
  renderer: (0, import_ag_charts_core3.callbackOf)((0, import_ag_charts_core3.or)(import_ag_charts_core3.string, import_ag_charts_core3.htmlElement))
};
var contextMenuItemLiterals = [
  "defaults",
  "download",
  "zoom-to-cursor",
  "pan-to-cursor",
  "toggle-series-visibility",
  "toggle-other-series",
  "separator"
];
var contextMenuItemObjectDef = {
  type: (0, import_ag_charts_core3.union)("action", "separator"),
  showOn: (0, import_ag_charts_core3.union)("always", "series-area", "series-node", "legend-item"),
  label: (0, import_ag_charts_core3.required)(import_ag_charts_core3.string),
  enabled: import_ag_charts_core3.boolean,
  action: import_ag_charts_core3.callback,
  items: (value, context) => contextMenuItemsArray(value, context)
};
contextMenuItemObjectDef.iconUrl = (0, import_ag_charts_core3.undocumented)(import_ag_charts_core3.string);
var contextMenuItemObjectValidator = (0, import_ag_charts_core3.optionsDefs)(contextMenuItemObjectDef);
var contextMenuItemValidator = (0, import_ag_charts_core3.attachDescription)(
  (value, context) => {
    let result;
    if (typeof value === "string") {
      const allowedValues = contextMenuItemLiterals;
      if (allowedValues.includes(value)) {
        result = true;
      } else {
        result = { valid: false, invalid: [], cleared: null };
        result.invalid.push(
          new import_ag_charts_core3.ValidationError(
            import_ag_charts_core3.ErrorType.Invalid,
            `a context menu item string alias: ["${contextMenuItemLiterals.join('", "')}"]`,
            value,
            context.path
          )
        );
      }
    } else {
      result = contextMenuItemObjectValidator(value, context);
    }
    return result;
  },
  `a context menu item object or string alias: [${contextMenuItemLiterals.join(", ")}]`
);
var contextMenuItemsArray = (0, import_ag_charts_core3.arrayOf)(contextMenuItemValidator, "a menu items array", false);
var contextMenuActionsArray = (0, import_ag_charts_core3.arrayOfDefs)(
  {
    label: (0, import_ag_charts_core3.required)(import_ag_charts_core3.string),
    action: (0, import_ag_charts_core3.required)(import_ag_charts_core3.callback)
  },
  "a context menu actions array"
);
var toolbarButtonOptionsDefs = {
  label: import_ag_charts_core3.string,
  ariaLabel: import_ag_charts_core3.string,
  tooltip: import_ag_charts_core3.string,
  icon: (0, import_ag_charts_core3.union)(
    "align-center",
    "align-left",
    "align-right",
    "arrow-drawing",
    "arrow-down-drawing",
    "arrow-up-drawing",
    "callout-annotation",
    "candlestick-series",
    "close",
    "comment-annotation",
    "date-range-drawing",
    "date-price-range-drawing",
    "delete",
    "disjoint-channel-drawing",
    "drag-handle",
    "fill-color",
    "line-style-solid",
    "line-style-dashed",
    "line-style-dotted",
    "high-low-series",
    "hlc-series",
    "hollow-candlestick-series",
    "horizontal-line-drawing",
    "line-color",
    "line-series",
    "line-with-markers-series",
    "locked",
    "measurer-drawing",
    "note-annotation",
    "ohlc-series",
    "pan-end",
    "pan-left",
    "pan-right",
    "pan-start",
    "parallel-channel-drawing",
    "position-bottom",
    "position-center",
    "position-top",
    "price-label-annotation",
    "price-range-drawing",
    "reset",
    "settings",
    "step-line-series",
    "text-annotation",
    "trend-line-drawing",
    "fibonacci-retracement-drawing",
    "fibonacci-retracement-trend-based-drawing",
    "unlocked",
    "vertical-line-drawing",
    "zoom-in",
    "zoom-out"
  )
};
var commonChartOptionsDefs = {
  width: import_ag_charts_core3.positiveNumber,
  height: import_ag_charts_core3.positiveNumber,
  minWidth: import_ag_charts_core3.positiveNumber,
  minHeight: import_ag_charts_core3.positiveNumber,
  suppressFieldDotNotation: import_ag_charts_core3.boolean,
  title: chartCaptionOptionsDefs,
  subtitle: chartCaptionOptionsDefs,
  footnote: chartCaptionOptionsDefs,
  padding: {
    top: import_ag_charts_core3.positiveNumber,
    right: import_ag_charts_core3.positiveNumber,
    bottom: import_ag_charts_core3.positiveNumber,
    left: import_ag_charts_core3.positiveNumber
  },
  seriesArea: {
    clip: import_ag_charts_core3.boolean,
    padding: {
      top: import_ag_charts_core3.positiveNumber,
      right: import_ag_charts_core3.positiveNumber,
      bottom: import_ag_charts_core3.positiveNumber,
      left: import_ag_charts_core3.positiveNumber
    }
  },
  legend: {
    enabled: import_ag_charts_core3.boolean,
    position: (0, import_ag_charts_core3.union)("top", "right", "bottom", "left"),
    orientation: (0, import_ag_charts_core3.union)("horizontal", "vertical"),
    maxWidth: import_ag_charts_core3.positiveNumber,
    maxHeight: import_ag_charts_core3.positiveNumber,
    spacing: import_ag_charts_core3.positiveNumber,
    preventHidingAll: import_ag_charts_core3.boolean,
    reverseOrder: import_ag_charts_core3.boolean,
    toggleSeries: import_ag_charts_core3.boolean,
    item: {
      marker: {
        size: import_ag_charts_core3.positiveNumber,
        shape: shapeValidator,
        padding: import_ag_charts_core3.positiveNumber,
        strokeWidth: import_ag_charts_core3.positiveNumber
      },
      line: {
        length: import_ag_charts_core3.positiveNumber,
        strokeWidth: import_ag_charts_core3.positiveNumber
      },
      label: {
        maxLength: import_ag_charts_core3.positiveNumber,
        formatter: import_ag_charts_core3.callback,
        ...import_ag_charts_core3.fontOptionsDef
      },
      maxWidth: import_ag_charts_core3.positiveNumber,
      paddingX: import_ag_charts_core3.positiveNumber,
      paddingY: import_ag_charts_core3.positiveNumber,
      showSeriesStroke: import_ag_charts_core3.boolean
    },
    pagination: {
      marker: {
        size: import_ag_charts_core3.positiveNumber,
        shape: shapeValidator,
        padding: import_ag_charts_core3.positiveNumber
      },
      activeStyle: {
        ...import_ag_charts_core3.fillOptionsDef,
        ...import_ag_charts_core3.strokeOptionsDef
      },
      inactiveStyle: {
        ...import_ag_charts_core3.fillOptionsDef,
        ...import_ag_charts_core3.strokeOptionsDef
      },
      highlightStyle: {
        ...import_ag_charts_core3.fillOptionsDef,
        ...import_ag_charts_core3.strokeOptionsDef
      },
      label: import_ag_charts_core3.fontOptionsDef
    },
    listeners: {
      legendItemClick: import_ag_charts_core3.callback,
      legendItemDoubleClick: import_ag_charts_core3.callback
    }
  },
  gradientLegend: {
    enabled: import_ag_charts_core3.boolean,
    position: (0, import_ag_charts_core3.union)("top", "right", "bottom", "left"),
    spacing: import_ag_charts_core3.positiveNumber,
    reverseOrder: import_ag_charts_core3.boolean,
    gradient: {
      preferredLength: import_ag_charts_core3.positiveNumber,
      thickness: import_ag_charts_core3.positiveNumber
    },
    scale: {
      label: {
        ...import_ag_charts_core3.fontOptionsDef,
        format: numberFormatValidator,
        formatter: import_ag_charts_core3.callback
      },
      padding: import_ag_charts_core3.positiveNumber,
      interval: {
        step: import_ag_charts_core3.number,
        values: import_ag_charts_core3.array,
        minSpacing: (0, import_ag_charts_core3.and)(import_ag_charts_core3.positiveNumber, (0, import_ag_charts_core3.lessThan)("maxSpacing")),
        maxSpacing: (0, import_ag_charts_core3.and)(import_ag_charts_core3.positiveNumber, (0, import_ag_charts_core3.greaterThan)("minSpacing"))
      }
    }
  },
  listeners: {
    seriesNodeClick: import_ag_charts_core3.callback,
    seriesNodeDoubleClick: import_ag_charts_core3.callback,
    seriesVisibilityChange: import_ag_charts_core3.callback,
    click: import_ag_charts_core3.callback,
    doubleClick: import_ag_charts_core3.callback,
    annotations: import_ag_charts_core3.callback,
    zoom: import_ag_charts_core3.callback
  },
  loadGoogleFonts: import_ag_charts_core3.boolean,
  highlight: {
    range: (0, import_ag_charts_core3.union)("tooltip", "node")
  },
  overlays: {
    loading: chartOverlayOptionsDefs,
    noData: chartOverlayOptionsDefs,
    noVisibleSeries: chartOverlayOptionsDefs,
    unsupportedBrowser: chartOverlayOptionsDefs
  },
  tooltip: {
    enabled: import_ag_charts_core3.boolean,
    showArrow: import_ag_charts_core3.boolean,
    pagination: import_ag_charts_core3.boolean,
    delay: import_ag_charts_core3.positiveNumber,
    range: rangeValidator,
    wrapping: textWrapValidator,
    mode: (0, import_ag_charts_core3.union)("single", "shared", "compact"),
    position: {
      type: tooltipDeprecatedTypeValidator,
      anchorTo: (0, import_ag_charts_core3.union)("pointer", "node", "chart"),
      placement: (0, import_ag_charts_core3.or)(tooltipPlacementValidator, (0, import_ag_charts_core3.arrayOf)(tooltipPlacementValidator)),
      xOffset: import_ag_charts_core3.number,
      yOffset: import_ag_charts_core3.number
    }
  },
  animation: {
    enabled: import_ag_charts_core3.boolean,
    duration: import_ag_charts_core3.positiveNumber
  },
  contextMenu: {
    enabled: import_ag_charts_core3.boolean,
    items: contextMenuItemsArray,
    extraActions: contextMenuActionsArray,
    extraSeriesAreaActions: contextMenuActionsArray,
    extraNodeActions: contextMenuActionsArray,
    extraLegendItemActions: contextMenuActionsArray
  },
  dataSource: {
    getData: import_ag_charts_core3.callback
  },
  keyboard: {
    enabled: import_ag_charts_core3.boolean,
    tabIndex: import_ag_charts_core3.number
  },
  touch: {
    dragAction: (0, import_ag_charts_core3.union)("none", "drag", "hover")
  },
  ranges: {
    enabled: import_ag_charts_core3.boolean,
    buttons: (0, import_ag_charts_core3.arrayOfDefs)(
      {
        ...toolbarButtonOptionsDefs,
        value: (0, import_ag_charts_core3.or)(import_ag_charts_core3.number, (0, import_ag_charts_core3.and)((0, import_ag_charts_core3.arrayOf)((0, import_ag_charts_core3.or)(import_ag_charts_core3.number, import_ag_charts_core3.date)), (0, import_ag_charts_core3.arrayLength)(2, 2)), import_ag_charts_core3.callback)
      },
      "range button options array"
    )
  },
  // modules
  locale: {
    localeText: import_ag_charts_core3.object,
    getLocaleText: (0, import_ag_charts_core3.callbackOf)(import_ag_charts_core3.string)
  },
  background: {
    visible: import_ag_charts_core3.boolean,
    fill: import_ag_charts_core3.color,
    // enterprise
    image: {
      url: (0, import_ag_charts_core3.required)(import_ag_charts_core3.string),
      top: import_ag_charts_core3.number,
      right: import_ag_charts_core3.number,
      bottom: import_ag_charts_core3.number,
      left: import_ag_charts_core3.number,
      width: import_ag_charts_core3.positiveNumber,
      height: import_ag_charts_core3.positiveNumber,
      opacity: import_ag_charts_core3.ratio
    }
  },
  styleNonce: import_ag_charts_core3.string,
  sync: {
    enabled: import_ag_charts_core3.boolean,
    groupId: import_ag_charts_core3.string,
    axes: (0, import_ag_charts_core3.union)("x", "y", "xy"),
    nodeInteraction: import_ag_charts_core3.boolean,
    zoom: import_ag_charts_core3.boolean
  },
  zoom: {
    enabled: import_ag_charts_core3.boolean,
    enableAxisDragging: import_ag_charts_core3.boolean,
    enableDoubleClickToReset: import_ag_charts_core3.boolean,
    enablePanning: import_ag_charts_core3.boolean,
    enableScrolling: import_ag_charts_core3.boolean,
    enableSelecting: import_ag_charts_core3.boolean,
    enableTwoFingerZoom: import_ag_charts_core3.boolean,
    keepAspectRatio: import_ag_charts_core3.boolean,
    anchorPointX: zoomAnchorPoint,
    anchorPointY: zoomAnchorPoint,
    axes: (0, import_ag_charts_core3.union)("x", "y", "xy"),
    deceleration: (0, import_ag_charts_core3.or)((0, import_ag_charts_core3.union)("off", "short", "long"), import_ag_charts_core3.ratio),
    minVisibleItems: import_ag_charts_core3.positiveNumber,
    minVisibleItemsX: import_ag_charts_core3.positiveNumber,
    minVisibleItemsY: import_ag_charts_core3.positiveNumber,
    panKey: (0, import_ag_charts_core3.union)("alt", "ctrl", "meta", "shift"),
    scrollingStep: import_ag_charts_core3.ratio,
    autoScaling: {
      enabled: import_ag_charts_core3.boolean,
      padding: import_ag_charts_core3.ratio
    },
    buttons: {
      enabled: import_ag_charts_core3.boolean,
      buttons: (0, import_ag_charts_core3.arrayOfDefs)(
        {
          ...toolbarButtonOptionsDefs,
          value: (0, import_ag_charts_core3.union)("reset", "zoom-in", "zoom-out", "pan-left", "pan-right", "pan-start", "pan-end"),
          section: import_ag_charts_core3.string
        },
        "zoom button options array"
      ),
      visible: (0, import_ag_charts_core3.union)("always", "zoomed", "hover")
    }
  }
};
commonChartOptionsDefs.dataSource.requestThrottle = (0, import_ag_charts_core3.undocumented)(import_ag_charts_core3.positiveNumber);
commonChartOptionsDefs.dataSource.updateThrottle = (0, import_ag_charts_core3.undocumented)(import_ag_charts_core3.positiveNumber);
commonChartOptionsDefs.dataSource.updateDuringInteraction = (0, import_ag_charts_core3.undocumented)(import_ag_charts_core3.boolean);
commonChartOptionsDefs.zoom.enableIndependentAxes = (0, import_ag_charts_core3.undocumented)(import_ag_charts_core3.boolean);
commonChartOptionsDefs.statusBar = (0, import_ag_charts_core3.undocumented)(import_ag_charts_core3.defined);
commonChartOptionsDefs.foreground = (0, import_ag_charts_core3.undocumented)({
  visible: import_ag_charts_core3.boolean,
  text: import_ag_charts_core3.string,
  image: {
    url: import_ag_charts_core3.string,
    top: import_ag_charts_core3.number,
    right: import_ag_charts_core3.number,
    bottom: import_ag_charts_core3.number,
    left: import_ag_charts_core3.number,
    width: import_ag_charts_core3.positiveNumber,
    height: import_ag_charts_core3.positiveNumber,
    opacity: import_ag_charts_core3.ratio
  },
  ...import_ag_charts_core3.fillOptionsDef
});
commonChartOptionsDefs.context = (0, import_ag_charts_core3.undocumented)(() => true);
commonChartOptionsDefs.overrideDevicePixelRatio = (0, import_ag_charts_core3.undocumented)(import_ag_charts_core3.number);
commonChartOptionsDefs.sync.domainMode = (0, import_ag_charts_core3.undocumented)((0, import_ag_charts_core3.union)("direction", "position", "key"));
var commonSeriesThemeableOptionsDefs = {
  cursor: import_ag_charts_core3.string,
  showInLegend: import_ag_charts_core3.boolean,
  nodeClickRange: rangeValidator,
  listeners: {
    nodeClick: import_ag_charts_core3.callback,
    nodeDoubleClick: import_ag_charts_core3.callback
  },
  highlightStyle: {
    item: { ...import_ag_charts_core3.fillOptionsDef, ...import_ag_charts_core3.strokeOptionsDef },
    series: {
      enabled: import_ag_charts_core3.boolean,
      dimOpacity: import_ag_charts_core3.ratio,
      strokeWidth: import_ag_charts_core3.positiveNumber
    }
  }
};
var commonSeriesOptionsDefs = {
  ...commonSeriesThemeableOptionsDefs,
  id: import_ag_charts_core3.string,
  visible: import_ag_charts_core3.boolean,
  data: import_ag_charts_core3.array
};
commonSeriesOptionsDefs.context = (0, import_ag_charts_core3.undocumented)(() => true);
commonSeriesOptionsDefs.seriesGrouping = (0, import_ag_charts_core3.undocumented)(import_ag_charts_core3.defined);
commonSeriesOptionsDefs.highlight = (0, import_ag_charts_core3.undocumented)({ enabled: import_ag_charts_core3.boolean });
var markerOptionsDefs = {
  enabled: import_ag_charts_core3.boolean,
  shape: shapeValidator,
  size: import_ag_charts_core3.positiveNumber,
  itemStyler: (0, import_ag_charts_core3.callbackDefs)({
    ...import_ag_charts_core3.fillOptionsDef,
    ...import_ag_charts_core3.strokeOptionsDef,
    ...import_ag_charts_core3.lineDashOptionsDef,
    shape: shapeValidator,
    size: import_ag_charts_core3.positiveNumber
  }),
  ...import_ag_charts_core3.fillOptionsDef,
  ...import_ag_charts_core3.strokeOptionsDef,
  ...import_ag_charts_core3.lineDashOptionsDef
};
var seriesLabelOptionsDefs = {
  enabled: import_ag_charts_core3.boolean,
  formatter: import_ag_charts_core3.callback,
  ...import_ag_charts_core3.fontOptionsDef
};
var autoSizedLabelOptionsDefs = {
  ...seriesLabelOptionsDefs,
  lineHeight: import_ag_charts_core3.positiveNumber,
  minimumFontSize: import_ag_charts_core3.positiveNumber,
  wrapping: textWrapValidator,
  overflowStrategy: (0, import_ag_charts_core3.union)("ellipsis", "hide")
};
var errorBarThemeableOptionsDefs = {
  visible: import_ag_charts_core3.boolean,
  cap: {
    visible: import_ag_charts_core3.boolean,
    length: import_ag_charts_core3.positiveNumber,
    lengthRatio: import_ag_charts_core3.ratio,
    ...import_ag_charts_core3.strokeOptionsDef,
    ...import_ag_charts_core3.lineDashOptionsDef
  },
  ...import_ag_charts_core3.strokeOptionsDef,
  ...import_ag_charts_core3.lineDashOptionsDef
};
var errorBarOptionsDefs = {
  ...errorBarThemeableOptionsDefs,
  xLowerKey: import_ag_charts_core3.string,
  xUpperKey: import_ag_charts_core3.string,
  yLowerKey: import_ag_charts_core3.string,
  yUpperKey: import_ag_charts_core3.string,
  xLowerName: import_ag_charts_core3.string,
  xUpperName: import_ag_charts_core3.string,
  yLowerName: import_ag_charts_core3.string,
  yUpperName: import_ag_charts_core3.string,
  itemStyler: (0, import_ag_charts_core3.callbackDefs)({
    visible: import_ag_charts_core3.boolean,
    ...import_ag_charts_core3.strokeOptionsDef,
    ...import_ag_charts_core3.lineDashOptionsDef,
    cap: {
      visible: import_ag_charts_core3.boolean,
      length: import_ag_charts_core3.positiveNumber,
      lengthRatio: import_ag_charts_core3.ratio,
      ...import_ag_charts_core3.strokeOptionsDef,
      ...import_ag_charts_core3.lineDashOptionsDef
    }
  })
};
var tooltipOptionsDefs = {
  enabled: import_ag_charts_core3.boolean,
  showArrow: import_ag_charts_core3.boolean,
  range: rangeValidator,
  renderer: (0, import_ag_charts_core3.callbackOf)(
    (0, import_ag_charts_core3.or)(
      import_ag_charts_core3.string,
      (0, import_ag_charts_core3.optionsDefs)(
        {
          heading: import_ag_charts_core3.string,
          title: import_ag_charts_core3.string,
          data: (0, import_ag_charts_core3.arrayOfDefs)({
            label: (0, import_ag_charts_core3.required)(import_ag_charts_core3.string),
            value: (0, import_ag_charts_core3.required)(import_ag_charts_core3.string)
          })
        },
        "tooltip renderer result object"
      )
    )
  ),
  position: {
    type: tooltipDeprecatedTypeValidator,
    anchorTo: (0, import_ag_charts_core3.union)("node", "pointer", "chart"),
    placement: (0, import_ag_charts_core3.or)(tooltipPlacementValidator, (0, import_ag_charts_core3.arrayOf)(tooltipPlacementValidator)),
    xOffset: import_ag_charts_core3.number,
    yOffset: import_ag_charts_core3.number
  },
  interaction: {
    enabled: import_ag_charts_core3.boolean
  }
};
tooltipOptionsDefs.position._seriesOverrideType = (0, import_ag_charts_core3.undocumented)(tooltipDeprecatedTypeValidator);
var shadowOptionsDefs = {
  enabled: import_ag_charts_core3.boolean,
  xOffset: import_ag_charts_core3.number,
  yOffset: import_ag_charts_core3.number,
  blur: import_ag_charts_core3.positiveNumber,
  color: import_ag_charts_core3.color
};
var interpolationOptionsDefs = (0, import_ag_charts_core3.typeUnion)(
  {
    linear: {},
    smooth: {
      tension: import_ag_charts_core3.ratio
    },
    step: {
      position: (0, import_ag_charts_core3.union)("start", "middle", "end")
    }
  },
  "interpolation line options"
);

// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesOptionsDef.ts
var import_ag_charts_core4 = require("ag-charts-core");
var areaSeriesThemeableOptionsDef = {
  showInMiniChart: import_ag_charts_core4.boolean,
  connectMissingData: import_ag_charts_core4.boolean,
  interpolation: interpolationOptionsDefs,
  label: seriesLabelOptionsDefs,
  marker: markerOptionsDefs,
  tooltip: tooltipOptionsDefs,
  shadow: shadowOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...import_ag_charts_core4.fillOptionsDef,
  ...import_ag_charts_core4.strokeOptionsDef,
  ...import_ag_charts_core4.lineDashOptionsDef
};
var areaSeriesOptionsDef = {
  ...areaSeriesThemeableOptionsDef,
  ...commonSeriesOptionsDefs,
  type: (0, import_ag_charts_core4.required)((0, import_ag_charts_core4.constant)("area")),
  xKey: (0, import_ag_charts_core4.required)(import_ag_charts_core4.string),
  yKey: (0, import_ag_charts_core4.required)(import_ag_charts_core4.string),
  xName: import_ag_charts_core4.string,
  yName: import_ag_charts_core4.string,
  stacked: import_ag_charts_core4.boolean,
  stackGroup: import_ag_charts_core4.string,
  normalizedTo: import_ag_charts_core4.number
};

// packages/ag-charts-community/src/chart/series/cartesian/barSeriesOptionsDef.ts
var import_ag_charts_core5 = require("ag-charts-core");
var barSeriesThemeableOptionsDef = {
  direction: (0, import_ag_charts_core5.union)("horizontal", "vertical"),
  showInMiniChart: import_ag_charts_core5.boolean,
  cornerRadius: import_ag_charts_core5.positiveNumber,
  itemStyler: (0, import_ag_charts_core5.callbackDefs)({
    ...import_ag_charts_core5.fillOptionsDef,
    ...import_ag_charts_core5.strokeOptionsDef,
    ...import_ag_charts_core5.lineDashOptionsDef,
    cornerRadius: import_ag_charts_core5.positiveNumber
  }),
  crisp: import_ag_charts_core5.boolean,
  label: {
    ...seriesLabelOptionsDefs,
    placement: (0, import_ag_charts_core5.union)("inside-center", "inside-start", "inside-end", "outside-start", "outside-end"),
    padding: import_ag_charts_core5.positiveNumber
  },
  errorBar: errorBarThemeableOptionsDefs,
  shadow: shadowOptionsDefs,
  tooltip: tooltipOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...import_ag_charts_core5.fillOptionsDef,
  ...import_ag_charts_core5.strokeOptionsDef,
  ...import_ag_charts_core5.lineDashOptionsDef
};
barSeriesThemeableOptionsDef.sparklineMode = (0, import_ag_charts_core5.undocumented)(import_ag_charts_core5.boolean);
var barSeriesOptionsDef = {
  ...barSeriesThemeableOptionsDef,
  ...commonSeriesOptionsDefs,
  type: (0, import_ag_charts_core5.required)((0, import_ag_charts_core5.constant)("bar")),
  xKey: (0, import_ag_charts_core5.required)(import_ag_charts_core5.string),
  yKey: (0, import_ag_charts_core5.required)(import_ag_charts_core5.string),
  xName: import_ag_charts_core5.string,
  yName: import_ag_charts_core5.string,
  direction: (0, import_ag_charts_core5.union)("horizontal", "vertical"),
  grouped: import_ag_charts_core5.boolean,
  stacked: import_ag_charts_core5.boolean,
  stackGroup: import_ag_charts_core5.string,
  normalizedTo: import_ag_charts_core5.number,
  legendItemName: import_ag_charts_core5.string,
  errorBar: errorBarOptionsDefs
};
barSeriesOptionsDef.pickOutsideVisibleMinorAxis = (0, import_ag_charts_core5.undocumented)(import_ag_charts_core5.boolean);
barSeriesOptionsDef.fastDataProcessing = (0, import_ag_charts_core5.undocumented)(import_ag_charts_core5.boolean);
barSeriesOptionsDef.focusPriority = (0, import_ag_charts_core5.undocumented)(import_ag_charts_core5.number);

// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesOptionsDef.ts
var import_ag_charts_core6 = require("ag-charts-core");
var lineSeriesThemeableOptionsDef = {
  title: import_ag_charts_core6.string,
  showInMiniChart: import_ag_charts_core6.boolean,
  connectMissingData: import_ag_charts_core6.boolean,
  interpolation: interpolationOptionsDefs,
  label: seriesLabelOptionsDefs,
  marker: markerOptionsDefs,
  tooltip: tooltipOptionsDefs,
  errorBar: errorBarThemeableOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...import_ag_charts_core6.strokeOptionsDef,
  ...import_ag_charts_core6.lineDashOptionsDef
};
lineSeriesThemeableOptionsDef.sparklineMode = (0, import_ag_charts_core6.undocumented)(import_ag_charts_core6.boolean);
var lineSeriesOptionsDef = {
  ...lineSeriesThemeableOptionsDef,
  ...commonSeriesOptionsDefs,
  type: (0, import_ag_charts_core6.constant)("line"),
  xKey: (0, import_ag_charts_core6.required)(import_ag_charts_core6.string),
  yKey: (0, import_ag_charts_core6.required)(import_ag_charts_core6.string),
  xName: import_ag_charts_core6.string,
  yName: import_ag_charts_core6.string,
  stacked: import_ag_charts_core6.boolean,
  stackGroup: import_ag_charts_core6.string,
  normalizedTo: import_ag_charts_core6.number,
  legendItemName: import_ag_charts_core6.string,
  errorBar: errorBarOptionsDefs
};
lineSeriesOptionsDef.pickOutsideVisibleMinorAxis = (0, import_ag_charts_core6.undocumented)(import_ag_charts_core6.boolean);
lineSeriesOptionsDef.focusPriority = (0, import_ag_charts_core6.undocumented)(import_ag_charts_core6.number);

// packages/ag-charts-community/src/util/object.ts
var import_ag_charts_core7 = require("ag-charts-core");

// packages/ag-charts-community/src/util/decorator.ts
var BREAK_TRANSFORM_CHAIN = Symbol("BREAK");
var CONFIG_KEY = "__decorator_config";
var ACCESSORS_KEY = "__decorator_accessors";
function addFakeTransformToInstanceProperty(target, propertyKeyOrSymbol) {
  initialiseConfig(target, propertyKeyOrSymbol).optional = true;
}
function initialiseConfig(target, propertyKeyOrSymbol) {
  if (Object.getOwnPropertyDescriptor(target, CONFIG_KEY) == null) {
    Object.defineProperty(target, CONFIG_KEY, { value: {} });
  }
  if (Object.getOwnPropertyDescriptor(target, ACCESSORS_KEY) == null) {
    const parentAccessors = Object.getPrototypeOf(target)?.[ACCESSORS_KEY];
    const accessors = parentAccessors?.slice() ?? [];
    Object.defineProperty(target, ACCESSORS_KEY, { value: accessors });
  }
  const config = target[CONFIG_KEY];
  const propertyKey = propertyKeyOrSymbol.toString();
  if (config[propertyKey] != null) {
    return config[propertyKey];
  }
  config[propertyKey] = { setters: [], getters: [], observers: [] };
  const descriptor = Object.getOwnPropertyDescriptor(target, propertyKeyOrSymbol);
  let prevGet = descriptor?.get;
  let prevSet = descriptor?.set;
  if (prevGet == null || prevSet == null) {
    const accessors = target[ACCESSORS_KEY];
    let index = accessors.indexOf(propertyKeyOrSymbol);
    if (index === -1) {
      index = accessors.push(propertyKeyOrSymbol) - 1;
    }
    prevGet ?? (prevGet = function() {
      let accessorValues = this.__accessors;
      if (accessorValues == null) {
        accessorValues = accessors.slice().fill(void 0);
        Object.defineProperty(this, "__accessors", { value: accessorValues });
      }
      return accessorValues[index];
    });
    prevSet ?? (prevSet = function(value) {
      let accessorValues = this.__accessors;
      if (accessorValues == null) {
        accessorValues = accessors.slice().fill(void 0);
        Object.defineProperty(this, "__accessors", { value: accessorValues });
      }
      accessorValues[index] = value;
    });
  }
  const getter = function() {
    let value = prevGet.call(this);
    for (const transformFn of config[propertyKey].getters) {
      value = transformFn(this, propertyKeyOrSymbol, value);
      if (value === BREAK_TRANSFORM_CHAIN) {
        return;
      }
    }
    return value;
  };
  const setter = function(value) {
    const { setters, observers } = config[propertyKey];
    let oldValue;
    if (setters.some((f) => f.length > 2)) {
      oldValue = prevGet.call(this);
    }
    for (const transformFn of setters) {
      value = transformFn(this, propertyKeyOrSymbol, value, oldValue);
      if (value === BREAK_TRANSFORM_CHAIN) {
        return;
      }
    }
    prevSet.call(this, value);
    for (const observerFn of observers) {
      observerFn(this, value, oldValue);
    }
  };
  Object.defineProperty(target, propertyKeyOrSymbol, {
    set: setter,
    get: getter,
    enumerable: true,
    configurable: false
  });
  return config[propertyKey];
}
function addTransformToInstanceProperty(setTransform, getTransform, configMetadata) {
  return (target, propertyKeyOrSymbol) => {
    const config = initialiseConfig(target, propertyKeyOrSymbol);
    config.setters.push(setTransform);
    if (getTransform) {
      config.getters.unshift(getTransform);
    }
    if (configMetadata) {
      Object.assign(config, configMetadata);
    }
  };
}
function addObserverToInstanceProperty(setObserver) {
  return (target, propertyKeyOrSymbol) => {
    initialiseConfig(target, propertyKeyOrSymbol).observers.push(setObserver);
  };
}
function isDecoratedObject(target) {
  return typeof target !== "undefined" && CONFIG_KEY in target;
}
function listDecoratedProperties(target) {
  const targets = /* @__PURE__ */ new Set();
  while (isDecoratedObject(target)) {
    targets.add(target?.[CONFIG_KEY]);
    target = Object.getPrototypeOf(target);
  }
  return Array.from(targets).flatMap((configMap) => Object.keys(configMap));
}
function extractDecoratedProperties(target) {
  return listDecoratedProperties(target).reduce((result, key) => {
    result[key] = target[key] ?? null;
    return result;
  }, {});
}

// packages/ag-charts-community/src/util/object.ts
function objectsEqual(a, b) {
  if (Array.isArray(a)) {
    if (!Array.isArray(b))
      return false;
    if (a.length !== b.length)
      return false;
    return a.every((av, i) => objectsEqual(av, b[i]));
  } else if ((0, import_ag_charts_core7.isPlainObject)(a)) {
    if (!(0, import_ag_charts_core7.isPlainObject)(b))
      return false;
    return objectsEqualWith(a, b, objectsEqual);
  }
  return a === b;
}
function objectsEqualWith(a, b, cmp2) {
  if (Object.is(a, b))
    return true;
  for (const key of Object.keys(b)) {
    if (!(key in a))
      return false;
  }
  for (const key of Object.keys(a)) {
    if (!(key in b))
      return false;
    if (!cmp2(a[key], b[key]))
      return false;
  }
  return true;
}
function mergeDefaults(...sources) {
  const target = {};
  for (const source of sources) {
    if (!(0, import_ag_charts_core7.isObject)(source))
      continue;
    const keys = isDecoratedObject(source) ? listDecoratedProperties(source) : Object.keys(source);
    for (const key of keys) {
      if ((0, import_ag_charts_core7.isPlainObject)(target[key]) && (0, import_ag_charts_core7.isPlainObject)(source[key])) {
        target[key] = mergeDefaults(target[key], source[key]);
      } else {
        target[key] ?? (target[key] = source[key]);
      }
    }
  }
  return target;
}
function merge(...sources) {
  const target = {};
  for (const source of sources) {
    if (!(0, import_ag_charts_core7.isObject)(source))
      continue;
    const keys = isDecoratedObject(source) ? listDecoratedProperties(source) : Object.keys(source);
    for (const key of keys) {
      if ((0, import_ag_charts_core7.isPlainObject)(target[key]) && (0, import_ag_charts_core7.isPlainObject)(source[key])) {
        target[key] = merge(target[key], source[key]);
      } else if (!(key in target)) {
        target[key] ?? (target[key] = source[key]);
      }
    }
  }
  return target;
}
function mergeArrayDefaults(dataArray, ...itemDefaults) {
  if (itemDefaults && (0, import_ag_charts_core7.isArray)(dataArray)) {
    return dataArray.map((item) => mergeDefaults(item, ...itemDefaults));
  }
  return dataArray;
}
function without(object3, keys) {
  const clone2 = { ...object3 };
  for (const key of keys) {
    delete clone2[key];
  }
  return clone2;
}
function getPath(object3, path) {
  const pathArray = (0, import_ag_charts_core7.isArray)(path) ? path : path.split(".");
  return pathArray.reduce((value, pathKey) => value[pathKey], object3);
}
var SKIP_JS_BUILTINS = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
function setPath(object3, path, newValue) {
  const pathArray = (0, import_ag_charts_core7.isArray)(path) ? path.slice() : path.split(".");
  const lastKey = pathArray.pop();
  if (pathArray.some((p) => SKIP_JS_BUILTINS.has(p)))
    return;
  const lastObject = pathArray.reduce((value, pathKey) => value[pathKey], object3);
  lastObject[lastKey] = newValue;
  return lastObject[lastKey];
}
function partialAssign(keysToCopy, target, source) {
  if (source === void 0) {
    return target;
  }
  for (const key of keysToCopy) {
    const value = source[key];
    if (value !== void 0) {
      target[key] = value;
    }
  }
  return target;
}

// packages/ag-charts-types/src/chart/navigatorOptions.ts
var __MINI_CHART_SERIES_OPTIONS = void 0;
var __VERIFY_MINI_CHART_SERIES_OPTIONS = void 0;
__VERIFY_MINI_CHART_SERIES_OPTIONS = __MINI_CHART_SERIES_OPTIONS;

// packages/ag-charts-types/src/chart/themeOptions.ts
var __THEME_OVERRIDES = void 0;
var __VERIFY_THEME_OVERRIDES = void 0;
__VERIFY_THEME_OVERRIDES = __THEME_OVERRIDES;

// packages/ag-charts-types/src/presets/gauge/commonOptions.ts
var __THEMEABLE_OPTIONS = void 0;
var __VERIFY_THEMEABLE_OPTIONS = void 0;
__VERIFY_THEMEABLE_OPTIONS = __THEMEABLE_OPTIONS;
var __AXIS_LABEL_OPTIONS = void 0;
var __VERIFY_AXIS_LABEL_OPTIONS = void 0;
__VERIFY_AXIS_LABEL_OPTIONS = __AXIS_LABEL_OPTIONS;

// packages/ag-charts-community/src/api/preset/presetUtils.ts
var IGNORED_PROP = Symbol("IGNORED_PROP");
function pickProps(opts, values) {
  const out = {};
  for (const key of Object.keys(values)) {
    const value = values[key];
    if (value !== IGNORED_PROP && Object.hasOwn(opts, key)) {
      out[key] = value;
    }
  }
  return out;
}

// packages/ag-charts-community/src/api/preset/gauge.ts
function tooltipOptions(opts) {
  const { enabled, mode, showArrow, range: range3, position, pagination, delay, wrapping, interaction, renderer, ...rest } = opts;
  const seriesTooltipOptions = pickProps(opts, {
    enabled,
    showArrow,
    range: range3,
    position,
    interaction,
    renderer,
    ...rest
  });
  const chartTooltipOptions = pickProps(opts, {
    enabled: IGNORED_PROP,
    showArrow: IGNORED_PROP,
    range: IGNORED_PROP,
    position: IGNORED_PROP,
    mode,
    pagination,
    delay,
    wrapping,
    ...rest
  });
  return { chartTooltipOptions, seriesTooltipOptions };
}
function radialGaugeOptions(opts) {
  const {
    animation,
    background,
    container,
    contextMenu,
    footnote,
    height: height2,
    listeners,
    locale,
    minHeight,
    minWidth,
    overrideDevicePixelRatio,
    padding,
    subtitle,
    theme,
    title,
    width: width2,
    type,
    cursor,
    nodeClickRange,
    tooltip = {},
    value,
    scale: scale2 = {},
    startAngle,
    endAngle,
    highlightStyle,
    segmentation,
    bar,
    needle,
    targets,
    outerRadius,
    innerRadius,
    outerRadiusRatio,
    innerRadiusRatio,
    cornerRadius,
    cornerMode,
    label,
    secondaryLabel,
    spacing,
    ...rest
  } = opts;
  const { chartTooltipOptions, seriesTooltipOptions } = tooltipOptions(tooltip);
  const chartOpts = pickProps(opts, {
    animation,
    background,
    container,
    contextMenu,
    footnote,
    height: height2,
    listeners,
    locale,
    minHeight,
    minWidth,
    overrideDevicePixelRatio,
    padding,
    subtitle,
    theme,
    title,
    tooltip: chartTooltipOptions,
    width: width2
  });
  const seriesOpts = pickProps(opts, {
    needle: needle != null ? { enabled: true, ...needle } : IGNORED_PROP,
    startAngle,
    endAngle,
    scale: scale2,
    type,
    cursor,
    nodeClickRange,
    tooltip: seriesTooltipOptions,
    value,
    highlightStyle,
    segmentation,
    bar,
    targets,
    outerRadius,
    innerRadius,
    outerRadiusRatio,
    innerRadiusRatio,
    cornerRadius,
    cornerMode,
    label,
    secondaryLabel,
    spacing,
    ...rest
  });
  if ("context" in opts) {
    chartOpts["context"] = opts.context;
  }
  return {
    ...chartOpts,
    series: [seriesOpts]
  };
}
function linearGaugeOptions(opts) {
  const {
    animation,
    background,
    container,
    contextMenu,
    footnote,
    height: height2,
    listeners,
    locale,
    minHeight,
    minWidth,
    overrideDevicePixelRatio,
    padding,
    subtitle,
    theme,
    title,
    width: width2,
    type,
    cursor,
    nodeClickRange,
    tooltip = {},
    value,
    scale: scale2 = {},
    direction = "vertical",
    thickness,
    highlightStyle,
    segmentation,
    bar,
    targets,
    cornerRadius,
    cornerMode,
    label,
    ...rest
  } = opts;
  const { chartTooltipOptions, seriesTooltipOptions } = tooltipOptions(tooltip);
  const chartOpts = pickProps(opts, {
    animation,
    background,
    container,
    contextMenu,
    footnote,
    height: height2,
    listeners,
    locale,
    minHeight,
    minWidth,
    overrideDevicePixelRatio,
    padding,
    subtitle,
    theme,
    title,
    tooltip: chartTooltipOptions,
    width: width2
  });
  const seriesOpts = pickProps(opts, {
    scale: scale2,
    type,
    cursor,
    nodeClickRange,
    tooltip: seriesTooltipOptions,
    value,
    direction,
    thickness,
    highlightStyle,
    segmentation,
    bar,
    targets,
    cornerRadius,
    cornerMode,
    label,
    ...rest
  });
  if ("context" in opts) {
    chartOpts["context"] = opts.context;
  }
  return {
    ...chartOpts,
    series: [seriesOpts]
  };
}
function applyThemeDefaults(opts, presetTheme) {
  if (presetTheme == null)
    return opts;
  const { targets: targetsTheme, ...gaugeTheme } = presetTheme;
  opts = mergeDefaults(opts, gaugeTheme);
  if (opts.targets != null && targetsTheme != null) {
    opts.targets = mergeArrayDefaults(opts.targets, targetsTheme);
  }
  return opts;
}
function gauge(opts, presetTheme) {
  if (opts.listeners) {
    const { nodeClick, nodeDoubleClick, ...listeners } = opts.listeners;
    opts = {
      ...opts,
      listeners: {
        seriesNodeClick: nodeClick,
        seriesNodeDoubleClick: nodeDoubleClick,
        ...listeners
      }
    };
  }
  switch (opts.type) {
    case "radial-gauge":
      const radialGaugeOpts = applyThemeDefaults(opts, presetTheme);
      return radialGaugeOptions(radialGaugeOpts);
    case "linear-gauge":
      const linearGaugeOpts = applyThemeDefaults(opts, presetTheme);
      return linearGaugeOptions(linearGaugeOpts);
    default:
      return {};
  }
}

// packages/ag-charts-community/src/api/preset/gaugeOptionsDefs.ts
var import_ag_charts_core8 = require("ag-charts-core");
var fillsOptionsDef = {
  fills: (0, import_ag_charts_core8.and)(
    (0, import_ag_charts_core8.arrayLength)(2),
    (0, import_ag_charts_core8.arrayOf)((0, import_ag_charts_core8.optionsDefs)({ color: import_ag_charts_core8.color, stop: import_ag_charts_core8.number }, "")),
    import_ag_charts_core8.colorStopsOrderValidator
  ),
  fillMode: (0, import_ag_charts_core8.union)("continuous", "discrete")
};
var linearGaugeTargetOptionsDef = {
  value: (0, import_ag_charts_core8.required)(import_ag_charts_core8.number),
  text: import_ag_charts_core8.string,
  shape: (0, import_ag_charts_core8.or)(
    (0, import_ag_charts_core8.union)("circle", "cross", "diamond", "heart", "plus", "pin", "square", "star", "triangle", "line"),
    import_ag_charts_core8.callback
  ),
  placement: (0, import_ag_charts_core8.union)("before", "after", "middle"),
  spacing: import_ag_charts_core8.positiveNumber,
  size: import_ag_charts_core8.positiveNumber,
  rotation: import_ag_charts_core8.number,
  ...import_ag_charts_core8.fillOptionsDef,
  ...import_ag_charts_core8.strokeOptionsDef,
  ...import_ag_charts_core8.lineDashOptionsDef
};
var radialGaugeTargetOptionsDef = {
  value: (0, import_ag_charts_core8.required)(import_ag_charts_core8.number),
  text: import_ag_charts_core8.string,
  shape: (0, import_ag_charts_core8.or)(
    (0, import_ag_charts_core8.union)("circle", "cross", "diamond", "heart", "plus", "pin", "square", "star", "triangle", "line"),
    import_ag_charts_core8.callback
  ),
  placement: (0, import_ag_charts_core8.union)("inside", "outside", "middle"),
  spacing: import_ag_charts_core8.positiveNumber,
  size: import_ag_charts_core8.positiveNumber,
  rotation: import_ag_charts_core8.number,
  label: {
    ...seriesLabelOptionsDefs,
    spacing: import_ag_charts_core8.positiveNumber
  },
  ...import_ag_charts_core8.fillOptionsDef,
  ...import_ag_charts_core8.strokeOptionsDef,
  ...import_ag_charts_core8.lineDashOptionsDef
};
var linearGaugeSeriesThemeableOptionsDef = {
  direction: (0, import_ag_charts_core8.union)("horizontal", "vertical"),
  cornerMode: (0, import_ag_charts_core8.union)("container", "item"),
  cornerRadius: import_ag_charts_core8.positiveNumber,
  thickness: import_ag_charts_core8.positiveNumber,
  segmentation: {
    enabled: import_ag_charts_core8.boolean,
    spacing: import_ag_charts_core8.positiveNumber,
    interval: {
      values: (0, import_ag_charts_core8.arrayOf)(import_ag_charts_core8.number),
      step: import_ag_charts_core8.number,
      count: import_ag_charts_core8.number
    }
  },
  bar: {
    enabled: import_ag_charts_core8.boolean,
    thickness: import_ag_charts_core8.positiveNumber,
    thicknessRatio: import_ag_charts_core8.ratio,
    ...fillsOptionsDef,
    ...import_ag_charts_core8.fillOptionsDef,
    ...import_ag_charts_core8.strokeOptionsDef,
    ...import_ag_charts_core8.lineDashOptionsDef
  },
  label: {
    ...autoSizedLabelOptionsDefs,
    text: import_ag_charts_core8.string,
    spacing: import_ag_charts_core8.positiveNumber,
    avoidCollisions: import_ag_charts_core8.boolean,
    placement: (0, import_ag_charts_core8.union)(
      "inside-start",
      "outside-start",
      "inside-end",
      "outside-end",
      "inside-center",
      "bar-inside",
      "bar-inside-end",
      "bar-outside-end",
      "bar-end"
    )
  },
  tooltip: tooltipOptionsDefs,
  ...without(commonSeriesThemeableOptionsDefs, ["listeners"])
};
var linearGaugeSeriesOptionsDef = {
  ...linearGaugeSeriesThemeableOptionsDef,
  ...without(commonSeriesOptionsDefs, ["listeners"]),
  type: (0, import_ag_charts_core8.required)((0, import_ag_charts_core8.constant)("linear-gauge")),
  value: (0, import_ag_charts_core8.required)(import_ag_charts_core8.number),
  scale: {
    min: (0, import_ag_charts_core8.and)(import_ag_charts_core8.number, (0, import_ag_charts_core8.lessThan)("max")),
    max: (0, import_ag_charts_core8.and)(import_ag_charts_core8.number, (0, import_ag_charts_core8.greaterThan)("min")),
    label: {
      enabled: import_ag_charts_core8.boolean,
      formatter: import_ag_charts_core8.callback,
      rotation: import_ag_charts_core8.number,
      spacing: import_ag_charts_core8.positiveNumber,
      minSpacing: import_ag_charts_core8.positiveNumber,
      placement: (0, import_ag_charts_core8.union)("before", "after"),
      avoidCollisions: import_ag_charts_core8.boolean,
      format: numberFormatValidator,
      ...import_ag_charts_core8.fontOptionsDef
    },
    interval: {
      values: (0, import_ag_charts_core8.arrayOf)(import_ag_charts_core8.number),
      step: import_ag_charts_core8.number
    },
    ...fillsOptionsDef,
    ...import_ag_charts_core8.fillOptionsDef,
    ...import_ag_charts_core8.strokeOptionsDef,
    ...import_ag_charts_core8.lineDashOptionsDef
  },
  targets: (0, import_ag_charts_core8.arrayOfDefs)(linearGaugeTargetOptionsDef, "target options array")
};
linearGaugeSeriesOptionsDef.margin = (0, import_ag_charts_core8.undocumented)(import_ag_charts_core8.number);
linearGaugeSeriesOptionsDef.defaultColorRange = (0, import_ag_charts_core8.undocumented)((0, import_ag_charts_core8.arrayOf)(import_ag_charts_core8.color));
linearGaugeSeriesOptionsDef.defaultTarget = (0, import_ag_charts_core8.undocumented)({
  ...linearGaugeTargetOptionsDef,
  value: import_ag_charts_core8.number,
  label: {
    ...seriesLabelOptionsDefs,
    spacing: import_ag_charts_core8.number
  }
});
linearGaugeSeriesOptionsDef.defaultScale = (0, import_ag_charts_core8.undocumented)(linearGaugeSeriesOptionsDef.scale);
linearGaugeSeriesOptionsDef.scale.defaultFill = (0, import_ag_charts_core8.undocumented)(import_ag_charts_core8.color);
var radialGaugeSeriesThemeableOptionsDef = {
  outerRadius: import_ag_charts_core8.positiveNumber,
  innerRadius: import_ag_charts_core8.positiveNumber,
  outerRadiusRatio: import_ag_charts_core8.ratio,
  innerRadiusRatio: import_ag_charts_core8.ratio,
  startAngle: import_ag_charts_core8.number,
  endAngle: import_ag_charts_core8.number,
  spacing: import_ag_charts_core8.positiveNumber,
  cornerMode: (0, import_ag_charts_core8.union)("container", "item"),
  cornerRadius: import_ag_charts_core8.positiveNumber,
  scale: {
    min: (0, import_ag_charts_core8.and)(import_ag_charts_core8.number, (0, import_ag_charts_core8.lessThan)("max")),
    max: (0, import_ag_charts_core8.and)(import_ag_charts_core8.number, (0, import_ag_charts_core8.greaterThan)("min")),
    label: {
      enabled: import_ag_charts_core8.boolean,
      formatter: import_ag_charts_core8.callback,
      rotation: import_ag_charts_core8.number,
      spacing: import_ag_charts_core8.positiveNumber,
      minSpacing: import_ag_charts_core8.positiveNumber,
      avoidCollisions: import_ag_charts_core8.boolean,
      format: numberFormatValidator,
      ...import_ag_charts_core8.fontOptionsDef
    },
    interval: {
      values: (0, import_ag_charts_core8.arrayOf)(import_ag_charts_core8.number),
      step: import_ag_charts_core8.number
    },
    ...fillsOptionsDef,
    ...import_ag_charts_core8.fillOptionsDef,
    ...import_ag_charts_core8.strokeOptionsDef,
    ...import_ag_charts_core8.lineDashOptionsDef
  },
  segmentation: {
    enabled: import_ag_charts_core8.boolean,
    spacing: import_ag_charts_core8.positiveNumber,
    interval: {
      values: (0, import_ag_charts_core8.arrayOf)(import_ag_charts_core8.number),
      step: import_ag_charts_core8.number,
      count: import_ag_charts_core8.number
    }
  },
  bar: {
    enabled: import_ag_charts_core8.boolean,
    ...fillsOptionsDef,
    ...import_ag_charts_core8.fillOptionsDef,
    ...import_ag_charts_core8.strokeOptionsDef,
    ...import_ag_charts_core8.lineDashOptionsDef
  },
  needle: {
    enabled: import_ag_charts_core8.boolean,
    spacing: import_ag_charts_core8.positiveNumber,
    radiusRatio: import_ag_charts_core8.ratio,
    ...import_ag_charts_core8.fillOptionsDef,
    ...import_ag_charts_core8.strokeOptionsDef,
    ...import_ag_charts_core8.lineDashOptionsDef
  },
  label: {
    text: import_ag_charts_core8.string,
    spacing: import_ag_charts_core8.positiveNumber,
    ...autoSizedLabelOptionsDefs
  },
  secondaryLabel: {
    text: import_ag_charts_core8.string,
    ...autoSizedLabelOptionsDefs
  },
  tooltip: tooltipOptionsDefs,
  ...commonSeriesThemeableOptionsDefs
};
var radialGaugeSeriesOptionsDef = {
  ...radialGaugeSeriesThemeableOptionsDef,
  ...commonSeriesOptionsDefs,
  type: (0, import_ag_charts_core8.required)((0, import_ag_charts_core8.constant)("radial-gauge")),
  value: (0, import_ag_charts_core8.required)(import_ag_charts_core8.number),
  targets: (0, import_ag_charts_core8.arrayOfDefs)(radialGaugeTargetOptionsDef, "target options array")
};
radialGaugeSeriesOptionsDef.defaultColorRange = (0, import_ag_charts_core8.undocumented)((0, import_ag_charts_core8.arrayOf)(import_ag_charts_core8.color));
radialGaugeSeriesOptionsDef.defaultTarget = (0, import_ag_charts_core8.undocumented)({
  ...radialGaugeTargetOptionsDef,
  value: import_ag_charts_core8.number,
  label: {
    ...seriesLabelOptionsDefs,
    spacing: import_ag_charts_core8.number
  }
});
radialGaugeSeriesOptionsDef.scale.defaultFill = (0, import_ag_charts_core8.undocumented)(import_ag_charts_core8.color);

// packages/ag-charts-community/src/api/preset/priceVolumePreset.ts
var import_ag_charts_core10 = require("ag-charts-core");

// packages/ag-charts-community/src/chart/themes/symbols.ts
var IS_DARK_THEME = Symbol("is-dark-theme");
var DEFAULT_SEPARATION_LINES_COLOUR = Symbol("default-separation-lines-colour");
var DEFAULT_SHADOW_COLOUR = Symbol("default-shadow-colour");
var DEFAULT_CAPTION_LAYOUT_STYLE = Symbol("default-caption-layout-style");
var DEFAULT_CAPTION_ALIGNMENT = Symbol("default-caption-alignment");
var PALETTE_UP_STROKE = Symbol("palette-up-stroke");
var PALETTE_DOWN_STROKE = Symbol("palette-down-stroke");
var PALETTE_UP_FILL = Symbol("palette-up-fill");
var PALETTE_DOWN_FILL = Symbol("palette-down-fill");
var PALETTE_NEUTRAL_STROKE = Symbol("palette-neutral-stroke");
var PALETTE_NEUTRAL_FILL = Symbol("palette-neutral-fill");
var PALETTE_ALT_UP_STROKE = Symbol("palette-alt-up-stroke");
var PALETTE_ALT_DOWN_STROKE = Symbol("palette-alt-down-stroke");
var PALETTE_ALT_UP_FILL = Symbol("palette-alt-up-fill");
var PALETTE_ALT_DOWN_FILL = Symbol("palette-alt-down-fill");
var PALETTE_ALT_NEUTRAL_FILL = Symbol("palette-gray-fill");
var PALETTE_ALT_NEUTRAL_STROKE = Symbol("palette-gray-stroke");
var DEFAULT_POLAR_SERIES_STROKE = Symbol("default-polar-series-stroke");
var DEFAULT_SPARKLINE_CROSSHAIR_STROKE = Symbol("default-sparkline-crosshair-stroke");
var DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR = Symbol(
  "default-financial-charts-annotation-stroke"
);
var DEFAULT_FIBONACCI_STROKES = Symbol("default-hierarchy-strokes");
var DEFAULT_TEXT_ANNOTATION_COLOR = Symbol("default-text-annotation-color");
var DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL = Symbol(
  "default-financial-charts-annotation-background-fill"
);
var DEFAULT_ANNOTATION_HANDLE_FILL = Symbol("default-annotation-handle-fill");
var DEFAULT_ANNOTATION_STATISTICS_FILL = Symbol("default-annotation-statistics-fill");
var DEFAULT_ANNOTATION_STATISTICS_STROKE = Symbol("default-annotation-statistics-stroke");
var DEFAULT_ANNOTATION_STATISTICS_COLOR = Symbol("default-annotation-statistics-color");
var DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE = Symbol(
  "default-annotation-statistics-divider-stroke"
);
var DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL = Symbol(
  "default-annotation-statistics-fill"
);
var DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE = Symbol(
  "default-annotation-statistics-stroke"
);
var DEFAULT_TEXTBOX_FILL = Symbol("default-textbox-fill");
var DEFAULT_TEXTBOX_STROKE = Symbol("default-textbox-stroke");
var DEFAULT_TEXTBOX_COLOR = Symbol("default-textbox-color");
var DEFAULT_TOOLBAR_POSITION = Symbol("default-toolbar-position");
var DEFAULT_GRIDLINE_ENABLED = Symbol("default-gridline-enabled");

// packages/ag-charts-community/src/util/color.ts
var import_ag_charts_core9 = require("ag-charts-core");
var lerp = (x, y, t) => x * (1 - t) + y * t;
var srgbToLinear = (value) => {
  const sign = value < 0 ? -1 : 1;
  const abs = Math.abs(value);
  if (abs <= 0.04045)
    return value / 12.92;
  return sign * ((abs + 0.055) / 1.055) ** 2.4;
};
var srgbFromLinear = (value) => {
  const sign = value < 0 ? -1 : 1;
  const abs = Math.abs(value);
  if (abs > 31308e-7) {
    return sign * (1.055 * abs ** (1 / 2.4) - 0.055);
  }
  return 12.92 * value;
};
var _Color = class _Color {
  /**
   * Every color component should be in the [0, 1] range.
   * Some easing functions (such as elastic easing) can overshoot the target value by some amount.
   * So, when animating colors, if the source or target color components are already near
   * or at the edge of the allowed [0, 1] range, it is possible for the intermediate color
   * component value to end up outside of that range mid-animation. For this reason the constructor
   * performs range checking/constraining.
   * @param r Red component.
   * @param g Green component.
   * @param b Blue component.
   * @param a Alpha (opacity) component.
   */
  constructor(r, g, b, a = 1) {
    this.r = (0, import_ag_charts_core9.clamp)(0, r || 0, 1);
    this.g = (0, import_ag_charts_core9.clamp)(0, g || 0, 1);
    this.b = (0, import_ag_charts_core9.clamp)(0, b || 0, 1);
    this.a = (0, import_ag_charts_core9.clamp)(0, a || 0, 1);
  }
  /**
   * A color string can be in one of the following formats to be valid:
   * - #rgb
   * - #rrggbb
   * - rgb(r, g, b)
   * - rgba(r, g, b, a)
   * - CSS color name such as 'white', 'orange', 'cyan', etc.
   */
  static validColorString(str) {
    if (str.indexOf("#") >= 0) {
      return !!_Color.parseHex(str);
    }
    if (str.indexOf("rgb") >= 0) {
      return !!_Color.stringToRgba(str);
    }
    return _Color.nameToHex.has(str.toLowerCase());
  }
  /**
   * The given string can be in one of the following formats:
   * - #rgb
   * - #rrggbb
   * - rgb(r, g, b)
   * - rgba(r, g, b, a)
   * - CSS color name such as 'white', 'orange', 'cyan', etc.
   * @param str
   */
  static fromString(str) {
    if (str.indexOf("#") >= 0) {
      return _Color.fromHexString(str);
    }
    const hex = _Color.nameToHex.get(str.toLowerCase());
    if (hex) {
      return _Color.fromHexString(hex);
    }
    if (str.indexOf("rgb") >= 0) {
      return _Color.fromRgbaString(str);
    }
    throw new Error(`Invalid color string: '${str}'`);
  }
  // See https://drafts.csswg.org/css-color/#hex-notation
  static parseHex(input) {
    input = input.replace(/ /g, "").slice(1);
    let parts;
    switch (input.length) {
      case 6:
      case 8:
        parts = [];
        for (let i = 0; i < input.length; i += 2) {
          parts.push(parseInt(`${input[i]}${input[i + 1]}`, 16));
        }
        break;
      case 3:
      case 4:
        parts = input.split("").map((p) => parseInt(p, 16)).map((p) => p + p * 16);
        break;
    }
    if (parts?.length >= 3 && parts.every((p) => p >= 0)) {
      if (parts.length === 3) {
        parts.push(255);
      }
      return parts;
    }
  }
  static fromHexString(str) {
    const values = _Color.parseHex(str);
    if (values) {
      const [r, g, b, a] = values;
      return new _Color(r / 255, g / 255, b / 255, a / 255);
    }
    throw new Error(`Malformed hexadecimal color string: '${str}'`);
  }
  static stringToRgba(str) {
    let po = -1;
    let pc = -1;
    for (let i = 0; i < str.length; i++) {
      const c = str[i];
      if (po === -1 && c === "(") {
        po = i;
      } else if (c === ")") {
        pc = i;
        break;
      }
    }
    if (po === -1 || pc === -1)
      return;
    const contents = str.substring(po + 1, pc);
    const parts = contents.split(",");
    const rgba = [];
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      let value = parseFloat(part);
      if (!Number.isFinite(value)) {
        return;
      }
      if (part.indexOf("%") >= 0) {
        value = (0, import_ag_charts_core9.clamp)(0, value, 100);
        value /= 100;
      } else if (i === 3) {
        value = (0, import_ag_charts_core9.clamp)(0, value, 1);
      } else {
        value = (0, import_ag_charts_core9.clamp)(0, value, 255);
        value /= 255;
      }
      rgba.push(value);
    }
    return rgba;
  }
  static fromRgbaString(str) {
    const rgba = _Color.stringToRgba(str);
    if (rgba) {
      if (rgba.length === 3) {
        return new _Color(rgba[0], rgba[1], rgba[2]);
      } else if (rgba.length === 4) {
        return new _Color(rgba[0], rgba[1], rgba[2], rgba[3]);
      }
    }
    throw new Error(`Malformed rgb/rgba color string: '${str}'`);
  }
  static fromArray(arr) {
    if (arr.length === 4) {
      return new _Color(arr[0], arr[1], arr[2], arr[3]);
    }
    if (arr.length === 3) {
      return new _Color(arr[0], arr[1], arr[2]);
    }
    throw new Error("The given array should contain 3 or 4 color components (numbers).");
  }
  static fromHSB(h, s, b, alpha = 1) {
    const rgb = _Color.HSBtoRGB(h, s, b);
    return new _Color(rgb[0], rgb[1], rgb[2], alpha);
  }
  static fromHSL(h, s, l, alpha = 1) {
    const rgb = _Color.HSLtoRGB(h, s, l);
    return new _Color(rgb[0], rgb[1], rgb[2], alpha);
  }
  static fromOKLCH(l, c, h, alpha = 1) {
    const rgb = _Color.OKLCHtoRGB(l, c, h);
    return new _Color(rgb[0], rgb[1], rgb[2], alpha);
  }
  static padHex(str) {
    return str.length === 1 ? "0" + str : str;
  }
  toHexString() {
    let hex = "#" + _Color.padHex(Math.round(this.r * 255).toString(16)) + _Color.padHex(Math.round(this.g * 255).toString(16)) + _Color.padHex(Math.round(this.b * 255).toString(16));
    if (this.a < 1) {
      hex += _Color.padHex(Math.round(this.a * 255).toString(16));
    }
    return hex;
  }
  toRgbaString(fractionDigits = 3) {
    const components = [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255)];
    const k = Math.pow(10, fractionDigits);
    if (this.a !== 1) {
      components.push(Math.round(this.a * k) / k);
      return `rgba(${components.join(", ")})`;
    }
    return `rgb(${components.join(", ")})`;
  }
  toString() {
    if (this.a === 1) {
      return this.toHexString();
    }
    return this.toRgbaString();
  }
  toHSB() {
    return _Color.RGBtoHSB(this.r, this.g, this.b);
  }
  static RGBtoOKLCH(r, g, b) {
    const LSRGB0 = srgbToLinear(r);
    const LSRGB1 = srgbToLinear(g);
    const LSRGB2 = srgbToLinear(b);
    const LMS0 = Math.cbrt(0.4122214708 * LSRGB0 + 0.5363325363 * LSRGB1 + 0.0514459929 * LSRGB2);
    const LMS1 = Math.cbrt(0.2119034982 * LSRGB0 + 0.6806995451 * LSRGB1 + 0.1073969566 * LSRGB2);
    const LMS2 = Math.cbrt(0.0883024619 * LSRGB0 + 0.2817188376 * LSRGB1 + 0.6299787005 * LSRGB2);
    const OKLAB0 = 0.2104542553 * LMS0 + 0.793617785 * LMS1 - 0.0040720468 * LMS2;
    const OKLAB1 = 1.9779984951 * LMS0 - 2.428592205 * LMS1 + 0.4505937099 * LMS2;
    const OKLAB2 = 0.0259040371 * LMS0 + 0.7827717662 * LMS1 - 0.808675766 * LMS2;
    const hue = Math.atan2(OKLAB2, OKLAB1) * 180 / Math.PI;
    const OKLCH0 = OKLAB0;
    const OKLCH1 = Math.hypot(OKLAB1, OKLAB2);
    const OKLCH2 = hue >= 0 ? hue : hue + 360;
    return [OKLCH0, OKLCH1, OKLCH2];
  }
  static OKLCHtoRGB(l, c, h) {
    const OKLAB0 = l;
    const OKLAB1 = c * Math.cos(h * Math.PI / 180);
    const OKLAB2 = c * Math.sin(h * Math.PI / 180);
    const LMS0 = (OKLAB0 + 0.3963377774 * OKLAB1 + 0.2158037573 * OKLAB2) ** 3;
    const LMS1 = (OKLAB0 - 0.1055613458 * OKLAB1 - 0.0638541728 * OKLAB2) ** 3;
    const LMS2 = (OKLAB0 - 0.0894841775 * OKLAB1 - 1.291485548 * OKLAB2) ** 3;
    const LSRGB0 = 4.0767416621 * LMS0 - 3.3077115913 * LMS1 + 0.2309699292 * LMS2;
    const LSRGB1 = -1.2684380046 * LMS0 + 2.6097574011 * LMS1 - 0.3413193965 * LMS2;
    const LSRGB2 = -0.0041960863 * LMS0 - 0.7034186147 * LMS1 + 1.707614701 * LMS2;
    const SRGB0 = srgbFromLinear(LSRGB0);
    const SRGB1 = srgbFromLinear(LSRGB1);
    const SRGB2 = srgbFromLinear(LSRGB2);
    return [SRGB0, SRGB1, SRGB2];
  }
  static RGBtoHSL(r, g, b) {
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const l = (max + min) / 2;
    let h;
    let s;
    if (max === min) {
      h = 0;
      s = 0;
    } else {
      const delta3 = max - min;
      s = l > 0.5 ? delta3 / (2 - max - min) : delta3 / (max + min);
      if (max === r) {
        h = (g - b) / delta3 + (g < b ? 6 : 0);
      } else if (max === g) {
        h = (b - r) / delta3 + 2;
      } else {
        h = (r - g) / delta3 + 4;
      }
      h *= 360 / 6;
    }
    return [h, s, l];
  }
  static HSLtoRGB(h, s, l) {
    h = (h % 360 + 360) % 360;
    if (s === 0) {
      return [l, l, l];
    }
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    function hueToRgb(t) {
      if (t < 0)
        t += 1;
      if (t > 1)
        t -= 1;
      if (t < 1 / 6)
        return p + (q - p) * 6 * t;
      if (t < 1 / 2)
        return q;
      if (t < 2 / 3)
        return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }
    const r = hueToRgb(h / 360 + 1 / 3);
    const g = hueToRgb(h / 360);
    const b = hueToRgb(h / 360 - 1 / 3);
    return [r, g, b];
  }
  /**
   * Converts the given RGB triple to an array of HSB (HSV) components.
   */
  static RGBtoHSB(r, g, b) {
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const S = max === 0 ? 0 : (max - min) / max;
    let H = 0;
    if (min !== max) {
      const delta3 = max - min;
      const rc = (max - r) / delta3;
      const gc = (max - g) / delta3;
      const bc = (max - b) / delta3;
      if (r === max) {
        H = bc - gc;
      } else if (g === max) {
        H = 2 + rc - bc;
      } else {
        H = 4 + gc - rc;
      }
      H /= 6;
      if (H < 0) {
        H = H + 1;
      }
    }
    return [H * 360, S, max];
  }
  /**
   * Converts the given HSB (HSV) triple to an array of RGB components.
   */
  static HSBtoRGB(H, S, B) {
    H = (H % 360 + 360) % 360 / 360;
    let r = 0;
    let g = 0;
    let b = 0;
    if (S === 0) {
      r = g = b = B;
    } else {
      const h = (H - Math.floor(H)) * 6;
      const f = h - Math.floor(h);
      const p = B * (1 - S);
      const q = B * (1 - S * f);
      const t = B * (1 - S * (1 - f));
      switch (h >> 0) {
        case 0:
          r = B;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = B;
          b = p;
          break;
        case 2:
          r = p;
          g = B;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = B;
          break;
        case 4:
          r = t;
          g = p;
          b = B;
          break;
        case 5:
          r = B;
          g = p;
          b = q;
          break;
      }
    }
    return [r, g, b];
  }
  static mix(c0, c1, t) {
    return new _Color(lerp(c0.r, c1.r, t), lerp(c0.g, c1.g, t), lerp(c0.b, c1.b, t), lerp(c0.a, c1.a, t));
  }
  static lighten(c, t) {
    const oklch = _Color.RGBtoOKLCH(c.r, c.g, c.b);
    return _Color.fromOKLCH((0, import_ag_charts_core9.clamp)(0, oklch[0] + t, 1), oklch[1], oklch[2]);
  }
  static darken(c, t) {
    const oklch = _Color.RGBtoOKLCH(c.r, c.g, c.b);
    return _Color.fromOKLCH((0, import_ag_charts_core9.clamp)(0, oklch[0] - t, 1), oklch[1], oklch[2]);
  }
  static interpolate(colors, count) {
    const step = 1 / (colors.length - 1);
    const oklchColors = colors.map((c) => _Color.RGBtoOKLCH(c.r, c.g, c.b));
    return Array.from({ length: count }, (_, i) => {
      const t = i / (count - 1);
      const index = colors.length <= 2 ? 0 : Math.min(Math.floor(t * (colors.length - 1)), colors.length - 2);
      const q = (t - index * step) / step;
      const c0 = oklchColors[index];
      const c1 = oklchColors[index + 1];
      return _Color.fromOKLCH(lerp(c0[0], c1[0], q), lerp(c0[1], c1[1], q), lerp(c0[2], c1[2], q));
    });
  }
};
/**
 * CSS Color Module Level 4:
 * https://drafts.csswg.org/css-color/#named-colors
 */
_Color.nameToHex = /* @__PURE__ */ new Map([
  ["aliceblue", "#F0F8FF"],
  ["antiquewhite", "#FAEBD7"],
  ["aqua", "#00FFFF"],
  ["aquamarine", "#7FFFD4"],
  ["azure", "#F0FFFF"],
  ["beige", "#F5F5DC"],
  ["bisque", "#FFE4C4"],
  ["black", "#000000"],
  ["blanchedalmond", "#FFEBCD"],
  ["blue", "#0000FF"],
  ["blueviolet", "#8A2BE2"],
  ["brown", "#A52A2A"],
  ["burlywood", "#DEB887"],
  ["cadetblue", "#5F9EA0"],
  ["chartreuse", "#7FFF00"],
  ["chocolate", "#D2691E"],
  ["coral", "#FF7F50"],
  ["cornflowerblue", "#6495ED"],
  ["cornsilk", "#FFF8DC"],
  ["crimson", "#DC143C"],
  ["cyan", "#00FFFF"],
  ["darkblue", "#00008B"],
  ["darkcyan", "#008B8B"],
  ["darkgoldenrod", "#B8860B"],
  ["darkgray", "#A9A9A9"],
  ["darkgreen", "#006400"],
  ["darkgrey", "#A9A9A9"],
  ["darkkhaki", "#BDB76B"],
  ["darkmagenta", "#8B008B"],
  ["darkolivegreen", "#556B2F"],
  ["darkorange", "#FF8C00"],
  ["darkorchid", "#9932CC"],
  ["darkred", "#8B0000"],
  ["darksalmon", "#E9967A"],
  ["darkseagreen", "#8FBC8F"],
  ["darkslateblue", "#483D8B"],
  ["darkslategray", "#2F4F4F"],
  ["darkslategrey", "#2F4F4F"],
  ["darkturquoise", "#00CED1"],
  ["darkviolet", "#9400D3"],
  ["deeppink", "#FF1493"],
  ["deepskyblue", "#00BFFF"],
  ["dimgray", "#696969"],
  ["dimgrey", "#696969"],
  ["dodgerblue", "#1E90FF"],
  ["firebrick", "#B22222"],
  ["floralwhite", "#FFFAF0"],
  ["forestgreen", "#228B22"],
  ["fuchsia", "#FF00FF"],
  ["gainsboro", "#DCDCDC"],
  ["ghostwhite", "#F8F8FF"],
  ["gold", "#FFD700"],
  ["goldenrod", "#DAA520"],
  ["gray", "#808080"],
  ["green", "#008000"],
  ["greenyellow", "#ADFF2F"],
  ["grey", "#808080"],
  ["honeydew", "#F0FFF0"],
  ["hotpink", "#FF69B4"],
  ["indianred", "#CD5C5C"],
  ["indigo", "#4B0082"],
  ["ivory", "#FFFFF0"],
  ["khaki", "#F0E68C"],
  ["lavender", "#E6E6FA"],
  ["lavenderblush", "#FFF0F5"],
  ["lawngreen", "#7CFC00"],
  ["lemonchiffon", "#FFFACD"],
  ["lightblue", "#ADD8E6"],
  ["lightcoral", "#F08080"],
  ["lightcyan", "#E0FFFF"],
  ["lightgoldenrodyellow", "#FAFAD2"],
  ["lightgray", "#D3D3D3"],
  ["lightgreen", "#90EE90"],
  ["lightgrey", "#D3D3D3"],
  ["lightpink", "#FFB6C1"],
  ["lightsalmon", "#FFA07A"],
  ["lightseagreen", "#20B2AA"],
  ["lightskyblue", "#87CEFA"],
  ["lightslategray", "#778899"],
  ["lightslategrey", "#778899"],
  ["lightsteelblue", "#B0C4DE"],
  ["lightyellow", "#FFFFE0"],
  ["lime", "#00FF00"],
  ["limegreen", "#32CD32"],
  ["linen", "#FAF0E6"],
  ["magenta", "#FF00FF"],
  ["maroon", "#800000"],
  ["mediumaquamarine", "#66CDAA"],
  ["mediumblue", "#0000CD"],
  ["mediumorchid", "#BA55D3"],
  ["mediumpurple", "#9370DB"],
  ["mediumseagreen", "#3CB371"],
  ["mediumslateblue", "#7B68EE"],
  ["mediumspringgreen", "#00FA9A"],
  ["mediumturquoise", "#48D1CC"],
  ["mediumvioletred", "#C71585"],
  ["midnightblue", "#191970"],
  ["mintcream", "#F5FFFA"],
  ["mistyrose", "#FFE4E1"],
  ["moccasin", "#FFE4B5"],
  ["navajowhite", "#FFDEAD"],
  ["navy", "#000080"],
  ["oldlace", "#FDF5E6"],
  ["olive", "#808000"],
  ["olivedrab", "#6B8E23"],
  ["orange", "#FFA500"],
  ["orangered", "#FF4500"],
  ["orchid", "#DA70D6"],
  ["palegoldenrod", "#EEE8AA"],
  ["palegreen", "#98FB98"],
  ["paleturquoise", "#AFEEEE"],
  ["palevioletred", "#DB7093"],
  ["papayawhip", "#FFEFD5"],
  ["peachpuff", "#FFDAB9"],
  ["peru", "#CD853F"],
  ["pink", "#FFC0CB"],
  ["plum", "#DDA0DD"],
  ["powderblue", "#B0E0E6"],
  ["purple", "#800080"],
  ["rebeccapurple", "#663399"],
  ["red", "#FF0000"],
  ["rosybrown", "#BC8F8F"],
  ["royalblue", "#4169E1"],
  ["saddlebrown", "#8B4513"],
  ["salmon", "#FA8072"],
  ["sandybrown", "#F4A460"],
  ["seagreen", "#2E8B57"],
  ["seashell", "#FFF5EE"],
  ["sienna", "#A0522D"],
  ["silver", "#C0C0C0"],
  ["skyblue", "#87CEEB"],
  ["slateblue", "#6A5ACD"],
  ["slategray", "#708090"],
  ["slategrey", "#708090"],
  ["snow", "#FFFAFA"],
  ["springgreen", "#00FF7F"],
  ["steelblue", "#4682B4"],
  ["tan", "#D2B48C"],
  ["teal", "#008080"],
  ["thistle", "#D8BFD8"],
  ["tomato", "#FF6347"],
  ["transparent", "#00000000"],
  ["turquoise", "#40E0D0"],
  ["violet", "#EE82EE"],
  ["wheat", "#F5DEB3"],
  ["white", "#FFFFFF"],
  ["whitesmoke", "#F5F5F5"],
  ["yellow", "#FFFF00"],
  ["yellowgreen", "#9ACD32"]
]);
var Color = _Color;

// packages/ag-charts-community/src/chart/themes/util.ts
var DIRECTION_SWAP_AXES = [
  {
    type: "number" /* NUMBER */,
    position: {
      $if: [
        { $eq: [{ $path: ["/direction", void 0] }, "horizontal"] },
        "bottom" /* BOTTOM */,
        "left" /* LEFT */
      ]
    }
  },
  {
    type: "category" /* CATEGORY */,
    position: {
      $if: [
        { $eq: [{ $path: ["/direction", void 0] }, "horizontal"] },
        "left" /* LEFT */,
        "bottom" /* BOTTOM */
      ]
    }
  }
];
var SAFE_STROKE_FILL_OPERATION = {
  $if: [
    { $isGradient: [{ $palette: "fill" }] },
    { $palette: "fillFallback" },
    {
      $if: [
        { $isPattern: [{ $palette: "fill" }] },
        { $path: ["./stroke", { $palette: "fillFallback" }, { $palette: "fill" }] },
        { $palette: "fill" }
      ]
    }
  ]
};
var FILL_PATTERN_DEFAULTS = {
  type: "pattern",
  pattern: "forward-slanted-lines",
  width: 10,
  height: 10,
  padding: 2,
  fill: {
    $if: [
      { $or: [{ $isGradient: [{ $palette: "fill" }] }, { $isImage: [{ $palette: "fill" }] }] },
      { $palette: "fillFallback" },
      {
        $if: [
          { $isPattern: [{ $palette: "fill" }] },
          { $path: ["./fill", { $palette: "fillFallback" }, { $palette: "fill" }] },
          { $palette: "fill" }
        ]
      }
    ]
  },
  fillOpacity: 1,
  stroke: SAFE_STROKE_FILL_OPERATION,
  strokeOpacity: 1,
  strokeWidth: 4,
  backgroundFill: "none",
  backgroundFillOpacity: 1,
  rotation: 0,
  scale: 1
};
var FILL_IMAGE_DEFAULTS = {
  type: "image",
  backgroundFill: { $palette: "fillFallback" },
  backgroundFillOpacity: 1,
  repeat: "no-repeat",
  fit: "contain",
  rotation: 0
};

// packages/ag-charts-community/src/api/preset/priceVolumePresetTheme.ts
var stroke = {
  stroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR
};
var handle = {
  fill: DEFAULT_ANNOTATION_HANDLE_FILL
};
var axisLabel = {
  color: "white",
  fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR
};
var lineText = {
  color: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR
};
var font = {
  color: DEFAULT_TEXT_ANNOTATION_COLOR,
  fontSize: { $rem: [1.1666666666666667 /* LARGE */] },
  fontFamily: { $ref: "fontFamily" }
};
var measurerStatistics = {
  ...font,
  fontSize: { $ref: "fontSize" },
  color: DEFAULT_ANNOTATION_STATISTICS_COLOR,
  fill: DEFAULT_ANNOTATION_STATISTICS_FILL,
  stroke: DEFAULT_ANNOTATION_STATISTICS_STROKE,
  strokeWidth: 1,
  divider: {
    stroke: DEFAULT_ANNOTATION_STATISTICS_DIVIDER_STROKE,
    strokeWidth: 1,
    strokeOpacity: 0.5
  }
};
var measurer = {
  ...stroke,
  background: {
    fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
    fillOpacity: 0.2
  },
  handle: { ...handle },
  text: { ...lineText },
  statistics: { ...measurerStatistics }
};
var annotationsTheme = {
  // Lines
  line: {
    ...stroke,
    handle: { ...handle },
    text: { ...lineText }
  },
  "horizontal-line": {
    ...stroke,
    handle: { ...handle },
    axisLabel: { ...axisLabel },
    text: { ...lineText }
  },
  "vertical-line": {
    ...stroke,
    handle: { ...handle },
    axisLabel: { ...axisLabel },
    text: { ...lineText }
  },
  // Channels
  "disjoint-channel": {
    ...stroke,
    background: {
      fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
      fillOpacity: 0.2
    },
    handle: { ...handle },
    text: { ...lineText }
  },
  "parallel-channel": {
    ...stroke,
    background: {
      fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
      fillOpacity: 0.2
    },
    handle: { ...handle },
    text: { ...lineText }
  },
  // Fibonnaccis
  "fibonacci-retracement": {
    ...stroke,
    strokes: DEFAULT_FIBONACCI_STROKES,
    rangeStroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR,
    handle: { ...handle },
    text: { ...lineText, position: "center" },
    label: {
      ...font,
      color: void 0,
      fontSize: {
        $round: [{ $mul: [{ $ref: "fontSize" }, 10 / 12] }]
      }
    }
  },
  "fibonacci-retracement-trend-based": {
    ...stroke,
    strokes: DEFAULT_FIBONACCI_STROKES,
    rangeStroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR,
    handle: { ...handle },
    text: { ...lineText, position: "center" },
    label: {
      ...font,
      color: void 0,
      fontSize: {
        $round: [{ $mul: [{ $ref: "fontSize" }, 10 / 12] }]
      }
    }
  },
  // Texts
  callout: {
    ...stroke,
    ...font,
    color: { $ref: "textColor" },
    handle: { ...handle },
    fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
    fillOpacity: 0.2
  },
  comment: {
    ...font,
    color: "white",
    fontWeight: 700,
    handle: { ...handle },
    fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR
  },
  note: {
    ...font,
    color: DEFAULT_TEXTBOX_COLOR,
    fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR,
    stroke: { $ref: "backgroundColor" },
    strokeWidth: 1,
    strokeOpacity: 1,
    handle: { ...handle },
    background: {
      fill: DEFAULT_TEXTBOX_FILL,
      stroke: DEFAULT_TEXTBOX_STROKE,
      strokeWidth: 1
    }
  },
  text: {
    ...font,
    handle: { ...handle }
  },
  // Shapes
  arrow: {
    ...stroke,
    handle: { ...handle },
    text: { ...lineText }
  },
  "arrow-up": {
    fill: { $palette: "up.fill" },
    handle: { ...handle, stroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR }
  },
  "arrow-down": {
    fill: { $palette: "down.fill" },
    handle: { ...handle, stroke: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_COLOR }
  },
  // Measurers
  "date-range": {
    ...measurer
  },
  "price-range": {
    ...measurer
  },
  "date-price-range": {
    ...measurer
  },
  "quick-date-price-range": {
    up: {
      ...stroke,
      fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
      fillOpacity: 0.2,
      handle: { ...handle },
      statistics: {
        ...measurerStatistics,
        color: "#fff",
        fill: DEFAULT_FINANCIAL_CHARTS_ANNOTATION_BACKGROUND_FILL,
        strokeWidth: 0,
        divider: {
          stroke: "#fff",
          strokeWidth: 1,
          strokeOpacity: 0.5
        }
      }
    },
    down: {
      ...stroke,
      stroke: DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE,
      fill: DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL,
      fillOpacity: 0.2,
      handle: {
        ...handle,
        stroke: DEFAULT_ANNOTATION_STATISTICS_DOWN_STROKE
      },
      statistics: {
        ...measurerStatistics,
        color: "#fff",
        fill: DEFAULT_ANNOTATION_STATISTICS_DOWN_FILL,
        strokeWidth: 0,
        divider: {
          stroke: "#fff",
          strokeWidth: 1,
          strokeOpacity: 0.5
        }
      }
    }
  },
  axesButtons: {
    enabled: true
  }
};

// packages/ag-charts-community/src/api/preset/priceVolumePreset.ts
var chartTypes = ["ohlc", "line", "step-line", "hlc", "high-low", "candlestick", "hollow-candlestick"];
var toolbarButtons = [
  {
    icon: "trend-line-drawing",
    tooltip: "toolbarAnnotationsLineAnnotations",
    value: "line-menu"
  },
  {
    icon: "fibonacci-retracement-drawing",
    tooltip: "toolbarAnnotationsFibonacciAnnotations",
    value: "fibonacci-menu"
  },
  {
    icon: "text-annotation",
    tooltip: "toolbarAnnotationsTextAnnotations",
    value: "text-menu"
  },
  {
    icon: "arrow-drawing",
    tooltip: "toolbarAnnotationsShapeAnnotations",
    value: "shape-menu"
  },
  {
    icon: "measurer-drawing",
    tooltip: "toolbarAnnotationsMeasurerAnnotations",
    value: "measurer-menu"
  },
  {
    icon: "delete",
    tooltip: "toolbarAnnotationsClearAll",
    value: "clear"
  }
];
function priceVolume(opts, _presetTheme, getTheme) {
  const {
    dateKey = "date",
    highKey = "high",
    openKey = "open",
    lowKey = "low",
    closeKey = "close",
    volumeKey = "volume",
    chartType = "candlestick",
    navigator = false,
    volume = true,
    rangeButtons = true,
    statusBar = true,
    toolbar = true,
    zoom = true,
    sync = false,
    theme,
    data,
    ...unusedOpts
  } = opts;
  const priceSeries = createPriceSeries(chartType, dateKey, highKey, lowKey, openKey, closeKey);
  const volumeSeries = createVolumeSeries(getTheme, openKey, closeKey, volume, volumeKey);
  const miniChart = volume ? {
    miniChart: {
      enabled: navigator,
      series: [
        {
          type: "line",
          xKey: dateKey,
          yKey: volumeKey,
          stroke: SAFE_STROKE_FILL_OPERATION,
          marker: { enabled: false }
        }
      ]
    },
    height: 40,
    minHandle: {
      height: 46
    },
    maxHandle: {
      height: 46
    }
  } : null;
  const navigatorOpts = {
    navigator: {
      enabled: navigator,
      ...miniChart
    }
  };
  const annotationOpts = {
    annotations: {
      enabled: toolbar,
      optionsToolbar: {
        enabled: toolbar
      },
      // @ts-expect-error undocumented option
      snap: true,
      toolbar: {
        enabled: toolbar,
        buttons: toolbarButtons,
        padding: 0
      },
      data,
      xKey: dateKey,
      volumeKey: volume ? volumeKey : void 0
    }
  };
  const statusBarOpts = statusBar ? {
    statusBar: {
      enabled: true,
      data,
      highKey,
      openKey,
      lowKey,
      closeKey,
      volumeKey: volume ? volumeKey : void 0
    }
  } : null;
  const zoomOpts = {
    zoom: {
      enabled: zoom,
      autoScaling: {
        enabled: true
      },
      // @ts-expect-error undocumented option
      enableIndependentAxes: true
    }
  };
  const toolbarOpts = {
    ranges: {
      enabled: rangeButtons
    }
  };
  const syncGroup = sync ? {
    sync: {
      enabled: sync,
      nodeInteraction: true,
      zoom: true
    }
  } : null;
  const volumeAxis = volume ? [
    {
      type: "number",
      position: "left",
      keys: [volumeKey],
      label: { enabled: false },
      crosshair: { enabled: false },
      gridLine: { enabled: false },
      nice: false,
      // @ts-expect-error undocumented option
      layoutConstraints: {
        stacked: false,
        width: 20,
        unit: "percent",
        align: "end"
      }
    }
  ] : [];
  return {
    theme: {
      baseTheme: typeof theme === "string" ? theme : "ag-financial",
      ...mergeDefaults(typeof theme === "object" ? theme : null, {
        overrides: {
          common: {
            title: { padding: 4 },
            padding: {
              top: 6,
              right: 8,
              bottom: 5
            },
            chartToolbar: {
              enabled: toolbar
            },
            annotations: { ...annotationsTheme },
            axes: {
              number: {
                interval: { maxSpacing: 45 },
                label: { format: ".2f" }
              }
            }
          },
          bar: {
            series: {
              fillOpacity: 0.5
            }
          },
          line: {
            series: {
              marker: { enabled: false },
              ...inlineSwitch(chartType, {
                hlc: {
                  stroke: { $palette: "altNeutral.stroke" },
                  strokeWidth: 2
                },
                line: {
                  stroke: { $palette: "neutral.stroke" }
                },
                "step-line": {
                  stroke: { $palette: "neutral.stroke" },
                  interpolation: { type: "step" }
                }
              })
            }
          },
          candlestick: {
            series: {
              ...inlineSwitch(chartType, {
                "hollow-candlestick": {
                  item: {
                    up: { fill: "transparent" }
                  }
                }
              })
            }
          },
          "range-area": {
            series: {
              fillOpacity: 0.3,
              strokeWidth: 2
            }
          }
        }
      })
    },
    animation: { enabled: false },
    legend: { enabled: false },
    series: [...volumeSeries, ...priceSeries],
    axes: [
      {
        type: "number",
        position: "right",
        keys: [openKey, closeKey, highKey, lowKey],
        crosshair: {
          enabled: true,
          snap: false
        },
        // @ts-expect-error undocumented option
        layoutConstraints: {
          stacked: false,
          width: 100,
          unit: "percent",
          align: "start"
        }
      },
      ...volumeAxis,
      {
        type: "ordinal-time",
        position: "bottom",
        line: {
          enabled: false
        },
        label: {
          enabled: true
        },
        crosshair: {
          enabled: true
        }
      }
    ],
    tooltip: { enabled: false },
    data,
    ...annotationOpts,
    ...navigatorOpts,
    ...statusBarOpts,
    ...zoomOpts,
    ...toolbarOpts,
    ...syncGroup,
    ...unusedOpts
  };
}
function createVolumeSeries(getTheme, openKey, closeKey, volume, volumeKey) {
  if (!volume)
    return [];
  return [
    {
      type: "bar",
      xKey: "date",
      yKey: volumeKey,
      tooltip: { enabled: false },
      itemStyler({ datum }) {
        const { up, down } = getTheme().palette;
        return { fill: datum[openKey] < datum[closeKey] ? up?.fill : down?.fill };
      },
      // @ts-expect-error undocumented option
      focusPriority: 1,
      fastDataProcessing: true,
      highlight: { enabled: false }
    }
  ];
}
var RANGE_AREA_TYPE = "range-area";
function createPriceSeries(chartType, xKey, highKey, lowKey, openKey, closeKey) {
  const keys = {
    xKey,
    openKey,
    closeKey,
    highKey,
    lowKey
  };
  const singleKeys = {
    xKey,
    yKey: closeKey
  };
  const common = {
    pickOutsideVisibleMinorAxis: true
  };
  switch (chartType ?? "candlestick") {
    case "ohlc":
      return createPriceSeriesOHLC(common, keys);
    case "line":
    case "step-line":
      return createPriceSeriesLine(common, singleKeys);
    case "hlc":
      return createPriceSeriesHLC(common, singleKeys, keys);
    case "high-low":
      return createPriceSeriesHighLow(common, keys);
    case "candlestick":
    case "hollow-candlestick":
      return createPriceSeriesCandlestick(common, keys);
    default:
      import_ag_charts_core10.Logger.warnOnce(`unknown chart type: ${chartType}; expected one of: ${chartTypes.join(", ")}`);
      return createPriceSeriesCandlestick(common, keys);
  }
}
function createPriceSeriesOHLC(common, keys) {
  return [
    {
      type: "ohlc",
      // @ts-expect-error undocumented option
      focusPriority: 0,
      ...common,
      ...keys
    }
  ];
}
function createPriceSeriesLine(common, singleKeys) {
  return [
    {
      type: "line",
      // @ts-expect-error undocumented option
      focusPriority: 0,
      ...common,
      ...singleKeys
    }
  ];
}
function createPriceSeriesHLC(common, singleKeys, { xKey, highKey, closeKey, lowKey }) {
  return [
    {
      type: RANGE_AREA_TYPE,
      // @ts-expect-error undocumented option
      focusPriority: 0,
      ...common,
      xKey,
      yHighKey: highKey,
      yLowKey: closeKey,
      fill: PALETTE_UP_FILL,
      stroke: PALETTE_UP_STROKE
    },
    {
      type: RANGE_AREA_TYPE,
      // @ts-expect-error undocumented option
      focusPriority: 0,
      ...common,
      xKey,
      yHighKey: closeKey,
      yLowKey: lowKey,
      fill: PALETTE_DOWN_FILL,
      stroke: PALETTE_DOWN_STROKE
    },
    {
      type: "line",
      ...common,
      ...singleKeys
    }
  ];
}
function createPriceSeriesHighLow(common, { xKey, highKey, lowKey }) {
  return [
    {
      type: "range-bar",
      ...common,
      xKey,
      yHighKey: highKey,
      yLowKey: lowKey,
      fill: PALETTE_NEUTRAL_FILL,
      stroke: PALETTE_NEUTRAL_STROKE,
      tooltip: {
        range: "nearest"
      },
      // @ts-expect-error undocumented option
      focusPriority: 0,
      fastDataProcessing: true
    }
  ];
}
function createPriceSeriesCandlestick(common, keys) {
  return [
    {
      type: "candlestick",
      // @ts-expect-error undocumented option
      focusPriority: 0,
      ...common,
      ...keys
    }
  ];
}
function inlineSwitch(caseName, switchCases) {
  return switchCases[caseName] ?? switchCases.default;
}

// packages/ag-charts-community/src/util/memo.ts
var memorizedFns = /* @__PURE__ */ new WeakMap();
function memo(params, fnGenerator) {
  const serialisedParams = JSON.stringify(params, null, 0);
  if (!memorizedFns.has(fnGenerator)) {
    memorizedFns.set(fnGenerator, /* @__PURE__ */ new Map());
  }
  if (!memorizedFns.get(fnGenerator)?.has(serialisedParams)) {
    memorizedFns.get(fnGenerator)?.set(serialisedParams, fnGenerator(params));
  }
  return memorizedFns.get(fnGenerator)?.get(serialisedParams);
}
function simpleMemorize(fn, cacheCallback) {
  const primitiveCache = /* @__PURE__ */ new Map();
  const paramsToKeys = (...params) => {
    return params.map((v) => {
      if (typeof v === "object")
        return v;
      if (typeof v === "symbol")
        return v;
      if (!primitiveCache.has(v)) {
        primitiveCache.set(v, { v });
      }
      return primitiveCache.get(v);
    });
  };
  const empty = {};
  const cache = /* @__PURE__ */ new WeakMap();
  return (...p) => {
    const keys = p.length === 0 ? [empty] : paramsToKeys(...p);
    let currentCache = cache;
    for (const key of keys.slice(0, -1)) {
      if (!currentCache.has(key)) {
        currentCache.set(key, /* @__PURE__ */ new WeakMap());
      }
      currentCache = currentCache.get(key);
    }
    const finalKey = keys.at(-1);
    let cachedValue = currentCache.get(finalKey);
    if (cachedValue) {
      cacheCallback?.("hit", fn, p);
    } else {
      cachedValue = fn(...p);
      currentCache.set(finalKey, cachedValue);
      cacheCallback?.("miss", fn, p);
    }
    return cachedValue;
  };
}

// packages/ag-charts-community/src/api/preset/sparkline.ts
var commonAxisProperties = {
  title: {
    enabled: false
  },
  label: {
    enabled: false
  },
  line: {
    enabled: false
  },
  gridLine: {
    enabled: false
  },
  crosshair: {
    enabled: false,
    stroke: DEFAULT_SPARKLINE_CROSSHAIR_STROKE,
    lineDash: [0],
    label: {
      enabled: false
    }
  }
};
var numericAxisProperties = {
  ...commonAxisProperties,
  nice: false
};
var chartTooltipDefaults = {
  mode: "compact",
  position: {
    anchorTo: "node",
    placement: ["right", "left"]
  },
  showArrow: false
};
var barGridLineDefaults = {
  style: [{ stroke: { $ref: "gridLineColor" } }],
  width: 2
};
var barAxisDefaults = {
  number: {
    gridLine: barGridLineDefaults
  },
  time: {
    gridLine: barGridLineDefaults
  },
  category: {
    gridLine: barGridLineDefaults
  }
};
var SPARKLINE_THEME = {
  overrides: {
    common: {
      animation: { enabled: false },
      contextMenu: { enabled: false },
      keyboard: { enabled: false },
      background: { visible: false },
      navigator: {
        enabled: false
      },
      padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      },
      axes: {
        number: {
          ...numericAxisProperties,
          interval: {
            values: [0]
          }
        },
        log: {
          ...numericAxisProperties
        },
        time: {
          ...numericAxisProperties
        },
        category: {
          ...commonAxisProperties
        }
      }
    },
    bar: {
      series: {
        crisp: false,
        label: {
          placement: "inside-end",
          padding: 4
        },
        // @ts-expect-error undocumented option
        sparklineMode: true
      },
      tooltip: {
        ...chartTooltipDefaults,
        position: {
          ...chartTooltipDefaults.position,
          anchorTo: "pointer"
        },
        range: "nearest"
      },
      axes: barAxisDefaults
    },
    line: {
      seriesArea: {
        padding: {
          top: 2,
          right: 2,
          bottom: 2,
          left: 2
        }
      },
      series: {
        // @ts-expect-error undocumented option
        sparklineMode: true,
        strokeWidth: 1,
        marker: {
          enabled: false,
          size: 3
        }
      },
      tooltip: chartTooltipDefaults
    },
    area: {
      seriesArea: {
        padding: {
          top: 1,
          right: 0,
          bottom: 1,
          left: 0
        }
      },
      series: {
        strokeWidth: 1,
        fillOpacity: 0.4
      },
      tooltip: chartTooltipDefaults
    }
  }
};
var setInitialBaseTheme = simpleMemorize(createInitialBaseTheme);
function createInitialBaseTheme(baseTheme, initialBaseTheme) {
  if (typeof baseTheme === "string") {
    return {
      ...initialBaseTheme,
      baseTheme
    };
  }
  if (baseTheme != null) {
    return {
      ...baseTheme,
      // @ts-expect-error internal implementation
      baseTheme: setInitialBaseTheme(baseTheme.baseTheme, initialBaseTheme)
    };
  }
  return initialBaseTheme;
}
function sparklineDataPreset(data) {
  if (Array.isArray(data) && data.length !== 0) {
    const firstItem = data[0];
    if (typeof firstItem === "number") {
      const mappedData = data.map((y, x) => ({ x, y }));
      return { data: mappedData, series: [{ xKey: "x", yKey: "y" }], datumKey: "y" };
    } else if (Array.isArray(firstItem)) {
      const mappedData = data.map((datum) => ({ x: datum[0], y: datum[1], datum }));
      return { data: mappedData, series: [{ xKey: "x", yKey: "y" }], datumKey: "datum" };
    }
  }
  return { data };
}
function axisPreset(opts) {
  switch (opts?.type) {
    case "number": {
      const { type, min, max, reverse: reverse2 } = opts;
      return pickProps(opts, {
        type,
        reverse: reverse2,
        min,
        max
      });
    }
    case "time": {
      const { type, min, max, reverse: reverse2 } = opts;
      return pickProps(opts, {
        type,
        reverse: reverse2,
        min,
        max
      });
    }
    case "category":
    default:
      const { paddingInner, paddingOuter, reverse } = opts ?? {};
      return pickProps(
        { ...opts, type: "category" },
        {
          type: "category",
          reverse,
          paddingInner,
          paddingOuter
        }
      );
  }
}
function gridLinePreset(opts, defaultEnabled, sparkOpts) {
  const gridLineOpts = {};
  if (opts?.stroke != null) {
    gridLineOpts.style = [{ stroke: opts?.stroke }];
    gridLineOpts.enabled ?? (gridLineOpts.enabled = true);
  }
  if (opts?.strokeWidth != null) {
    gridLineOpts.width = opts?.strokeWidth;
    gridLineOpts.enabled ?? (gridLineOpts.enabled = true);
  }
  if (sparkOpts.type === "bar" && sparkOpts.direction !== "horizontal") {
    gridLineOpts.enabled ?? (gridLineOpts.enabled = true);
  }
  if (opts?.visible != null) {
    gridLineOpts.enabled = opts.visible;
  }
  gridLineOpts.enabled ?? (gridLineOpts.enabled = defaultEnabled);
  return gridLineOpts;
}
var tooltipRendererFn = simpleMemorize((context, tooltip, datumKey) => {
  return (params) => {
    const xValue = params.datum[params.xKey];
    const yValue = params.datum[params.yKey];
    const datum = datumKey != null ? params.datum[datumKey] : params.datum;
    const userContent = tooltip?.renderer?.({ context, datum, xValue, yValue });
    if (typeof userContent === "string")
      return userContent;
    const content = userContent?.content ?? yValue.toFixed(2);
    return userContent?.title ? {
      heading: void 0,
      title: void 0,
      data: [{ label: userContent.title, value: content }]
    } : {
      heading: void 0,
      title: content,
      data: []
    };
  };
});
function sparkline(opts) {
  const {
    background,
    container,
    height: height2,
    listeners,
    locale,
    minHeight,
    minWidth,
    overrideDevicePixelRatio,
    padding,
    width: width2,
    theme: baseTheme,
    data: baseData,
    crosshair,
    axis,
    min,
    max,
    tooltip,
    context,
    styleNonce,
    ...optsRest
  } = opts;
  const chartOpts = pickProps(opts, {
    background,
    container,
    height: height2,
    listeners,
    locale,
    minHeight,
    minWidth,
    overrideDevicePixelRatio,
    padding,
    width: width2,
    styleNonce,
    tooltip: IGNORED_PROP,
    context: IGNORED_PROP,
    data: IGNORED_PROP,
    crosshair: IGNORED_PROP,
    axis: IGNORED_PROP,
    min: IGNORED_PROP,
    max: IGNORED_PROP,
    theme: IGNORED_PROP
  });
  const { data, series: [seriesOverrides] = [], datumKey } = sparklineDataPreset(baseData);
  const seriesOptions = optsRest;
  if (seriesOverrides != null)
    Object.assign(seriesOptions, seriesOverrides);
  seriesOptions.tooltip = {
    ...tooltip,
    renderer: tooltipRendererFn(context, tooltip, datumKey)
  };
  chartOpts.theme = setInitialBaseTheme(baseTheme, SPARKLINE_THEME);
  chartOpts.data = data;
  chartOpts.series = [seriesOptions];
  const swapAxes = seriesOptions.type !== "bar" || seriesOptions.direction !== "horizontal";
  const [xAxisPosition, yAxisPosition] = swapAxes ? ["bottom", "left"] : ["left", "bottom"];
  const xAxis = {
    ...axisPreset(axis),
    position: xAxisPosition,
    ...pickProps(opts, { crosshair })
  };
  const yAxis = {
    type: "number",
    gridLine: gridLinePreset(axis, false, opts),
    position: yAxisPosition,
    ...pickProps(opts, { min, max })
  };
  chartOpts.axes = swapAxes ? [yAxis, xAxis] : [xAxis, yAxis];
  return chartOpts;
}

// packages/ag-charts-community/src/api/preset/presetModules.ts
var priceVolumeOptionsDef = {
  chartType: (0, import_ag_charts_core11.union)("candlestick", "hollow-candlestick", "ohlc", "line", "step-line", "hlc", "high-low"),
  dateKey: import_ag_charts_core11.string,
  openKey: import_ag_charts_core11.string,
  highKey: import_ag_charts_core11.string,
  lowKey: import_ag_charts_core11.string,
  closeKey: import_ag_charts_core11.string,
  volumeKey: import_ag_charts_core11.string,
  navigator: import_ag_charts_core11.boolean,
  volume: import_ag_charts_core11.boolean,
  rangeButtons: import_ag_charts_core11.boolean,
  statusBar: import_ag_charts_core11.boolean,
  toolbar: import_ag_charts_core11.boolean,
  zoom: import_ag_charts_core11.boolean,
  sync: import_ag_charts_core11.boolean,
  // Valid pass-through options
  theme: import_ag_charts_core11.defined,
  container: import_ag_charts_core11.defined,
  width: import_ag_charts_core11.defined,
  height: import_ag_charts_core11.defined,
  minWidth: import_ag_charts_core11.defined,
  minHeight: import_ag_charts_core11.defined,
  listeners: import_ag_charts_core11.defined,
  initialState: import_ag_charts_core11.defined,
  title: import_ag_charts_core11.defined,
  data: import_ag_charts_core11.array
};
var commonGaugeOptions = {
  // Valid pass-through options
  theme: import_ag_charts_core11.defined,
  container: import_ag_charts_core11.defined,
  animation: import_ag_charts_core11.defined,
  background: import_ag_charts_core11.defined,
  contextMenu: import_ag_charts_core11.defined,
  listeners: import_ag_charts_core11.defined,
  locale: import_ag_charts_core11.defined,
  width: import_ag_charts_core11.defined,
  height: import_ag_charts_core11.defined,
  minWidth: import_ag_charts_core11.defined,
  minHeight: import_ag_charts_core11.defined,
  title: import_ag_charts_core11.defined,
  subtitle: import_ag_charts_core11.defined,
  footnote: import_ag_charts_core11.defined,
  padding: import_ag_charts_core11.defined,
  tooltip: {
    ...tooltipOptionsDefs,
    ...commonChartOptionsDefs.tooltip
  }
};
commonGaugeOptions.overrideDevicePixelRatio = (0, import_ag_charts_core11.undocumented)(import_ag_charts_core11.positiveNumber);
var commonSparklineOmit = [
  "showInLegend",
  "showInMiniChart",
  "grouped",
  "stacked",
  "stackGroup",
  "tooltip",
  "listeners",
  "errorBar",
  "xKey",
  "yKey",
  "type"
];
var commonSparklineAxisOptionsDef = {
  visible: import_ag_charts_core11.boolean,
  reverse: import_ag_charts_core11.boolean,
  stroke: import_ag_charts_core11.color,
  strokeWidth: import_ag_charts_core11.positiveNumber
};
var commonSparklineOptionsDef = {
  context: import_ag_charts_core11.defined,
  tooltip: import_ag_charts_core11.defined,
  theme: import_ag_charts_core11.defined,
  background: import_ag_charts_core11.defined,
  container: import_ag_charts_core11.defined,
  width: import_ag_charts_core11.defined,
  height: import_ag_charts_core11.defined,
  minWidth: import_ag_charts_core11.defined,
  minHeight: import_ag_charts_core11.defined,
  padding: import_ag_charts_core11.defined,
  listeners: import_ag_charts_core11.defined,
  locale: import_ag_charts_core11.defined,
  data: import_ag_charts_core11.defined,
  styleNonce: import_ag_charts_core11.string,
  axis: (0, import_ag_charts_core11.typeUnion)(
    {
      number: {
        ...commonSparklineAxisOptionsDef,
        min: (0, import_ag_charts_core11.and)(import_ag_charts_core11.number, (0, import_ag_charts_core11.lessThan)("max")),
        max: (0, import_ag_charts_core11.and)(import_ag_charts_core11.number, (0, import_ag_charts_core11.greaterThan)("min"))
      },
      category: {
        ...commonSparklineAxisOptionsDef,
        paddingInner: import_ag_charts_core11.ratio,
        paddingOuter: import_ag_charts_core11.ratio
      },
      time: {
        ...commonSparklineAxisOptionsDef,
        min: (0, import_ag_charts_core11.and)((0, import_ag_charts_core11.or)(import_ag_charts_core11.number, import_ag_charts_core11.date), (0, import_ag_charts_core11.lessThan)("max")),
        max: (0, import_ag_charts_core11.and)((0, import_ag_charts_core11.or)(import_ag_charts_core11.number, import_ag_charts_core11.date), (0, import_ag_charts_core11.greaterThan)("min"))
      }
    },
    "axis options",
    "category"
    // AG-14799 - Contrary to the AgSparklineAxisOptions interface, type is optional and defaults to 'category'.
  ),
  min: (0, import_ag_charts_core11.and)(import_ag_charts_core11.number, (0, import_ag_charts_core11.lessThan)("max")),
  max: (0, import_ag_charts_core11.and)(import_ag_charts_core11.number, (0, import_ag_charts_core11.greaterThan)("min")),
  crosshair: {
    enabled: import_ag_charts_core11.boolean,
    snap: import_ag_charts_core11.boolean,
    ...import_ag_charts_core11.strokeOptionsDef,
    ...import_ag_charts_core11.lineDashOptionsDef
  },
  xKey: import_ag_charts_core11.string,
  yKey: import_ag_charts_core11.string
};
var PriceVolumePresetModule = {
  type: "preset",
  name: "price-volume",
  enterprise: true,
  options: priceVolumeOptionsDef,
  create: priceVolume
};
var GaugePresetModule = {
  type: "preset",
  name: "gauge-preset",
  enterprise: true,
  options: (0, import_ag_charts_core11.typeUnion)(
    {
      "linear-gauge": {
        ...without(linearGaugeSeriesOptionsDef, ["type"]),
        ...commonGaugeOptions
      },
      "radial-gauge": {
        ...without(radialGaugeSeriesOptionsDef, ["type"]),
        ...commonGaugeOptions
      }
    },
    "gauge options"
  ),
  create: gauge
};
var SparklinePresetModule = {
  type: "preset",
  name: "sparkline",
  options: (0, import_ag_charts_core11.typeUnion)(
    {
      area: {
        ...commonSparklineOptionsDef,
        ...without(areaSeriesOptionsDef, commonSparklineOmit)
      },
      bar: {
        ...commonSparklineOptionsDef,
        ...without(barSeriesOptionsDef, commonSparklineOmit)
      },
      line: {
        ...commonSparklineOptionsDef,
        ...without(lineSeriesOptionsDef, commonSparklineOmit)
      }
    },
    "sparkline options"
  ),
  create: sparkline,
  processData: sparklineDataPreset
};

// packages/ag-charts-community/src/chart/cartesianChartModule.ts
var import_ag_charts_core119 = require("ag-charts-core");

// packages/ag-charts-community/src/chart/cartesianChart.ts
var import_ag_charts_core117 = require("ag-charts-core");

// packages/ag-charts-community/src/motion/animation.ts
var import_ag_charts_core15 = require("ag-charts-core");

// packages/ag-charts-community/src/scene/node.ts
var import_ag_charts_core14 = require("ag-charts-core");

// packages/ag-charts-community/src/scene/bbox.ts
var import_ag_charts_core12 = require("ag-charts-core");

// packages/ag-charts-community/src/util/bboxinterface.ts
var BBoxValues = { containsPoint, equals, isEmpty, normalize };
function containsPoint(bbox, x, y) {
  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
}
function equals(lhs, rhs) {
  return lhs.x === rhs.x && lhs.y === rhs.y && lhs.width === rhs.width && lhs.height === rhs.height;
}
function isEmpty(bbox) {
  return bbox == null || bbox.height === 0 || bbox.width === 0 || isNaN(bbox.height) || isNaN(bbox.width);
}
function normalize(bbox) {
  let { x, y, width: width2, height: height2 } = bbox;
  if ((width2 == null || width2 > 0) && (height2 == null || height2 > 0))
    return bbox;
  if (x != null && width2 != null && width2 < 0) {
    width2 = -width2;
    x = x - width2;
  }
  if (y != null && height2 != null && height2 < 0) {
    height2 = -height2;
    y = y - height2;
  }
  return { x, y, width: width2, height: height2 };
}

// packages/ag-charts-community/src/util/interpolating.ts
var interpolate = Symbol("interpolate");
var isInterpolating = (x) => x[interpolate] != null;

// packages/ag-charts-community/src/util/nearest.ts
function nearestSquared(x, y, objects, maxDistanceSquared = Infinity) {
  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };
  for (const obj of objects) {
    const thisDistance = obj.distanceSquared(x, y);
    if (thisDistance === 0) {
      return { nearest: obj, distanceSquared: 0 };
    } else if (thisDistance < result.distanceSquared) {
      result.nearest = obj;
      result.distanceSquared = thisDistance;
    }
  }
  return result;
}

// packages/ag-charts-community/src/scene/bbox.ts
var _BBox = class _BBox {
  constructor(x, y, width2, height2) {
    this.x = x;
    this.y = y;
    this.width = width2;
    this.height = height2;
  }
  static fromDOMRect({ x, y, width: width2, height: height2 }) {
    return new _BBox(x, y, width2, height2);
  }
  static merge(boxes) {
    let left = Infinity;
    let top = Infinity;
    let right = -Infinity;
    let bottom = -Infinity;
    for (const box of boxes) {
      if (box.x < left) {
        left = box.x;
      }
      if (box.y < top) {
        top = box.y;
      }
      if (box.x + box.width > right) {
        right = box.x + box.width;
      }
      if (box.y + box.height > bottom) {
        bottom = box.y + box.height;
      }
    }
    return new _BBox(left, top, right - left, bottom - top);
  }
  static nearestBox(x, y, boxes) {
    return nearestSquared(x, y, boxes);
  }
  toDOMRect() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height,
      top: this.y,
      left: this.x,
      right: this.x + this.width,
      bottom: this.y + this.height,
      toJSON() {
        return {};
      }
    };
  }
  clone() {
    const { x, y, width: width2, height: height2 } = this;
    return new _BBox(x, y, width2, height2);
  }
  equals(other) {
    return BBoxValues.equals(this, other);
  }
  containsPoint(x, y) {
    return BBoxValues.containsPoint(this, x, y);
  }
  intersection(other) {
    if (!this.collidesBBox(other))
      return;
    const newX1 = (0, import_ag_charts_core12.clamp)(other.x, this.x, other.x + other.width);
    const newY1 = (0, import_ag_charts_core12.clamp)(other.y, this.y, other.y + other.height);
    const newX2 = (0, import_ag_charts_core12.clamp)(other.x, this.x + this.width, other.x + other.width);
    const newY2 = (0, import_ag_charts_core12.clamp)(other.y, this.y + this.height, other.y + other.height);
    return new _BBox(newX1, newY1, newX2 - newX1, newY2 - newY1);
  }
  collidesBBox(other) {
    return this.x < other.x + other.width && this.x + this.width > other.x && this.y < other.y + other.height && this.y + this.height > other.y;
  }
  computeCenter() {
    return { x: this.x + this.width / 2, y: this.y + this.height / 2 };
  }
  isFinite() {
    return Number.isFinite(this.x) && Number.isFinite(this.y) && Number.isFinite(this.width) && Number.isFinite(this.height);
  }
  distanceSquared(x, y) {
    if (this.containsPoint(x, y)) {
      return 0;
    }
    const dx = x - (0, import_ag_charts_core12.clamp)(this.x, x, this.x + this.width);
    const dy = y - (0, import_ag_charts_core12.clamp)(this.y, y, this.y + this.height);
    return dx * dx + dy * dy;
  }
  shrink(amount, position) {
    if (typeof amount === "number") {
      this.applyMargin(amount, position);
    } else {
      for (const key of Object.keys(amount)) {
        const value = amount[key];
        if (typeof value === "number") {
          this.applyMargin(value, key);
        }
      }
    }
    if (this.width < 0) {
      this.width = 0;
    }
    if (this.height < 0) {
      this.height = 0;
    }
    return this;
  }
  grow(amount, position) {
    if (typeof amount === "number") {
      this.applyMargin(-amount, position);
    } else {
      for (const key of Object.keys(amount)) {
        const value = amount[key];
        if (typeof value === "number") {
          this.applyMargin(-value, key);
        }
      }
    }
    return this;
  }
  applyMargin(value, position) {
    switch (position) {
      case "top":
        this.y += value;
      case "bottom":
        this.height -= value;
        break;
      case "left":
        this.x += value;
      case "right":
        this.width -= value;
        break;
      case "vertical":
        this.y += value;
        this.height -= value * 2;
        break;
      case "horizontal":
        this.x += value;
        this.width -= value * 2;
        break;
      case void 0:
        this.x += value;
        this.y += value;
        this.width -= value * 2;
        this.height -= value * 2;
        break;
    }
  }
  translate(x, y) {
    this.x += x;
    this.y += y;
    return this;
  }
  [interpolate](other, d) {
    return new _BBox(
      this.x * (1 - d) + other.x * d,
      this.y * (1 - d) + other.y * d,
      this.width * (1 - d) + other.width * d,
      this.height * (1 - d) + other.height * d
    );
  }
};
_BBox.zero = Object.freeze(new _BBox(0, 0, 0, 0));
_BBox.NaN = Object.freeze(new _BBox(NaN, NaN, NaN, NaN));
var BBox = _BBox;

// packages/ag-charts-community/src/scene/changeDetectable.ts
var import_ag_charts_core13 = require("ag-charts-core");
var TRIPLE_EQ = (lhs, rhs) => lhs === rhs;
function SceneChangeDetection(opts) {
  return function(target, key) {
    const privateKey = `__${key}`;
    if (target[key]) {
      return;
    }
    prepareGetSet(target, key, privateKey, opts);
  };
}
function SceneObjectChangeDetection(opts) {
  return SceneChangeDetection(opts);
}
function SceneArrayChangeDetection(opts) {
  const baseOpts = opts ?? {};
  baseOpts.equals = import_ag_charts_core13.arraysEqual;
  return SceneChangeDetection(opts);
}
function prepareGetSet(target, key, privateKey, opts) {
  const { changeCb, convertor, checkDirtyOnAssignment = false } = opts ?? {};
  const requiredOpts = { changeCb, checkDirtyOnAssignment, convertor };
  const setter = buildCheckDirtyChain(
    privateKey,
    buildChangeCallbackChain(
      buildConvertorChain(buildSetter(privateKey, requiredOpts), requiredOpts),
      requiredOpts
    ),
    requiredOpts
  );
  const getter = function() {
    return this[privateKey];
  };
  Object.defineProperty(target, key, {
    set: setter,
    get: getter,
    enumerable: true,
    configurable: true
  });
}
function buildConvertorChain(setterFn, opts) {
  const { convertor } = opts;
  if (convertor) {
    return function(value) {
      setterFn.call(this, convertor(value));
    };
  }
  return setterFn;
}
var NO_CHANGE = Symbol("no-change");
function buildChangeCallbackChain(setterFn, opts) {
  const { changeCb } = opts;
  if (changeCb) {
    return function(value) {
      const change = setterFn.call(this, value);
      if (change !== NO_CHANGE) {
        changeCb.call(this, this);
      }
      return change;
    };
  }
  return setterFn;
}
function buildCheckDirtyChain(privateKey, setterFn, opts) {
  const { checkDirtyOnAssignment } = opts;
  if (checkDirtyOnAssignment) {
    return function(value) {
      const change = setterFn.call(this, value);
      if (value?._dirty === true) {
        this.markDirty(privateKey);
      }
      return change;
    };
  }
  return setterFn;
}
function buildSetter(privateKey, opts) {
  const { equals: equals2 = TRIPLE_EQ } = opts;
  return function(value) {
    const oldValue = this[privateKey];
    if (!equals2(value, oldValue)) {
      this[privateKey] = value;
      this.onChangeDetection(privateKey);
      return value;
    }
    return NO_CHANGE;
  };
}

// packages/ag-charts-community/src/scene/node.ts
var _Node = class _Node {
  constructor(options) {
    /** Unique number to allow creation order to be easily determined. */
    this.serialNumber = _Node._nextSerialNumber++;
    this.childNodeCounts = { groups: 0, nonGroups: 0, thisComplexity: 0, complexity: 0 };
    /** Unique node ID in the form `ClassName-NaturalNumber`. */
    this.id = (0, import_ag_charts_core14.createId)(this);
    this.pointerEvents = 0 /* All */;
    this.scene = void 0;
    this._dirty = true;
    this.dirtyZIndex = false;
    /**
     * To simplify the type system (especially in Selections) we don't have the `Parent` node
     * (one that has children). Instead, we mimic HTML DOM, where any node can have children.
     * But we still need to distinguish regular leaf nodes from container leafs somehow.
     */
    this.isContainerNode = false;
    this.visible = true;
    this.zIndex = 0;
    this.name = options?.name;
    this.tag = options?.tag ?? NaN;
    this.zIndex = options?.zIndex ?? 0;
    if (options?.debugDirty ?? _Node._debugEnabled) {
      this._debugDirtyProperties = /* @__PURE__ */ new Map([["__first__", []]]);
    }
  }
  static toSVG(node, width2, height2) {
    const svg = node?.toSVG();
    if (svg == null || !svg.elements.length && !svg.defs?.length)
      return;
    const root = (0, import_ag_charts_core14.createSvgElement)("svg");
    root.setAttribute("width", String(width2));
    root.setAttribute("height", String(height2));
    root.setAttribute("viewBox", `0 0 ${width2} ${height2}`);
    if (svg.defs?.length) {
      const defs = (0, import_ag_charts_core14.createSvgElement)("defs");
      defs.append(...svg.defs);
      root.append(defs);
    }
    root.append(...svg.elements);
    return root.outerHTML;
  }
  static *extractBBoxes(nodes, skipInvisible) {
    for (const n of nodes) {
      if (!skipInvisible || n.visible && !n.transitionOut) {
        const bbox = n.getBBox();
        if (bbox)
          yield bbox;
      }
    }
  }
  /**
   * Some arbitrary data bound to the node.
   */
  get datum() {
    return this._datum;
  }
  set datum(datum) {
    if (this._datum !== datum) {
      this._previousDatum = this._datum;
      this._datum = datum;
    }
  }
  get previousDatum() {
    return this._previousDatum;
  }
  get layerManager() {
    return this.scene?.layersManager;
  }
  get imageLoader() {
    return this.scene?.imageLoader;
  }
  get dirty() {
    return this._dirty;
  }
  closestDatum() {
    for (const { datum } of this.traverseUp(true)) {
      if (datum != null) {
        return datum;
      }
    }
  }
  /** Perform any pre-rendering initialization. */
  preRender(renderCtx, thisComplexity = 1) {
    this.childNodeCounts.groups = 0;
    this.childNodeCounts.nonGroups = 1;
    this.childNodeCounts.complexity = thisComplexity;
    this.childNodeCounts.thisComplexity = thisComplexity;
    for (const child of this.children()) {
      const childCounts = child.preRender(renderCtx);
      this.childNodeCounts.groups += childCounts.groups;
      this.childNodeCounts.nonGroups += childCounts.nonGroups;
      this.childNodeCounts.complexity += childCounts.complexity;
    }
    return this.childNodeCounts;
  }
  render(renderCtx) {
    const { stats } = renderCtx;
    this._dirty = false;
    this.debugDirtyProperties();
    if (renderCtx.debugNodeSearch) {
      const idOrName = this.name ?? this.id;
      if (renderCtx.debugNodeSearch.some((v) => typeof v === "string" ? v === idOrName : v.test(idOrName))) {
        renderCtx.debugNodes[this.name ?? this.id] = this;
      }
    }
    if (stats) {
      stats.nodesRendered++;
      stats.opsPerformed += this.childNodeCounts.thisComplexity;
    }
  }
  setScene(scene) {
    this.scene = scene;
    this._debug = scene?.layersManager?.debug;
    for (const child of this.children()) {
      child.setScene(scene);
    }
  }
  sortChildren(compareFn) {
    this.dirtyZIndex = false;
    if (!this.childNodes)
      return;
    const sortedChildren = [...this.childNodes].sort(compareFn);
    this.childNodes.clear();
    for (const child of sortedChildren) {
      this.childNodes.add(child);
    }
  }
  *traverseUp(includeSelf) {
    let node = this;
    if (includeSelf) {
      yield node;
    }
    while (node = node.parentNode) {
      yield node;
    }
  }
  *children() {
    if (!this.childNodes)
      return;
    for (const child of this.childNodes) {
      yield child;
    }
  }
  *descendants() {
    for (const child of this.children()) {
      yield child;
      yield* child.descendants();
    }
  }
  /**
   * Checks if the node is a leaf (has no children).
   */
  isLeaf() {
    return !this.childNodes?.size;
  }
  /**
   * Checks if the node is the root (has no parent).
   */
  isRoot() {
    return !this.parentNode;
  }
  /**
   * Appends one or more new node instances to this parent.
   * If one needs to:
   * - move a child to the end of the list of children
   * - move a child from one parent to another (including parents in other scenes)
   * one should use the {@link insertBefore} method instead.
   * @param nodes A node or nodes to append.
   */
  append(nodes) {
    this.childNodes ?? (this.childNodes = /* @__PURE__ */ new Set());
    for (const node of (0, import_ag_charts_core14.toIterable)(nodes)) {
      node.parentNode?.removeChild(node);
      this.childNodes.add(node);
      node.parentNode = this;
      node.setScene(this.scene);
    }
    this.invalidateCachedBBox();
    this.dirtyZIndex = true;
    this.markDirty();
  }
  appendChild(node) {
    this.append(node);
    return node;
  }
  removeChild(node) {
    if (!this.childNodes?.delete(node)) {
      throw new Error(
        `AG Charts - internal error, unknown child node ${node.name ?? node.id} in $${this.name ?? this.id}`
      );
    }
    delete node.parentNode;
    node.setScene();
    this.invalidateCachedBBox();
    this.dirtyZIndex = true;
    this.markDirty();
  }
  remove() {
    this.parentNode?.removeChild(this);
  }
  clear() {
    for (const child of this.children()) {
      delete child.parentNode;
      child.setScene();
    }
    this.childNodes?.clear();
    this.invalidateCachedBBox();
  }
  destroy() {
    this.parentNode?.removeChild(this);
  }
  setProperties(styles, pickKeys) {
    if (pickKeys) {
      for (const key of pickKeys) {
        this[key] = styles[key];
      }
    } else {
      Object.assign(this, styles);
    }
    return this;
  }
  containsPoint(_x, _y) {
    return false;
  }
  /**
   * Hit testing method.
   * Recursively checks if the given point is inside this node or any of its children.
   * Returns the first matching node or `undefined`.
   * Nodes that render later (show on top) are hit tested first.
   */
  pickNode(x, y) {
    if (!this.visible || this.pointerEvents === 1 /* None */ || !this.containsPoint(x, y)) {
      return;
    }
    if (this.childNodes != null && this.childNodes.size !== 0) {
      const children = [...this.children()];
      for (let i = children.length - 1; i >= 0; i--) {
        const hit = children[i].pickNode(x, y);
        if (hit) {
          return hit;
        }
      }
    } else if (!this.isContainerNode) {
      return this;
    }
  }
  pickNodes(x, y, into = []) {
    if (!this.visible || this.pointerEvents === 1 /* None */ || !this.containsPoint(x, y)) {
      return into;
    }
    if (!this.isContainerNode) {
      into.push(this);
    }
    for (const child of this.children()) {
      child.pickNodes(x, y, into);
    }
    return into;
  }
  invalidateCachedBBox() {
    if (this.cachedBBox != null) {
      this.cachedBBox = void 0;
      this.parentNode?.invalidateCachedBBox();
    }
  }
  getBBox() {
    if (this.cachedBBox == null) {
      this.cachedBBox = Object.freeze(this.computeBBox());
    }
    return this.cachedBBox;
  }
  computeBBox() {
    return;
  }
  onChangeDetection(property) {
    this.markDirty(property);
  }
  markDirty(property) {
    const { _dirty } = this;
    if (property != null && this._debugDirtyProperties) {
      this.markDebugProperties(property);
    }
    const noParentCachedBBox = this.cachedBBox == null;
    if (noParentCachedBBox && _dirty)
      return;
    this.invalidateCachedBBox();
    this._dirty = true;
    if (this.parentNode) {
      this.parentNode.markDirty();
    }
  }
  markClean() {
    if (!this._dirty)
      return;
    this._dirty = false;
    this.debugDirtyProperties();
    for (const child of this.children()) {
      child.markClean();
    }
  }
  markDebugProperties(property) {
    const sources = this._debugDirtyProperties?.get(property) ?? [];
    const caller = new Error().stack?.split("\n").filter((line) => {
      return line !== "Error" && !line.includes(".markDebugProperties") && !line.includes(".markDirty") && !line.includes("Object.assign ") && !line.includes(`${this.constructor.name}.`);
    }) ?? "unknown";
    sources.push(caller[0].replace(" at ", "").trim());
    this._debugDirtyProperties?.set(property, sources);
  }
  debugDirtyProperties() {
    if (this._debugDirtyProperties == null)
      return;
    if (!this._debugDirtyProperties.has("__first__")) {
      this._debugDirtyProperties.forEach((sources, property) => {
        if (sources.length > 1) {
          console.groupCollapsed(
            `Property changed multiple times before render: ${this.constructor.name}.${property} (${sources.length}x)`
          );
          sources.forEach((source) => console.log(source));
          console.groupEnd();
        }
      });
    }
    this._debugDirtyProperties.clear();
  }
  onZIndexChange() {
    const { parentNode } = this;
    if (parentNode) {
      parentNode.dirtyZIndex = true;
    }
  }
  toSVG() {
    return;
  }
};
_Node._nextSerialNumber = 0;
// eslint-disable-next-line sonarjs/public-static-readonly
_Node._debugEnabled = false;
__decorateClass([
  SceneChangeDetection()
], _Node.prototype, "visible", 2);
__decorateClass([
  SceneObjectChangeDetection({
    equals: objectsEqual,
    changeCb: (target) => target.onZIndexChange()
  })
], _Node.prototype, "zIndex", 2);
var Node2 = _Node;

// packages/ag-charts-community/src/util/interpolate.ts
function interpolateNumber(a, b) {
  return (d) => Number(a) * (1 - d) + Number(b) * d;
}
function interpolateColor(a, b) {
  if (typeof a === "string") {
    try {
      a = Color.fromString(a);
    } catch {
      a = Color.fromArray([0, 0, 0]);
    }
  }
  if (typeof b === "string") {
    try {
      b = Color.fromString(b);
    } catch {
      b = Color.fromArray([0, 0, 0]);
    }
  }
  return (d) => Color.mix(a, b, d).toRgbaString();
}

// packages/ag-charts-community/src/motion/easing.ts
var linear = (n) => n;
var easeOut = (n) => Math.sin(n * Math.PI / 2);
var inverseEaseOut = (x) => 2 * Math.asin(x) / Math.PI;

// packages/ag-charts-community/src/motion/animation.ts
var QUICK_TRANSITION = 0.2;
var PHASE_ORDER = ["initial", "remove", "update", "add", "trailing", "end", "none"];
var PHASE_METADATA = {
  initial: {
    animationDuration: 1,
    animationDelay: 0
  },
  add: {
    animationDuration: 0.25,
    animationDelay: 0.75
  },
  remove: {
    animationDuration: 0.25,
    animationDelay: 0
  },
  update: {
    animationDuration: 0.5,
    animationDelay: 0.25
  },
  trailing: {
    animationDuration: QUICK_TRANSITION,
    animationDelay: 1,
    skipIfNoEarlierAnimations: true
  },
  end: {
    animationDelay: 1 + QUICK_TRANSITION,
    animationDuration: 0,
    skipIfNoEarlierAnimations: true
  },
  none: {
    animationDuration: 0,
    animationDelay: 0
  }
};
function isNodeArray(array4) {
  return array4.every((n) => n instanceof Node2);
}
function deconstructSelectionsOrNodes(selectionsOrNodes) {
  return isNodeArray(selectionsOrNodes) ? { nodes: selectionsOrNodes, selections: [] } : { nodes: [], selections: selectionsOrNodes };
}
function animationValuesEqual(a, b) {
  if (a === b) {
    return true;
  } else if (Array.isArray(a) && Array.isArray(b)) {
    return a.length === b.length && a.every((v, i) => animationValuesEqual(v, b[i]));
  } else if (isInterpolating(a) && isInterpolating(b)) {
    return a.equals(b);
  } else if ((0, import_ag_charts_core15.isPlainObject)(a) && (0, import_ag_charts_core15.isPlainObject)(b)) {
    return objectsEqualWith(a, b, animationValuesEqual);
  }
  return false;
}
var Animation = class {
  constructor(opts) {
    this.isComplete = false;
    this.elapsed = 0;
    this.iteration = 0;
    this.isPlaying = false;
    this.isReverse = false;
    this.id = opts.id;
    this.groupId = opts.groupId;
    this.autoplay = opts.autoplay ?? true;
    this.ease = opts.ease ?? linear;
    this.phase = opts.phase;
    const durationProportion = opts.duration ?? PHASE_METADATA[this.phase].animationDuration;
    this.duration = durationProportion * opts.defaultDuration;
    this.delay = (opts.delay ?? 0) * opts.defaultDuration;
    this.onComplete = opts.onComplete;
    this.onPlay = opts.onPlay;
    this.onStop = opts.onStop;
    this.onUpdate = opts.onUpdate;
    this.interpolate = this.createInterpolator(opts.from, opts.to);
    this.from = opts.from;
    if (opts.skip === true) {
      this.onUpdate?.(opts.to, false, this);
      this.onStop?.(this);
      this.onComplete?.(this);
      this.isComplete = true;
    }
    if (opts.collapsable !== false) {
      this.duration = this.checkCollapse(opts, this.duration);
    }
  }
  checkCollapse(opts, calculatedDuration) {
    return animationValuesEqual(opts.from, opts.to) ? 0 : calculatedDuration;
  }
  play(initialUpdate = false) {
    if (this.isPlaying || this.isComplete)
      return;
    this.isPlaying = true;
    this.onPlay?.(this);
    if (!this.autoplay)
      return;
    this.autoplay = false;
    if (!initialUpdate)
      return;
    this.onUpdate?.(this.from, true, this);
  }
  stop() {
    this.isPlaying = false;
    if (!this.isComplete) {
      this.isComplete = true;
      this.onStop?.(this);
    }
  }
  update(time2) {
    if (this.isComplete)
      return time2;
    if (!this.isPlaying && this.autoplay) {
      this.play(true);
    }
    const previousElapsed = this.elapsed;
    this.elapsed += time2;
    if (this.delay > this.elapsed)
      return 0;
    const value = this.interpolate(this.isReverse ? 1 - this.delta : this.delta);
    this.onUpdate?.(value, false, this);
    const totalDuration = this.delay + this.duration;
    if (this.elapsed >= totalDuration) {
      this.stop();
      this.isComplete = true;
      this.onComplete?.(this);
      return time2 - (totalDuration - previousElapsed);
    }
    return 0;
  }
  get delta() {
    return this.ease((0, import_ag_charts_core15.clamp)(0, (this.elapsed - this.delay) / this.duration, 1));
  }
  createInterpolator(from2, to) {
    if (typeof to !== "object" || isInterpolating(to)) {
      return this.interpolateValue(from2, to);
    }
    const interpolatorEntries = [];
    for (const key of Object.keys(to)) {
      const interpolator = this.interpolateValue(from2[key], to[key]);
      if (interpolator != null) {
        interpolatorEntries.push([key, interpolator]);
      }
    }
    return (d) => {
      const result = {};
      for (const [key, interpolator] of interpolatorEntries) {
        result[key] = interpolator(d);
      }
      return result;
    };
  }
  interpolateValue(a, b) {
    if (a == null || b == null) {
      return;
    } else if (isInterpolating(a)) {
      return (d) => a[interpolate](b, d);
    }
    try {
      switch (typeof a) {
        case "number":
          return interpolateNumber(a, b);
        case "string":
          return interpolateColor(a, b);
        case "boolean":
          if (a === b) {
            return () => a;
          }
          break;
        case "object":
          return () => a;
        default:
          throw new Error(`Unable to interpolate values: ${a}, ${b}`);
      }
    } catch {
    }
    throw new Error(`Unable to interpolate values: ${a}, ${b}`);
  }
};

// packages/ag-charts-community/src/motion/fromToMotion.ts
var NODE_UPDATE_STATE_TO_PHASE_MAPPING = {
  added: "add",
  updated: "update",
  removed: "remove",
  unknown: "initial",
  "no-op": "none"
};
function fromToMotion(groupId, subId, animationManager, selectionsOrNodes, fns, getDatumId, diff2) {
  const { fromFn, toFn, applyFn = (node, props) => node.setProperties(props) } = fns;
  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);
  const processNodes = (liveNodes, subNodes) => {
    let prevFromProps;
    let liveNodeIndex = 0;
    let nodeIndex = 0;
    for (const node of subNodes) {
      const isLive = liveNodes[liveNodeIndex] === node;
      const ctx = {
        last: nodeIndex >= subNodes.length - 1,
        lastLive: liveNodeIndex >= liveNodes.length - 1,
        prev: subNodes[nodeIndex - 1],
        prevFromProps,
        prevLive: liveNodes[liveNodeIndex - 1],
        next: subNodes[nodeIndex + 1],
        nextLive: liveNodes[liveNodeIndex + (isLive ? 1 : 0)]
      };
      const animationId = `${groupId}_${subId}_${node.id}`;
      animationManager.stopByAnimationId(animationId);
      let status = "unknown";
      if (!isLive) {
        status = "removed";
      } else if (getDatumId && diff2) {
        status = calculateStatus(node, node.datum, getDatumId, diff2);
      }
      node.transitionOut = status === "removed";
      const { phase, start: start2, finish, delay, duration, ...from2 } = fromFn(node, node.datum, status, ctx);
      const {
        phase: toPhase,
        start: toStart,
        finish: toFinish,
        delay: toDelay,
        duration: toDuration,
        ...to
      } = toFn(node, node.datum, status, ctx);
      const collapsable = finish == null;
      animationManager.animate({
        id: animationId,
        groupId,
        phase: phase ?? toPhase ?? "update",
        duration: duration ?? toDuration,
        delay: delay ?? toDelay,
        from: from2,
        to,
        ease: easeOut,
        collapsable,
        onPlay: () => {
          const startProps = { ...start2, ...toStart, ...from2 };
          applyFn(node, startProps, "start");
        },
        onUpdate(props) {
          applyFn(node, props, "update");
        },
        onStop: () => {
          const endProps = {
            ...start2,
            ...toStart,
            ...from2,
            ...to,
            ...finish,
            ...toFinish
          };
          applyFn(node, endProps, "end");
        }
      });
      if (isLive) {
        liveNodeIndex++;
      }
      nodeIndex++;
      prevFromProps = from2;
    }
  };
  let selectionIndex = 0;
  for (const selection of selections) {
    const selectionNodes = selection.nodes();
    const liveNodes = selectionNodes.filter((n) => !selection.isGarbage(n));
    processNodes(liveNodes, selectionNodes);
    animationManager.animate({
      id: `${groupId}_${subId}_selection_${selectionIndex}`,
      groupId,
      phase: "end",
      from: 0,
      to: 1,
      ease: easeOut,
      onStop() {
        selection.cleanup();
      }
    });
    selectionIndex++;
  }
  processNodes(nodes, nodes);
}
function staticFromToMotion(groupId, subId, animationManager, selectionsOrNodes, from2, to, extraOpts) {
  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);
  const { start: start2, finish, phase } = extraOpts;
  animationManager.animate({
    id: `${groupId}_${subId}`,
    groupId,
    phase: phase ?? "update",
    from: from2,
    to,
    ease: easeOut,
    onPlay: () => {
      if (!start2)
        return;
      for (const node of nodes) {
        node.setProperties(start2);
      }
      for (const selection of selections) {
        for (const node of selection.nodes()) {
          node.setProperties(start2);
        }
      }
    },
    onUpdate(props) {
      for (const node of nodes) {
        node.setProperties(props);
      }
      for (const selection of selections) {
        for (const node of selection.nodes()) {
          node.setProperties(props);
        }
      }
    },
    onStop: () => {
      for (const node of nodes) {
        node.setProperties({ ...to, ...finish });
      }
      for (const selection of selections) {
        for (const node of selection.nodes()) {
          node.setProperties({ ...to, ...finish });
        }
        selection.cleanup();
      }
    }
  });
}
function calculateStatus(node, datum, getDatumId, diff2) {
  const id = getDatumId(node, datum);
  if (diff2.added.has(id)) {
    return "added";
  }
  if (diff2.removed.has(id)) {
    return "removed";
  }
  if (node.previousDatum == null && node.datum != null) {
    return "added";
  }
  if (node.previousDatum != null && node.datum == null) {
    return "removed";
  }
  return "updated";
}

// packages/ag-charts-community/src/chart/axis/categoryAxis.ts
var import_ag_charts_core53 = require("ag-charts-core");

// packages/ag-charts-community/src/util/number.ts
var import_ag_charts_core16 = require("ag-charts-core");
function clampArray(value, array4) {
  const [min, max] = findMinMax(array4);
  return (0, import_ag_charts_core16.clamp)(min, value, max);
}
function findMinMax(array4) {
  if (array4.length === 0)
    return [];
  const result = [Infinity, -Infinity];
  for (const val of array4) {
    if (val < result[0])
      result[0] = val;
    if (val > result[1])
      result[1] = val;
  }
  return result;
}
function findRangeExtent(array4) {
  const [min, max] = findMinMax(array4);
  return max - min;
}

// packages/ag-charts-community/src/util/timeFormat.ts
var CONSTANTS = {
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
};
function dayOfYear(date5, startOfYear = new Date(date5.getFullYear(), 0, 1)) {
  const startOffset = date5.getTimezoneOffset() - startOfYear.getTimezoneOffset();
  const timeDiff = date5.getTime() - startOfYear.getTime() + startOffset * 6e4;
  const timeOneDay = 36e5 * 24;
  return Math.floor(timeDiff / timeOneDay);
}
function weekOfYear(date5, startDay) {
  const startOfYear = new Date(date5.getFullYear(), 0, 1);
  const startOfYearDay = startOfYear.getDay();
  const firstWeekStartOffset = (startDay - startOfYearDay + 7) % 7;
  const startOffset = new Date(date5.getFullYear(), 0, firstWeekStartOffset + 1);
  if (startOffset <= date5) {
    return Math.floor(dayOfYear(date5, startOffset) / 7) + 1;
  }
  return 0;
}
var SUNDAY = 0;
var MONDAY = 1;
var THURSDAY = 4;
function isoWeekOfYear(date5, year2 = date5.getFullYear()) {
  const firstOfYear = new Date(year2, 0, 1);
  const firstOfYearDay = firstOfYear.getDay();
  const firstThursdayOffset = (THURSDAY - firstOfYearDay + 7) % 7;
  const startOffset = new Date(year2, 0, firstThursdayOffset - (THURSDAY - MONDAY) + 1);
  if (startOffset <= date5) {
    return Math.floor(dayOfYear(date5, startOffset) / 7) + 1;
  }
  return isoWeekOfYear(date5, year2 - 1);
}
function timezone(date5) {
  const offset4 = date5.getTimezoneOffset();
  const unsignedOffset = Math.abs(offset4);
  const sign = offset4 > 0 ? "-" : "+";
  return `${sign}${pad(Math.floor(unsignedOffset / 60), 2, "0")}${pad(Math.floor(unsignedOffset % 60), 2, "0")}`;
}
var FORMATTERS = {
  a: (d) => CONSTANTS.shortDays[d.getDay()],
  A: (d) => CONSTANTS.days[d.getDay()],
  b: (d) => CONSTANTS.shortMonths[d.getMonth()],
  B: (d) => CONSTANTS.months[d.getMonth()],
  c: "%x, %X",
  d: (d, p) => pad(d.getDate(), 2, p ?? "0"),
  e: "%_d",
  f: (d, p) => pad(d.getMilliseconds() * 1e3, 6, p ?? "0"),
  H: (d, p) => pad(d.getHours(), 2, p ?? "0"),
  I: (d, p) => {
    const hours = d.getHours() % 12;
    return hours === 0 ? "12" : pad(hours, 2, p ?? "0");
  },
  j: (d, p) => pad(dayOfYear(d) + 1, 3, p ?? "0"),
  m: (d, p) => pad(d.getMonth() + 1, 2, p ?? "0"),
  M: (d, p) => pad(d.getMinutes(), 2, p ?? "0"),
  L: (d, p) => pad(d.getMilliseconds(), 3, p ?? "0"),
  p: (d) => d.getHours() < 12 ? "AM" : "PM",
  Q: (d) => String(d.getTime()),
  s: (d) => String(Math.floor(d.getTime() / 1e3)),
  S: (d, p) => pad(d.getSeconds(), 2, p ?? "0"),
  u: (d) => {
    let day2 = d.getDay();
    if (day2 < 1)
      day2 += 7;
    return String(day2 % 7);
  },
  U: (d, p) => pad(weekOfYear(d, SUNDAY), 2, p ?? "0"),
  V: (d, p) => pad(isoWeekOfYear(d), 2, p ?? "0"),
  w: (d, p) => pad(d.getDay(), 2, p ?? "0"),
  W: (d, p) => pad(weekOfYear(d, MONDAY), 2, p ?? "0"),
  x: "%-m/%-d/%Y",
  X: "%-I:%M:%S %p",
  y: (d, p) => pad(d.getFullYear() % 100, 2, p ?? "0"),
  Y: (d, p) => pad(d.getFullYear(), 4, p ?? "0"),
  Z: (d) => timezone(d),
  "%": () => "%"
};
var PADS = {
  _: " ",
  "0": "0",
  "-": ""
};
function pad(value, size, padChar) {
  const output = String(Math.floor(value));
  if (output.length >= size) {
    return output;
  }
  return `${padChar.repeat(size - output.length)}${output}`;
}
function buildFormatter(formatString) {
  const formatParts = [];
  while (formatString.length > 0) {
    let nextEscapeIdx = formatString.indexOf("%");
    if (nextEscapeIdx !== 0) {
      const literalPart = nextEscapeIdx > 0 ? formatString.substring(0, nextEscapeIdx) : formatString;
      formatParts.push(literalPart);
    }
    if (nextEscapeIdx < 0)
      break;
    const maybePadSpecifier = formatString[nextEscapeIdx + 1];
    const maybePad = PADS[maybePadSpecifier];
    if (maybePad != null) {
      nextEscapeIdx++;
    }
    const maybeFormatterSpecifier = formatString[nextEscapeIdx + 1];
    const maybeFormatter = FORMATTERS[maybeFormatterSpecifier];
    if (typeof maybeFormatter === "function") {
      formatParts.push([maybeFormatter, maybePad]);
    } else if (typeof maybeFormatter === "string") {
      const formatter = buildFormatter(maybeFormatter);
      formatParts.push([formatter, maybePad]);
    } else {
      formatParts.push(`${maybePad ?? ""}${maybeFormatterSpecifier}`);
    }
    formatString = formatString.substring(nextEscapeIdx + 2);
  }
  return (dateTime) => {
    const dateTimeAsDate = typeof dateTime === "number" ? new Date(dateTime) : dateTime;
    return formatParts.map((c) => typeof c === "string" ? c : c[0](dateTimeAsDate, c[1])).join("");
  };
}

// packages/ag-charts-community/src/util/timeFormatDefaults.ts
function dateToNumber(value) {
  return value instanceof Date ? value.getTime() : value;
}
function defaultTimeTickFormat(ticks, domain, formatOffset) {
  const formatString = calculateDefaultTimeTickFormat(ticks, domain, formatOffset);
  const formatter = buildFormatter(formatString);
  return (date5) => formatter(date5);
}
function calculateDefaultTimeTickFormat(ticks, domain, formatOffset = 0) {
  let minInterval = Infinity;
  for (let i = 1; i < ticks.length; i++) {
    minInterval = Math.min(minInterval, Math.abs(ticks[i].valueOf() - ticks[i - 1].valueOf()));
  }
  const [d0, d1] = domain.length === 0 ? [0, 0] : findMinMax([domain[0].valueOf(), domain[domain.length - 1].valueOf()]);
  const startYear = new Date(d0).getFullYear();
  const stopYear = new Date(d1).getFullYear();
  const yearChange = stopYear - startYear > 0;
  const timeFormat = isFinite(minInterval) ? getIntervalLowestGranularityFormat(minInterval, ticks) : getLowestGranularityFormat(ticks[0]);
  return formatStringBuilder(Math.max(timeFormat - formatOffset, 0), yearChange, ticks);
}
function getIntervalLowestGranularityFormat(value, ticks) {
  if (value < durationSecond) {
    return 0 /* MILLISECOND */;
  } else if (value < durationMinute) {
    return 1 /* SECOND */;
  } else if (value < durationHour) {
    return 2 /* MINUTE */;
  } else if (value < durationDay) {
    return 3 /* HOUR */;
  } else if (value < durationWeek) {
    return 4 /* WEEK_DAY */;
  } else if (value < durationDay * 28 || value < durationDay * 31 && hasDuplicateMonth(ticks)) {
    return 5 /* SHORT_MONTH */;
  } else if (value < durationYear) {
    return 6 /* MONTH */;
  }
  return 7 /* YEAR */;
}
function getLowestGranularityFormat(value) {
  if (second.floor(value) < value) {
    return 0 /* MILLISECOND */;
  } else if (minute.floor(value) < value) {
    return 1 /* SECOND */;
  } else if (hour.floor(value) < value) {
    return 2 /* MINUTE */;
  } else if (day.floor(value) < value) {
    return 3 /* HOUR */;
  } else if (month.floor(value) < value) {
    if (sunday.floor(value) < value) {
      return 4 /* WEEK_DAY */;
    }
    return 5 /* SHORT_MONTH */;
  } else if (year.floor(value) < value) {
    return 6 /* MONTH */;
  }
  return 7 /* YEAR */;
}
function hasDuplicateMonth(ticks) {
  let prevMonth = new Date(ticks[0]).getMonth();
  for (let i = 1; i < ticks.length; i++) {
    const tickMonth = new Date(ticks[i]).getMonth();
    if (prevMonth === tickMonth) {
      return true;
    }
    prevMonth = tickMonth;
  }
  return false;
}
function formatStringBuilder(defaultTimeFormat, yearChange, ticks) {
  const firstTick = dateToNumber(ticks[0]);
  const lastTick = dateToNumber(ticks.at(-1));
  const extent2 = Math.abs(lastTick - firstTick);
  const activeYear = yearChange || defaultTimeFormat === 7 /* YEAR */;
  const activeDate = extent2 === 0;
  const parts = [
    ["hour", 6 * durationHour, 14 * durationDay, 3 /* HOUR */, "%I %p"],
    ["hour", durationMinute, 6 * durationHour, 3 /* HOUR */, "%I:%M"],
    ["second", 1e3, 6 * durationHour, 1 /* SECOND */, ":%S"],
    ["ms", 0, 6 * durationHour, 0 /* MILLISECOND */, ".%L"],
    ["am/pm", durationMinute, 6 * durationHour, 3 /* HOUR */, "%p"],
    " ",
    ["day", durationDay, durationWeek, 4 /* WEEK_DAY */, "%a"],
    ["month", activeDate ? 0 : durationWeek, 52 * durationWeek, 5 /* SHORT_MONTH */, "%b %d"],
    ["month", 5 * durationWeek, 10 * durationYear, 6 /* MONTH */, "%B"],
    " ",
    ["year", activeYear ? 0 : durationYear, Infinity, 7 /* YEAR */, "%Y"]
  ];
  const formatParts = parts.filter((v) => {
    if (typeof v === "string") {
      return true;
    }
    const [_, min, max, format] = v;
    return format >= defaultTimeFormat && min <= extent2 && extent2 < max;
  }).reduce(
    (r, next) => {
      if (typeof next === "string") {
        r.result.push(next);
      } else if (!r.used.has(next[0])) {
        r.result.push(next);
        r.used.add(next[0]);
      }
      return r;
    },
    { result: [], used: /* @__PURE__ */ new Set() }
  ).result;
  const firstFormat = formatParts.findIndex((v) => typeof v !== "string");
  const lastFormat = formatParts.findLastIndex((v) => typeof v !== "string");
  return formatParts.slice(firstFormat, lastFormat + 1).map((v) => typeof v === "string" ? v : v[4]).join("").replaceAll(/\s+/g, " ").trim();
}

// packages/ag-charts-community/src/scale/bandScale.ts
var import_ag_charts_core17 = require("ag-charts-core");

// packages/ag-charts-community/src/scale/abstractScale.ts
var AbstractScale = class {
  ticks(_ticks, _domain, _visibleRange) {
    return void 0;
  }
  niceDomain(_ticks, domain = this.domain) {
    return domain;
  }
  tickFormatter(_params) {
    return void 0;
  }
  datumFormatter(_params) {
    return void 0;
  }
  get bandwidth() {
    return void 0;
  }
  get step() {
    return void 0;
  }
  get inset() {
    return void 0;
  }
};

// packages/ag-charts-community/src/scale/invalidating.ts
var Invalidating = (target, propertyKey) => {
  const mappedProperty = Symbol(String(propertyKey));
  target[mappedProperty] = void 0;
  Object.defineProperty(target, propertyKey, {
    get() {
      return this[mappedProperty];
    },
    set(newValue) {
      const oldValue = this[mappedProperty];
      if (oldValue !== newValue) {
        this[mappedProperty] = newValue;
        this.invalid = true;
      }
    },
    enumerable: true,
    configurable: false
  });
};

// packages/ag-charts-community/src/scale/bandScale.ts
var _BandScale = class _BandScale extends AbstractScale {
  constructor() {
    super(...arguments);
    this.invalid = true;
    this.range = [0, 1];
    this.round = false;
    this._bandwidth = 1;
    this._step = 1;
    this._inset = 1;
    this._rawBandwidth = 1;
    /**
     * The ratio of the range that is reserved for space between bands.
     */
    this._paddingInner = 0;
    /**
     * The ratio of the range that is reserved for space before the first
     * and after the last band.
     */
    this._paddingOuter = 0;
  }
  static is(value) {
    return value instanceof _BandScale;
  }
  get bandwidth() {
    this.refresh();
    return this._bandwidth;
  }
  get step() {
    this.refresh();
    return this._step;
  }
  get inset() {
    this.refresh();
    return this._inset;
  }
  get rawBandwidth() {
    this.refresh();
    return this._rawBandwidth;
  }
  set padding(value) {
    value = (0, import_ag_charts_core17.clamp)(0, value, 1);
    this._paddingInner = value;
    this._paddingOuter = value;
  }
  get padding() {
    return this._paddingInner;
  }
  set paddingInner(value) {
    this.invalid = true;
    this._paddingInner = (0, import_ag_charts_core17.clamp)(0, value, 1);
  }
  get paddingInner() {
    return this._paddingInner;
  }
  set paddingOuter(value) {
    this.invalid = true;
    this._paddingOuter = (0, import_ag_charts_core17.clamp)(0, value, 1);
  }
  get paddingOuter() {
    return this._paddingOuter;
  }
  refresh() {
    if (!this.invalid)
      return;
    this.invalid = false;
    this.update();
    if (this.invalid) {
      import_ag_charts_core17.Logger.warnOnce("Expected update to not invalidate scale");
    }
  }
  convert(d, _options) {
    this.refresh();
    const i = this.findIndex(d);
    if (i == null || i < 0 || i >= this.bands.length) {
      return NaN;
    }
    return this.ordinalRange(i);
  }
  invertNearestIndex(position) {
    this.refresh();
    const bandCount = this.bands.length;
    if (bandCount === 0)
      return -1;
    let low = 0;
    let high = bandCount - 1;
    let closestDistance = Infinity;
    let closestIndex = 0;
    while (low <= high) {
      const mid = (high + low) / 2 | 0;
      const p = this.ordinalRange(mid);
      const distance = Math.abs(p - position);
      if (distance === 0)
        return mid;
      if (distance < closestDistance) {
        closestDistance = distance;
        closestIndex = mid;
      }
      if (p < position) {
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }
    return closestIndex;
  }
  update() {
    const [r0, r1] = this.range;
    let { _paddingInner: paddingInner } = this;
    const { _paddingOuter: paddingOuter, round: round3, bands } = this;
    const bandCount = bands.length;
    if (bandCount === 0)
      return;
    const rangeDistance = r1 - r0;
    let rawStep;
    if (bandCount === 1) {
      paddingInner = 0;
      rawStep = rangeDistance * (1 - paddingOuter * 2);
    } else {
      rawStep = rangeDistance / Math.max(1, bandCount - paddingInner + paddingOuter * 2);
    }
    const step = round3 ? Math.floor(rawStep) : rawStep;
    let inset = r0 + (rangeDistance - step * (bandCount - paddingInner)) / 2;
    let bandwidth = step * (1 - paddingInner);
    if (round3) {
      inset = Math.round(inset);
      bandwidth = Math.round(bandwidth);
    }
    this._step = step;
    this._inset = inset;
    this._bandwidth = bandwidth;
    this._rawBandwidth = rawStep * (1 - paddingInner);
  }
  ordinalRange(i) {
    const { _inset: inset, _step: step, range: range3 } = this;
    const min = Math.min(range3[0], range3[1]);
    const max = Math.max(range3[0], range3[1]);
    return (0, import_ag_charts_core17.clamp)(min, inset + step * i, max);
  }
};
__decorateClass([
  Invalidating
], _BandScale.prototype, "range", 2);
__decorateClass([
  Invalidating
], _BandScale.prototype, "round", 2);
var BandScale = _BandScale;

// packages/ag-charts-community/src/scale/scaleUtil.ts
var import_ag_charts_core18 = require("ag-charts-core");
function filterVisibleTicks(ticks, reversed, visibleRange) {
  if (visibleRange == null || visibleRange[0] === 0 && visibleRange[1] === 1)
    return { ticks, count: ticks.length };
  const vt0 = (0, import_ag_charts_core18.clamp)(0, Math.floor(visibleRange[0] * ticks.length), ticks.length);
  const vt1 = (0, import_ag_charts_core18.clamp)(0, Math.ceil(visibleRange[1] * ticks.length), ticks.length);
  const t0 = reversed ? ticks.length - vt1 : vt0;
  const t1 = reversed ? ticks.length - vt0 : vt1;
  return {
    ticks: ticks.slice(t0, t1),
    count: ticks.length
  };
}

// packages/ag-charts-community/src/scale/categoryScale.ts
var CategoryScale = class _CategoryScale extends BandScale {
  constructor() {
    super(...arguments);
    this.type = "band";
    /**
     * Maps datum to its index in the {@link domain} array.
     * Used to check for duplicate data (not allowed).
     */
    this.index = void 0;
    /**
     * Contains unique data only.
     */
    this._domain = [];
  }
  static is(value) {
    return value instanceof _CategoryScale;
  }
  set domain(values) {
    if (this._domain === values)
      return;
    this.invalid = true;
    this._domain = values;
    this.index = void 0;
  }
  get domain() {
    return this._domain;
  }
  get bands() {
    return this._domain;
  }
  normalizeDomains(...domains) {
    let normalizedDomain = void 0;
    const seenDomains = /* @__PURE__ */ new Set();
    let animatable = true;
    for (const domain of domains) {
      if (seenDomains.has(domain))
        continue;
      seenDomains.add(domain);
      if (normalizedDomain == null) {
        normalizedDomain = deduplicateCategories(domain);
      } else {
        animatable && (animatable = domainOrderedToNormalizedDomain(domain, normalizedDomain));
        normalizedDomain = deduplicateCategories([...normalizedDomain, ...domain]);
      }
    }
    normalizedDomain ?? (normalizedDomain = []);
    return { domain: normalizedDomain, animatable };
  }
  toDomain(_value) {
    return void 0;
  }
  invert(position, nearest = false) {
    this.refresh();
    const offset4 = nearest ? this.bandwidth / 2 : 0;
    const index = this.invertNearestIndex(Math.max(0, position - offset4));
    const matches = nearest || position === this.ordinalRange(index);
    return matches ? this.domain[index] : void 0;
  }
  ticks(_params, domain = this.domain, visibleRange) {
    return filterVisibleTicks(domain, false, visibleRange);
  }
  findIndex(value) {
    let { index } = this;
    if (index == null) {
      const { domain } = this;
      index = /* @__PURE__ */ new Map();
      for (let i = 0; i < domain.length; i++) {
        index.set(dateToNumber(domain[i]), i);
      }
      this.index = index;
    }
    return index.get(dateToNumber(value));
  }
};
function deduplicateCategories(d) {
  let domain;
  const uniqueValues = /* @__PURE__ */ new Set();
  for (const value of d) {
    const key = dateToNumber(value);
    const lastSize = uniqueValues.size;
    uniqueValues.add(key);
    const isUniqueValue = uniqueValues.size !== lastSize;
    if (isUniqueValue) {
      domain?.push(value);
    } else {
      domain ?? (domain = d.slice(0, uniqueValues.size));
    }
  }
  return domain ?? d;
}
function domainOrderedToNormalizedDomain(domain, normalizedDomain) {
  let normalizedIndex = -1;
  for (const value of domain) {
    const normalizedNextIndex = normalizedDomain.indexOf(value);
    if (normalizedNextIndex === -1) {
      normalizedIndex = Infinity;
    } else if (normalizedNextIndex <= normalizedIndex) {
      return false;
    } else {
      normalizedIndex = normalizedNextIndex;
    }
  }
  return true;
}

// packages/ag-charts-community/src/util/properties.ts
var import_ag_charts_core19 = require("ag-charts-core");
var Property = addFakeTransformToInstanceProperty;
var BaseProperties = class {
  handleUnknownProperties(_unknownKeys, _properties) {
  }
  set(properties) {
    const { className = this.constructor.name } = this.constructor;
    if (typeof properties !== "object") {
      import_ag_charts_core19.Logger.warn(`unable to set ${className} - expecting a properties object`);
      return this;
    }
    const keys = new Set(Object.keys(properties));
    for (const propertyKey of listDecoratedProperties(this)) {
      if (keys.has(propertyKey)) {
        const value = properties[propertyKey];
        const self = this;
        if (isProperties(self[propertyKey])) {
          if (self[propertyKey] instanceof PropertiesArray) {
            const array4 = self[propertyKey].reset(value);
            if (array4 != null) {
              self[propertyKey] = array4;
            } else {
              import_ag_charts_core19.Logger.warn(`unable to set [${propertyKey}] - expecting a properties array`);
            }
          } else {
            self[propertyKey].set(value);
          }
        } else if ((0, import_ag_charts_core19.isPlainObject)(value)) {
          self[propertyKey] = merge(value, self[propertyKey] ?? {});
        } else {
          self[propertyKey] = value;
        }
        keys.delete(propertyKey);
      }
    }
    this.handleUnknownProperties(keys, properties);
    for (const unknownKey of keys) {
      import_ag_charts_core19.Logger.warn(`unable to set [${unknownKey}] in ${className} - property is unknown`);
    }
    return this;
  }
  toJson() {
    return listDecoratedProperties(this).reduce((object3, propertyKey) => {
      const propertyValue = this[propertyKey];
      object3[propertyKey] = isProperties(propertyValue) ? propertyValue.toJson() : propertyValue;
      return object3;
    }, {});
  }
};
var PropertiesArray = class _PropertiesArray extends Array {
  constructor(itemFactory, ...properties) {
    super(properties.length);
    const isConstructor = (value2) => Boolean(value2?.prototype?.constructor?.name);
    const value = isConstructor(itemFactory) ? (params) => new itemFactory().set(params) : itemFactory;
    Object.defineProperty(this, "itemFactory", { value, enumerable: false, configurable: false });
    this.set(properties);
  }
  set(properties) {
    if ((0, import_ag_charts_core19.isArray)(properties)) {
      this.length = properties.length;
      for (let i = 0; i < properties.length; i++) {
        this[i] = this.itemFactory(properties[i]);
      }
    }
    return this;
  }
  reset(properties) {
    if (Array.isArray(properties)) {
      return new _PropertiesArray(this.itemFactory, ...properties);
    }
  }
  toJson() {
    return this.map((value) => value?.toJson?.() ?? value);
  }
};
function isProperties(value) {
  return value instanceof BaseProperties || value instanceof PropertiesArray;
}

// packages/ag-charts-community/src/chart/axis/cartesianAxis.ts
var import_ag_charts_core52 = require("ag-charts-core");

// packages/ag-charts-community/src/motion/resetMotion.ts
function resetMotion(selectionsOrNodes, propsFn) {
  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);
  for (const selection of selections) {
    for (const node of selection.nodes()) {
      const from2 = propsFn(node, node.datum);
      node.setProperties(from2);
    }
    selection.cleanup();
  }
  for (const node of nodes) {
    const from2 = propsFn(node, node.datum);
    node.setProperties(from2);
  }
}

// packages/ag-charts-community/src/scale/continuousScale.ts
var _ContinuousScale = class _ContinuousScale extends AbstractScale {
  constructor(domain = [], range3 = []) {
    super();
    this.domain = domain;
    this.range = range3;
    this.defaultClamp = false;
  }
  static is(value) {
    return value instanceof _ContinuousScale;
  }
  normalizeDomains(...domains) {
    return normalizeContinuousDomains(...domains);
  }
  transform(x) {
    return x;
  }
  transformInvert(x) {
    return x;
  }
  calcBandwidth(smallestInterval = 1, minWidth = 1) {
    const { domain } = this;
    const rangeDistance = this.getPixelRange();
    if (domain.length === 0)
      return rangeDistance;
    const intervals = Math.abs(domain[1].valueOf() - domain[0].valueOf()) / smallestInterval + 1;
    let bands = intervals;
    if (minWidth !== 0) {
      const maxBands = Math.floor(rangeDistance);
      bands = Math.min(bands, maxBands);
    }
    return rangeDistance / Math.max(1, bands);
  }
  convert(value, options) {
    const { domain } = this;
    if (!domain || domain.length < 2) {
      return NaN;
    }
    const clamp19 = options?.clamp ?? this.defaultClamp;
    const d0 = Number(this.transform(domain[0]));
    const d1 = Number(this.transform(domain[1]));
    const x = Number(this.transform(value));
    const { range: range3 } = this;
    const [r0, r1] = range3;
    if (clamp19) {
      const [start2, stop] = findMinMax([d0, d1]);
      if (x < start2) {
        return r0;
      } else if (x > stop) {
        return r1;
      }
    }
    if (d0 === d1) {
      return (r0 + r1) / 2;
    } else if (x === d0) {
      return r0;
    } else if (x === d1) {
      return r1;
    }
    return r0 + (x - d0) / (d1 - d0) * (r1 - r0);
  }
  invert(x, _nearest) {
    const domain = this.domain.map((d2) => this.transform(d2));
    const [d0, d1] = domain;
    const { range: range3 } = this;
    const [r0, r1] = range3;
    let d;
    if (r0 === r1) {
      d = this.toDomain((Number(d0) + Number(d1)) / 2);
    } else {
      d = this.toDomain(Number(d0) + (x - r0) / (r1 - r0) * (Number(d1) - Number(d0)));
    }
    return this.transformInvert(d);
  }
  getPixelRange() {
    const [a, b] = this.range;
    return Math.abs(b - a);
  }
};
_ContinuousScale.defaultTickCount = 5;
var ContinuousScale = _ContinuousScale;
function normalizeContinuousDomains(...domains) {
  let min;
  let minValue = Infinity;
  let max;
  let maxValue = -Infinity;
  for (const domain of domains) {
    for (const d of domain) {
      const value = d.valueOf();
      if (value < minValue) {
        minValue = value;
        min = d;
      }
      if (value > maxValue) {
        maxValue = value;
        max = d;
      }
    }
  }
  if (min != null && max != null) {
    const domain = [min, max];
    return { domain, animatable: true };
  } else {
    return { domain: [], animatable: false };
  }
}

// packages/ag-charts-community/src/scene/group.ts
var import_ag_charts_core35 = require("ag-charts-core");

// packages/ag-charts-community/src/util/debug.ts
var import_ag_charts_core20 = require("ag-charts-core");
var LONG_TIME_PERIOD_THRESHOLD = 2e3;
var timeOfLastLog = Date.now();
var logTimeGap = () => {
  const timeSinceLastLog = Date.now() - timeOfLastLog;
  if (timeSinceLastLog > LONG_TIME_PERIOD_THRESHOLD) {
    const prettyDuration = (Math.floor(timeSinceLastLog / 100) / 10).toFixed(1);
    import_ag_charts_core20.Logger.log(`**** ${prettyDuration}s since last log message ****`);
  }
  timeOfLastLog = Date.now();
};
var Debug = {
  create(...debugSelectors) {
    const resultFn = (...logContent) => {
      if (Debug.check(...debugSelectors)) {
        if (typeof logContent[0] === "function") {
          logContent = (0, import_ag_charts_core20.toArray)(logContent[0]());
        }
        logTimeGap();
        import_ag_charts_core20.Logger.log(...logContent);
      }
    };
    return Object.assign(resultFn, {
      check: () => Debug.check(...debugSelectors),
      group: (name, cb) => {
        if (Debug.check(...debugSelectors)) {
          return import_ag_charts_core20.Logger.logGroup(name, cb);
        }
        return cb();
      }
    });
  },
  check(...debugSelectors) {
    if (debugSelectors.length === 0) {
      debugSelectors.push(true);
    }
    const chartDebug = (0, import_ag_charts_core20.toArray)((0, import_ag_charts_core20.getWindow)("agChartsDebug"));
    return chartDebug.some((selector) => debugSelectors.includes(selector));
  },
  inDevelopmentMode(fn) {
    if (Debug.check("dev")) {
      return fn();
    }
  }
};

// packages/ag-charts-community/src/scene/canvas/canvasUtil.ts
function clearContext({
  context,
  pixelRatio,
  width: width2,
  height: height2
}) {
  context.save();
  context.resetTransform();
  context.clearRect(0, 0, Math.ceil(width2 * pixelRatio), Math.ceil(height2 * pixelRatio));
  context.restore();
}
function debugContext(ctx) {
  if (Debug.check("canvas")) {
    const save = ctx.save.bind(ctx);
    const restore = ctx.restore.bind(ctx);
    let depth = 0;
    Object.assign(ctx, {
      save() {
        save();
        depth++;
      },
      restore() {
        if (depth === 0) {
          throw new Error("AG Charts - Unable to restore() past depth 0");
        }
        restore();
        depth--;
      },
      verifyDepthZero() {
        if (depth !== 0) {
          throw new Error(`AG Charts - Save/restore depth is non-zero: ${depth}`);
        }
      }
    });
  }
}

// packages/ag-charts-community/src/scene/canvas/hdpiOffscreenCanvas.ts
function canvasDimensions(width2, height2, pixelRatio) {
  return [Math.floor(width2 * pixelRatio), Math.floor(height2 * pixelRatio)];
}
var HdpiOffscreenCanvas = class {
  constructor(options) {
    const { width: width2, height: height2, pixelRatio, willReadFrequently = false } = options;
    this.width = width2;
    this.height = height2;
    this.pixelRatio = pixelRatio;
    const [canvasWidth, canvasHeight] = canvasDimensions(width2, height2, pixelRatio);
    this.canvas = new OffscreenCanvas(canvasWidth, canvasHeight);
    this.context = this.canvas.getContext("2d", { willReadFrequently });
    this.context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    debugContext(this.context);
  }
  drawImage(context, dx = 0, dy = 0) {
    return context.drawImage(this.canvas, dx, dy);
  }
  transferToImageBitmap() {
    return this.canvas.transferToImageBitmap();
  }
  resize(width2, height2, pixelRatio) {
    if (!(width2 > 0 && height2 > 0))
      return;
    const { canvas, context } = this;
    if (width2 !== this.width || height2 !== this.height || pixelRatio !== this.pixelRatio) {
      const [canvasWidth, canvasHeight] = canvasDimensions(width2, height2, pixelRatio);
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
    }
    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    this.width = width2;
    this.height = height2;
    this.pixelRatio = pixelRatio;
  }
  clear() {
    clearContext(this);
  }
  destroy() {
    this.canvas.width = 0;
    this.canvas.height = 0;
    this.context.clearRect(0, 0, 0, 0);
    this.canvas = null;
    this.context = null;
    Object.freeze(this);
  }
};

// packages/ag-charts-community/src/scene/shape/shape.ts
var import_ag_charts_core32 = require("ag-charts-core");

// packages/ag-charts-community/src/scene/gradient/conicGradient.ts
var import_ag_charts_core23 = require("ag-charts-core");

// packages/ag-charts-community/src/util/angle.ts
var twoPi = Math.PI * 2;
var halfPi = Math.PI / 2;
function normalizeAngle360(radians) {
  radians %= twoPi;
  radians += twoPi;
  radians %= twoPi;
  return radians;
}
function normalizeAngle180(radians) {
  radians %= twoPi;
  if (radians < -Math.PI) {
    radians += twoPi;
  } else if (radians >= Math.PI) {
    radians -= twoPi;
  }
  return radians;
}
function isBetweenAngles(targetAngle, startAngle, endAngle) {
  const t = normalizeAngle360(targetAngle);
  const a0 = normalizeAngle360(startAngle);
  const a1 = normalizeAngle360(endAngle);
  if (a0 < a1) {
    return a0 <= t && t <= a1;
  } else if (a0 > a1) {
    return a0 <= t || t <= a1;
  } else {
    return true;
  }
}
function toRadians(degrees) {
  return degrees / 180 * Math.PI;
}
function angleBetween(angle0, angle1) {
  angle0 = normalizeAngle360(angle0);
  angle1 = normalizeAngle360(angle1);
  return angle1 - angle0 + (angle0 > angle1 ? twoPi : 0);
}
function getAngleRatioRadians(angle) {
  const normalizedAngle = normalizeAngle360(angle);
  if (normalizedAngle <= halfPi) {
    return normalizedAngle / halfPi;
  } else if (normalizedAngle <= Math.PI) {
    return (Math.PI - normalizedAngle) / halfPi;
  } else if (normalizedAngle <= 1.5 * Math.PI) {
    return (normalizedAngle - Math.PI) / halfPi;
  } else {
    return (twoPi - normalizedAngle) / halfPi;
  }
}
function angularPadding(hPadding, vPadding, angle) {
  const angleRatio = getAngleRatioRadians(angle);
  return hPadding * angleRatio + vPadding * Math.abs(1 - angleRatio);
}
function normalizeAngle360FromDegrees(degrees) {
  return degrees ? normalizeAngle360(toRadians(degrees)) : 0;
}

// packages/ag-charts-community/src/scene/gradient/gradient.ts
var import_ag_charts_core22 = require("ag-charts-core");

// packages/ag-charts-community/src/scale/colorScale.ts
var import_ag_charts_core21 = require("ag-charts-core");
var convertColorStringToOklcha = (v) => {
  const color7 = Color.fromString(v);
  const [l, c, h] = Color.RGBtoOKLCH(color7.r, color7.g, color7.b);
  return { l, c, h, a: color7.a };
};
var delta = 1e-6;
var isAchromatic = (x) => x.c < delta || x.l < delta || x.l > 1 - delta;
var interpolateOklch = (x, y, d) => {
  d = (0, import_ag_charts_core21.clamp)(0, d, 1);
  let h;
  if (isAchromatic(x)) {
    h = y.h;
  } else if (isAchromatic(y)) {
    h = x.h;
  } else {
    const xH = x.h;
    let yH = y.h;
    const deltaH = y.h - x.h;
    if (deltaH > 180) {
      yH -= 360;
    } else if (deltaH < -180) {
      yH += 360;
    }
    h = xH * (1 - d) + yH * d;
  }
  const c = x.c * (1 - d) + y.c * d;
  const l = x.l * (1 - d) + y.l * d;
  const a = x.a * (1 - d) + y.a * d;
  return Color.fromOKLCH(l, c, h, a);
};
var ColorScale = class extends AbstractScale {
  constructor() {
    super(...arguments);
    this.type = "color";
    this.invalid = true;
    this.domain = [0, 1];
    this.range = ["red", "blue"];
    this.parsedRange = this.range.map(convertColorStringToOklcha);
  }
  update() {
    const { domain, range: range3 } = this;
    if (domain.length < 2) {
      import_ag_charts_core21.Logger.warnOnce("`colorDomain` should have at least 2 values.");
      if (domain.length === 0) {
        domain.push(0, 1);
      } else if (domain.length === 1) {
        domain.push(domain[0] + 1);
      }
    }
    for (let i = 1; i < domain.length; i++) {
      const a = domain[i - 1];
      const b = domain[i];
      if (a >= b) {
        import_ag_charts_core21.Logger.warnOnce("`colorDomain` values should be supplied in ascending order.");
        domain.sort((a2, b2) => a2 - b2);
        break;
      }
    }
    if (range3.length < domain.length) {
      for (let i = range3.length; i < domain.length; i++) {
        range3.push(range3.length > 0 ? range3[0] : "black");
      }
    }
    this.parsedRange = this.range.map(convertColorStringToOklcha);
  }
  normalizeDomains(...domains) {
    return { domain: domains.flat(), animatable: true };
  }
  toDomain() {
    return;
  }
  convert(x) {
    this.refresh();
    const { domain, range: range3, parsedRange } = this;
    const d0 = domain[0];
    const d1 = domain.at(-1);
    const r0 = range3[0];
    const r1 = range3[range3.length - 1];
    if (x <= d0) {
      return r0;
    }
    if (x >= d1) {
      return r1;
    }
    let index;
    let q;
    if (domain.length === 2) {
      const t = (x - d0) / (d1 - d0);
      const step = 1 / (range3.length - 1);
      index = range3.length <= 2 ? 0 : Math.min(Math.floor(t * (range3.length - 1)), range3.length - 2);
      q = (t - index * step) / step;
    } else {
      for (index = 0; index < domain.length - 2; index++) {
        if (x < domain[index + 1]) {
          break;
        }
      }
      const a = domain[index];
      const b = domain[index + 1];
      q = (x - a) / (b - a);
    }
    const c0 = parsedRange[index];
    const c1 = parsedRange[index + 1];
    return interpolateOklch(c0, c1, q).toRgbaString();
  }
  invert() {
    return;
  }
  refresh() {
    if (!this.invalid)
      return;
    this.invalid = false;
    this.update();
    if (this.invalid) {
      import_ag_charts_core21.Logger.warnOnce("Expected update to not invalidate scale");
    }
  }
};
__decorateClass([
  Invalidating
], ColorScale.prototype, "domain", 2);
__decorateClass([
  Invalidating
], ColorScale.prototype, "range", 2);

// packages/ag-charts-community/src/scene/gradient/gradient.ts
var Gradient = class {
  constructor(colorSpace, stops = [], bbox) {
    this.colorSpace = colorSpace;
    this.stops = stops;
    this.bbox = bbox;
    this._cache = void 0;
  }
  createGradient(ctx, shapeBbox, params) {
    const bbox = this.bbox ?? shapeBbox;
    if (isNaN(bbox.x) || isNaN(bbox.y)) {
      return;
    }
    if (this._cache != null && this._cache.ctx === ctx && this._cache.bbox.equals(bbox)) {
      return this._cache.gradient;
    }
    const { stops, colorSpace } = this;
    if (stops.length === 0)
      return;
    if (stops.length === 1)
      return stops[0].color;
    let gradient = this.createCanvasGradient(ctx, bbox, params);
    if (gradient == null)
      return;
    const isOkLch = colorSpace === "oklch";
    const step = 0.05;
    let c0 = stops[0];
    gradient.addColorStop(c0.stop, c0.color);
    for (let i = 1; i < stops.length; i += 1) {
      const c1 = stops[i];
      if (isOkLch) {
        const scale2 = new ColorScale();
        scale2.domain = [c0.stop, c1.stop];
        scale2.range = [c0.color, c1.color];
        for (let stop = c0.stop + step; stop < c1.stop; stop += step) {
          gradient.addColorStop(stop, scale2.convert(stop));
        }
      }
      gradient.addColorStop(c1.stop, c1.color);
      c0 = c1;
    }
    if ("createPattern" in gradient) {
      gradient = gradient.createPattern();
    }
    this._cache = { ctx, bbox, gradient };
    return gradient;
  }
  toSvg(shapeBbox) {
    const bbox = this.bbox ?? shapeBbox;
    const gradient = this.createSvgGradient(bbox);
    this.stops.forEach(({ stop: offset4, color: color7 }) => {
      const stop = (0, import_ag_charts_core22.createSvgElement)("stop");
      stop.setAttribute("offset", `${offset4}`);
      stop.setAttribute("stop-color", `${color7}`);
      gradient.appendChild(stop);
    });
    return gradient;
  }
};

// packages/ag-charts-community/src/scene/gradient/conicGradient.ts
var ConicGradient = class extends Gradient {
  constructor(colorSpace, stops, angle = 0, bbox) {
    super(colorSpace, stops, bbox);
    this.angle = angle;
  }
  createCanvasGradient(ctx, bbox, params) {
    const angleOffset = -90;
    const { angle } = this;
    const radians = normalizeAngle360FromDegrees(angle + angleOffset);
    const cx = params?.centerX ?? bbox.x + bbox.width * 0.5;
    const cy = params?.centerY ?? bbox.y + bbox.height * 0.5;
    return ctx.createConicGradient(radians, cx, cy);
  }
  createSvgGradient(_bbox) {
    return (0, import_ag_charts_core23.createSvgElement)("linearGradient");
  }
};

// packages/ag-charts-community/src/scene/gradient/linearGradient.ts
var import_ag_charts_core24 = require("ag-charts-core");
var LinearGradient = class extends Gradient {
  constructor(colorSpace, stops, angle = 0, bbox) {
    super(colorSpace, stops, bbox);
    this.angle = angle;
  }
  getGradientPoints(bbox) {
    const angleOffset = 90;
    const { angle } = this;
    const radians = normalizeAngle360FromDegrees(angle + angleOffset);
    const cos = Math.cos(radians);
    const sin = Math.sin(radians);
    const w = bbox.width;
    const h = bbox.height;
    const cx = bbox.x + w * 0.5;
    const cy = bbox.y + h * 0.5;
    const diagonal = Math.sqrt(h * h + w * w) / 2;
    const diagonalAngle = Math.atan2(h, w);
    let quarteredAngle;
    if (radians < Math.PI / 2) {
      quarteredAngle = radians;
    } else if (radians < Math.PI) {
      quarteredAngle = Math.PI - radians;
    } else if (radians < 1.5 * Math.PI) {
      quarteredAngle = radians - Math.PI;
    } else {
      quarteredAngle = 2 * Math.PI - radians;
    }
    const l = diagonal * Math.abs(Math.cos(quarteredAngle - diagonalAngle));
    return { x0: cx + cos * l, y0: cy + sin * l, x1: cx - cos * l, y1: cy - sin * l };
  }
  createCanvasGradient(ctx, bbox) {
    const { x0, y0, x1, y1 } = this.getGradientPoints(bbox);
    if (isNaN(x0) || isNaN(y0) || isNaN(x1) || isNaN(y1)) {
      return void 0;
    }
    return ctx.createLinearGradient(x0, y0, x1, y1);
  }
  createSvgGradient(bbox) {
    const { x0, y0, x1, y1 } = this.getGradientPoints(bbox);
    const gradient = (0, import_ag_charts_core24.createSvgElement)("linearGradient");
    gradient.setAttribute("x1", String(x0));
    gradient.setAttribute("y1", String(y0));
    gradient.setAttribute("x2", String(x1));
    gradient.setAttribute("y2", String(y1));
    gradient.setAttribute("gradientUnits", "userSpaceOnUse");
    return gradient;
  }
};

// packages/ag-charts-community/src/scene/gradient/radialGradient.ts
var import_ag_charts_core25 = require("ag-charts-core");
var RadialGradient = class extends Gradient {
  constructor(colorSpace, stops, bbox) {
    super(colorSpace, stops, bbox);
  }
  createCanvasGradient(ctx, bbox, params) {
    const cx = params?.centerX ?? bbox.x + bbox.width * 0.5;
    const cy = params?.centerY ?? bbox.y + bbox.height * 0.5;
    const innerRadius = params?.innerRadius ?? 0;
    const outerRadius = params?.outerRadius ?? Math.hypot(bbox.width * 0.5, bbox.height * 0.5) / Math.SQRT2;
    return ctx.createRadialGradient(cx, cy, innerRadius, cx, cy, outerRadius);
  }
  createSvgGradient(bbox) {
    const cx = bbox.x + bbox.width * 0.5;
    const cy = bbox.y + bbox.height * 0.5;
    const gradient = (0, import_ag_charts_core25.createSvgElement)("radialGradient");
    gradient.setAttribute("cx", String(cx));
    gradient.setAttribute("cy", String(cy));
    gradient.setAttribute("r", String(Math.hypot(bbox.width * 0.5, bbox.height * 0.5) / Math.SQRT2));
    gradient.setAttribute("gradientUnits", "userSpaceOnUse");
    return gradient;
  }
};

// packages/ag-charts-community/src/scene/gradient/stops.ts
var import_ag_charts_core26 = require("ag-charts-core");
var StopProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.color = "black";
  }
};
__decorateClass([
  Property
], StopProperties.prototype, "stop", 2);
__decorateClass([
  Property
], StopProperties.prototype, "color", 2);
function stopsAreAscending(fills) {
  let currentStop;
  for (const fill of fills) {
    if (fill?.stop == null)
      continue;
    if (currentStop != null && fill.stop < currentStop) {
      return false;
    }
    currentStop = fill.stop;
  }
  return true;
}
function discreteColorStops(colorStops) {
  return colorStops.flatMap((colorStop, i) => {
    const { stop } = colorStop;
    const nextColor = colorStops.at(i + 1)?.color;
    return nextColor != null ? [colorStop, { stop, color: nextColor }] : [colorStop];
  });
}
function getDefaultColorStops(defaultColorStops, fillMode) {
  const stopOffset = fillMode === "discrete" ? 1 : 0;
  const colorStops = defaultColorStops.map(
    (color7, index, { length }) => ({
      stop: (index + stopOffset) / (length - 1 + stopOffset),
      color: color7
    })
  );
  return fillMode === "discrete" ? discreteColorStops(colorStops) : colorStops;
}
function getColorStops(baseFills, defaultColorStops, domain, fillMode = "continuous") {
  const fills = baseFills.map((fill) => typeof fill === "string" ? { color: fill } : fill);
  if (fills.length === 0) {
    return getDefaultColorStops(defaultColorStops, fillMode);
  } else if (!stopsAreAscending(fills)) {
    import_ag_charts_core26.Logger.warnOnce(`[fills] must have the stops defined in ascending order`);
    return [];
  }
  const d0 = Math.min(...domain);
  const d1 = Math.max(...domain);
  const isDiscrete = fillMode === "discrete";
  const stops = new Float64Array(fills.length);
  let previousDefinedStopIndex = 0;
  let nextDefinedStopIndex = -1;
  for (let i = 0; i < fills.length; i += 1) {
    const colorStop = fills[i];
    if (i >= nextDefinedStopIndex) {
      nextDefinedStopIndex = fills.length - 1;
      for (let j = i + 1; j < fills.length; j += 1) {
        if (fills[j]?.stop != null) {
          nextDefinedStopIndex = j;
          break;
        }
      }
    }
    let stop = colorStop?.stop;
    if (stop == null) {
      const stop0 = fills[previousDefinedStopIndex]?.stop;
      const stop1 = fills[nextDefinedStopIndex]?.stop;
      const value0 = stop0 ?? d0;
      const value1 = stop1 ?? d1;
      const stopOffset = isDiscrete && stop0 == null ? 1 : 0;
      stop = value0 + (value1 - value0) * (i - previousDefinedStopIndex + stopOffset) / (nextDefinedStopIndex - previousDefinedStopIndex + stopOffset);
    } else {
      previousDefinedStopIndex = i;
    }
    stops[i] = Math.max(0, Math.min(1, (stop - d0) / (d1 - d0)));
  }
  let lastDefinedColor = fills.find((c) => c.color != null)?.color;
  let colorScale;
  const colorStops = fills.map((fill, i) => {
    let color7 = fill?.color;
    const stop = stops[i];
    if (color7 != null) {
      lastDefinedColor = color7;
    } else if (lastDefinedColor != null) {
      color7 = lastDefinedColor;
    } else {
      if (colorScale == null) {
        colorScale = new ColorScale();
        colorScale.domain = [0, 1];
        colorScale.range = defaultColorStops;
      }
      color7 = colorScale.convert(stop);
    }
    return { stop, color: color7 };
  });
  return fillMode === "discrete" ? discreteColorStops(colorStops) : colorStops;
}

// packages/ag-charts-community/src/scene/image/image.ts
var import_ag_charts_core27 = require("ag-charts-core");
var Image2 = class {
  constructor(imageLoader, imageOptions) {
    this.imageLoader = imageLoader;
    this._cache = void 0;
    this.url = imageOptions.url;
    this.backgroundFill = imageOptions.backgroundFill ?? "black";
    this.backgroundFillOpacity = imageOptions.backgroundFillOpacity ?? 1;
    this.repeat = imageOptions.repeat ?? "no-repeat";
    this.width = imageOptions.width;
    this.height = imageOptions.height;
    this.fit = imageOptions.fit ?? "stretch";
    this.rotation = imageOptions.rotation ?? 0;
  }
  createCanvasImage(ctx, image, width2, height2) {
    if (!image)
      return null;
    const [renderedWidth, renderedHeight] = this.getSize(image.width, image.height, width2, height2);
    if (renderedWidth < 1 || renderedHeight < 1) {
      import_ag_charts_core27.Logger.warnOnce("Image fill is too small to render, ignoring.");
      return null;
    }
    return ctx.createPattern(image, this.repeat);
  }
  getSize(imageWidth, imageHeight, width2, height2) {
    const { fit } = this;
    let dw = imageWidth;
    let dh = imageHeight;
    let scale2 = 1;
    const shapeAspectRatio = width2 / height2;
    const imageAspectRatio = imageWidth / imageHeight;
    if (fit === "stretch" || imageWidth === 0 || imageHeight === 0) {
      dw = width2;
      dh = height2;
    } else if (fit === "contain") {
      scale2 = imageAspectRatio > shapeAspectRatio ? width2 / imageWidth : height2 / imageHeight;
    } else if (fit === "cover") {
      scale2 = imageAspectRatio > shapeAspectRatio ? height2 / imageHeight : width2 / imageWidth;
    }
    return [Math.max(1, dw * scale2), Math.max(1, dh * scale2)];
  }
  setImageTransform(pattern, bbox) {
    if (typeof pattern === "string")
      return;
    const { url, rotation, width: width2, height: height2 } = this;
    const image = this.imageLoader?.loadImage(url);
    if (!image) {
      return;
    }
    const angle = normalizeAngle360FromDegrees(rotation);
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const [renderedWidth, renderedHeight] = this.getSize(
      image.width,
      image.height,
      width2 ?? bbox.width,
      height2 ?? bbox.height
    );
    const widthScale = renderedWidth / image.width;
    const heightScale = renderedHeight / image.height;
    const bboxCenterX = bbox.x + bbox.width / 2;
    const bboxCenterY = bbox.y + bbox.height / 2;
    const rotatedW = cos * renderedWidth - sin * renderedHeight;
    const rotatedH = sin * renderedWidth + cos * renderedHeight;
    const shapeCenterX = rotatedW / 2;
    const shapeCenterY = rotatedH / 2;
    pattern?.setTransform(
      new DOMMatrix([
        cos * widthScale,
        sin * heightScale,
        -sin * widthScale,
        cos * heightScale,
        bboxCenterX - shapeCenterX,
        bboxCenterY - shapeCenterY
      ])
    );
  }
  createPattern(ctx, shapeWidth, shapeHeight, node) {
    const width2 = this.width ?? shapeWidth;
    const height2 = this.height ?? shapeHeight;
    const cache = this._cache;
    if (cache != null && cache.ctx === ctx && cache.width === width2 && cache.height === height2) {
      return cache.pattern;
    }
    const image = this.imageLoader?.loadImage(this.url, node);
    const pattern = this.createCanvasImage(ctx, image, width2, height2);
    if (pattern == null)
      return this.backgroundFill;
    this._cache = { ctx, pattern, width: width2, height: height2 };
    return pattern;
  }
  toSvg(bbox, pixelRatio) {
    const { url, rotation, backgroundFill, backgroundFillOpacity } = this;
    const { x, y, width: width2, height: height2 } = bbox;
    const pattern = (0, import_ag_charts_core27.createSvgElement)("pattern");
    pattern.setAttribute("viewBox", `0 0 ${width2} ${height2}`);
    pattern.setAttribute("x", String(x));
    pattern.setAttribute("y", String(y));
    pattern.setAttribute("width", String(width2));
    pattern.setAttribute("height", String(height2));
    pattern.setAttribute("patternUnits", "userSpaceOnUse");
    const rect = (0, import_ag_charts_core27.createSvgElement)("rect");
    rect.setAttribute("x", "0");
    rect.setAttribute("y", "0");
    rect.setAttribute("width", String(width2));
    rect.setAttribute("height", String(height2));
    rect.setAttribute("fill", backgroundFill);
    rect.setAttribute("fill-opacity", String(backgroundFillOpacity));
    pattern.appendChild(rect);
    const image = (0, import_ag_charts_core27.createSvgElement)("image");
    image.setAttribute("href", url);
    image.setAttribute("x", "0");
    image.setAttribute("y", "0");
    image.setAttribute("width", String(width2));
    image.setAttribute("height", String(height2));
    image.setAttribute("preserveAspectRatio", "none");
    image.setAttribute("transform", `scale(${1 / pixelRatio}) rotate(${rotation}, ${width2 / 2}, ${height2 / 2})`);
    pattern.appendChild(image);
    return pattern;
  }
};

// packages/ag-charts-community/src/scene/pattern/pattern.ts
var import_ag_charts_core30 = require("ag-charts-core");

// packages/ag-charts-community/src/util/svg.ts
var import_ag_charts_core28 = require("ag-charts-core");
var commandEx = /^[\t\n\f\r ]*([achlmqstvz])[\t\n\f\r ]*/i;
var coordinateEx = /^[+-]?((\d*\.\d+)|(\d+\.)|(\d+))(e[+-]?\d+)?/i;
var commaEx = /[\t\n\f\r ]*,?[\t\n\f\r ]*/;
var flagEx = /^[01]/;
var pathParams = {
  z: [],
  h: [coordinateEx],
  v: [coordinateEx],
  m: [coordinateEx, coordinateEx],
  l: [coordinateEx, coordinateEx],
  t: [coordinateEx, coordinateEx],
  s: [coordinateEx, coordinateEx, coordinateEx, coordinateEx],
  q: [coordinateEx, coordinateEx, coordinateEx, coordinateEx],
  c: [coordinateEx, coordinateEx, coordinateEx, coordinateEx, coordinateEx, coordinateEx],
  a: [coordinateEx, coordinateEx, coordinateEx, flagEx, flagEx, coordinateEx, coordinateEx]
};
function parseSvg(d) {
  if (!d)
    return;
  const segments = [];
  let i = 0;
  let currentCommand;
  while (i < d.length) {
    const commandMatch = commandEx.exec(d.slice(i));
    let command;
    if (commandMatch == null) {
      if (!currentCommand) {
        import_ag_charts_core28.Logger.warnOnce(`Invalid SVG path, error at index ${i}: Missing command.`);
        return;
      }
      command = currentCommand;
    } else {
      command = commandMatch[1];
      i += commandMatch[0].length;
    }
    const segment = parseSegment(command, d, i);
    if (!segment)
      return;
    i = segment[0];
    currentCommand = command;
    segments.push(segment[1]);
  }
  return segments;
}
function parseSegment(command, d, index) {
  const params = pathParams[command.toLocaleLowerCase()];
  const pathSeg = { command, params: [] };
  for (const regex of params) {
    const segment = d.slice(index);
    const match = regex.exec(segment);
    if (match != null) {
      pathSeg.params.push(parseFloat(match[0]));
      index += match[0].length;
      const next = commaEx.exec(segment.slice(match[0].length));
      if (next != null) {
        index += next[0].length;
      }
    } else if (pathSeg.params.length === 1) {
      return [index, pathSeg];
    } else {
      import_ag_charts_core28.Logger.warnOnce(
        `Invalid SVG path, error at index ${index}: No path segment parameters for command [${command}]`
      );
      return;
    }
  }
  return [index, pathSeg];
}

// packages/ag-charts-community/src/scene/extendedPath2D.ts
var import_ag_charts_core29 = require("ag-charts-core");

// packages/ag-charts-community/src/util/distance.ts
function pointsDistanceSquared(x1, y1, x2, y2) {
  const dx = x1 - x2;
  const dy = y1 - y2;
  return dx * dx + dy * dy;
}
function lineDistanceSquared(x, y, x1, y1, x2, y2, best) {
  if (x1 === x2 && y1 === y2) {
    return Math.min(best, pointsDistanceSquared(x, y, x1, y1));
  }
  const dx = x2 - x1;
  const dy = y2 - y1;
  const t = Math.max(0, Math.min(1, ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy)));
  const ix = x1 + t * dx;
  const iy = y1 + t * dy;
  return Math.min(best, pointsDistanceSquared(x, y, ix, iy));
}
function arcDistanceSquared(x, y, cx, cy, radius, startAngle, endAngle, counterClockwise, best) {
  if (counterClockwise) {
    [endAngle, startAngle] = [startAngle, endAngle];
  }
  const angle = Math.atan2(y - cy, x - cx);
  if (!isBetweenAngles(angle, startAngle, endAngle)) {
    const startX = cx + Math.cos(startAngle) * radius;
    const startY = cy + Math.sin(startAngle) * radius;
    const endX = cx + Math.cos(startAngle) * radius;
    const endY = cy + Math.sin(startAngle) * radius;
    return Math.min(best, pointsDistanceSquared(x, y, startX, startY), pointsDistanceSquared(x, y, endX, endY));
  }
  const distToArc = radius - Math.sqrt(pointsDistanceSquared(x, y, cx, cy));
  return Math.min(best, distToArc * distToArc);
}

// packages/ag-charts-community/src/scene/polyRoots.ts
function linearRoot(a, b) {
  const t = -b / a;
  return a !== 0 && t >= 0 && t <= 1 ? [t] : [];
}
function quadraticRoots(a, b, c) {
  if (a === 0) {
    return linearRoot(b, c);
  }
  const D = b * b - 4 * a * c;
  const roots = [];
  if (D === 0) {
    const t = -b / (2 * a);
    if (t >= 0 && t <= 1) {
      roots.push(t);
    }
  } else if (D > 0) {
    const rD = Math.sqrt(D);
    const t1 = (-b - rD) / (2 * a);
    const t2 = (-b + rD) / (2 * a);
    if (t1 >= 0 && t1 <= 1) {
      roots.push(t1);
    }
    if (t2 >= 0 && t2 <= 1) {
      roots.push(t2);
    }
  }
  return roots;
}
function cubicRoots(a, b, c, d) {
  if (a === 0) {
    return quadraticRoots(b, c, d);
  }
  const A = b / a;
  const B = c / a;
  const C2 = d / a;
  const Q = (3 * B - A * A) / 9;
  const R = (9 * A * B - 27 * C2 - 2 * A * A * A) / 54;
  const D = Q * Q * Q + R * R;
  const third = 1 / 3;
  const roots = [];
  if (D >= 0) {
    const rD = Math.sqrt(D);
    const S = Math.sign(R + rD) * Math.pow(Math.abs(R + rD), third);
    const T = Math.sign(R - rD) * Math.pow(Math.abs(R - rD), third);
    const Im = Math.abs(Math.sqrt(3) * (S - T) / 2);
    const t = -third * A + (S + T);
    if (t >= 0 && t <= 1) {
      roots.push(t);
    }
    if (Im === 0) {
      const t2 = -third * A - (S + T) / 2;
      if (t2 >= 0 && t2 <= 1) {
        roots.push(t2);
      }
    }
  } else {
    const theta = Math.acos(R / Math.sqrt(-Q * Q * Q));
    const thirdA = third * A;
    const twoSqrtQ = 2 * Math.sqrt(-Q);
    const t1 = twoSqrtQ * Math.cos(third * theta) - thirdA;
    const t2 = twoSqrtQ * Math.cos(third * (theta + 2 * Math.PI)) - thirdA;
    const t3 = twoSqrtQ * Math.cos(third * (theta + 4 * Math.PI)) - thirdA;
    if (t1 >= 0 && t1 <= 1) {
      roots.push(t1);
    }
    if (t2 >= 0 && t2 <= 1) {
      roots.push(t2);
    }
    if (t3 >= 0 && t3 <= 1) {
      roots.push(t3);
    }
  }
  return roots;
}

// packages/ag-charts-community/src/scene/intersection.ts
function segmentIntersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
  const d = (ax2 - ax1) * (by2 - by1) - (ay2 - ay1) * (bx2 - bx1);
  if (d === 0) {
    return 0;
  }
  const ua = ((bx2 - bx1) * (ay1 - by1) - (ax1 - bx1) * (by2 - by1)) / d;
  const ub = ((ax2 - ax1) * (ay1 - by1) - (ay2 - ay1) * (ax1 - bx1)) / d;
  if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
    return 1;
  }
  return 0;
}
function cubicSegmentIntersections(px1, py1, px2, py2, px3, py3, px4, py4, x1, y1, x2, y2) {
  let intersections = 0;
  const A = y1 - y2;
  const B = x2 - x1;
  const C2 = x1 * (y2 - y1) - y1 * (x2 - x1);
  const bx = bezierCoefficients(px1, px2, px3, px4);
  const by = bezierCoefficients(py1, py2, py3, py4);
  const a = A * bx[0] + B * by[0];
  const b = A * bx[1] + B * by[1];
  const c = A * bx[2] + B * by[2];
  const d = A * bx[3] + B * by[3] + C2;
  const roots = cubicRoots(a, b, c, d);
  for (const t of roots) {
    const tt = t * t;
    const ttt = t * tt;
    const x = bx[0] * ttt + bx[1] * tt + bx[2] * t + bx[3];
    const y = by[0] * ttt + by[1] * tt + by[2] * t + by[3];
    let s;
    if (x1 === x2) {
      s = (y - y1) / (y2 - y1);
    } else {
      s = (x - x1) / (x2 - x1);
    }
    if (s >= 0 && s <= 1) {
      intersections++;
    }
  }
  return intersections;
}
function bezierCoefficients(P1, P2, P3, P4) {
  return [
    // Bézier expressed as matrix operations:
    -P1 + 3 * P2 - 3 * P3 + P4,
    //                 |-1  3 -3  1| |P1|
    3 * P1 - 6 * P2 + 3 * P3,
    //   [t^3 t^2 t 1] | 3 -6  3  0| |P2|
    -3 * P1 + 3 * P2,
    //                 |-3  3  0  0| |P3|
    P1
    //                 | 1  0  0  0| |P4|
  ];
}
function arcIntersections(cx, cy, r, startAngle, endAngle, counterClockwise, x1, y1, x2, y2) {
  if (isNaN(cx) || isNaN(cy)) {
    return 0;
  }
  if (counterClockwise) {
    [endAngle, startAngle] = [startAngle, endAngle];
  }
  const k = (y2 - y1) / (x2 - x1);
  const y0 = y1 - k * x1;
  const a = Math.pow(k, 2) + 1;
  const b = 2 * (k * (y0 - cy) - cx);
  const c = Math.pow(cx, 2) + Math.pow(y0 - cy, 2) - Math.pow(r, 2);
  const d = Math.pow(b, 2) - 4 * a * c;
  if (d < 0) {
    return 0;
  }
  const i1x = (-b + Math.sqrt(d)) / 2 / a;
  const i2x = (-b - Math.sqrt(d)) / 2 / a;
  let intersections = 0;
  [i1x, i2x].forEach((x) => {
    const isXInsideLine = x >= Math.min(x1, x2) && x <= Math.max(x1, x2);
    if (!isXInsideLine) {
      return;
    }
    const y = k * x + y0;
    const adjacent = x - cx;
    const opposite = y - cy;
    const angle = Math.atan2(opposite, adjacent);
    if (isBetweenAngles(angle, startAngle, endAngle)) {
      intersections++;
    }
  });
  return intersections;
}

// packages/ag-charts-community/src/scene/util/bezier.ts
function evaluateBezier(p0, p1, p2, p3, t) {
  return (1 - t) ** 3 * p0 + 3 * (1 - t) ** 2 * t * p1 + 3 * (1 - t) * t ** 2 * p2 + t ** 3 * p3;
}
function solveBezier(p0, p1, p2, p3, value) {
  if (value <= Math.min(p0, p3)) {
    return p0 < p3 ? 0 : 1;
  } else if (value >= Math.max(p0, p3)) {
    return p0 < p3 ? 1 : 0;
  }
  let t0 = 0;
  let t1 = 1;
  let t = NaN;
  for (let i = 0; i < 12; i += 1) {
    t = (t0 + t1) / 2;
    const curveValue = evaluateBezier(p0, p1, p2, p3, t);
    if (curveValue < value) {
      t0 = t;
    } else {
      t1 = t;
    }
  }
  return t;
}
function splitBezier(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, t) {
  const x01 = (1 - t) * p0x + t * p1x;
  const y01 = (1 - t) * p0y + t * p1y;
  const x12 = (1 - t) * p1x + t * p2x;
  const y12 = (1 - t) * p1y + t * p2y;
  const x23 = (1 - t) * p2x + t * p3x;
  const y23 = (1 - t) * p2y + t * p3y;
  const x012 = (1 - t) * x01 + t * x12;
  const y012 = (1 - t) * y01 + t * y12;
  const x123 = (1 - t) * x12 + t * x23;
  const y123 = (1 - t) * y12 + t * y23;
  const x0123 = (1 - t) * x012 + t * x123;
  const y0123 = (1 - t) * y012 + t * y123;
  return [
    [
      { x: p0x, y: p0y },
      { x: x01, y: y01 },
      { x: x012, y: y012 },
      { x: x0123, y: y0123 }
    ],
    [
      { x: x0123, y: y0123 },
      { x: x123, y: y123 },
      { x: x23, y: y23 },
      { x: p3x, y: p3y }
    ]
  ];
}
function calculateDerivativeExtrema(p0, p1, p2, p3) {
  const a = -p0 + 3 * p1 - 3 * p2 + p3;
  const b = 2 * (p0 - 2 * p1 + p2);
  const c = -p0 + p1;
  if (a === 0) {
    if (b !== 0) {
      const t = -c / b;
      if (t > 0 && t < 1) {
        return [t];
      }
    }
    return [];
  }
  const discriminant = b * b - 4 * a * c;
  if (discriminant >= 0) {
    const sqrtDiscriminant = Math.sqrt(discriminant);
    const t1 = (-b + sqrtDiscriminant) / (2 * a);
    const t2 = (-b - sqrtDiscriminant) / (2 * a);
    return [t1, t2].filter((t) => t > 0 && t < 1);
  }
  return [];
}
function calculateDerivativeExtremaXY(sx, sy, cp1x, cp1y, cp2x, cp2y, x, y) {
  const tx = calculateDerivativeExtrema(sx, cp1x, cp2x, x);
  const ty = calculateDerivativeExtrema(sy, cp1y, cp2y, y);
  return [...tx, ...ty];
}

// packages/ag-charts-community/src/scene/extendedPath2D.ts
var ExtendedPath2D = class {
  constructor() {
    // The methods of this class will likely be called many times per animation frame,
    // and any allocation can trigger a GC cycle during animation, so we attempt
    // to minimize the number of allocations.
    this.path2d = new Path2D();
    this.previousCommands = [];
    this.previousParams = [];
    this.previousClosedPath = false;
    this.commands = [];
    this.params = [];
    this.openedPath = false;
    this.closedPath = false;
  }
  isEmpty() {
    return this.commands.length === 0;
  }
  isDirty() {
    return this.closedPath !== this.previousClosedPath || this.previousCommands.length !== this.commands.length || this.previousParams.length !== this.params.length || this.previousCommands.toString() !== this.commands.toString() || this.previousParams.toString() !== this.params.toString();
  }
  getPath2D() {
    return this.path2d;
  }
  moveTo(x, y) {
    this.openedPath = true;
    this.path2d.moveTo(x, y);
    this.commands.push(0 /* Move */);
    this.params.push(x, y);
  }
  lineTo(x, y) {
    if (this.openedPath) {
      this.path2d.lineTo(x, y);
      this.commands.push(1 /* Line */);
      this.params.push(x, y);
    } else {
      this.moveTo(x, y);
    }
  }
  rect(x, y, width2, height2) {
    this.moveTo(x, y);
    this.lineTo(x + width2, y);
    this.lineTo(x + width2, y + height2);
    this.lineTo(x, y + height2);
    this.closePath();
  }
  appendSvg(parts) {
    let sx = 0;
    let sy = 0;
    let cx;
    let cy;
    let cpx = 0;
    let cpy = 0;
    for (const { command, params } of parts) {
      cx ?? (cx = params[0]);
      cy ?? (cy = params[1]);
      const relative = command === command.toLowerCase();
      const dx = relative ? cx : 0;
      const dy = relative ? cy : 0;
      switch (command.toLowerCase()) {
        case "m":
          this.moveTo(dx + params[0], dy + params[1]);
          cx = dx + params[0];
          cy = dy + params[1];
          sx = cx;
          sy = cy;
          break;
        case "c":
          this.cubicCurveTo(
            dx + params[0],
            dy + params[1],
            dx + params[2],
            dy + params[3],
            dx + params[4],
            dy + params[5]
          );
          cpx = dx + params[2];
          cpy = dy + params[3];
          cx = dx + params[4];
          cy = dy + params[5];
          break;
        case "s":
          this.cubicCurveTo(
            cx + cx - cpx,
            cy + cy - cpy,
            dx + params[0],
            dy + params[1],
            dx + params[2],
            dy + params[3]
          );
          cpx = dx + params[0];
          cpy = dy + params[1];
          cx = dx + params[2];
          cy = dy + params[3];
          break;
        case "q":
          this.cubicCurveTo(
            (dx + 2 * params[0]) / 3,
            (dy + 2 * params[1]) / 3,
            (2 * params[0] + params[2]) / 3,
            (2 * params[1] + params[3]) / 3,
            params[2],
            params[3]
          );
          cpx = params[0];
          cpy = params[1];
          cx = params[2];
          cy = params[3];
          break;
        case "t":
          this.cubicCurveTo(
            (cx + 2 * (cx + cx - cpx)) / 3,
            (cy + 2 * (cy + cy - cpy)) / 3,
            (2 * (cx + cx - cpx) + params[0]) / 3,
            (2 * (cy + cy - cpy) + params[1]) / 3,
            params[0],
            params[1]
          );
          cpx = cx + cx - cpx;
          cpy = cy + cy - cpy;
          cx = params[0];
          cy = params[1];
          break;
        case "a":
          this.ellipse(
            cx,
            cy,
            params[0],
            params[1],
            params[2] * Math.PI / 180,
            params[3],
            params[4],
            dx + params[5],
            dy + params[6]
          );
          cx = dx + params[5];
          cy = dy + params[6];
          break;
        case "h":
          this.lineTo(dx + params[0], cy);
          cx = dx + params[0];
          break;
        case "l":
          this.lineTo(dx + params[0], dy + params[1]);
          cx = dx + params[0];
          cy = dy + params[1];
          break;
        case "v":
          this.lineTo(cx, dy + params[0]);
          cy = dy + params[0];
          break;
        case "z":
          this.closePath();
          cx = sx;
          cy = sy;
          break;
        default:
          throw new Error(`Could not translate command '${command}' with '${params.join(" ")}'`);
      }
    }
  }
  ellipse(x1, y1, rx, ry, rotation, fA, fS, x2, y2) {
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    const dx = (x1 - x2) / 2;
    const dy = (y1 - y2) / 2;
    const sin = Math.sin(rotation);
    const cos = Math.cos(rotation);
    const rotX = cos * dx + sin * dy;
    const rotY = -sin * dx + cos * dy;
    const normX = rotX / rx;
    const normY = rotY / ry;
    let scale2 = normX * normX + normY * normY;
    let cx = (x1 + x2) / 2;
    let cy = (y1 + y2) / 2;
    let cpx = 0;
    let cpy = 0;
    if (scale2 >= 1) {
      scale2 = Math.sqrt(scale2);
      rx *= scale2;
      ry *= scale2;
    } else {
      scale2 = Math.sqrt(1 / scale2 - 1);
      if (fA === fS)
        scale2 = -scale2;
      cpx = scale2 * rx * normY;
      cpy = -scale2 * ry * normX;
      cx += cos * cpx - sin * cpy;
      cy += sin * cpx + cos * cpy;
    }
    const sAngle = Math.atan2((rotY - cpy) / ry, (rotX - cpx) / rx);
    const deltaTheta = Math.atan2((-rotY - cpy) / ry, (-rotX - cpx) / rx) - sAngle;
    const eAngle = sAngle + deltaTheta;
    const counterClockwise = !!(1 - fS);
    this.ellipticalArc(cx, cy, rx, ry, rotation, sAngle, eAngle, counterClockwise);
  }
  ellipticalArc(cx, cy, rx, ry, rotation, sAngle, eAngle, counterClockwise) {
    if (counterClockwise) {
      [sAngle, eAngle] = [eAngle, sAngle];
    }
    const params = [];
    const f90 = 0.5522847498307935;
    const sinS = Math.sin(sAngle);
    const cosS = Math.cos(sAngle);
    const sinR = Math.sin(rotation);
    const cosR = Math.cos(rotation);
    let xx = cosR * cosS * rx - sinR * sinS * ry;
    let yx = sinR * cosS * rx + cosR * sinS * ry;
    let xy = -cosR * sinS * rx - sinR * cosS * ry;
    let yy = -sinR * sinS * rx + cosR * cosS * ry;
    params.push(xx + cx, yx + cy);
    eAngle -= sAngle;
    eAngle = normalizeAngle360(eAngle);
    const rightAngle = Math.PI / 2;
    const fullRightAngles = Math.floor(eAngle / rightAngle);
    const remainderAngle = eAngle % rightAngle;
    for (let i = 0; i < fullRightAngles; i++) {
      params.push(
        xx + xy * f90 + cx,
        yx + yy * f90 + cy,
        xx * f90 + xy + cx,
        yx * f90 + yy + cy,
        xy + cx,
        yy + cy
      );
      [xx, xy] = [xy, -xx];
      [yx, yy] = [yy, -yx];
    }
    if (remainderAngle > 0) {
      const sinRA = Math.sin(remainderAngle);
      const cosRA = Math.cos(remainderAngle);
      const factor = Math.tan(remainderAngle / 4) * (4 / 3);
      const cpx = cosRA + factor * sinRA;
      const cpy = sinRA - factor * cosRA;
      params.push(
        xx + xy * factor + cx,
        yx + yy * factor + cy,
        xx * cpx + xy * cpy + cx,
        yx * cpx + yy * cpy + cy,
        xx * cosRA + xy * sinRA + cx,
        yx * cosRA + yy * sinRA + cy
      );
    }
    if (counterClockwise) {
      for (let i = 0, j = params.length - 2; i < j; i += 2, j -= 2) {
        [params[i], params[j]] = [params[j], params[i]];
        [params[i + 1], params[j + 1]] = [params[j + 1], params[i + 1]];
      }
    }
    for (let i = 2; i < params.length; i += 6) {
      const [cx1, cy1, cx2, cy2, x, y] = params.slice(i, i + 6);
      this.cubicCurveTo(cx1, cy1, cx2, cy2, x, y);
    }
  }
  roundRect(x, y, width2, height2, radii) {
    radii = Math.min(radii, width2 / 2, height2 / 2);
    this.moveTo(x, y + radii);
    this.arc(x + radii, y + radii, radii, Math.PI, 1.5 * Math.PI);
    this.lineTo(x + radii, y);
    this.lineTo(x + width2 - radii, y);
    this.arc(x + width2 - radii, y + radii, radii, 1.5 * Math.PI, 2 * Math.PI);
    this.lineTo(x + width2, y + radii);
    this.lineTo(x + width2, y + height2 - radii);
    this.arc(x + width2 - radii, y + height2 - radii, radii, 0, Math.PI / 2);
    this.lineTo(x + width2 - radii, y + height2);
    this.lineTo(x + radii, y + height2);
    this.arc(x + +radii, y + height2 - radii, radii, Math.PI / 2, Math.PI);
    this.lineTo(x, y + height2 - radii);
    this.closePath();
  }
  arc(x, y, r, sAngle, eAngle, counterClockwise) {
    this.openedPath = true;
    this.path2d.arc(x, y, r, sAngle, eAngle, counterClockwise);
    this.commands.push(2 /* Arc */);
    this.params.push(x, y, r, sAngle, eAngle, counterClockwise ? 1 : 0);
  }
  cubicCurveTo(cx1, cy1, cx2, cy2, x, y) {
    if (!this.openedPath) {
      this.moveTo(cx1, cy1);
    }
    this.path2d.bezierCurveTo(cx1, cy1, cx2, cy2, x, y);
    this.commands.push(3 /* Curve */);
    this.params.push(cx1, cy1, cx2, cy2, x, y);
  }
  closePath() {
    if (this.openedPath) {
      this.path2d.closePath();
      this.commands.push(4 /* ClosePath */);
      this.openedPath = false;
      this.closedPath = true;
    }
  }
  clear(trackChanges) {
    if (trackChanges) {
      this.previousCommands = this.commands;
      this.previousParams = this.params;
      this.previousClosedPath = this.closedPath;
    }
    this.path2d = new Path2D();
    this.openedPath = false;
    this.closedPath = false;
    this.commands = [];
    this.params = [];
  }
  isPointInPath(x, y) {
    const commands = this.commands;
    const params = this.params;
    const cn = commands.length;
    const ox = -1e4;
    const oy = -1e4;
    let sx = NaN;
    let sy = NaN;
    let px = 0;
    let py = 0;
    let intersectionCount = 0;
    for (let ci = 0, pi = 0; ci < cn; ci++) {
      switch (commands[ci]) {
        case 0 /* Move */:
          intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);
          px = params[pi++];
          sx = px;
          py = params[pi++];
          sy = py;
          break;
        case 1 /* Line */:
          intersectionCount += segmentIntersection(px, py, params[pi++], params[pi++], ox, oy, x, y);
          px = params[pi - 2];
          py = params[pi - 1];
          break;
        case 3 /* Curve */:
          intersectionCount += cubicSegmentIntersections(
            px,
            py,
            params[pi++],
            params[pi++],
            params[pi++],
            params[pi++],
            params[pi++],
            params[pi++],
            ox,
            oy,
            x,
            y
          );
          px = params[pi - 2];
          py = params[pi - 1];
          break;
        case 2 /* Arc */: {
          const cx = params[pi++];
          const cy = params[pi++];
          const r = params[pi++];
          const startAngle = params[pi++];
          const endAngle = params[pi++];
          const counterClockwise = Boolean(params[pi++]);
          intersectionCount += arcIntersections(
            cx,
            cy,
            r,
            startAngle,
            endAngle,
            counterClockwise,
            ox,
            oy,
            x,
            y
          );
          if (!isNaN(sx)) {
            const startX = cx + Math.cos(startAngle) * r;
            const startY = cy + Math.sin(startAngle) * r;
            intersectionCount += segmentIntersection(px, py, startX, startY, ox, oy, x, y);
          }
          px = cx + Math.cos(endAngle) * r;
          py = cy + Math.sin(endAngle) * r;
          break;
        }
        case 4 /* ClosePath */:
          intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);
          break;
      }
    }
    return intersectionCount % 2 === 1;
  }
  distanceSquared(x, y) {
    let best = Infinity;
    const commands = this.commands;
    const params = this.params;
    const cn = commands.length;
    let sx = NaN;
    let sy = NaN;
    let px = 0;
    let py = 0;
    for (let ci = 0, pi = 0; ci < cn; ci++) {
      switch (commands[ci]) {
        case 0 /* Move */:
          px = sx = params[pi++];
          py = sy = params[pi++];
          break;
        case 1 /* Line */: {
          const nx = params[pi++];
          const ny = params[pi++];
          best = lineDistanceSquared(x, y, px, py, nx, ny, best);
          break;
        }
        case 3 /* Curve */:
          import_ag_charts_core29.Logger.error("Command.Curve distanceSquare not implemented");
          break;
        case 2 /* Arc */: {
          const cx = params[pi++];
          const cy = params[pi++];
          const r = params[pi++];
          const startAngle = params[pi++];
          const endAngle = params[pi++];
          const startX = cx + Math.cos(startAngle) * r;
          const startY = cy + Math.sin(startAngle) * r;
          const counterClockwise = Boolean(params[pi++]);
          best = lineDistanceSquared(x, y, px, py, startX, startY, best);
          best = arcDistanceSquared(x, y, cx, cy, r, startAngle, endAngle, counterClockwise, best);
          px = cx + Math.cos(endAngle) * r;
          py = cy + Math.sin(endAngle) * r;
          break;
        }
        case 4 /* ClosePath */:
          best = lineDistanceSquared(x, y, px, py, sx, sy, best);
          break;
      }
    }
    return best;
  }
  // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d
  toSVG(transform = (x, y) => ({ x, y })) {
    const buffer = [];
    const { commands, params } = this;
    const addCommand = (command, ...points) => {
      buffer.push(command);
      for (let i = 0; i < points.length; i += 2) {
        const { x, y } = transform(points[i], points[i + 1]);
        buffer.push(x, y);
      }
    };
    let pi = 0;
    for (const command of commands) {
      switch (command) {
        case 0 /* Move */:
          addCommand("M", params[pi++], params[pi++]);
          break;
        case 1 /* Line */:
          addCommand("L", params[pi++], params[pi++]);
          break;
        case 3 /* Curve */:
          addCommand("C", params[pi++], params[pi++], params[pi++], params[pi++], params[pi++], params[pi++]);
          break;
        case 2 /* Arc */: {
          const cx = params[pi++];
          const cy = params[pi++];
          const r = params[pi++];
          const A0 = params[pi++];
          const A1 = params[pi++];
          const ccw = params[pi++];
          let sweep = ccw ? A0 - A1 : A1 - A0;
          if (sweep < 0) {
            sweep += Math.ceil(-sweep / (2 * Math.PI)) * 2 * Math.PI;
          }
          if (ccw) {
            sweep = -sweep;
          }
          const arcSections = Math.max(Math.ceil(Math.abs(sweep) / (Math.PI / 2)), 1);
          const step = sweep / arcSections;
          const h = 4 / 3 * Math.tan(step / 4);
          const move = buffer.length === 0 ? "M" : "L";
          addCommand(move, cx + Math.cos(A0) * r, cy + Math.sin(A0) * r);
          for (let i = 0; i < arcSections; i += 1) {
            const a0 = A0 + step * (i + 0);
            const a1 = A0 + step * (i + 1);
            const rSinStart = r * Math.sin(a0);
            const rCosStart = r * Math.cos(a0);
            const rSinEnd = r * Math.sin(a1);
            const rCosEnd = r * Math.cos(a1);
            addCommand(
              "C",
              cx + rCosStart - h * rSinStart,
              cy + rSinStart + h * rCosStart,
              cx + rCosEnd + h * rSinEnd,
              cy + rSinEnd - h * rCosEnd,
              cx + rCosEnd,
              cy + rSinEnd
            );
          }
          break;
        }
        case 4 /* ClosePath */:
          buffer.push("Z");
          break;
      }
    }
    return buffer.join(" ");
  }
  computeBBox() {
    const { commands, params } = this;
    let [top, left, right, bot] = [Infinity, Infinity, -Infinity, -Infinity];
    let [sx, sy] = [NaN, NaN];
    let [mx, my] = [NaN, NaN];
    const joinPoint = (x, y, updatestart) => {
      top = Math.min(y, top);
      left = Math.min(x, left);
      right = Math.max(x, right);
      bot = Math.max(y, bot);
      if (updatestart) {
        [sx, sy] = [x, y];
      }
    };
    const joinAngle = (cx, cy, r, angle, updatestart) => {
      const px = cx + r * Math.cos(angle);
      const py = cy + r * Math.sin(angle);
      joinPoint(px, py, updatestart);
    };
    let pi = 0;
    for (const command of commands) {
      switch (command) {
        case 0 /* Move */:
          joinPoint(params[pi++], params[pi++], true);
          [mx, my] = [sx, sy];
          break;
        case 1 /* Line */:
          joinPoint(params[pi++], params[pi++], true);
          break;
        case 3 /* Curve */: {
          const cp1x = params[pi++];
          const cp1y = params[pi++];
          const cp2x = params[pi++];
          const cp2y = params[pi++];
          const x = params[pi++];
          const y = params[pi++];
          const ts = calculateDerivativeExtremaXY(sx, sy, cp1x, cp1y, cp2x, cp2y, x, y);
          ts.forEach((t) => {
            const px = evaluateBezier(sx, cp1x, cp2x, x, t);
            const py = evaluateBezier(sy, cp1y, cp2y, y, t);
            joinPoint(px, py);
          });
          joinPoint(x, y, true);
          break;
        }
        case 2 /* Arc */: {
          const cx = params[pi++];
          const cy = params[pi++];
          const r = params[pi++];
          const a0 = normalizeAngle360(params[pi++]);
          const a1 = normalizeAngle360(params[pi++]);
          const ccw = params[pi++];
          joinAngle(cx, cy, r, a0);
          const criticalAngles = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2];
          const [r0, r1] = ccw ? [a1, a0] : [a0, a1];
          for (const crit of criticalAngles) {
            if (r0 < r1 && r0 <= crit && crit <= r1 || r0 > r1 && (r0 <= crit || crit <= r1)) {
              joinAngle(cx, cy, r, crit);
            }
          }
          joinAngle(cx, cy, r, a1, true);
          break;
        }
        case 4 /* ClosePath */:
          [sx, sy] = [mx, my];
          break;
      }
    }
    return new BBox(left, top, right - left, bot - top);
  }
};

// packages/ag-charts-community/src/scene/util/pixel.ts
function align(pixelRatio, start2, length) {
  const alignedStart = Math.round(start2 * pixelRatio) / pixelRatio;
  if (length == null) {
    return alignedStart;
  } else if (length === 0) {
    return 0;
  } else if (length < 1) {
    return Math.ceil(length * pixelRatio) / pixelRatio;
  }
  return Math.round((length + start2) * pixelRatio) / pixelRatio - alignedStart;
}
function alignBefore(pixelRatio, start2) {
  return Math.floor(start2 * pixelRatio) / pixelRatio;
}

// packages/ag-charts-community/src/scene/pattern/patterns.ts
function drawPatternUnitPolygon(path, params, moves) {
  const { width: width2, height: height2, padding, strokeWidth } = params;
  const x0 = width2 / 2;
  const y0 = height2 / 2;
  const w = Math.max(1, width2 - padding - strokeWidth / 2);
  const h = Math.max(1, height2 - padding - strokeWidth / 2);
  let didMove = false;
  for (const [dx, dy] of moves) {
    const x = x0 + (dx - 0.5) * w;
    const y = y0 + (dy - 0.5) * h;
    if (didMove) {
      path.lineTo(x, y);
    } else {
      path.moveTo(x, y);
    }
    didMove = true;
  }
  path.closePath();
}
var PATTERNS = {
  circles(path, { width: width2, strokeWidth, padding }) {
    const c = width2 / 2;
    const r = Math.max(1, c - padding - strokeWidth / 2);
    path.arc(c, c, r, 0, Math.PI * 2);
  },
  squares(path, { width: width2, height: height2, pixelRatio, padding, strokeWidth }) {
    const offset4 = padding + strokeWidth / 2;
    path.moveTo(align(pixelRatio, offset4), align(pixelRatio, offset4));
    path.lineTo(align(pixelRatio, width2 - offset4), align(pixelRatio, offset4));
    path.lineTo(align(pixelRatio, width2 - offset4), align(pixelRatio, height2 - offset4));
    path.lineTo(align(pixelRatio, offset4), align(pixelRatio, height2 - offset4));
    path.closePath();
  },
  triangles(path, params) {
    drawPatternUnitPolygon(path, params, [
      [0.5, 0],
      [1, 1],
      [0, 1]
    ]);
  },
  diamonds(path, params) {
    drawPatternUnitPolygon(path, params, [
      [0.5, 0],
      [1, 0.5],
      [0.5, 1],
      [0, 0.5]
    ]);
  },
  stars(path, { width: width2, height: height2, padding }) {
    const spikes = 5;
    const outerRadius = Math.max(1, (width2 - padding) / 2);
    const innerRadius = outerRadius / 2;
    const rotation = Math.PI / 2;
    for (let i = 0; i < spikes * 2; i++) {
      const radius = i % 2 === 0 ? outerRadius : innerRadius;
      const angle = i * Math.PI / spikes - rotation;
      const xCoordinate = width2 / 2 + Math.cos(angle) * radius;
      const yCoordinate = height2 / 2 + Math.sin(angle) * radius;
      path.lineTo(xCoordinate, yCoordinate);
    }
    path.closePath();
  },
  hearts(path, { width: width2, height: height2, padding }) {
    const r = Math.max(1, width2 / 4 - padding / 2);
    const x = width2 / 2;
    const y = height2 / 2 + r / 2;
    path.arc(x - r, y - r, r, toRadians(130), toRadians(330));
    path.arc(x + r, y - r, r, toRadians(220), toRadians(50));
    path.lineTo(x, y + r);
    path.closePath();
  },
  crosses(path, params) {
    drawPatternUnitPolygon(path, params, [
      [0.25, 0],
      [0.5, 0.25],
      [0.75, 0],
      [1, 0.25],
      [0.75, 0.5],
      [1, 0.75],
      [0.75, 1],
      [0.5, 0.75],
      [0.25, 1],
      [0, 0.75],
      [0.25, 0.5],
      [0, 0.25]
    ]);
  },
  "vertical-lines"(path, { width: width2, height: height2, pixelRatio, strokeWidth }) {
    const x = align(pixelRatio, width2 / 2) - strokeWidth % 2 / 2;
    path.moveTo(x, 0);
    path.lineTo(x, height2);
  },
  "horizontal-lines"(path, { width: width2, height: height2, pixelRatio, strokeWidth }) {
    const y = align(pixelRatio, height2 / 2) - strokeWidth % 2 / 2;
    path.moveTo(0, y);
    path.lineTo(width2, y);
  },
  "forward-slanted-lines"(path, { width: width2, height: height2, strokeWidth }) {
    const angle = Math.atan2(height2, width2);
    const insetX = strokeWidth * Math.cos(angle);
    const insetY = strokeWidth * Math.sin(angle);
    path.moveTo(-insetX, insetY);
    path.lineTo(insetX, -insetY);
    path.moveTo(-insetX, height2 + insetY);
    path.lineTo(width2 + insetX, -insetY);
    path.moveTo(width2 - insetX, height2 + insetY);
    path.lineTo(width2 + insetX, height2 - insetY);
  },
  "backward-slanted-lines"(path, { width: width2, height: height2, strokeWidth }) {
    const angle = Math.atan2(height2, width2);
    const insetX = strokeWidth * Math.cos(angle);
    const insetY = strokeWidth * Math.sin(angle);
    path.moveTo(width2 - insetX, -insetY);
    path.lineTo(width2 + insetX, insetY);
    path.moveTo(-insetX, -insetY);
    path.lineTo(width2 + insetX, height2 + insetY);
    path.moveTo(-insetX, height2 - insetY);
    path.lineTo(insetX, height2 + insetY);
  }
};

// packages/ag-charts-community/src/scene/pattern/pattern.ts
var Pattern = class {
  constructor(patternOptions) {
    this._cache = void 0;
    this.width = Math.max(patternOptions?.width ?? 10, 1);
    this.height = Math.max(patternOptions?.height ?? 10, 1);
    this.fill = patternOptions.fill ?? "none";
    this.fillOpacity = patternOptions.fillOpacity ?? 1;
    this.backgroundFill = patternOptions.backgroundFill ?? "none";
    this.backgroundFillOpacity = patternOptions.backgroundFillOpacity ?? 1;
    this.stroke = patternOptions.stroke ?? "black";
    this.strokeOpacity = patternOptions.strokeOpacity ?? 1;
    this.strokeWidth = patternOptions.strokeWidth ?? 1;
    this.padding = patternOptions.padding ?? 1;
    this.pattern = patternOptions.pattern ?? "forward-slanted-lines";
    this.rotation = patternOptions.rotation ?? 0;
    this.scale = patternOptions.scale ?? 1;
    this.path = patternOptions.path;
  }
  getPath(pixelRatio) {
    const { pattern, width: width2, height: height2, padding, strokeWidth, path: svgPath } = this;
    const path = new ExtendedPath2D();
    const svgParts = parseSvg(svgPath);
    if (svgParts) {
      path.appendSvg(svgParts);
    } else {
      PATTERNS[pattern](path, { width: width2, height: height2, pixelRatio, strokeWidth, padding });
    }
    return path;
  }
  renderStroke(path2d, ctx) {
    const { stroke: stroke2, strokeWidth, strokeOpacity } = this;
    if (!strokeWidth)
      return;
    ctx.strokeStyle = stroke2;
    ctx.lineWidth = strokeWidth;
    ctx.globalAlpha = strokeOpacity;
    ctx.stroke(path2d);
  }
  renderFill(path2d, ctx) {
    const { fill, fillOpacity } = this;
    if (fill === "none") {
      return;
    }
    ctx.fillStyle = fill;
    ctx.globalAlpha = fillOpacity;
    ctx.fill(path2d);
  }
  createCanvasPattern(ctx, pixelRatio) {
    const { width: width2, height: height2, scale: scale2, backgroundFill, backgroundFillOpacity } = this;
    if (width2 * scale2 < 1 || height2 * scale2 < 1) {
      import_ag_charts_core30.Logger.warnOnce("Pattern fill is too small to render, ignoring.");
      return null;
    }
    const offscreenPattern = new HdpiOffscreenCanvas({ width: width2, height: height2, pixelRatio: pixelRatio * scale2 });
    const offscreenPatternCtx = offscreenPattern.context;
    if (backgroundFill !== "none") {
      offscreenPatternCtx.fillStyle = backgroundFill;
      offscreenPatternCtx.globalAlpha = backgroundFillOpacity;
      offscreenPatternCtx.fillRect(0, 0, width2, height2);
    }
    const path2d = this.getPath(pixelRatio).getPath2D();
    this.renderFill(path2d, offscreenPatternCtx);
    this.renderStroke(path2d, offscreenPatternCtx);
    const pattern = ctx.createPattern(offscreenPattern.canvas, "repeat");
    this.setPatternTransform(pattern, pixelRatio);
    offscreenPattern.destroy();
    return pattern;
  }
  setPatternTransform(pattern, pixelRatio, tx = 0, ty = 0) {
    const angle = normalizeAngle360FromDegrees(this.rotation);
    const scale2 = 1 / pixelRatio;
    const cos = Math.cos(angle) * scale2;
    const sin = Math.sin(angle) * scale2;
    pattern?.setTransform(new DOMMatrix([cos, sin, -sin, cos, tx, ty]));
  }
  createPattern(ctx, pixelRatio) {
    if (this._cache != null && this._cache.ctx === ctx && this._cache.pixelRatio === pixelRatio) {
      return this._cache.pattern;
    }
    const pattern = this.createCanvasPattern(ctx, pixelRatio);
    if (pattern == null)
      return;
    this._cache = { ctx, pattern, pixelRatio };
    return pattern;
  }
  toSvg() {
    const {
      width: width2,
      height: height2,
      fill,
      fillOpacity,
      backgroundFill,
      backgroundFillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      rotation,
      scale: scale2
    } = this;
    const pattern = (0, import_ag_charts_core30.createSvgElement)("pattern");
    pattern.setAttribute("viewBox", `0 0 ${width2} ${height2}`);
    pattern.setAttribute("width", String(width2));
    pattern.setAttribute("height", String(height2));
    pattern.setAttribute("patternUnits", "userSpaceOnUse");
    const rect = (0, import_ag_charts_core30.createSvgElement)("rect");
    rect.setAttribute("x", "0");
    rect.setAttribute("y", "0");
    rect.setAttribute("width", String(width2));
    rect.setAttribute("height", String(height2));
    rect.setAttribute("fill", backgroundFill);
    rect.setAttribute("fill-opacity", String(backgroundFillOpacity));
    pattern.appendChild(rect);
    const path = (0, import_ag_charts_core30.createSvgElement)("path");
    path.setAttribute("fill", fill);
    path.setAttribute("fill-opacity", String(fillOpacity));
    path.setAttribute("stroke-opacity", String(strokeOpacity));
    path.setAttribute("stroke", stroke2);
    path.setAttribute("stroke-width", String(strokeWidth));
    path.setAttribute("transform", `rotate(${rotation}) scale(${scale2})`);
    path.setAttribute("d", this.getPath(1).toSVG());
    pattern.appendChild(path);
    return pattern;
  }
};

// packages/ag-charts-community/src/scene/util/fill.ts
var import_ag_charts_core31 = require("ag-charts-core");
function isGradientFill(fill) {
  return (0, import_ag_charts_core31.isObject)(fill) && fill.type == "gradient";
}
function isStringFillArray(fills) {
  return (0, import_ag_charts_core31.isArray)(fills) && fills.every((fill) => typeof fill === "string");
}
function isPatternFill(fill) {
  return fill !== null && (0, import_ag_charts_core31.isObject)(fill) && fill.type == "pattern";
}
function isImageFill(fill) {
  return fill !== null && (0, import_ag_charts_core31.isObject)(fill) && fill.type == "image";
}

// packages/ag-charts-community/src/scene/shape/shape.ts
var _Shape = class _Shape extends Node2 {
  constructor() {
    super(...arguments);
    this.fillOpacity = 1;
    this.strokeOpacity = 1;
    this.fill = _Shape.defaultStyles.fill;
    this.stroke = _Shape.defaultStyles.stroke;
    this.strokeWidth = _Shape.defaultStyles.strokeWidth;
    this.lineDash = _Shape.defaultStyles.lineDash;
    this.lineDashOffset = _Shape.defaultStyles.lineDashOffset;
    this.lineCap = _Shape.defaultStyles.lineCap;
    this.lineJoin = _Shape.defaultStyles.lineJoin;
    this.miterLimit = void 0;
    this.opacity = _Shape.defaultStyles.opacity;
    this.fillShadow = _Shape.defaultStyles.fillShadow;
  }
  /**
   * Restores the default styles introduced by this subclass.
   */
  restoreOwnStyles() {
    const { defaultStyles } = this.constructor;
    Object.assign(this, defaultStyles);
  }
  getGradient(fill) {
    if (isGradientFill(fill))
      return this.createGradient(fill);
  }
  createGradient(fill) {
    const { colorSpace = "rgb", gradient = "linear", colorStops, rotation = 0, reverse = false } = fill;
    if (colorStops == null)
      return;
    let stops = getColorStops(colorStops, ["black"], [0, 1]);
    if (reverse) {
      stops = stops.map((s) => ({ color: s.color, stop: 1 - s.stop })).reverse();
    }
    switch (gradient) {
      case "linear":
        return new LinearGradient(colorSpace, stops, rotation);
      case "radial":
        return new RadialGradient(colorSpace, stops);
      case "conic":
        return new ConicGradient(colorSpace, stops, rotation);
    }
  }
  getPattern(fill) {
    if (isPatternFill(fill))
      return this.createPattern(fill);
  }
  createPattern(fill) {
    return new Pattern(fill);
  }
  getImage(fill) {
    if (isImageFill(fill))
      return this.createImage(fill);
  }
  createImage(fill) {
    return new Image2(this.imageLoader, fill);
  }
  onFillChange() {
    if (typeof this.fill === "object") {
      if (objectsEqual(this._cachedFill ?? {}, this.fill)) {
        return;
      }
    }
    this.fillGradient = this.getGradient(this.fill);
    this.fillPattern = this.getPattern(this.fill);
    this.fillImage = this.getImage(this.fill);
    this._cachedFill = this.fill;
  }
  onStrokeChange() {
    this.strokeGradient = this.getGradient(this.stroke);
  }
  /**
   * Returns a device-pixel aligned coordinate (or length if length is supplied).
   *
   * NOTE: Not suitable for strokes, since the stroke needs to be offset to the middle
   * of a device pixel.
   */
  align(start2, length) {
    return align(this.layerManager?.canvas?.pixelRatio ?? 1, start2, length);
  }
  preRender(renderCtx, thisComplexity) {
    if (this.dirty) {
      this.cachedDefaultGradientFillBBox = void 0;
    }
    return super.preRender(renderCtx, thisComplexity);
  }
  fillStroke(ctx, path) {
    this.renderFill(ctx, path);
    this.renderStroke(ctx, path);
  }
  renderFill(ctx, path) {
    const { fill, fillImage } = this;
    if (fill && fill !== "none") {
      const { globalAlpha } = ctx;
      if (fillImage) {
        ctx.globalAlpha = fillImage.backgroundFillOpacity;
        ctx.fillStyle = fillImage.backgroundFill;
        this.executeFill(ctx, path);
        ctx.globalAlpha = globalAlpha;
      }
      this.applyFillAndAlpha(ctx);
      this.applyShadow(ctx);
      this.executeFill(ctx, path);
      ctx.globalAlpha = globalAlpha;
    }
    ctx.shadowColor = "rgba(0, 0, 0, 0)";
  }
  executeFill(ctx, path) {
    if (path) {
      ctx.fill(path);
    } else {
      ctx.fill();
    }
  }
  applyFillAndAlpha(ctx) {
    const { fill, fillGradient, fillPattern, fillImage, fillOpacity, opacity } = this;
    ctx.globalAlpha *= opacity * fillOpacity;
    if (fillGradient) {
      const { fillBBox = this.getDefaultGradientFillBBox() ?? this.getBBox(), fillParams } = this;
      ctx.fillStyle = fillGradient.createGradient(ctx, fillBBox, fillParams) ?? "black";
    } else if (fillPattern) {
      const { x, y } = this.getBBox();
      const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;
      const pattern = fillPattern.createPattern(ctx, pixelRatio);
      fillPattern.setPatternTransform(pattern, pixelRatio, x, y);
      if (pattern) {
        ctx.fillStyle = pattern;
      } else {
        ctx.fillStyle = fillPattern.fill;
        ctx.globalAlpha *= fillPattern.fillOpacity;
      }
    } else if (fillImage) {
      const bbox = this.getBBox();
      const image = fillImage.createPattern(ctx, bbox.width, bbox.height, this);
      fillImage.setImageTransform(image, bbox);
      ctx.fillStyle = image ?? "transparent";
    } else {
      ctx.fillStyle = typeof fill === "string" ? fill : "black";
    }
  }
  applyStrokeAndAlpha(ctx) {
    const { stroke: stroke2, strokeOpacity, strokeGradient, opacity } = this;
    ctx.strokeStyle = strokeGradient?.createGradient(ctx, this.getBBox()) ?? (typeof stroke2 === "string" ? stroke2 : void 0) ?? "black";
    ctx.globalAlpha *= opacity * strokeOpacity;
  }
  applyShadow(ctx) {
    const pixelRatio = this.layerManager?.canvas.pixelRatio ?? 1;
    const fillShadow = this.fillShadow;
    if (fillShadow?.enabled) {
      ctx.shadowColor = fillShadow.color;
      ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;
      ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;
      ctx.shadowBlur = fillShadow.blur * pixelRatio;
    }
  }
  renderStroke(ctx, path) {
    const { stroke: stroke2, strokeWidth, lineDash, lineDashOffset, lineCap, lineJoin, miterLimit } = this;
    if (stroke2 && strokeWidth) {
      const { globalAlpha } = ctx;
      this.applyStrokeAndAlpha(ctx);
      ctx.lineWidth = strokeWidth;
      if (lineDash) {
        ctx.setLineDash(lineDash);
      }
      if (lineDashOffset) {
        ctx.lineDashOffset = lineDashOffset;
      }
      if (lineCap) {
        ctx.lineCap = lineCap;
      }
      if (lineJoin) {
        ctx.lineJoin = lineJoin;
      }
      if (miterLimit != null) {
        ctx.miterLimit = miterLimit;
      }
      this.executeStroke(ctx, path);
      ctx.globalAlpha = globalAlpha;
    }
  }
  executeStroke(ctx, path) {
    if (path) {
      ctx.stroke(path);
    } else {
      ctx.stroke();
    }
  }
  getDefaultGradientFillBBox() {
    if (this.cachedDefaultGradientFillBBox == null) {
      this.cachedDefaultGradientFillBBox = Object.freeze(this.computeDefaultGradientFillBBox());
    }
    return this.cachedDefaultGradientFillBBox;
  }
  computeDefaultGradientFillBBox() {
    return;
  }
  containsPoint(x, y) {
    return this.isPointInPath(x, y);
  }
  applySvgFillAttributes(element2, defs) {
    const { fill, fillOpacity } = this;
    if (typeof fill === "string") {
      element2.setAttribute("fill", fill);
    } else if (isGradientFill(fill) && this.fillGradient) {
      defs ?? (defs = []);
      const gradient = this.fillGradient.toSvg(this.fillBBox ?? this.getBBox());
      const id = (0, import_ag_charts_core32.generateUUID)();
      gradient.setAttribute("id", id);
      defs.push(gradient);
      element2.setAttribute("fill", `url(#${id})`);
    } else if (isPatternFill(fill) && this.fillPattern) {
      defs ?? (defs = []);
      const pattern = this.fillPattern.toSvg();
      const id = (0, import_ag_charts_core32.generateUUID)();
      pattern.setAttribute("id", id);
      defs.push(pattern);
      element2.setAttribute("fill", `url(#${id})`);
    } else if (isImageFill(fill) && this.fillImage) {
      defs ?? (defs = []);
      const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;
      const pattern = this.fillImage.toSvg(this.getBBox(), pixelRatio);
      const id = (0, import_ag_charts_core32.generateUUID)();
      pattern.setAttribute("id", id);
      defs.push(pattern);
      element2.setAttribute("fill", `url(#${id})`);
    } else {
      element2.setAttribute("fill", "none");
    }
    element2.setAttribute("fill-opacity", String(fillOpacity));
    return defs;
  }
  applySvgStrokeAttributes(element2) {
    const { stroke: stroke2, strokeOpacity, strokeWidth, lineDash, lineDashOffset } = this;
    if (stroke2 != null) {
      element2.setAttribute("stroke", typeof stroke2 === "string" ? stroke2 : "none");
      element2.setAttribute("stroke-opacity", String(strokeOpacity));
      element2.setAttribute("stroke-width", String(strokeWidth));
    }
    if (lineDash?.some((d) => d !== 0) === true) {
      const svgLineDash = lineDash.length % 2 === 1 ? [...lineDash, ...lineDash] : lineDash;
      element2.setAttribute("stroke-dasharray", svgLineDash.join(" "));
      element2.setAttribute("stroke-dashoffset", String(lineDashOffset));
    }
  }
};
/**
 * Defaults for style properties. Note that properties that affect the position
 * and shape of the node are not considered style properties, for example:
 * `x`, `y`, `width`, `height`, `radius`, `rotation`, etc.
 * Can be used to reset to the original styling after some custom styling
 * has been applied (using the `restoreOwnStyles` method).
 * These static defaults are meant to be inherited by subclasses.
 */
_Shape.defaultStyles = {
  fill: "black",
  stroke: void 0,
  strokeWidth: 0,
  lineDash: void 0,
  lineDashOffset: 0,
  lineCap: void 0,
  lineJoin: void 0,
  opacity: 1,
  fillShadow: void 0
};
__decorateClass([
  SceneChangeDetection()
], _Shape.prototype, "fillOpacity", 2);
__decorateClass([
  SceneChangeDetection()
], _Shape.prototype, "strokeOpacity", 2);
__decorateClass([
  SceneObjectChangeDetection({ equals: objectsEqual, changeCb: (s) => s.onFillChange() })
], _Shape.prototype, "fill", 2);
__decorateClass([
  SceneObjectChangeDetection({ equals: objectsEqual, changeCb: (s) => s.onStrokeChange() })
], _Shape.prototype, "stroke", 2);
__decorateClass([
  SceneChangeDetection()
], _Shape.prototype, "strokeWidth", 2);
__decorateClass([
  SceneArrayChangeDetection()
], _Shape.prototype, "lineDash", 2);
__decorateClass([
  SceneChangeDetection()
], _Shape.prototype, "lineDashOffset", 2);
__decorateClass([
  SceneChangeDetection()
], _Shape.prototype, "lineCap", 2);
__decorateClass([
  SceneChangeDetection()
], _Shape.prototype, "lineJoin", 2);
__decorateClass([
  SceneChangeDetection()
], _Shape.prototype, "miterLimit", 2);
__decorateClass([
  SceneChangeDetection({ convertor: (v) => (0, import_ag_charts_core32.clamp)(0, v, 1) })
], _Shape.prototype, "opacity", 2);
__decorateClass([
  SceneObjectChangeDetection({ equals: TRIPLE_EQ, checkDirtyOnAssignment: true })
], _Shape.prototype, "fillShadow", 2);
__decorateClass([
  SceneObjectChangeDetection({ equals: BBoxValues.equals, changeCb: (s) => s.onFillChange() })
], _Shape.prototype, "fillBBox", 2);
__decorateClass([
  SceneObjectChangeDetection({ equals: objectsEqual, changeCb: (s) => s.onFillChange() })
], _Shape.prototype, "fillParams", 2);
var Shape = _Shape;

// packages/ag-charts-community/src/scene/transformable.ts
var import_ag_charts_core34 = require("ag-charts-core");

// packages/ag-charts-community/src/scene/matrix.ts
var import_ag_charts_core33 = require("ag-charts-core");
var IDENTITY_MATRIX_ELEMENTS = [1, 0, 0, 1, 0, 0];
var Matrix = class _Matrix {
  get e() {
    return [...this.elements];
  }
  constructor(elements = IDENTITY_MATRIX_ELEMENTS) {
    this.elements = [...elements];
  }
  setElements(elements) {
    const e = this.elements;
    e[0] = elements[0];
    e[1] = elements[1];
    e[2] = elements[2];
    e[3] = elements[3];
    e[4] = elements[4];
    e[5] = elements[5];
    return this;
  }
  get identity() {
    const e = this.elements;
    return (0, import_ag_charts_core33.isNumberEqual)(e[0], 1) && (0, import_ag_charts_core33.isNumberEqual)(e[1], 0) && (0, import_ag_charts_core33.isNumberEqual)(e[2], 0) && (0, import_ag_charts_core33.isNumberEqual)(e[3], 1) && (0, import_ag_charts_core33.isNumberEqual)(e[4], 0) && (0, import_ag_charts_core33.isNumberEqual)(e[5], 0);
  }
  /**
   * Performs the AxB matrix multiplication and saves the result
   * to `C`, if given, or to `A` otherwise.
   */
  AxB(A, B, C2) {
    const a = A[0] * B[0] + A[2] * B[1], b = A[1] * B[0] + A[3] * B[1], c = A[0] * B[2] + A[2] * B[3], d = A[1] * B[2] + A[3] * B[3], e = A[0] * B[4] + A[2] * B[5] + A[4], f = A[1] * B[4] + A[3] * B[5] + A[5];
    C2 = C2 ?? A;
    C2[0] = a;
    C2[1] = b;
    C2[2] = c;
    C2[3] = d;
    C2[4] = e;
    C2[5] = f;
  }
  /**
   * The `other` matrix gets post-multiplied to the current matrix.
   * Returns the current matrix.
   * @param other
   */
  multiplySelf(other) {
    this.AxB(this.elements, other.elements);
    return this;
  }
  /**
   * The `other` matrix gets post-multiplied to the current matrix.
   * Returns a new matrix.
   * @param other
   */
  multiply(other) {
    const elements = new Array(6);
    if (other instanceof _Matrix) {
      this.AxB(this.elements, other.elements, elements);
    } else {
      this.AxB(this.elements, [other.a, other.b, other.c, other.d, other.e, other.f], elements);
    }
    return new _Matrix(elements);
  }
  preMultiplySelf(other) {
    this.AxB(other.elements, this.elements, this.elements);
    return this;
  }
  /**
   * Returns the inverse of this matrix as a new matrix.
   */
  inverse() {
    const el = this.elements;
    let a = el[0], b = el[1], c = el[2], d = el[3];
    const e = el[4], f = el[5];
    const rD = 1 / (a * d - b * c);
    a *= rD;
    b *= rD;
    c *= rD;
    d *= rD;
    return new _Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);
  }
  invertSelf() {
    const el = this.elements;
    let a = el[0], b = el[1], c = el[2], d = el[3];
    const e = el[4], f = el[5];
    const rD = 1 / (a * d - b * c);
    a *= rD;
    b *= rD;
    c *= rD;
    d *= rD;
    el[0] = d;
    el[1] = -b;
    el[2] = -c;
    el[3] = a;
    el[4] = c * f - d * e;
    el[5] = b * e - a * f;
    return this;
  }
  transformPoint(x, y) {
    const e = this.elements;
    return {
      x: x * e[0] + y * e[2] + e[4],
      y: x * e[1] + y * e[3] + e[5]
    };
  }
  transformBBox(bbox, target) {
    const el = this.elements;
    const xx = el[0];
    const xy = el[1];
    const yx = el[2];
    const yy = el[3];
    const h_w = bbox.width * 0.5;
    const h_h = bbox.height * 0.5;
    const cx = bbox.x + h_w;
    const cy = bbox.y + h_h;
    const w = Math.abs(h_w * xx) + Math.abs(h_h * yx);
    const h = Math.abs(h_w * xy) + Math.abs(h_h * yy);
    target ?? (target = new BBox(0, 0, 0, 0));
    target.x = cx * xx + cy * yx + el[4] - w;
    target.y = cx * xy + cy * yy + el[5] - h;
    target.width = w + w;
    target.height = h + h;
    return target;
  }
  toContext(ctx) {
    if (this.identity) {
      return;
    }
    const e = this.elements;
    ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);
  }
  static updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, opts) {
    const sx = scalingX;
    const sy = scalingY;
    let scx;
    let scy;
    if (sx === 1 && sy === 1) {
      scx = 0;
      scy = 0;
    } else {
      scx = opts?.scalingCenterX ?? 0;
      scy = opts?.scalingCenterY ?? 0;
    }
    const r = rotation;
    const cos = Math.cos(r);
    const sin = Math.sin(r);
    let rcx;
    let rcy;
    if (r === 0) {
      rcx = 0;
      rcy = 0;
    } else {
      rcx = opts?.rotationCenterX ?? 0;
      rcy = opts?.rotationCenterY ?? 0;
    }
    const tx = translationX;
    const ty = translationY;
    const tx4 = scx * (1 - sx) - rcx;
    const ty4 = scy * (1 - sy) - rcy;
    matrix.setElements([
      cos * sx,
      sin * sx,
      -sin * sy,
      cos * sy,
      cos * tx4 - sin * ty4 + rcx + tx,
      sin * tx4 + cos * ty4 + rcy + ty
    ]);
    return matrix;
  }
};

// packages/ag-charts-community/src/scene/transformable.ts
function isMatrixTransform(node) {
  return isMatrixTransformType(node.constructor);
}
var MATRIX_TRANSFORM_TYPE = Symbol("isMatrixTransform");
function isMatrixTransformType(cstr) {
  return cstr[MATRIX_TRANSFORM_TYPE] === true;
}
function MatrixTransform(Parent) {
  var _a, _b;
  const ParentNode = Parent;
  if (isMatrixTransformType(Parent)) {
    return Parent;
  }
  const TRANSFORM_MATRIX = Symbol("matrix_combined_transform");
  class MatrixTransformInternal extends ParentNode {
    constructor() {
      super(...arguments);
      this[_b] = new Matrix();
      this._dirtyTransform = true;
    }
    markDirtyTransform() {
      this._dirtyTransform = true;
      super.markDirty();
    }
    onChangeDetection(property) {
      super.onChangeDetection(property);
      this.markDirtyTransform();
    }
    updateMatrix(_matrix) {
    }
    computeTransformMatrix() {
      if (!this._dirtyTransform)
        return;
      this[TRANSFORM_MATRIX].setElements(IDENTITY_MATRIX_ELEMENTS);
      this.updateMatrix(this[TRANSFORM_MATRIX]);
      this._dirtyTransform = false;
    }
    toParent(bbox) {
      this.computeTransformMatrix();
      if (this[TRANSFORM_MATRIX].identity)
        return bbox.clone();
      return this[TRANSFORM_MATRIX].transformBBox(bbox);
    }
    toParentPoint(x, y) {
      this.computeTransformMatrix();
      if (this[TRANSFORM_MATRIX].identity)
        return { x, y };
      return this[TRANSFORM_MATRIX].transformPoint(x, y);
    }
    fromParent(bbox) {
      this.computeTransformMatrix();
      if (this[TRANSFORM_MATRIX].identity)
        return bbox.clone();
      return this[TRANSFORM_MATRIX].inverse().transformBBox(bbox);
    }
    fromParentPoint(x, y) {
      this.computeTransformMatrix();
      if (this[TRANSFORM_MATRIX].identity)
        return { x, y };
      return this[TRANSFORM_MATRIX].inverse().transformPoint(x, y);
    }
    computeBBox() {
      const bbox = super.computeBBox();
      if (!bbox)
        return bbox;
      return this.toParent(bbox);
    }
    computeBBoxWithoutTransforms() {
      return super.computeBBox();
    }
    pickNode(x, y) {
      ({ x, y } = this.fromParentPoint(x, y));
      return super.pickNode(x, y);
    }
    pickNodes(x, y, into) {
      ({ x, y } = this.fromParentPoint(x, y));
      return super.pickNodes(x, y, into);
    }
    render(renderCtx) {
      this.computeTransformMatrix();
      const { ctx } = renderCtx;
      const matrix = this[TRANSFORM_MATRIX];
      let performRestore = false;
      if (!matrix.identity) {
        ctx.save();
        performRestore = true;
        matrix.toContext(ctx);
      }
      super.render(renderCtx);
      if (performRestore) {
        ctx.restore();
      }
    }
    toSVG() {
      this.computeTransformMatrix();
      const svg = super.toSVG();
      const matrix = this[TRANSFORM_MATRIX];
      if (matrix.identity || svg == null)
        return svg;
      const g = (0, import_ag_charts_core34.createSvgElement)("g");
      g.append(...svg.elements);
      const [a, b, c, d, e, f] = matrix.e;
      g.setAttribute("transform", `matrix(${a} ${b} ${c} ${d} ${e} ${f})`);
      return {
        elements: [g],
        defs: svg.defs
      };
    }
  }
  _a = MATRIX_TRANSFORM_TYPE, _b = TRANSFORM_MATRIX;
  MatrixTransformInternal[_a] = true;
  return MatrixTransformInternal;
}
function Rotatable(Parent) {
  var _a;
  const ParentNode = Parent;
  const ROTATABLE_MATRIX = Symbol("matrix_rotation");
  class RotatableInternal extends MatrixTransform(ParentNode) {
    constructor() {
      super(...arguments);
      this[_a] = new Matrix();
      this.rotationCenterX = 0;
      this.rotationCenterY = 0;
      this.rotation = 0;
    }
    updateMatrix(matrix) {
      super.updateMatrix(matrix);
      const { rotation, rotationCenterX, rotationCenterY } = this;
      if (rotation === 0)
        return;
      Matrix.updateTransformMatrix(this[ROTATABLE_MATRIX], 1, 1, rotation, 0, 0, {
        rotationCenterX,
        rotationCenterY
      });
      matrix.multiplySelf(this[ROTATABLE_MATRIX]);
    }
  }
  _a = ROTATABLE_MATRIX;
  __decorateClass([
    SceneChangeDetection()
  ], RotatableInternal.prototype, "rotationCenterX", 2);
  __decorateClass([
    SceneChangeDetection()
  ], RotatableInternal.prototype, "rotationCenterY", 2);
  __decorateClass([
    SceneChangeDetection()
  ], RotatableInternal.prototype, "rotation", 2);
  return RotatableInternal;
}
function Scalable(Parent) {
  var _a;
  const ParentNode = Parent;
  const SCALABLE_MATRIX = Symbol("matrix_scale");
  class ScalableInternal extends MatrixTransform(ParentNode) {
    constructor() {
      super(...arguments);
      this[_a] = new Matrix();
      this.scalingX = 1;
      this.scalingY = 1;
      this.scalingCenterX = 0;
      this.scalingCenterY = 0;
    }
    updateMatrix(matrix) {
      super.updateMatrix(matrix);
      const { scalingX, scalingY, scalingCenterX, scalingCenterY } = this;
      if (scalingX === 1 && scalingY === 1)
        return;
      Matrix.updateTransformMatrix(this[SCALABLE_MATRIX], scalingX, scalingY, 0, 0, 0, {
        scalingCenterX,
        scalingCenterY
      });
      matrix.multiplySelf(this[SCALABLE_MATRIX]);
    }
  }
  _a = SCALABLE_MATRIX;
  __decorateClass([
    SceneChangeDetection()
  ], ScalableInternal.prototype, "scalingX", 2);
  __decorateClass([
    SceneChangeDetection()
  ], ScalableInternal.prototype, "scalingY", 2);
  __decorateClass([
    SceneChangeDetection()
  ], ScalableInternal.prototype, "scalingCenterX", 2);
  __decorateClass([
    SceneChangeDetection()
  ], ScalableInternal.prototype, "scalingCenterY", 2);
  return ScalableInternal;
}
function Translatable(Parent) {
  var _a;
  const ParentNode = Parent;
  const TRANSLATABLE_MATRIX = Symbol("matrix_translation");
  class TranslatableInternal extends MatrixTransform(ParentNode) {
    constructor() {
      super(...arguments);
      this[_a] = new Matrix();
      this.translationX = 0;
      this.translationY = 0;
    }
    updateMatrix(matrix) {
      super.updateMatrix(matrix);
      const { translationX, translationY } = this;
      if (translationX === 0 && translationY === 0)
        return;
      Matrix.updateTransformMatrix(this[TRANSLATABLE_MATRIX], 1, 1, 0, translationX, translationY);
      matrix.multiplySelf(this[TRANSLATABLE_MATRIX]);
    }
  }
  _a = TRANSLATABLE_MATRIX;
  __decorateClass([
    SceneChangeDetection()
  ], TranslatableInternal.prototype, "translationX", 2);
  __decorateClass([
    SceneChangeDetection()
  ], TranslatableInternal.prototype, "translationY", 2);
  return TranslatableInternal;
}
var Transformable = class {
  /**
   * Converts a BBox from canvas coordinate space into the coordinate space of the given Node.
   */
  static fromCanvas(node, bbox) {
    const parents = [];
    for (const parent of node.traverseUp()) {
      if (isMatrixTransform(parent)) {
        parents.unshift(parent);
      }
    }
    for (const parent of parents) {
      bbox = parent.fromParent(bbox);
    }
    if (isMatrixTransform(node)) {
      bbox = node.fromParent(bbox);
    }
    return bbox;
  }
  /**
   * Converts a Nodes BBox (or an arbitrary BBox if supplied) from local Node coordinate space
   * into the Canvas coordinate space.
   */
  static toCanvas(node, bbox) {
    if (bbox == null) {
      bbox = node.getBBox();
    } else if (isMatrixTransform(node)) {
      bbox = node.toParent(bbox);
    }
    for (const parent of node.traverseUp()) {
      if (isMatrixTransform(parent)) {
        bbox = parent.toParent(bbox);
      }
    }
    return bbox;
  }
  /**
   * Converts a point from canvas coordinate space into the coordinate space of the given Node.
   */
  static fromCanvasPoint(node, x, y) {
    const parents = [];
    for (const parent of node.traverseUp()) {
      if (isMatrixTransform(parent)) {
        parents.unshift(parent);
      }
    }
    for (const parent of parents) {
      ({ x, y } = parent.fromParentPoint(x, y));
    }
    if (isMatrixTransform(node)) {
      ({ x, y } = node.fromParentPoint(x, y));
    }
    return { x, y };
  }
  /**
   * Converts a point from a Nodes local coordinate space into the Canvas coordinate space.
   */
  static toCanvasPoint(node, x, y) {
    if (isMatrixTransform(node)) {
      ({ x, y } = node.toParentPoint(x, y));
    }
    for (const parent of node.traverseUp()) {
      if (isMatrixTransform(parent)) {
        ({ x, y } = parent.toParentPoint(x, y));
      }
    }
    return { x, y };
  }
};

// packages/ag-charts-community/src/scene/zIndex.ts
var cmp = (a, b) => Math.sign(a - b);
function compareZIndex(a, b) {
  if (typeof a === "number" && typeof b === "number") {
    return cmp(a, b);
  }
  const aArray = typeof a === "number" ? [a] : a;
  const bArray = typeof b === "number" ? [b] : b;
  const length = Math.min(aArray.length, bArray.length);
  for (let i = 0; i < length; i += 1) {
    const diff2 = cmp(aArray[i], bArray[i]);
    if (diff2 !== 0)
      return diff2;
  }
  return cmp(aArray.length, bArray.length);
}

// packages/ag-charts-community/src/scene/group.ts
var sharedOffscreenCanvas;
var _Group = class _Group extends Node2 {
  // optimizeForInfrequentRedraws: true
  constructor(opts) {
    super(opts);
    this.opacity = 1;
    this.renderToOffscreenCanvas = false;
    this.optimizeForInfrequentRedraws = false;
    // Used when renderToOffscreenCanvas: true
    this.layer = void 0;
    // optimizeForInfrequentRedraws: false
    this.image = void 0;
    this._lastWidth = NaN;
    this._lastHeight = NaN;
    this._lastDevicePixelRatio = NaN;
    this.isContainerNode = true;
    this.renderToOffscreenCanvas = opts?.renderToOffscreenCanvas === true;
  }
  static is(value) {
    return value instanceof _Group;
  }
  static computeChildrenBBox(nodes, skipInvisible = true) {
    return BBox.merge(Node2.extractBBoxes(nodes, skipInvisible));
  }
  static compareChildren(a, b) {
    return compareZIndex(a.zIndex, b.zIndex) || a.serialNumber - b.serialNumber;
  }
  // We consider a group to be boundless, thus any point belongs to it.
  containsPoint(_x, _y) {
    return true;
  }
  computeBBox() {
    return _Group.computeChildrenBBox(this.children());
  }
  computeSafeClippingBBox(pixelRatio) {
    const bbox = this.computeBBox();
    if (!bbox.isFinite())
      return;
    let strokeWidth = 0;
    const strokeMiterAmount = 4;
    for (const child of this.descendants()) {
      if (child instanceof Shape) {
        strokeWidth = Math.max(strokeWidth, child.strokeWidth);
      }
    }
    const padding = Math.max(
      // Account for anti-aliasing artefacts
      1,
      // Account for strokes (incl. miters) - this may not be the best place to include this
      strokeWidth / 2 * strokeMiterAmount
    );
    const { x: originX, y: originY } = Transformable.toCanvasPoint(this, 0, 0);
    const x = alignBefore(pixelRatio, originX + bbox.x - padding) - originX;
    const y = alignBefore(pixelRatio, originY + bbox.y - padding) - originY;
    const width2 = Math.ceil(bbox.x + bbox.width - x + padding);
    const height2 = Math.ceil(bbox.y + bbox.height - y + padding);
    return new BBox(x, y, width2, height2);
  }
  prepareSharedCanvas(width2, height2, pixelRatio) {
    if (sharedOffscreenCanvas == null || sharedOffscreenCanvas.pixelRatio !== pixelRatio) {
      sharedOffscreenCanvas = new HdpiOffscreenCanvas({ width: width2, height: height2, pixelRatio });
    } else {
      sharedOffscreenCanvas.resize(width2, height2, pixelRatio);
    }
    return sharedOffscreenCanvas;
  }
  isDirty(renderCtx) {
    const { width: width2, height: height2, devicePixelRatio } = renderCtx;
    const { dirty, dirtyZIndex, layer } = this;
    const layerResized = layer != null && (this._lastWidth !== width2 || this._lastHeight !== height2);
    const pixelRatioChanged = this._lastDevicePixelRatio !== devicePixelRatio;
    this._lastWidth = width2;
    this._lastHeight = height2;
    this._lastDevicePixelRatio = devicePixelRatio;
    if (dirty || dirtyZIndex || layerResized || pixelRatioChanged)
      return true;
    for (const child of this.children()) {
      if (child.dirty)
        return true;
    }
    return false;
  }
  preRender(renderCtx) {
    const counts = super.preRender(renderCtx, 0);
    counts.groups += 1;
    counts.nonGroups -= 1;
    if (this.renderToOffscreenCanvas && !this.optimizeForInfrequentRedraws && counts.nonGroups > 0 && this.getVisibility()) {
      this.layer ?? (this.layer = this.layerManager?.addLayer({ name: this.name }));
    } else if (this.layer != null) {
      this.layerManager?.removeLayer(this.layer);
      this.layer = void 0;
    }
    return counts;
  }
  render(renderCtx) {
    const { layer, renderToOffscreenCanvas } = this;
    const childRenderCtx = { ...renderCtx };
    if (!renderToOffscreenCanvas) {
      this.renderInContext(childRenderCtx);
      super.render(childRenderCtx);
      return;
    }
    const { ctx, stats, devicePixelRatio: pixelRatio } = renderCtx;
    let { image } = this;
    if (this.isDirty(renderCtx)) {
      image?.bitmap.close();
      image = void 0;
      const bbox = layer ? void 0 : this.computeSafeClippingBBox(pixelRatio);
      const renderOffscreen = (offscreenCanvas, ...transform) => {
        const offscreenCtx = offscreenCanvas.context;
        childRenderCtx.ctx = offscreenCtx;
        offscreenCanvas.clear();
        offscreenCtx.save();
        offscreenCtx.setTransform(...transform);
        offscreenCtx.globalAlpha = 1;
        this.renderInContext(childRenderCtx);
        offscreenCtx.restore();
        offscreenCtx.verifyDepthZero?.();
      };
      if (layer) {
        renderOffscreen(layer, ctx.getTransform());
      } else if (bbox) {
        const { x, y, width: width2, height: height2 } = bbox;
        const canvas = this.prepareSharedCanvas(width2, height2, pixelRatio);
        renderOffscreen(canvas, pixelRatio, 0, 0, pixelRatio, -x * pixelRatio, -y * pixelRatio);
        image = { bitmap: canvas.transferToImageBitmap(), x, y, width: width2, height: height2 };
      } else if (this.dirtyZIndex) {
        this.sortChildren(_Group.compareChildren);
      }
      this.image = image;
      if (stats)
        stats.layersRendered++;
    } else {
      this.skipRender(childRenderCtx);
      if (stats)
        stats.layersSkipped++;
    }
    const { globalAlpha } = ctx;
    ctx.globalAlpha = globalAlpha * this.opacity;
    if (layer) {
      ctx.save();
      ctx.resetTransform();
      layer.drawImage(ctx);
      ctx.restore();
    } else if (image) {
      const { bitmap, x, y, width: width2, height: height2 } = image;
      ctx.drawImage(bitmap, 0, 0, width2 * pixelRatio, height2 * pixelRatio, x, y, width2, height2);
    }
    ctx.globalAlpha = globalAlpha;
    super.render(childRenderCtx);
  }
  skipRender(childRenderCtx) {
    const { stats } = childRenderCtx;
    for (const child of this.children()) {
      child.markClean();
      if (stats) {
        stats.nodesSkipped += this.childNodeCounts.groups + this.childNodeCounts.nonGroups;
        stats.opsSkipped += this.childNodeCounts.complexity;
      }
    }
  }
  applyClip(ctx, clipRect) {
    const { x, y, width: width2, height: height2 } = clipRect;
    ctx.beginPath();
    ctx.rect(x, y, width2, height2);
    ctx.clip();
  }
  renderInContext(childRenderCtx) {
    const { ctx, stats } = childRenderCtx;
    if (this.dirtyZIndex) {
      this.sortChildren(_Group.compareChildren);
    }
    ctx.save();
    ctx.globalAlpha *= this.opacity;
    if (this.clipRect != null) {
      this.applyClip(ctx, this.clipRect);
      childRenderCtx.clipBBox = Transformable.toCanvas(this, this.clipRect);
    }
    for (const child of this.children()) {
      if (!child.visible) {
        child.markClean();
        if (stats) {
          stats.nodesSkipped += child.childNodeCounts.nonGroups + child.childNodeCounts.groups;
          stats.opsSkipped += child.childNodeCounts.complexity;
        }
        continue;
      }
      ctx.save();
      child.render(childRenderCtx);
      ctx.restore();
    }
    ctx.restore();
  }
  /**
   * Transforms bbox given in the canvas coordinate space to bbox in this group's coordinate space and
   * sets this group's clipRect to the transformed bbox.
   * @param bbox clipRect bbox in the canvas coordinate space.
   */
  setClipRect(bbox) {
    this.clipRect = bbox ? Transformable.fromCanvas(this, bbox) : void 0;
  }
  /**
   * Set the clip rect within the canvas coordinate space.
   * @param bbox clipRect bbox in the canvas coordinate space.
   */
  setClipRectCanvasSpace(bbox) {
    this.clipRect = bbox;
  }
  setScene(scene) {
    if (this.layer) {
      this.scene?.layersManager.removeLayer(this.layer);
      this.layer = void 0;
    }
    super.setScene(scene);
  }
  getVisibility() {
    for (const node of this.traverseUp(true)) {
      if (!node.visible) {
        return false;
      }
    }
    return true;
  }
  toSVG() {
    if (!this.visible)
      return;
    const defs = [];
    const elements = [];
    for (const child of this.children()) {
      const svg = child.toSVG();
      if (svg != null) {
        elements.push(...svg.elements);
        if (svg.defs != null) {
          defs.push(...svg.defs);
        }
      }
    }
    return { elements, defs };
  }
};
_Group.className = "Group";
__decorateClass([
  SceneChangeDetection({ convertor: (v) => (0, import_ag_charts_core35.clamp)(0, v, 1) })
], _Group.prototype, "opacity", 2);
var Group = _Group;
var ScalableGroup = class extends Scalable(Group) {
};
var RotatableGroup = class extends Rotatable(Group) {
};
var TranslatableGroup = class extends Translatable(Group) {
};
var TransformableGroup = class extends Rotatable(Translatable(Group)) {
};

// packages/ag-charts-community/src/scene/selection.ts
var Selection = class _Selection {
  constructor(parentNode, classOrFactory, autoCleanup = true) {
    this.parentNode = parentNode;
    this.autoCleanup = autoCleanup;
    this.garbageBin = /* @__PURE__ */ new Set();
    this._nodesMap = /* @__PURE__ */ new Map();
    this._nodes = [];
    this.data = [];
    this.debug = Debug.create(true, "scene", "scene:selections");
    this.nodeFactory = Object.prototype.isPrototypeOf.call(Node2, classOrFactory) ? () => new classOrFactory() : classOrFactory;
  }
  static select(parent, classOrFactory, garbageCollection = true) {
    return new _Selection(parent, classOrFactory, garbageCollection);
  }
  static selectAll(parent, predicate) {
    const results = [];
    const traverse = (node) => {
      if (predicate(node)) {
        results.push(node);
      }
      for (const child of node.children()) {
        traverse(child);
      }
    };
    traverse(parent);
    return results;
  }
  static selectByClass(node, ...Classes) {
    return _Selection.selectAll(node, (n) => Classes.some((C2) => n instanceof C2));
  }
  static selectByTag(node, tag) {
    return _Selection.selectAll(node, (n) => n.tag === tag);
  }
  createNode(datum, initializer, idx) {
    const node = this.nodeFactory(datum);
    node.datum = datum;
    initializer?.(node);
    if (idx == null) {
      this._nodes.push(node);
    } else {
      this._nodes.splice(idx, 0, node);
    }
    this.parentNode.appendChild(node);
    return node;
  }
  /**
   * Update the data in a selection. If an `getDatumId()` function is provided, maintain a list of ids related to
   * the nodes. Otherwise, take the more efficient route of simply creating and destroying nodes at the end
   * of the array.
   */
  update(data, initializer, getDatumId) {
    if (this.garbageBin.size > 0) {
      this.debug(`Selection - update() called with pending garbage`, data);
    }
    if (getDatumId) {
      const dataMap = new Map(
        data.map((datum, idx) => [getDatumId(datum), [datum, idx]])
      );
      for (const [node, datumId] of this._nodesMap.entries()) {
        if (dataMap.has(datumId)) {
          const [newDatum] = dataMap.get(datumId);
          node.datum = newDatum;
          this.garbageBin.delete(node);
          dataMap.delete(datumId);
        } else {
          this.garbageBin.add(node);
        }
      }
      for (const [datumId, [datum, idx]] of dataMap.entries()) {
        this._nodesMap.set(this.createNode(datum, initializer, idx), datumId);
      }
    } else {
      const maxLength = Math.max(data.length, this.data.length);
      for (let i = 0; i < maxLength; i++) {
        if (i >= data.length) {
          this.garbageBin.add(this._nodes[i]);
        } else if (i >= this._nodes.length) {
          this.createNode(data[i], initializer);
        } else {
          this._nodes[i].datum = data[i];
          this.garbageBin.delete(this._nodes[i]);
        }
      }
    }
    this.data = data.slice();
    if (this.autoCleanup) {
      this.cleanup();
    }
    return this;
  }
  cleanup() {
    if (this.garbageBin.size === 0) {
      return this;
    }
    this._nodes = this._nodes.filter((node) => {
      if (this.garbageBin.has(node)) {
        this._nodesMap.delete(node);
        this.garbageBin.delete(node);
        node.destroy();
        return false;
      }
      return true;
    });
    return this;
  }
  clear() {
    this.update([]);
    return this;
  }
  isGarbage(node) {
    return this.garbageBin.has(node);
  }
  each(iterate3) {
    for (const entry of this._nodes.entries()) {
      iterate3(entry[1], entry[1].datum, entry[0]);
    }
    return this;
  }
  *[Symbol.iterator]() {
    for (let index = 0; index < this._nodes.length; index++) {
      const node = this._nodes[index];
      yield { node, datum: node.datum, index };
    }
  }
  select(predicate) {
    return _Selection.selectAll(this.parentNode, predicate);
  }
  selectByClass(Class) {
    return _Selection.selectByClass(this.parentNode, Class);
  }
  selectByTag(tag) {
    return _Selection.selectByTag(this.parentNode, tag);
  }
  nodes() {
    return this._nodes;
  }
  at(index) {
    return this._nodes.at(index);
  }
  get length() {
    return this._nodes.length;
  }
};

// packages/ag-charts-community/src/scene/shape/line.ts
var import_ag_charts_core36 = require("ag-charts-core");
var Line = class extends Shape {
  constructor(opts = {}) {
    super(opts);
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.restoreOwnStyles();
  }
  set x(value) {
    this.x1 = value;
    this.x2 = value;
  }
  set y(value) {
    this.y1 = value;
    this.y2 = value;
  }
  get midPoint() {
    return { x: (this.x1 + this.x2) / 2, y: (this.y1 + this.y2) / 2 };
  }
  computeBBox() {
    return new BBox(
      Math.min(this.x1, this.x2),
      Math.min(this.y1, this.y2),
      Math.abs(this.x2 - this.x1),
      Math.abs(this.y2 - this.y1)
    );
  }
  isPointInPath(x, y) {
    if (this.x1 === this.x2 || this.y1 === this.y2) {
      return this.getBBox().clone().grow(this.strokeWidth / 2).containsPoint(x, y);
    }
    return false;
  }
  distanceSquared(px, py) {
    const { x1, y1, x2, y2 } = this;
    return lineDistanceSquared(px, py, x1, y1, x2, y2, Infinity);
  }
  render(renderCtx) {
    const { ctx, devicePixelRatio } = renderCtx;
    let { x1, y1, x2, y2 } = this;
    if (x1 === x2) {
      const { strokeWidth } = this;
      const x = Math.round(x1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);
      x1 = x;
      x2 = x;
    } else if (y1 === y2) {
      const { strokeWidth } = this;
      const y = Math.round(y1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);
      y1 = y;
      y2 = y;
    }
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    this.fillStroke(ctx);
    this.fillShadow?.markClean();
    super.render(renderCtx);
  }
  toSVG() {
    if (!this.visible)
      return;
    const element2 = (0, import_ag_charts_core36.createSvgElement)("line");
    element2.setAttribute("x1", String(this.x1));
    element2.setAttribute("y1", String(this.y1));
    element2.setAttribute("x2", String(this.x2));
    element2.setAttribute("y2", String(this.y2));
    this.applySvgStrokeAttributes(element2);
    return {
      elements: [element2]
    };
  }
};
Line.className = "Line";
Line.defaultStyles = { ...Shape.defaultStyles, fill: void 0, strokeWidth: 1 };
__decorateClass([
  SceneChangeDetection()
], Line.prototype, "x1", 2);
__decorateClass([
  SceneChangeDetection()
], Line.prototype, "y1", 2);
__decorateClass([
  SceneChangeDetection()
], Line.prototype, "x2", 2);
__decorateClass([
  SceneChangeDetection()
], Line.prototype, "y2", 2);

// packages/ag-charts-community/src/scene/shape/text.ts
var import_ag_charts_core37 = require("ag-charts-core");

// packages/ag-charts-community/src/util/canvas.util.ts
function createCanvasContext(width2 = 0, height2 = 0) {
  return new OffscreenCanvas(width2, height2).getContext("2d");
}

// packages/ag-charts-community/src/util/lruCache.ts
var LRUCache = class {
  constructor(maxCacheSize = 5) {
    this.maxCacheSize = maxCacheSize;
    this.store = /* @__PURE__ */ new Map();
  }
  get(key) {
    if (!this.store.has(key))
      return void 0;
    const hit = this.store.get(key);
    this.store.delete(key);
    this.store.set(key, hit);
    return hit;
  }
  has(key) {
    return this.store.has(key);
  }
  set(key, value) {
    this.store.set(key, value);
    if (this.store.size > this.maxCacheSize) {
      const iterator = this.store.keys();
      let evictCount = this.store.size - this.maxCacheSize;
      while (evictCount > 0) {
        const evictKeyIterator = iterator.next();
        if (!evictKeyIterator.done) {
          this.store.delete(evictKeyIterator.value);
        }
        evictCount--;
      }
    }
    return value;
  }
  clear() {
    this.store.clear();
  }
};

// packages/ag-charts-community/src/util/textMeasurer.ts
var CachedTextMeasurerPool = class {
  // Measures the dimensions of the provided text, handling multiline if needed.
  static measureText(text, options) {
    const textMeasurer = this.getMeasurer(options);
    return textMeasurer.measureText(text);
  }
  static measureLines(text, options) {
    const textMeasurer = this.getMeasurer(options);
    return textMeasurer.measureLines(text);
  }
  // Gets a TextMeasurer instance, configuring text alignment and baseline if provided.
  static getMeasurer(options) {
    const font2 = typeof options.font === "string" ? options.font : TextUtils.toFontString(options.font);
    const key = `${font2}-${options.textAlign ?? "start"}-${options.textBaseline ?? "alphabetic"}`;
    return this.instanceMap.get(key) ?? this.createFontMeasurer(font2, options, key);
  }
  static clear() {
    this.instanceMap.clear();
  }
  // Creates or retrieves a TextMeasurer instance for a specific font.
  static createFontMeasurer(font2, options, key) {
    const ctx = createCanvasContext();
    ctx.font = font2;
    ctx.textAlign = options.textAlign ?? "start";
    ctx.textBaseline = options.textBaseline ?? "alphabetic";
    const measurer2 = new CachedTextMeasurer(ctx, options);
    this.instanceMap.set(key, measurer2);
    return measurer2;
  }
};
CachedTextMeasurerPool.instanceMap = new LRUCache(10);
var CachedTextMeasurer = class {
  constructor(ctx, options) {
    this.ctx = ctx;
    // cached text measurements
    this.measureMap = new LRUCache(100);
    if (options.textAlign) {
      ctx.textAlign = options.textAlign;
    }
    if (options.textBaseline) {
      ctx.textBaseline = options.textBaseline;
    }
    ctx.font = typeof options.font === "string" ? options.font : TextUtils.toFontString(options.font);
    this.textMeasurer = new SimpleTextMeasurer(
      (t) => this.cachedCtxMeasureText(t),
      options.textBaseline ?? "alphabetic"
    );
  }
  textWidth(text, estimate) {
    return this.textMeasurer.textWidth(text, estimate);
  }
  measureText(text) {
    return this.textMeasurer.measureText(text);
  }
  measureLines(text) {
    return this.textMeasurer.measureLines(text);
  }
  cachedCtxMeasureText(text) {
    if (!this.measureMap.has(text)) {
      const rawResult = this.ctx.measureText(text);
      this.measureMap.set(text, {
        actualBoundingBoxAscent: rawResult.actualBoundingBoxAscent,
        emHeightAscent: rawResult.emHeightAscent,
        emHeightDescent: rawResult.emHeightDescent,
        actualBoundingBoxDescent: rawResult.actualBoundingBoxDescent,
        actualBoundingBoxLeft: rawResult.actualBoundingBoxLeft,
        actualBoundingBoxRight: rawResult.actualBoundingBoxRight,
        alphabeticBaseline: rawResult.alphabeticBaseline,
        fontBoundingBoxAscent: rawResult.fontBoundingBoxAscent,
        fontBoundingBoxDescent: rawResult.fontBoundingBoxDescent,
        hangingBaseline: rawResult.hangingBaseline,
        ideographicBaseline: rawResult.ideographicBaseline,
        width: rawResult.width
      });
    }
    return this.measureMap.get(text);
  }
};
var TextUtils = class {
  static toFontString({ fontSize = 10, fontStyle, fontWeight, fontFamily, lineHeight }) {
    let fontString = "";
    if (fontStyle) {
      fontString += `${fontStyle} `;
    }
    if (fontWeight) {
      fontString += `${fontWeight} `;
    }
    fontString += `${fontSize}px`;
    if (lineHeight) {
      fontString += `/${lineHeight}px`;
    }
    fontString += ` ${fontFamily}`;
    return fontString.trim();
  }
  static getLineHeight(fontSize) {
    return Math.ceil(fontSize * this.defaultLineHeight);
  }
  // Determines vertical offset modifier based on text baseline.
  static getVerticalModifier(textBaseline) {
    switch (textBaseline) {
      case "hanging":
      case "top":
        return 0;
      case "middle":
        return 0.5;
      case "alphabetic":
      case "bottom":
      case "ideographic":
      default:
        return 1;
    }
  }
};
TextUtils.EllipsisChar = "\u2026";
// Representation for text clipping.
TextUtils.defaultLineHeight = 1.15;
// Normally between 1.1 and 1.2
TextUtils.lineSplitter = /\r?\n/g;
var SimpleTextMeasurer = class {
  constructor(measureTextFn, textBaseline = "alphabetic") {
    this.measureTextFn = measureTextFn;
    this.textBaseline = textBaseline;
    // local chars width cache per TextMeasurer
    this.charMap = /* @__PURE__ */ new Map();
  }
  // Measures metrics for a single line of text.
  getMetrics(text) {
    const m = this.measureTextFn(text);
    m.fontBoundingBoxAscent ?? (m.fontBoundingBoxAscent = m.emHeightAscent);
    m.fontBoundingBoxDescent ?? (m.fontBoundingBoxDescent = m.emHeightDescent);
    return {
      width: m.width,
      height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,
      lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,
      offsetTop: m.actualBoundingBoxAscent,
      offsetLeft: m.actualBoundingBoxLeft
    };
  }
  // Calculates aggregated metrics for multiline text.
  getMultilineMetrics(lines) {
    let width2 = 0;
    let height2 = 0;
    let offsetTop = 0;
    let offsetLeft = 0;
    let baselineDistance = 0;
    const verticalModifier = TextUtils.getVerticalModifier(this.textBaseline);
    const lineMetrics = [];
    let index = 0;
    const length = lines.length;
    for (const line of lines) {
      const m = this.measureTextFn(line);
      m.fontBoundingBoxAscent ?? (m.fontBoundingBoxAscent = m.emHeightAscent);
      m.fontBoundingBoxDescent ?? (m.fontBoundingBoxDescent = m.emHeightDescent);
      if (width2 < m.width) {
        width2 = m.width;
      }
      if (offsetLeft < m.actualBoundingBoxLeft) {
        offsetLeft = m.actualBoundingBoxLeft;
      }
      if (index === 0) {
        height2 += m.actualBoundingBoxAscent;
        offsetTop += m.actualBoundingBoxAscent;
      } else {
        baselineDistance += m.fontBoundingBoxAscent;
      }
      if (index === length - 1) {
        height2 += m.actualBoundingBoxDescent;
      } else {
        baselineDistance += m.fontBoundingBoxDescent;
      }
      lineMetrics.push({
        text: line,
        width: m.width,
        height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,
        lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,
        offsetTop: m.actualBoundingBoxAscent,
        offsetLeft: m.actualBoundingBoxLeft
      });
      index++;
    }
    height2 += baselineDistance;
    offsetTop += baselineDistance * verticalModifier;
    return { width: width2, height: height2, offsetTop, offsetLeft, lineMetrics };
  }
  textWidth(text, estimate) {
    if (estimate) {
      let estimatedWidth = 0;
      for (let i = 0; i < text.length; i++) {
        estimatedWidth += this.textWidth(text.charAt(i));
      }
      return estimatedWidth;
    }
    if (text.length > 1) {
      return this.measureTextFn(text).width;
    }
    return this.charMap.get(text) ?? this.charWidth(text);
  }
  measureText(text) {
    return this.getMetrics(text);
  }
  // Measures the dimensions of the provided text, handling multiline if needed.
  measureLines(text) {
    const lines = typeof text === "string" ? text.split(TextUtils.lineSplitter) : text;
    return this.getMultilineMetrics(lines);
  }
  charWidth(char) {
    const { width: width2 } = this.measureTextFn(char);
    this.charMap.set(char, width2);
    return width2;
  }
};

// packages/ag-charts-community/src/scene/shape/text.ts
var _Text = class _Text extends Shape {
  constructor() {
    super(...arguments);
    this.x = 0;
    this.y = 0;
    this.lines = [];
    this.text = void 0;
    this.fontSize = 10;
    this.fontFamily = "sans-serif";
    this.textAlign = _Text.defaultStyles.textAlign;
    this.textBaseline = _Text.defaultStyles.textBaseline;
  }
  onTextChange() {
    this.lines = this.text?.split("\n").map((s) => s.trim()) ?? [];
  }
  static computeBBox(lines, x, y, opts) {
    const { offsetTop, offsetLeft, width: width2, height: exactHeight } = CachedTextMeasurerPool.measureLines(lines, opts);
    const height2 = opts.lineHeight ? opts.lineHeight * lines.length : exactHeight;
    return new BBox(x - offsetLeft, y - offsetTop, width2, height2);
  }
  computeBBox() {
    const { x, y, lines, textBaseline, textAlign, lineHeight } = this;
    return _Text.computeBBox(lines, x, y, { font: this, textBaseline, textAlign, lineHeight });
  }
  getTextMeasureBBox() {
    return this.computeBBox();
  }
  isPointInPath(x, y) {
    const bbox = this.getBBox();
    return bbox ? bbox.containsPoint(x, y) : false;
  }
  render(renderCtx) {
    const { ctx, stats } = renderCtx;
    if (!this.lines.length || !this.layerManager) {
      if (stats)
        stats.nodesSkipped += 1;
      return super.render(renderCtx);
    }
    const { fill, stroke: stroke2, strokeWidth } = this;
    const { globalAlpha } = ctx;
    const { pixelRatio } = this.layerManager.canvas;
    if (!fill && !(stroke2 != null && strokeWidth > 0)) {
      return super.render(renderCtx);
    }
    const font2 = TextUtils.toFontString(this);
    if (ctx.font !== font2) {
      ctx.font = font2;
    }
    ctx.textAlign = this.textAlign;
    ctx.textBaseline = this.textBaseline;
    if (fill) {
      this.applyFillAndAlpha(ctx);
      const { fillShadow } = this;
      if (fillShadow?.enabled) {
        ctx.shadowColor = fillShadow.color;
        ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;
        ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;
        ctx.shadowBlur = fillShadow.blur * pixelRatio;
      }
      this.renderLines((line, x, y) => ctx.fillText(line, x, y));
      ctx.globalAlpha = globalAlpha;
    }
    if (stroke2 && strokeWidth) {
      this.applyStrokeAndAlpha(ctx);
      ctx.lineWidth = strokeWidth;
      const { lineDash, lineDashOffset, lineCap, lineJoin } = this;
      if (lineDash) {
        ctx.setLineDash([...lineDash]);
      }
      if (lineDashOffset) {
        ctx.lineDashOffset = lineDashOffset;
      }
      if (lineCap) {
        ctx.lineCap = lineCap;
      }
      if (lineJoin) {
        ctx.lineJoin = lineJoin;
      }
      this.renderLines((line, x, y) => ctx.strokeText(line, x, y));
      ctx.globalAlpha = globalAlpha;
    }
    super.render(renderCtx);
  }
  renderLines(renderCallback) {
    const { lines, x, y } = this;
    const lineHeight = this.lineHeight ?? TextUtils.getLineHeight(this.fontSize);
    let offsetY = (lineHeight - lineHeight * lines.length) * TextUtils.getVerticalModifier(this.textBaseline);
    for (const line of lines) {
      renderCallback(line, x, y + offsetY);
      offsetY += lineHeight;
    }
  }
  setFont(props) {
    this.fontFamily = props.fontFamily;
    this.fontSize = props.fontSize;
    this.fontStyle = props.fontStyle;
    this.fontWeight = props.fontWeight;
  }
  setAlign(props) {
    this.textAlign = props.textAlign;
    this.textBaseline = props.textBaseline;
  }
  toSVG() {
    if (!this.visible || !this.text)
      return;
    const element2 = (0, import_ag_charts_core37.createSvgElement)("text");
    this.applySvgFillAttributes(element2);
    element2.setAttribute("font-family", this.fontFamily?.split(",")[0] ?? "");
    element2.setAttribute("font-size", String(this.fontSize));
    element2.setAttribute("font-style", this.fontStyle ?? "");
    element2.setAttribute("font-weight", String(this.fontWeight ?? ""));
    element2.setAttribute(
      "text-anchor",
      {
        center: "middle",
        left: "start",
        right: "end",
        start: "start",
        end: "end"
      }[this.textAlign ?? "start"]
    );
    element2.setAttribute(
      "alignment-baseline",
      {
        alphabetic: "alphabetic",
        top: "top",
        bottom: "bottom",
        hanging: "hanging",
        middle: "middle",
        ideographic: "ideographic"
      }[this.textBaseline ?? "alphabetic"]
    );
    element2.setAttribute("x", String(this.x));
    element2.setAttribute("y", String(this.y));
    element2.textContent = this.text ?? "";
    return { elements: [element2] };
  }
};
_Text.className = "Text";
_Text.defaultStyles = {
  ...Shape.defaultStyles,
  textAlign: "start",
  fontStyle: void 0,
  fontWeight: void 0,
  fontSize: 10,
  fontFamily: "sans-serif",
  textBaseline: "alphabetic"
};
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "x", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "y", 2);
__decorateClass([
  SceneChangeDetection({
    convertor: (value) => (0, import_ag_charts_core37.isDefined)(value) ? String(value) : value,
    changeCb: (o) => o.onTextChange()
  })
], _Text.prototype, "text", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "fontStyle", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "fontWeight", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "fontSize", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "fontFamily", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "textAlign", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "textBaseline", 2);
__decorateClass([
  SceneChangeDetection()
], _Text.prototype, "lineHeight", 2);
var Text = _Text;
var RotatableText = class extends Rotatable(Text) {
};
var TransformableText = class extends Rotatable(Translatable(Text)) {
};

// packages/ag-charts-community/src/util/stateMachine.ts
var debugColor = "color: green";
var debugQuietColor = "color: grey";
function applyProperties(parentState, childState) {
  const childProperties = listDecoratedProperties(childState);
  if (childProperties.length === 0)
    return;
  const properties = extractDecoratedProperties(parentState);
  for (const property of childProperties) {
    if (property in properties) {
      childState[property] = properties[property];
    }
  }
}
var AbstractStateMachine = class {
  transitionRoot(event, data) {
    if (this.parent) {
      this.parent.transitionRoot(event, data);
    } else {
      this.transition(event, data);
    }
  }
};
var _StateMachine = class _StateMachine extends AbstractStateMachine {
  constructor(defaultState, states, enterEach) {
    super();
    this.defaultState = defaultState;
    this.states = states;
    this.enterEach = enterEach;
    this.debug = Debug.create(true, "animation");
    this.state = defaultState;
    this.debug(`%c${this.constructor.name} | init -> ${defaultState}`, debugColor);
  }
  // TODO: handle events which do not require data without requiring `undefined` to be passed as as parameter, while
  // also still requiring data to be passed to those events which do require it.
  transition(event, data) {
    const shouldTransitionSelf = this.transitionChild(event, data);
    if (!shouldTransitionSelf || this.state === _StateMachine.child || this.state === _StateMachine.parent) {
      return;
    }
    const currentState = this.state;
    const currentStateConfig = this.states[this.state];
    let destination = currentStateConfig[event];
    const debugPrefix = `%c${this.constructor.name} | ${this.state} -> ${event} ->`;
    if (Array.isArray(destination)) {
      destination = destination.find((transition) => {
        if (!transition.guard)
          return true;
        const valid = transition.guard(data);
        if (!valid) {
          this.debug(`${debugPrefix} (guarded)`, transition.target, debugQuietColor);
        }
        return valid;
      });
    } else if (typeof destination === "object" && !(destination instanceof _StateMachine) && destination.guard && !destination.guard(data)) {
      this.debug(`${debugPrefix} (guarded)`, destination.target, debugQuietColor);
      return;
    }
    if (!destination) {
      this.debug(`${debugPrefix} ${this.state}`, debugQuietColor);
      return;
    }
    const destinationState = this.getDestinationState(destination);
    const exitFn = destinationState === this.state ? void 0 : currentStateConfig.onExit;
    this.debug(`${debugPrefix} ${destinationState}`, debugColor);
    this.state = destinationState;
    if (typeof destination === "function") {
      destination(data);
    } else if (typeof destination === "object" && !(destination instanceof _StateMachine)) {
      destination.action?.(data);
    }
    exitFn?.();
    this.enterEach?.(currentState, destinationState);
    if (destinationState !== currentState && destinationState !== _StateMachine.child && destinationState !== _StateMachine.parent) {
      this.states[destinationState].onEnter?.(currentState, data);
    }
  }
  transitionAsync(event, data) {
    setTimeout(() => {
      this.transition(event, data);
    }, 0);
  }
  is(value) {
    if (this.state === _StateMachine.child && this.childState) {
      return this.childState.is(value);
    }
    return this.state === value;
  }
  resetHierarchy() {
    this.debug(
      `%c${this.constructor.name} | ${this.state} -> [resetHierarchy] -> ${this.defaultState}`,
      "color: green"
    );
    this.state = this.defaultState;
  }
  transitionChild(event, data) {
    if (this.state !== _StateMachine.child || !this.childState)
      return true;
    applyProperties(this, this.childState);
    this.childState.transition(event, data);
    if (!this.childState.is(_StateMachine.parent))
      return true;
    this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${this.defaultState}`, debugColor);
    this.state = this.defaultState;
    this.states[this.state].onEnter?.();
    this.childState.resetHierarchy();
    return false;
  }
  getDestinationState(destination) {
    let state = this.state;
    if (typeof destination === "string") {
      state = destination;
    } else if (destination instanceof _StateMachine) {
      this.childState = destination;
      this.childState.parent = this;
      state = _StateMachine.child;
    } else if (typeof destination === "object") {
      if (destination.target instanceof _StateMachine) {
        this.childState = destination.target;
        this.childState.parent = this;
        state = _StateMachine.child;
      } else if (destination.target != null) {
        state = destination.target;
      }
    }
    return state;
  }
};
_StateMachine.child = "__child";
_StateMachine.parent = "__parent";
var StateMachine = _StateMachine;

// packages/ag-charts-community/src/chart/caption.ts
var import_ag_charts_core39 = require("ag-charts-core");

// packages/ag-charts-community/src/util/proxy.ts
var import_ag_charts_core38 = require("ag-charts-core");
function ProxyProperty(proxyPath, configMetadata) {
  const pathArray = (0, import_ag_charts_core38.isArray)(proxyPath) ? proxyPath : proxyPath.split(".");
  if (pathArray.length === 1) {
    const [property] = pathArray;
    return addTransformToInstanceProperty(
      (target, _, value) => target[property] = value,
      (target) => target[property],
      configMetadata
    );
  }
  return addTransformToInstanceProperty(
    (target, _, value) => setPath(target, pathArray, value),
    (target) => getPath(target, pathArray),
    configMetadata
  );
}
function ProxyPropertyOnWrite(childName, childProperty) {
  return addTransformToInstanceProperty((target, key, value) => target[childName][childProperty ?? key] = value);
}
function ActionOnSet(opts) {
  const { newValue: newValueFn, oldValue: oldValueFn, changeValue: changeValueFn } = opts;
  return addTransformToInstanceProperty((target, _, newValue, oldValue) => {
    if (newValue !== oldValue) {
      if (oldValue !== void 0) {
        oldValueFn?.call(target, oldValue);
      }
      if (newValue !== void 0) {
        newValueFn?.call(target, newValue);
      }
      changeValueFn?.call(target, newValue, oldValue);
    }
    return newValue;
  });
}
function ObserveChanges(observerFn) {
  return addObserverToInstanceProperty(observerFn);
}

// packages/ag-charts-community/src/util/textWrapper.ts
var TextWrapper = class {
  static wrapText(text, options) {
    return this.wrapLines(text, options).join("\n");
  }
  static wrapLines(text, options) {
    const clippedResult = this.textWrap(text, options);
    if (options.overflow === "hide" && clippedResult.some((l) => l.endsWith(TextUtils.EllipsisChar))) {
      return [];
    }
    return clippedResult;
  }
  static appendEllipsis(text) {
    return text.replace(/[.,]{1,5}$/, "") + TextUtils.EllipsisChar;
  }
  static truncateLine(text, measurer2, maxWidth, ellipsisForce) {
    const ellipsisWidth = measurer2.textWidth(TextUtils.EllipsisChar);
    let estimatedWidth = 0;
    let i = 0;
    for (; i < text.length; i++) {
      const charWidth = measurer2.textWidth(text.charAt(i));
      if (estimatedWidth + charWidth > maxWidth)
        break;
      estimatedWidth += charWidth;
    }
    if (text.length === i && (!ellipsisForce || estimatedWidth + ellipsisWidth <= maxWidth)) {
      return ellipsisForce ? text + TextUtils.EllipsisChar : text;
    }
    text = text.slice(0, i).trimEnd();
    while (text.length && measurer2.textWidth(text) + ellipsisWidth > maxWidth) {
      text = text.slice(0, -1).trimEnd();
    }
    return text + TextUtils.EllipsisChar;
  }
  static textWrap(text, options) {
    const lines = text.split(TextUtils.lineSplitter);
    const measurer2 = CachedTextMeasurerPool.getMeasurer(options);
    if (options.textWrap === "never") {
      return lines.map((line) => this.truncateLine(line.trimEnd(), measurer2, options.maxWidth));
    }
    const result = [];
    const wrapHyphenate = options.textWrap === "hyphenate";
    const wrapOnSpace = options.textWrap == null || options.textWrap === "on-space";
    for (const untrimmedLine of lines) {
      let line = untrimmedLine.trimEnd();
      if (line === "") {
        result.push(line);
        continue;
      }
      let i = 0;
      let estimatedWidth = 0;
      let lastSpaceIndex = 0;
      while (i < line.length) {
        const char = line.charAt(i);
        estimatedWidth += measurer2.textWidth(char);
        if (char === " ") {
          lastSpaceIndex = i;
        }
        if (estimatedWidth > options.maxWidth) {
          if (i === 0)
            break;
          const actualWidth = measurer2.textWidth(line.slice(0, i + 1));
          if (actualWidth <= options.maxWidth) {
            estimatedWidth = actualWidth;
            i++;
            continue;
          }
          if (lastSpaceIndex) {
            const nextWord = this.getWordAt(line, lastSpaceIndex + 1);
            const textWidth = measurer2.textWidth(nextWord);
            if (textWidth <= options.maxWidth) {
              result.push(line.slice(0, lastSpaceIndex).trimEnd());
              line = line.slice(lastSpaceIndex).trimStart();
              i = 0;
              estimatedWidth = 0;
              lastSpaceIndex = 0;
              continue;
            } else if (wrapOnSpace && textWidth > options.maxWidth) {
              result.push(
                line.slice(0, lastSpaceIndex).trimEnd(),
                this.truncateLine(
                  line.slice(lastSpaceIndex).trimStart(),
                  measurer2,
                  options.maxWidth,
                  true
                )
              );
            }
          } else if (wrapOnSpace) {
            result.push(this.truncateLine(line, measurer2, options.maxWidth, true));
          }
          if (wrapOnSpace) {
            line = "";
            break;
          }
          const postfix = wrapHyphenate ? "-" : "";
          let newLine = line.slice(0, i).trim();
          while (newLine.length && measurer2.textWidth(newLine + postfix) > options.maxWidth) {
            newLine = newLine.slice(0, -1).trimEnd();
          }
          result.push(newLine + postfix);
          if (!newLine.length) {
            line = "";
            break;
          }
          line = line.slice(newLine.length).trimStart();
          i = -1;
          estimatedWidth = 0;
          lastSpaceIndex = 0;
        }
        i++;
      }
      if (line) {
        result.push(line);
      }
    }
    this.avoidOrphans(result, measurer2, options);
    return this.clipLines(result, measurer2, options);
  }
  static getWordAt(text, position) {
    const nextSpaceIndex = text.indexOf(" ", position);
    return nextSpaceIndex === -1 ? text.slice(position) : text.slice(position, nextSpaceIndex);
  }
  static clipLines(lines, measurer2, options) {
    if (!options.maxHeight) {
      return lines;
    }
    const { height: height2, lineMetrics } = measurer2.measureLines(lines);
    if (height2 <= options.maxHeight) {
      return lines;
    }
    for (let i = 0, cumulativeHeight = 0; i < lineMetrics.length; i++) {
      const { lineHeight } = lineMetrics[i];
      cumulativeHeight += lineHeight;
      if (cumulativeHeight > options.maxHeight) {
        if (options.overflow === "hide") {
          return [];
        }
        const clippedResults = lines.slice(0, i || 1);
        const lastLine = clippedResults.pop();
        return clippedResults.concat(this.truncateLine(lastLine, measurer2, options.maxWidth, true));
      }
    }
    return lines;
  }
  static avoidOrphans(lines, measurer2, options) {
    if (options.avoidOrphans === false || lines.length < 2)
      return;
    const { length } = lines;
    const lastLine = lines[length - 1];
    const beforeLast = lines[length - 2];
    if (beforeLast.length < lastLine.length)
      return;
    const lastSpaceIndex = beforeLast.lastIndexOf(" ");
    if (lastSpaceIndex === -1 || lastSpaceIndex === beforeLast.indexOf(" ") || lastLine.includes(" "))
      return;
    const lastWord = beforeLast.slice(lastSpaceIndex + 1);
    if (measurer2.textWidth(lastLine + lastWord) <= options.maxWidth) {
      lines[length - 2] = beforeLast.slice(0, lastSpaceIndex);
      lines[length - 1] = lastWord + " " + lastLine;
    }
  }
};

// packages/ag-charts-community/src/chart/caption.ts
var Caption = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.id = (0, import_ag_charts_core39.createId)(this);
    this.node = new RotatableText({ zIndex: 1 }).setProperties({
      textAlign: "center",
      pointerEvents: 1 /* None */
    });
    this.enabled = false;
    this.textAlign = "center";
    this.fontSize = 10;
    this.fontFamily = "sans-serif";
    this.wrapping = "always";
    this.padding = 0;
    this.layoutStyle = "block";
    this.truncated = false;
  }
  registerInteraction(moduleCtx, where) {
    return moduleCtx.layoutManager.addListener("layout:complete", () => this.updateA11yText(moduleCtx, where));
  }
  computeTextWrap(containerWidth, containerHeight) {
    const { text, padding, wrapping } = this;
    const maxWidth = Math.min(this.maxWidth ?? Infinity, containerWidth) - padding * 2;
    const maxHeight = this.maxHeight ?? containerHeight - padding * 2;
    if (!isFinite(maxWidth) && !isFinite(maxHeight)) {
      this.node.text = text;
      return;
    }
    const wrappedText = TextWrapper.wrapText(text ?? "", { maxWidth, maxHeight, font: this, textWrap: wrapping });
    this.node.text = wrappedText;
    this.truncated = wrappedText.includes(TextUtils.EllipsisChar);
  }
  updateA11yText(moduleCtx, where) {
    const { proxyInteractionService } = moduleCtx;
    if (this.enabled && this.text) {
      const bbox = Transformable.toCanvas(this.node);
      if (bbox) {
        const { id: domManagerId } = this;
        this.proxyText ?? (this.proxyText = proxyInteractionService.createProxyElement({ type: "text", domManagerId, where }));
        this.proxyText.textContent = this.text;
        this.proxyText.setBounds(bbox);
        this.proxyText.addListener("mousemove", (ev) => this.handleMouseMove(moduleCtx, ev));
        this.proxyText.addListener("mouseleave", (ev) => this.handleMouseLeave(moduleCtx, ev));
      }
    } else {
      this.proxyText?.destroy();
      this.proxyText = void 0;
    }
  }
  handleMouseMove(moduleCtx, event) {
    if (event != null && this.enabled && this.node.visible && this.truncated) {
      const { x, y } = Transformable.toCanvas(this.node);
      const canvasX = event.sourceEvent.offsetX + x;
      const canvasY = event.sourceEvent.offsetY + y;
      moduleCtx.tooltipManager.updateTooltip(this.id, { canvasX, canvasY, showArrow: false }, [
        { type: "structured", title: this.text }
      ]);
    }
  }
  handleMouseLeave(moduleCtx, _event) {
    moduleCtx.tooltipManager.removeTooltip(this.id);
  }
};
Caption.SMALL_PADDING = 10;
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node", "visible")
], Caption.prototype, "enabled", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node")
], Caption.prototype, "text", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node")
], Caption.prototype, "textAlign", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node")
], Caption.prototype, "fontStyle", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node")
], Caption.prototype, "fontWeight", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node")
], Caption.prototype, "fontSize", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node")
], Caption.prototype, "fontFamily", 2);
__decorateClass([
  Property,
  ProxyPropertyOnWrite("node", "fill")
], Caption.prototype, "color", 2);
__decorateClass([
  Property
], Caption.prototype, "spacing", 2);
__decorateClass([
  Property
], Caption.prototype, "maxWidth", 2);
__decorateClass([
  Property
], Caption.prototype, "maxHeight", 2);
__decorateClass([
  Property
], Caption.prototype, "wrapping", 2);
__decorateClass([
  Property
], Caption.prototype, "padding", 2);
__decorateClass([
  Property
], Caption.prototype, "layoutStyle", 2);

// packages/ag-charts-community/src/chart/chartAxisDirection.ts
var ChartAxisDirection = /* @__PURE__ */ ((ChartAxisDirection2) => {
  ChartAxisDirection2["X"] = "x";
  ChartAxisDirection2["Y"] = "y";
  ChartAxisDirection2["Angle"] = "angle";
  ChartAxisDirection2["Radius"] = "radius";
  return ChartAxisDirection2;
})(ChartAxisDirection || {});

// packages/ag-charts-community/src/chart/axis/axis.ts
var import_ag_charts_core49 = require("ag-charts-core");

// packages/ag-charts-community/src/module/moduleMap.ts
var import_ag_charts_core40 = require("ag-charts-core");
var ModuleMap = class {
  constructor() {
    this.moduleMap = /* @__PURE__ */ new Map();
  }
  *modules() {
    for (const m of this.moduleMap.values()) {
      yield m.moduleInstance;
    }
  }
  addModule(module2, moduleFactory) {
    if (this.moduleMap.has(module2.optionsKey)) {
      throw new Error(`AG Charts - module already initialised: ${module2.optionsKey}`);
    }
    this.moduleMap.set(module2.optionsKey, { module: module2, moduleInstance: moduleFactory(module2) });
  }
  removeModule(module2) {
    const moduleKey = (0, import_ag_charts_core40.isString)(module2) ? module2 : module2.optionsKey;
    this.moduleMap.get(moduleKey)?.moduleInstance.destroy();
    this.moduleMap.delete(moduleKey);
  }
  getModule(module2) {
    return this.moduleMap.get((0, import_ag_charts_core40.isString)(module2) ? module2 : module2.optionsKey)?.moduleInstance;
  }
  isEnabled(module2) {
    return this.moduleMap.has((0, import_ag_charts_core40.isString)(module2) ? module2 : module2.optionsKey);
  }
  mapModules(callback5) {
    return Array.from(this.moduleMap.values(), (m, i) => callback5(m.moduleInstance, i));
  }
  destroy() {
    for (const moduleKey of this.moduleMap.keys()) {
      this.moduleMap.get(moduleKey)?.moduleInstance.destroy();
    }
    this.moduleMap.clear();
  }
};

// packages/ag-charts-community/src/scale/discreteTimeScale.ts
var import_ag_charts_core41 = require("ag-charts-core");
var DiscreteTimeScale = class _DiscreteTimeScale extends BandScale {
  static is(value) {
    return value instanceof _DiscreteTimeScale;
  }
  toDomain(value) {
    return new Date(value);
  }
  convert(d, options) {
    const { domain, bands } = this;
    if (domain.length <= 0)
      return NaN;
    const r0 = this.ordinalRange(0);
    const r1 = this.ordinalRange(bands.length - 1);
    const interpolate3 = options?.interpolate ?? false;
    const reversed = domain[0].valueOf() > domain[domain.length - 1].valueOf();
    if (!interpolate3) {
      const r = super.convert(d, options);
      return reversed ? r1 - (r - r0) : r;
    }
    if (bands.length === 0)
      return r0;
    const v = d.valueOf();
    let domainIndex;
    if (reversed) {
      domainIndex = ((0, import_ag_charts_core41.findMinIndex)(0, domain.length - 1, (i) => domain[i].valueOf() <= v) ?? domain.length) - 1;
    } else {
      domainIndex = (0, import_ag_charts_core41.findMaxIndex)(0, domain.length - 1, (i) => domain[i].valueOf() <= v) ?? 0;
    }
    domainIndex = Math.min(Math.max(domainIndex, 0), domain.length - 2);
    const v0 = domain[domainIndex].valueOf();
    const v1 = domain[domainIndex + 1].valueOf();
    const ratioWithinInterval = (v - v0) / (v1 - v0);
    const ratio8 = (domainIndex + ratioWithinInterval) / (domain.length - 1);
    return ratio8 * (r1 - r0) + r0;
  }
  invert(position, nearest = false) {
    this.refresh();
    const { domain, bands } = this;
    const reversed = domain[0].valueOf() > domain[domain.length - 1].valueOf();
    let index;
    if (nearest) {
      index = this.invertNearestIndex(position - this.bandwidth / 2);
    } else {
      const closestIndex = (0, import_ag_charts_core41.findMinIndex)(0, bands.length - 1, (i) => {
        const p = this.ordinalRange(i);
        return p >= position;
      });
      index = closestIndex ?? 0;
    }
    return bands[reversed ? bands.length - 1 - index : index];
  }
  /**
   * Returns a time format function suitable for displaying tick values.
   * @param specifier If the specifier string is provided, this method is equivalent to
   * the {@link TimeLocaleObject.format} method.
   * If no specifier is provided, this method returns the default time format function.
   */
  tickFormatter({ domain, ticks, specifier }, formatOffset) {
    return specifier != null ? buildFormatter(specifier) : defaultTimeTickFormat(ticks, domain, formatOffset);
  }
};

// packages/ag-charts-community/src/scale/unitTimeScale.ts
var import_ag_charts_core42 = require("ag-charts-core");

// packages/ag-charts-community/src/util/timeInterop.ts
function intervalInstance(interval) {
  return typeof interval === "string" ? time_exports[interval] : interval;
}
function intervalUnit(interval) {
  return intervalInstance(interval).unit;
}
function intervalStep(interval) {
  return intervalInstance(interval).step;
}
function intervalHierarchy(interval) {
  return intervalInstance(interval).hierarchy;
}
function intervalMilliseconds(interval) {
  return intervalInstance(interval).milliseconds;
}
function intervalRange(interval, start2, stop, options) {
  return intervalInstance(interval).range(start2, stop, options);
}
function intervalFloor(interval, date5) {
  return intervalInstance(interval).floor(date5);
}

// packages/ag-charts-community/src/scale/unitTimeScale.ts
var _UnitTimeScale = class _UnitTimeScale extends DiscreteTimeScale {
  constructor() {
    super(...arguments);
    this.type = "unit-time";
    this._domain = [];
    /* eslint-enable */
    this._bands = void 0;
  }
  static is(value) {
    return value instanceof _UnitTimeScale;
  }
  set domain(domain) {
    if (domain === this._domain)
      return;
    this._domain = domain;
    this._bands = void 0;
  }
  get domain() {
    return this._domain;
  }
  get interval() {
    return this._interval;
  }
  set interval(interval) {
    if (this._interval === interval)
      return;
    this._interval = interval;
    this._bands = void 0;
  }
  get bands() {
    this._bands ?? (this._bands = this.calculateBands(this._domain, [0, 1]));
    return this._bands;
  }
  normalizeDomains(...domains) {
    return normalizeContinuousDomains(...domains);
  }
  convert(d, options) {
    const { domain, interval } = this;
    if (domain.length < 2)
      return NaN;
    if (interval != null) {
      const t = d.valueOf();
      const [start2, stop] = this.calculateBandRange(domain, interval);
      const d0 = Math.min(start2.valueOf(), stop.valueOf());
      const d1 = Math.max(start2.valueOf(), stop.valueOf());
      if (t < d0 || t >= d1 + intervalMilliseconds(interval))
        return NaN;
    }
    return super.convert(d, options);
  }
  calculateBandRange(domain, interval) {
    const start2 = intervalFloor(interval, domain[0]);
    const stop = intervalFloor(interval, domain[1]);
    return [start2, stop];
  }
  calculateBands(domain, visibleRange, extend = false) {
    if (domain === this.domain && visibleRange[0] === 0 && visibleRange[1] === 1 && !extend && this._bands != null) {
      return this._bands;
    }
    if (domain.length < 2)
      return [];
    const { interval } = this;
    if (interval == null)
      return [];
    const [start2, stop] = this.calculateBandRange(domain, interval);
    return intervalRange(interval, start2, stop, { visibleRange, extend });
  }
  ticks({ interval }, domain = this.domain, visibleRange = [0, 1], extend = false) {
    if (domain.length < 2)
      return;
    const bands = this.calculateBands(domain, visibleRange, extend);
    const milliseconds = this.interval ? intervalMilliseconds(this.interval) : Infinity;
    if (interval == null)
      return { ticks: bands, count: void 0 };
    const d0 = Math.min(domain[0].valueOf(), domain[1].valueOf());
    const d1 = Math.max(domain[0].valueOf(), domain[1].valueOf());
    const ticks = [];
    let intervalTicks;
    let intervalStartIndex;
    let intervalEndIndex;
    if (interval instanceof TimeInterval) {
      intervalTicks = interval.range(domain[0], domain[1], { extend: true, visibleRange });
      intervalStartIndex = 0;
      intervalEndIndex = intervalTicks.length - 1;
    } else {
      intervalTicks = bands;
      intervalStartIndex = (0, import_ag_charts_core42.findMaxIndex)(0, bands.length - 1, (index) => bands[index].valueOf() <= d0) ?? 0;
      intervalEndIndex = (0, import_ag_charts_core42.findMaxIndex)(0, bands.length - 1, (index) => bands[index].valueOf() <= d1) ?? bands.length - 1;
    }
    let lastIndex;
    for (let i = intervalStartIndex; i <= intervalEndIndex; i++) {
      const intervalTickValue = intervalTicks[i].valueOf();
      const bandIndex = (0, import_ag_charts_core42.findMaxIndex)(0, bands.length - 1, (index) => bands[index].valueOf() <= intervalTickValue);
      const tick = bandIndex != null && bandIndex != lastIndex ? bands[bandIndex] : void 0;
      lastIndex = bandIndex;
      if (tick != null && intervalTickValue - tick.getTime() <= milliseconds)
        ticks.push(tick);
    }
    let bandStart;
    let bandEnd;
    if (this.interval) {
      const bandRange = this.calculateBandRange([new Date(d0), new Date(d1)], this.interval);
      bandStart = bandRange[0].valueOf();
      bandEnd = bandRange[1].valueOf();
    } else {
      bandStart = d0;
      bandEnd = d1;
    }
    let firstTickIndex = (0, import_ag_charts_core42.findMinIndex)(0, ticks.length - 1, (i) => ticks[i].valueOf() >= bandStart) ?? 0;
    let lastTickIndex = (0, import_ag_charts_core42.findMaxIndex)(0, ticks.length - 1, (i) => ticks[i].valueOf() <= bandEnd) ?? ticks.length - 1;
    if (extend) {
      firstTickIndex = Math.max(firstTickIndex - 1, 0);
      lastTickIndex = Math.min(lastTickIndex + 1, ticks.length - 1);
    }
    return {
      ticks: ticks.slice(firstTickIndex, lastTickIndex + 1),
      count: ticks.length
    };
  }
  findIndex(value) {
    const { bands } = this;
    const target = value.valueOf();
    return (0, import_ag_charts_core42.findMaxIndex)(0, bands.length - 1, (index) => bands[index].valueOf() <= target);
  }
  datumFormatter(params) {
    const formatter = this.tickFormatter(params, 1);
    return (date5) => {
      const index = this.findIndex(date5);
      return index != null ? formatter(this.bands[index]) : formatter(date5);
    };
  }
};
_UnitTimeScale.defaultTickCount = 12;
var UnitTimeScale = _UnitTimeScale;

// packages/ag-charts-community/src/util/format.util.ts
var percentFormatter = new Intl.NumberFormat("en-US", { style: "percent" });
function formatValue(value, maximumFractionDigits = 2) {
  if (typeof value === "number") {
    return formatNumber(value, maximumFractionDigits);
  }
  return typeof value === "string" ? value : String(value ?? "");
}
function formatPercent(value) {
  return percentFormatter.format(value);
}
var numberFormatters = (/* @__PURE__ */ new Map()).set(
  2,
  new Intl.NumberFormat("en-US", { maximumFractionDigits: 2, useGrouping: false })
);
function formatNumber(value, maximumFractionDigits) {
  let formatter = numberFormatters.get(maximumFractionDigits);
  if (!formatter) {
    formatter = new Intl.NumberFormat("en-US", { maximumFractionDigits, useGrouping: false });
    numberFormatters.set(maximumFractionDigits, formatter);
  }
  return formatter.format(value);
}

// packages/ag-charts-community/src/chart/crossline/cartesianCrossLine.ts
var import_ag_charts_core46 = require("ag-charts-core");

// packages/ag-charts-community/src/util/date.ts
function compareDates(a, b) {
  return a.valueOf() - b.valueOf();
}
function deduplicateSortedArray(values) {
  let v0 = NaN;
  const out = [];
  for (const v of values) {
    const v1 = v.valueOf();
    if (v0 !== v1)
      out.push(v);
    v0 = v1;
  }
  return out;
}
function sortAndUniqueDates(values) {
  const sortedValues = values.slice().sort(compareDates);
  return datesSortOrder(sortedValues) == null ? deduplicateSortedArray(sortedValues) : sortedValues;
}
function datesSortOrder(d) {
  if (d.length === 0)
    return 1;
  const sign = Number(d[d.length - 1]) > Number(d[0]) ? 1 : -1;
  let v0 = -Infinity * sign;
  for (const v of d) {
    const v1 = v.valueOf();
    if (Math.sign(v1 - v0) !== sign)
      return;
    v0 = v1;
  }
  return sign;
}

// packages/ag-charts-community/src/util/ticks.ts
var import_ag_charts_core43 = require("ag-charts-core");
var tInterval = (timeInterval, baseDuration, step) => ({
  duration: baseDuration * step,
  timeInterval,
  step
});
var TickIntervals = [
  tInterval(second, durationSecond, 1),
  tInterval(second, durationSecond, 5),
  tInterval(second, durationSecond, 15),
  tInterval(second, durationSecond, 30),
  tInterval(minute, durationMinute, 1),
  tInterval(minute, durationMinute, 5),
  tInterval(minute, durationMinute, 15),
  tInterval(minute, durationMinute, 30),
  tInterval(hour, durationHour, 1),
  tInterval(hour, durationHour, 3),
  tInterval(hour, durationHour, 6),
  tInterval(hour, durationHour, 12),
  tInterval(day, durationDay, 1),
  tInterval(day, durationDay, 2),
  tInterval(sunday, durationWeek, 1),
  tInterval(sunday, durationWeek, 2),
  tInterval(sunday, durationWeek, 3),
  tInterval(month, durationMonth, 1),
  tInterval(month, durationMonth, 2),
  tInterval(month, durationMonth, 3),
  tInterval(month, durationMonth, 4),
  tInterval(month, durationMonth, 6),
  tInterval(year, durationYear, 1)
];
var TickMultipliers = [1, 2, 5, 10];
function isCloseToInteger(n, delta3) {
  return Math.abs(Math.round(n) - n) < delta3;
}
function countTicks(d0, d1, step) {
  const extent2 = Math.abs(d1 - d0);
  return extent2 >= step ? Math.abs(d1 - d0) / step + 1 : 1;
}
function createTicks(start2, stop, count, minCount, maxCount, visibleRange) {
  if (start2 === stop)
    return { ticks: [start2], count: 1 };
  if (count < 2)
    return { ticks: [start2, stop], count: 2 };
  const step = tickStep(start2, stop, count, minCount, maxCount);
  if (!Number.isFinite(step))
    return { ticks: [], count: 0 };
  let d0 = start2;
  let d1 = stop;
  if (!isCloseToInteger(d0 / step, 1e-12)) {
    d0 = Math.ceil(d0 / step) * step;
  }
  if (!isCloseToInteger(d1 / step, 1e-12)) {
    d1 = Math.floor(d1 / step) * step;
  }
  if (visibleRange != null) {
    const dr = d1 - d0;
    const vr = stop - start2;
    const vd0 = start2 + vr * visibleRange[0];
    const vd1 = start2 + vr * visibleRange[1];
    visibleRange = [(vd0 - d0) / dr, (vd1 - d0) / dr];
  }
  const { ticks } = range(d0, d1, step, visibleRange);
  return { ticks, count: countTicks(start2, stop, step) };
}
var minPrimaryTickRatio = Math.floor(2 * sunday.milliseconds / month.milliseconds * 10) / 10;
function isPrimaryTickInterval({ timeInterval, step }) {
  const milliseconds = timeInterval.milliseconds * step;
  return milliseconds <= (timeInterval.hierarchy?.milliseconds ?? Infinity) * minPrimaryTickRatio;
}
function getTickTimeInterval(start2, stop, count, minCount, maxCount, {
  weekStart,
  primaryOnly = false,
  targetInterval
}) {
  if (count <= 0)
    return;
  const target = targetInterval ?? Math.abs(stop - start2) / Math.max(count, 1);
  const i0 = TickIntervals.findLast((t) => (!primaryOnly || isPrimaryTickInterval(t)) && target > t.duration);
  const i1 = TickIntervals.find((t) => (!primaryOnly || isPrimaryTickInterval(t)) && target <= t.duration);
  if (i0 == null) {
    const step2 = Math.max(tickStep(start2, stop, count, minCount, maxCount), 1);
    return millisecond.every(step2);
  } else if (i1 == null) {
    const step2 = targetInterval == null ? tickStep(start2 / durationYear, stop / durationYear, count, minCount, maxCount) : 1;
    return year.every(step2);
  }
  const { timeInterval, step } = target - i0.duration < i1.duration - target ? i0 : i1;
  if (timeInterval === sunday) {
    return weekStart?.every(step) ?? day.every(7 * step);
  }
  return timeInterval.every(step);
}
function tickStep(start2, end2, count, minCount = 0, maxCount = Infinity) {
  if (start2 === end2) {
    return (0, import_ag_charts_core43.clamp)(1, minCount, maxCount);
  } else if (count < 1) {
    return NaN;
  }
  const extent2 = Math.abs(end2 - start2);
  const step = 10 ** Math.floor(Math.log10(extent2 / count));
  let m = NaN, minDiff = Infinity, isInBounds = false;
  for (const multiplier of TickMultipliers) {
    const c = Math.ceil(extent2 / (multiplier * step));
    const validBounds = c >= minCount && c <= maxCount;
    if (isInBounds && !validBounds)
      continue;
    const diffCount = Math.abs(c - count);
    if (minDiff > diffCount || isInBounds !== validBounds) {
      isInBounds || (isInBounds = validBounds);
      minDiff = diffCount;
      m = multiplier;
    }
  }
  return m * step;
}
function decimalPlaces(decimal) {
  for (let i = decimal.length - 1; i >= 0; i -= 1) {
    if (decimal[i] !== "0") {
      return i + 1;
    }
  }
  return 0;
}
function tickFormat(ticks, format) {
  const options = (0, import_ag_charts_core43.parseNumberFormat)(format ?? ",f");
  if (options.precision == null || isNaN(options.precision)) {
    if (!options.type || "eEFgGnprs".includes(options.type)) {
      options.precision = Math.max(
        ...ticks.map((x) => {
          if (!Number.isFinite(x))
            return 0;
          const [integer, decimal] = x.toExponential((options.type ? 6 : 12) - 1).split(/[.e]/g);
          return (integer !== "1" && integer !== "-1" ? 1 : 0) + decimalPlaces(decimal) + 1;
        })
      );
    } else if ("f%".includes(options.type)) {
      options.precision = Math.max(
        ...ticks.map((x) => {
          if (!Number.isFinite(x) || x === 0)
            return 0;
          const l = Math.floor(Math.log10(Math.abs(x)));
          const digits = options.type ? 6 : 12;
          const decimal = x.toExponential(digits - 1).split(/[.e]/g)[1];
          const decimalLength = decimalPlaces(decimal);
          return Math.max(0, decimalLength - l);
        })
      );
    }
  }
  const formatter = (0, import_ag_charts_core43.createNumberFormatter)(options);
  return (n) => formatter(Number(n));
}
function range(start2, end2, step, visibleRange) {
  if (!Number.isFinite(step) || step <= 0) {
    return { ticks: [], count: 0 };
  } else if (start2 === end2) {
    return { ticks: [start2], count: 1 };
  }
  const f = 10 ** (0, import_ag_charts_core43.countFractionDigits)(step);
  const d0 = Math.min(start2, end2);
  const d1 = Math.max(start2, end2);
  let vd0;
  let vd1;
  if (visibleRange != null && (visibleRange[0] !== 0 || visibleRange[1] !== 1)) {
    const rangeExtent = end2 - start2;
    const adjustedStart = start2 + rangeExtent * visibleRange[0];
    const adjustedEnd = end2 - rangeExtent * (1 - visibleRange[1]);
    vd0 = Math.min(adjustedStart, adjustedEnd);
    vd1 = Math.max(adjustedStart, adjustedEnd);
  } else {
    vd0 = d0;
    vd1 = d1;
  }
  vd0 = Math.floor(vd0 * f) / f;
  vd1 = Math.ceil(vd1 * f) / f;
  const ticks = [];
  for (let i = 0; ; i += 1) {
    const p = Math.round((d0 + step * i) * f) / f;
    if (p > d1)
      break;
    if (p >= vd0 && p <= vd1) {
      ticks.push(p);
    }
  }
  return { ticks, count: countTicks(d0, d1, step) };
}
function isDenseInterval(count, availableRange) {
  if (count >= availableRange) {
    import_ag_charts_core43.Logger.warnOnce(
      `the configured interval results in more than 1 item per pixel, ignoring. Supply a larger interval or omit this configuration`
    );
    return true;
  }
  return false;
}
function niceTicksDomain(start2, end2) {
  const extent2 = Math.abs(end2 - start2);
  const step = 10 ** Math.floor(Math.log10(extent2));
  let minError = Infinity, ticks = [start2, end2];
  for (const multiplier of TickMultipliers) {
    const m = multiplier * step;
    const d0 = Math.floor(start2 / m) * m;
    const d1 = Math.ceil(end2 / m) * m;
    const error = 1 - extent2 / Math.abs(d1 - d0);
    if (minError > error) {
      minError = error;
      ticks = [d0, d1];
    }
  }
  return ticks;
}
function estimateTickCount(rangeExtent, zoomExtent, minSpacing, maxSpacing, defaultTickCount, defaultMinSpacing) {
  if (rangeExtent <= 0) {
    return { minTickCount: 0, maxTickCount: 0, tickCount: 0 };
  }
  defaultMinSpacing = Math.max(defaultMinSpacing, rangeExtent / (defaultTickCount + 1));
  minSpacing ?? (minSpacing = defaultMinSpacing);
  maxSpacing ?? (maxSpacing = rangeExtent);
  if (minSpacing > maxSpacing) {
    if (minSpacing === defaultMinSpacing) {
      minSpacing = maxSpacing;
    } else {
      maxSpacing = minSpacing;
    }
  }
  const maxTickCount = Math.max(1, Math.floor(rangeExtent / (zoomExtent * minSpacing)));
  const minTickCount = Math.min(maxTickCount, Math.ceil(rangeExtent / (zoomExtent * maxSpacing)));
  const tickCount = (0, import_ag_charts_core43.clamp)(minTickCount, Math.floor(defaultTickCount / zoomExtent), maxTickCount);
  return { minTickCount, maxTickCount, tickCount };
}

// packages/ag-charts-community/src/scale/timeScale.ts
var TimeScale = class _TimeScale extends ContinuousScale {
  constructor() {
    super([], [0, 1]);
    this.type = "time";
  }
  static is(value) {
    return value instanceof _TimeScale;
  }
  toDomain(d) {
    return new Date(d);
  }
  convert(value, options) {
    if (!(value instanceof Date))
      value = new Date(value);
    return super.convert(value, options);
  }
  invert(value) {
    return new Date(super.invert(value));
  }
  niceDomain(ticks, domain = this.domain) {
    if (domain.length < 2)
      return [];
    let [d0, d1] = domain;
    const maxAttempts = 4;
    const availableRange = this.getPixelRange();
    for (let i = 0; i < maxAttempts; i++) {
      const [n0, n1] = updateNiceDomainIteration(d0, d1, ticks, availableRange);
      if (dateToNumber(d0) === dateToNumber(n0) && dateToNumber(d1) === dateToNumber(n1)) {
        break;
      }
      d0 = n0;
      d1 = n1;
    }
    return [d0, d1];
  }
  /**
   * Returns uniformly-spaced dates that represent the scale's domain.
   */
  ticks(params, domain = this.domain, visibleRange = [0, 1], extend = false) {
    const { nice, interval, tickCount = ContinuousScale.defaultTickCount, minTickCount, maxTickCount } = params;
    if (domain.length < 2)
      return;
    const timestamps = domain.map(dateToNumber);
    const start2 = timestamps[0];
    const stop = timestamps[timestamps.length - 1];
    if (interval != null) {
      const availableRange = this.getPixelRange();
      return {
        ticks: getDateTicksForInterval({ start: start2, stop, interval, availableRange, visibleRange, extend }) ?? getDefaultDateTicks({ start: start2, stop, tickCount, minTickCount, maxTickCount, visibleRange, extend }),
        count: void 0
      };
    } else if (nice && tickCount === 2) {
      return { ticks: domain, count: void 0 };
    } else if (nice && tickCount === 1) {
      return { ticks: domain.slice(0, 1), count: void 0 };
    }
    return {
      ticks: getDefaultDateTicks({ start: start2, stop, tickCount, minTickCount, maxTickCount, visibleRange, extend }),
      count: void 0
    };
  }
  _tickFormatter({ domain, ticks, specifier }, formatOffset) {
    return specifier != null ? buildFormatter(specifier) : defaultTimeTickFormat(ticks, domain, formatOffset);
  }
  /**
   * Returns a time format function suitable for displaying tick values.
   *
   * @param ticks Optional array of tick values for custom formatting.
   * @param domain Optional array representing the [min, max] values of the time axis.
   * @param specifier Optional format specifier string for custom date formatting (e.g., `%Y`, `%m`, `%d`).
   * @param formatOffset Optional number for applying an offset to the format (e.g., timezone shifts).
   * @returns A function that formats a `Date` object into a string based on the provided specifier or default format.
   */
  tickFormatter(params) {
    return this._tickFormatter(params);
  }
  datumFormatter(params) {
    return this._tickFormatter(params, 1);
  }
};
function getDefaultDateTicks({
  start: start2,
  stop,
  tickCount,
  minTickCount,
  maxTickCount,
  visibleRange,
  extend
}) {
  const t = getTickTimeInterval(start2, stop, tickCount, minTickCount, maxTickCount, { weekStart: sunday });
  return t ? t.range(new Date(start2), new Date(stop), { visibleRange, extend }) : [];
}
function getDateTicksForInterval({
  start: start2,
  stop,
  interval,
  availableRange,
  visibleRange,
  extend
}) {
  if (!interval) {
    return [];
  }
  if (interval instanceof TimeInterval || typeof interval === "string") {
    const ticks2 = intervalRange(interval, new Date(start2), new Date(stop), { visibleRange, extend });
    if (isDenseInterval(ticks2.length, availableRange)) {
      return;
    }
    return ticks2;
  }
  const absInterval = Math.abs(interval);
  if (isDenseInterval(Math.abs(stop - start2) / absInterval, availableRange))
    return;
  const timeInterval = TickIntervals.findLast((tickInterval) => absInterval % tickInterval.duration === 0);
  if (timeInterval) {
    const i = timeInterval.timeInterval.every(absInterval / (timeInterval.duration / timeInterval.step));
    return i.range(new Date(start2), new Date(stop), { visibleRange, extend });
  }
  let date5 = new Date(Math.min(start2, stop));
  const stopDate = new Date(Math.max(start2, stop));
  const ticks = [];
  while (date5 <= stopDate) {
    ticks.push(date5);
    date5 = new Date(date5);
    date5.setMilliseconds(date5.getMilliseconds() + absInterval);
  }
  return ticks;
}
function updateNiceDomainIteration(d0, d1, ticks, availableRange) {
  const { interval } = ticks;
  const start2 = Math.min(dateToNumber(d0), dateToNumber(d1));
  const stop = Math.max(dateToNumber(d0), dateToNumber(d1));
  let i;
  if (interval instanceof TimeInterval) {
    i = interval;
  } else if (typeof interval === "string") {
    i = interval;
  } else {
    let tickCount;
    if (typeof interval === "number") {
      tickCount = (stop - start2) / Math.max(interval, 1);
      if (isDenseInterval(tickCount, availableRange)) {
        tickCount = void 0;
      }
    }
    tickCount ?? (tickCount = ticks.tickCount ?? ContinuousScale.defaultTickCount);
    i = getTickTimeInterval(start2, stop, tickCount, ticks.minTickCount, ticks.maxTickCount, { weekStart: sunday });
  }
  if (i == null)
    return [d0, d1];
  const domain = intervalRange(i, new Date(start2), new Date(stop), { extend: true });
  if (domain == null || domain.length < 2)
    return [d0, d1];
  const r0 = domain[0];
  const r1 = domain[domain.length - 1];
  return d0 <= d1 ? [r0, r1] : [r1, r0];
}

// packages/ag-charts-community/src/scale/ordinalTimeScale.ts
var OrdinalTimeScale = class _OrdinalTimeScale extends DiscreteTimeScale {
  constructor() {
    super(...arguments);
    this.type = "ordinal-time";
    this._domain = [];
    this.isReversed = false;
  }
  static is(value) {
    return value instanceof _OrdinalTimeScale;
  }
  set domain(domain) {
    if (domain === this._domain)
      return;
    this.invalid = true;
    this._domain = domain;
    this._bands = void 0;
    this.isReversed = domain.length > 0 && domain[0] > domain[domain.length - 1];
    this.sortedTimestamps = void 0;
    this.precomputedSteps = void 0;
  }
  get domain() {
    return this._domain;
  }
  get bands() {
    this._bands ?? (this._bands = this.isReversed ? this.domain.slice().reverse() : this.domain);
    return this._bands;
  }
  normalizeDomains(...domains) {
    const sortedDomains = domains.filter((domain) => domain.length > 0);
    if (sortedDomains.length === 0) {
      return { domain: [], animatable: false };
    } else if (sortedDomains.length === 1) {
      let domain = sortedDomains[0];
      const sortOrder = datesSortOrder(domain);
      if (sortOrder === -1) {
        domain = domain.slice().reverse();
      } else if (sortOrder == null) {
        domain = sortAndUniqueDates(domain.slice());
      }
      return { domain, animatable: true };
    }
    return {
      domain: sortAndUniqueDates(sortedDomains.flat()),
      animatable: true
    };
  }
  ticks({ interval, maxTickCount }, domain = this.domain, visibleRange = [0, 1], extend = false) {
    if (!domain.length)
      return;
    this.refresh();
    const { isReversed } = this;
    if (interval == null) {
      return {
        ticks: getDefaultTicks(domain, maxTickCount, isReversed, visibleRange, extend),
        count: void 0
      };
    }
    const start2 = domain[0].valueOf();
    const stop = domain[domain.length - 1].valueOf();
    const [r0, r1] = this.range;
    const availableRange = Math.abs(r1 - r0);
    let ticks = getDateTicksForInterval({ start: start2, stop, interval, availableRange, visibleRange, extend }) ?? getDefaultTicks(domain, maxTickCount, isReversed, visibleRange, extend);
    let lastIndex = -1;
    ticks = ticks.filter((tick) => {
      const index = this.findInterval(tick.valueOf());
      const duplicated = index === lastIndex;
      lastIndex = index;
      return !duplicated;
    });
    return {
      ticks,
      count: void 0
    };
  }
  getSortedTimestamps() {
    let { sortedTimestamps } = this;
    if (sortedTimestamps == null) {
      sortedTimestamps ?? (sortedTimestamps = this.bands.map(dateToNumber));
      this.sortedTimestamps = sortedTimestamps;
    }
    return sortedTimestamps;
  }
  getPrecomputedSteps() {
    const { domain } = this;
    let { precomputedSteps } = this;
    const computedStepCount = domain.length < 1e4 ? domain.length : Math.ceil(domain.length / 16);
    if (precomputedSteps != null || computedStepCount <= 1)
      return precomputedSteps;
    const sortedTimestamps = this.getSortedTimestamps();
    precomputedSteps = new Int32Array(computedStepCount);
    const d0 = sortedTimestamps[0];
    const d1 = sortedTimestamps[sortedTimestamps.length - 1];
    const dRange = d1 - d0;
    const low = 0;
    const high = sortedTimestamps.length - 1;
    for (let i = 0; i < precomputedSteps.length; i += 1) {
      precomputedSteps[i] = this.findIntervalInRange(d0 + i / computedStepCount * dRange, low, high);
    }
    this.precomputedSteps = precomputedSteps;
  }
  findIntervalInRange(target, low, high) {
    const sortedTimestamps = this.getSortedTimestamps();
    while (low <= high) {
      const mid = (low + high) / 2 | 0;
      if (sortedTimestamps[mid] === target) {
        return mid;
      } else if (sortedTimestamps[mid] < target) {
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }
    return low;
  }
  findInterval(target) {
    const precomputedSteps = this.getPrecomputedSteps();
    let low;
    let high;
    if (precomputedSteps == null) {
      low = 0;
      high = this.domain.length - 1;
    } else {
      const sortedTimestamps = this.getSortedTimestamps();
      const d0 = sortedTimestamps[0];
      const d1 = sortedTimestamps[sortedTimestamps.length - 1];
      const i = Math.min(
        (target - d0) / (d1 - d0) * precomputedSteps.length | 0,
        precomputedSteps.length - 1 | 0
      );
      low = precomputedSteps[i];
      high = i < precomputedSteps.length - 2 ? precomputedSteps[i + 1] : sortedTimestamps.length - 1;
    }
    return this.findIntervalInRange(target, low, high);
  }
  datumFormatter(params) {
    return this.tickFormatter(params);
  }
  findIndex(value) {
    const sortedTimestamps = this.getSortedTimestamps();
    const n = Number(value);
    if (n < sortedTimestamps[0]) {
      return void 0;
    }
    return this.findInterval(n);
  }
};
function getDefaultTicks(domain, maxTickCount, isReversed, visibleRange, extend) {
  const ticks = [];
  const tickEvery = Math.ceil(domain.length / maxTickCount);
  const tickOffset = Math.floor(tickEvery / 2);
  let startIndex = Math.floor(visibleRange[0] * domain.length);
  let endIndex = Math.ceil(visibleRange[1] * domain.length);
  if (extend) {
    if (startIndex > tickEvery)
      startIndex -= tickEvery;
    if (endIndex < domain.length - tickEvery)
      endIndex += tickEvery;
  }
  for (let index = startIndex; index < endIndex; index += 1) {
    const tickIndex = isReversed ? domain.length - 1 - index : index;
    if (tickEvery <= 0 || (tickIndex + tickOffset) % tickEvery === 0) {
      ticks.push(domain[index]);
    }
  }
  return ticks;
}

// packages/ag-charts-community/src/scene/shape/range.ts
var Range = class extends Shape {
  constructor(opts = {}) {
    super(opts);
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.startLine = false;
    this.endLine = false;
    this.horizontal = false;
    this.restoreOwnStyles();
  }
  computeBBox() {
    return new BBox(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);
  }
  isPointInPath(_x, _y) {
    return false;
  }
  render(renderCtx) {
    const { ctx } = renderCtx;
    let { x1, y1, x2, y2 } = this;
    x1 = this.align(x1);
    y1 = this.align(y1);
    x2 = this.align(x2);
    y2 = this.align(y2);
    const { fill, horizontal } = this;
    const { globalAlpha } = ctx;
    if (fill != null) {
      this.applyFillAndAlpha(ctx);
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y1);
      ctx.lineTo(x2, y2);
      ctx.lineTo(x1, y2);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = globalAlpha;
    }
    const { stroke: stroke2, strokeWidth, startLine, endLine } = this;
    const strokeActive = !!((startLine || endLine) && stroke2 && strokeWidth);
    if (strokeActive) {
      const { lineDash, lineDashOffset, lineCap, lineJoin } = this;
      this.applyStrokeAndAlpha(ctx);
      ctx.lineWidth = strokeWidth;
      if (lineDash) {
        ctx.setLineDash([...lineDash]);
      }
      if (lineDashOffset) {
        ctx.lineDashOffset = lineDashOffset;
      }
      if (lineCap) {
        ctx.lineCap = lineCap;
      }
      if (lineJoin) {
        ctx.lineJoin = lineJoin;
      }
      ctx.beginPath();
      if (startLine) {
        ctx.moveTo(x1, y1);
        if (horizontal) {
          ctx.lineTo(x1, y2);
        } else {
          ctx.lineTo(x2, y1);
        }
      }
      if (endLine) {
        ctx.moveTo(x2, y2);
        if (horizontal) {
          ctx.lineTo(x2, y1);
        } else {
          ctx.lineTo(x1, y2);
        }
      }
      ctx.stroke();
      ctx.globalAlpha = globalAlpha;
    }
    this.fillShadow?.markClean();
    super.render(renderCtx);
  }
};
Range.className = "Range";
Range.defaultStyles = {
  ...Shape.defaultStyles,
  strokeWidth: 1
};
__decorateClass([
  SceneChangeDetection()
], Range.prototype, "x1", 2);
__decorateClass([
  SceneChangeDetection()
], Range.prototype, "y1", 2);
__decorateClass([
  SceneChangeDetection()
], Range.prototype, "x2", 2);
__decorateClass([
  SceneChangeDetection()
], Range.prototype, "y2", 2);
__decorateClass([
  SceneChangeDetection()
], Range.prototype, "startLine", 2);
__decorateClass([
  SceneChangeDetection()
], Range.prototype, "endLine", 2);
__decorateClass([
  SceneChangeDetection()
], Range.prototype, "horizontal", 2);

// packages/ag-charts-community/src/chart/crossline/crossLine.ts
var import_ag_charts_core45 = require("ag-charts-core");

// packages/ag-charts-community/src/util/value.ts
var import_ag_charts_core44 = require("ag-charts-core");
function isStringObject(value) {
  return value != null && Object.hasOwn(value, "toString") && (0, import_ag_charts_core44.isString)(value.toString());
}
function isNumberObject(value) {
  return value != null && Object.hasOwn(value, "valueOf") && (0, import_ag_charts_core44.isFiniteNumber)(value.valueOf());
}
function isContinuous(value) {
  return (0, import_ag_charts_core44.isFiniteNumber)(value) || (0, import_ag_charts_core44.isValidDate)(value) || isNumberObject(value);
}
function checkDatum(value, isContinuousScale) {
  return value != null && (!isContinuousScale || isContinuous(value));
}
function transformIntegratedCategoryValue(value) {
  if (isStringObject(value) && Object.hasOwn(value, "id")) {
    return value.id;
  }
  return value;
}

// packages/ag-charts-community/src/chart/crossline/crossLine.ts
function getCrossLineValue(crossLine) {
  switch (crossLine.type) {
    case "line":
      return crossLine.value;
    case "range":
      return crossLine.range;
  }
}
function validateCrossLineValue(value, scale2) {
  if (value == null) {
    return false;
  }
  const isContinuous2 = ContinuousScale.is(scale2) || DiscreteTimeScale.is(scale2);
  const validValue = (val) => checkDatum(val, isContinuous2) && !isNaN(scale2.convert(val));
  if ((0, import_ag_charts_core45.isArray)(value)) {
    const [start2, end2] = value;
    return validValue(start2) && validValue(end2);
  } else {
    return validValue(value);
  }
}

// packages/ag-charts-community/src/chart/crossline/cartesianCrossLine.ts
var horizontalLineAnchors = {
  top: { rangeH: 0, rangeV: -1, labelH: 0, labelV: 1 },
  "inside-top": { rangeH: 0, rangeV: -1, labelH: 0, labelV: 1 },
  "top-left": { rangeH: -1, rangeV: -1, labelH: -1, labelV: 1 },
  "inside-top-left": { rangeH: -1, rangeV: -1, labelH: -1, labelV: 1 },
  left: { rangeH: -1, rangeV: 0, labelH: 1, labelV: 0 },
  "inside-left": { rangeH: -1, rangeV: 0, labelH: -1, labelV: 0 },
  "bottom-left": { rangeH: -1, rangeV: 1, labelH: -1, labelV: -1 },
  "inside-bottom-left": { rangeH: -1, rangeV: 1, labelH: -1, labelV: -1 },
  bottom: { rangeH: 0, rangeV: 1, labelH: 0, labelV: -1 },
  "inside-bottom": { rangeH: 0, rangeV: 1, labelH: 0, labelV: -1 },
  "bottom-right": { rangeH: 1, rangeV: 1, labelH: 1, labelV: -1 },
  "inside-bottom-right": { rangeH: 1, rangeV: 1, labelH: 1, labelV: -1 },
  right: { rangeH: 1, rangeV: 0, labelH: -1, labelV: 0 },
  "inside-right": { rangeH: 1, rangeV: 0, labelH: 1, labelV: 0 },
  "top-right": { rangeH: 1, rangeV: -1, labelH: 1, labelV: 1 },
  "inside-top-right": { rangeH: 1, rangeV: -1, labelH: 1, labelV: 1 },
  inside: { rangeH: 0, rangeV: 0, labelH: 0, labelV: 0 }
};
var verticalLineAnchors = {
  top: { rangeH: 0, rangeV: -1, labelH: 0, labelV: 1 },
  "inside-top": { rangeH: 0, rangeV: -1, labelH: 0, labelV: -1 },
  "top-left": { rangeH: -1, rangeV: -1, labelH: 1, labelV: -1 },
  "inside-top-left": { rangeH: -1, rangeV: -1, labelH: 1, labelV: -1 },
  left: { rangeH: -1, rangeV: 0, labelH: 1, labelV: 0 },
  "inside-left": { rangeH: -1, rangeV: 0, labelH: 1, labelV: 0 },
  "bottom-left": { rangeH: -1, rangeV: 1, labelH: 1, labelV: 1 },
  "inside-bottom-left": { rangeH: -1, rangeV: 1, labelH: 1, labelV: 1 },
  bottom: { rangeH: 0, rangeV: 1, labelH: 0, labelV: -1 },
  "inside-bottom": { rangeH: 0, rangeV: 1, labelH: 0, labelV: 1 },
  "bottom-right": { rangeH: 1, rangeV: 1, labelH: -1, labelV: 1 },
  "inside-bottom-right": { rangeH: 1, rangeV: 1, labelH: -1, labelV: 1 },
  right: { rangeH: 1, rangeV: 0, labelH: -1, labelV: 0 },
  "inside-right": { rangeH: 1, rangeV: 0, labelH: -1, labelV: 0 },
  "top-right": { rangeH: 1, rangeV: -1, labelH: -1, labelV: -1 },
  "inside-top-right": { rangeH: -1, rangeV: -1, labelH: -1, labelV: -1 },
  inside: { rangeH: 0, rangeV: 0, labelH: 0, labelV: 0 }
};
var horizontalRangeAnchors = {
  top: { rangeH: 0, rangeV: -1, labelH: 0, labelV: 1 },
  "inside-top": { rangeH: 0, rangeV: -1, labelH: 0, labelV: -1 },
  "top-left": { rangeH: -1, rangeV: -1, labelH: -1, labelV: 1 },
  "inside-top-left": { rangeH: -1, rangeV: -1, labelH: -1, labelV: -1 },
  left: { rangeH: -1, rangeV: 0, labelH: 1, labelV: 0 },
  "inside-left": { rangeH: -1, rangeV: 0, labelH: -1, labelV: 0 },
  "bottom-left": { rangeH: -1, rangeV: 1, labelH: -1, labelV: -1 },
  "inside-bottom-left": { rangeH: -1, rangeV: 1, labelH: -1, labelV: 1 },
  bottom: { rangeH: 0, rangeV: 1, labelH: 0, labelV: -1 },
  "inside-bottom": { rangeH: 0, rangeV: 1, labelH: 0, labelV: 1 },
  "bottom-right": { rangeH: 1, rangeV: 1, labelH: 1, labelV: -1 },
  "inside-bottom-right": { rangeH: 1, rangeV: 1, labelH: 1, labelV: 1 },
  right: { rangeH: 1, rangeV: 0, labelH: -1, labelV: 0 },
  "inside-right": { rangeH: 1, rangeV: 0, labelH: 1, labelV: 0 },
  "top-right": { rangeH: 1, rangeV: -1, labelH: 1, labelV: 1 },
  "inside-top-right": { rangeH: 1, rangeV: -1, labelH: 1, labelV: -1 },
  inside: { rangeH: 0, rangeV: 0, labelH: 0, labelV: 0 }
};
var verticalRangeAnchors = {
  top: { rangeH: 0, rangeV: -1, labelH: 0, labelV: 1 },
  "inside-top": { rangeH: 0, rangeV: -1, labelH: 0, labelV: -1 },
  "top-left": { rangeH: -1, rangeV: -1, labelH: 1, labelV: -1 },
  "inside-top-left": { rangeH: -1, rangeV: -1, labelH: -1, labelV: -1 },
  left: { rangeH: -1, rangeV: 0, labelH: 1, labelV: 0 },
  "inside-left": { rangeH: -1, rangeV: 0, labelH: -1, labelV: 0 },
  "bottom-left": { rangeH: -1, rangeV: 1, labelH: 1, labelV: 1 },
  "inside-bottom-left": { rangeH: -1, rangeV: 1, labelH: -1, labelV: 1 },
  bottom: { rangeH: 0, rangeV: 1, labelH: 0, labelV: -1 },
  "inside-bottom": { rangeH: 0, rangeV: 1, labelH: 0, labelV: 1 },
  "bottom-right": { rangeH: 1, rangeV: 1, labelH: -1, labelV: 1 },
  "inside-bottom-right": { rangeH: 1, rangeV: 1, labelH: 1, labelV: 1 },
  right: { rangeH: 1, rangeV: 0, labelH: -1, labelV: 0 },
  "inside-right": { rangeH: 1, rangeV: 0, labelH: 1, labelV: 0 },
  "top-right": { rangeH: 1, rangeV: -1, labelH: -1, labelV: -1 },
  "inside-top-right": { rangeH: 1, rangeV: -1, labelH: 1, labelV: -1 },
  inside: { rangeH: 0, rangeV: 0, labelH: 0, labelV: 0 }
};
var CartesianCrossLineLabel = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.fontSize = 14;
    this.fontFamily = "Verdana, sans-serif";
    this.padding = 5;
    this.color = "rgba(87, 87, 87, 1)";
  }
};
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "enabled", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "text", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "fontStyle", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "fontWeight", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "fontSize", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "fontFamily", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "padding", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "color", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "position", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "rotation", 2);
__decorateClass([
  Property
], CartesianCrossLineLabel.prototype, "parallel", 2);
var CartesianCrossLine = class extends BaseProperties {
  constructor() {
    super();
    this.id = (0, import_ag_charts_core46.createId)(this);
    this.defaultColorRange = [];
    this.fill = "#c16068";
    this.label = new CartesianCrossLineLabel();
    this.scale = void 0;
    this.clippedRange = [-Infinity, Infinity];
    this.gridLength = 0;
    this.position = "top";
    this.rangeGroup = new Group({ name: this.id });
    this.lineGroup = new Group({ name: this.id });
    this.labelGroup = new Group({ name: this.id });
    this.crossLineRange = new Range();
    this.crossLineLabel = new TransformableText();
    this.data = void 0;
    this.startLine = false;
    this.endLine = false;
    this._isRange = void 0;
    this.lineGroup.append(this.crossLineRange);
    this.labelGroup.append(this.crossLineLabel);
    this.crossLineRange.pointerEvents = 1 /* None */;
  }
  get defaultLabelPosition() {
    return "top";
  }
  update(visible) {
    const { enabled, type, data, scale: scale2 } = this;
    if (!scale2 || !enabled || !visible || !validateCrossLineValue(getCrossLineValue(this), scale2) || data == null) {
      this.rangeGroup.visible = false;
      this.lineGroup.visible = false;
      this.labelGroup.visible = false;
      return;
    }
    this.rangeGroup.visible = visible;
    this.lineGroup.visible = visible;
    this.labelGroup.visible = visible;
    this.updateNodes();
    const isRange = type === "range";
    if (isRange !== this._isRange) {
      if (isRange) {
        this.rangeGroup.appendChild(this.crossLineRange);
      } else {
        this.lineGroup.appendChild(this.crossLineRange);
      }
    }
    this._isRange = isRange;
  }
  calculateLayout(visible, reversedAxis) {
    this.data = void 0;
    if (!visible)
      return;
    const { type, range: range3, value, scale: scale2, clippedRange, strokeWidth = 0 } = this;
    if (!scale2)
      return;
    const bandwidth = scale2.bandwidth ?? 0;
    const step = scale2.step ?? 0;
    const rangePadding = (reversedAxis ? -1 : 1) * (scale2 instanceof BandScale ? (step - bandwidth) / 2 : 0);
    let yStart;
    let yEnd;
    let clampedYStart;
    let clampedYEnd;
    if (type === "line") {
      const offset4 = bandwidth / 2;
      yStart = scale2.convert(value) + offset4;
      yEnd = NaN;
      clampedYStart = scale2.convert(value, { clamp: true }) + offset4;
      clampedYEnd = NaN;
    } else if (range3) {
      const [r0, r1] = range3;
      const ordinalTimeScalePadding = r0?.valueOf() === r1?.valueOf() && OrdinalTimeScale.is(scale2) ? bandwidth / 2 + rangePadding : 0;
      yStart = scale2.convert(r0) + ordinalTimeScalePadding;
      yEnd = scale2.convert(r1) + bandwidth;
      clampedYStart = scale2.convert(r0, { clamp: true }) + ordinalTimeScalePadding - rangePadding;
      clampedYEnd = scale2.convert(r1, { clamp: true }) + bandwidth + rangePadding;
    } else {
      return;
    }
    clampedYStart = clampArray(clampedYStart, clippedRange);
    clampedYEnd = clampArray(clampedYEnd, clippedRange);
    const validRange = (yStart === clampedYStart || yEnd === clampedYEnd || clampedYStart !== clampedYEnd) && Math.abs(clampedYEnd - clampedYStart) > 0;
    if (validRange && clampedYStart > clampedYEnd) {
      [clampedYStart, clampedYEnd] = [clampedYEnd, clampedYStart];
      [yStart, yEnd] = [yEnd, yStart];
    }
    if (yStart - rangePadding >= clampedYStart)
      yStart -= rangePadding;
    if (yEnd + rangePadding <= clampedYEnd)
      yEnd += rangePadding;
    this.startLine = strokeWidth > 0 && yStart >= clampedYStart && yStart <= clampedYStart + rangePadding;
    this.endLine = strokeWidth > 0 && yEnd >= clampedYEnd - bandwidth - rangePadding && yEnd <= clampedYEnd;
    if (type === "range" && !validRange && !this.startLine && !this.endLine)
      return;
    this.data = [clampedYStart, clampedYEnd];
    if (this.label.enabled === false || !this.label.text)
      return;
  }
  updateNodes() {
    const { position, data: [r0, r1] = [0, 0], gridLength } = this;
    const dr = Number.isFinite(r1) ? r1 - r0 : 0;
    let bounds;
    switch (position) {
      case "top":
      case "bottom":
        bounds = new BBox(r0, position === "top" ? 0 : -gridLength, dr, gridLength);
        break;
      case "left":
      case "right":
        bounds = new BBox(position === "left" ? 0 : -gridLength, r0, gridLength, dr);
    }
    this.updateRangeNode(bounds);
    const { label } = this;
    if (label.enabled !== false && label.text) {
      this.updateLabel();
      this.positionLabel(bounds);
    }
  }
  updateRangeNode(bounds) {
    const {
      type,
      position,
      crossLineRange,
      startLine,
      endLine,
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash
    } = this;
    crossLineRange.x1 = bounds.x;
    crossLineRange.x2 = bounds.x + bounds.width;
    crossLineRange.y1 = bounds.y;
    crossLineRange.y2 = bounds.y + bounds.height;
    crossLineRange.horizontal = position === "top" || position === "bottom";
    crossLineRange.startLine = startLine;
    crossLineRange.endLine = endLine;
    crossLineRange.fill = type === "range" ? fill : void 0;
    crossLineRange.fillOpacity = fillOpacity ?? 1;
    crossLineRange.stroke = stroke2;
    crossLineRange.strokeWidth = strokeWidth ?? 1;
    crossLineRange.strokeOpacity = strokeOpacity ?? 1;
    crossLineRange.lineDash = lineDash;
  }
  updateLabel() {
    const { crossLineLabel, label } = this;
    if (!label.text)
      return;
    crossLineLabel.fontStyle = label.fontStyle;
    crossLineLabel.fontWeight = label.fontWeight;
    crossLineLabel.fontSize = label.fontSize;
    crossLineLabel.fontFamily = label.fontFamily;
    crossLineLabel.fill = label.color;
    crossLineLabel.text = label.text;
  }
  get anchor() {
    const horizontal = this.position === "left" || this.position === "right";
    const range3 = this.type === "range";
    const { position = this.defaultLabelPosition } = this.label;
    if (range3) {
      const anchors = horizontal ? horizontalRangeAnchors : verticalRangeAnchors;
      return anchors[position];
    } else {
      const anchors = horizontal ? horizontalLineAnchors : verticalLineAnchors;
      return anchors[position];
    }
  }
  positionLabel(bounds) {
    const { crossLineLabel, label, anchor } = this;
    crossLineLabel.rotation = toRadians(label.rotation ?? 0);
    crossLineLabel.textBaseline = "middle";
    crossLineLabel.textAlign = "center";
    const bbox = crossLineLabel.getBBox();
    if (!bbox)
      return;
    const { width: width2, height: height2 } = bbox;
    const xOffset = label.padding + width2 / 2;
    const yOffset = label.padding + height2 / 2;
    const x = bounds.x + bounds.width * (anchor.rangeH + 1) / 2 - xOffset * anchor.labelH;
    const y = bounds.y + bounds.height * (anchor.rangeV + 1) / 2 - yOffset * anchor.labelV;
    crossLineLabel.x = x;
    crossLineLabel.y = y;
    crossLineLabel.rotationCenterX = x;
    crossLineLabel.rotationCenterY = y;
  }
  computeLabelSize() {
    const { label } = this;
    if (label.enabled === false || !label.text)
      return;
    const tempText = new TransformableText();
    tempText.fontFamily = label.fontFamily;
    tempText.fontSize = label.fontSize;
    tempText.fontStyle = label.fontStyle;
    tempText.fontWeight = label.fontWeight;
    tempText.text = label.text;
    tempText.rotation = toRadians(label.rotation ?? 0);
    tempText.textBaseline = "middle";
    tempText.textAlign = "center";
    const bbox = tempText.getBBox();
    if (!bbox)
      return;
    const { width: width2, height: height2 } = bbox;
    return { width: width2, height: height2 };
  }
  calculatePadding(into) {
    const { label, anchor } = this;
    const size = this.computeLabelSize();
    if (!size)
      return;
    const { width: width2, height: height2 } = size;
    const xOffset = label.padding + width2;
    const yOffset = label.padding + height2;
    const horizontal = this.position === "left" || this.position === "right";
    if (horizontal) {
      if (anchor.rangeH === -1 && anchor.labelH === 1) {
        into.left = Math.max(into.left ?? 0, xOffset);
      } else if (anchor.rangeH === 1 && anchor.labelH === -1) {
        into.right = Math.max(into.right ?? 0, xOffset);
      }
    }
    if (!horizontal) {
      if (anchor.rangeV === -1 && anchor.labelV === 1) {
        into.top = Math.max(into.top ?? 0, yOffset);
      } else if (anchor.rangeV === 1 && anchor.labelV === -1) {
        into.bottom = Math.max(into.bottom ?? 0, yOffset);
      }
    }
  }
};
CartesianCrossLine.className = "CrossLine";
__decorateClass([
  Property
], CartesianCrossLine.prototype, "enabled", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "type", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "range", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "value", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "defaultColorRange", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "fill", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "stroke", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "lineDash", 2);
__decorateClass([
  Property
], CartesianCrossLine.prototype, "label", 2);

// packages/ag-charts-community/src/chart/label.ts
var import_ag_charts_core47 = require("ag-charts-core");
var Label = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
  }
  getFont() {
    return TextUtils.toFontString(this);
  }
};
__decorateClass([
  Property
], Label.prototype, "enabled", 2);
__decorateClass([
  Property
], Label.prototype, "color", 2);
__decorateClass([
  Property
], Label.prototype, "fontStyle", 2);
__decorateClass([
  Property
], Label.prototype, "fontWeight", 2);
__decorateClass([
  Property
], Label.prototype, "fontSize", 2);
__decorateClass([
  Property
], Label.prototype, "fontFamily", 2);
__decorateClass([
  Property
], Label.prototype, "formatter", 2);
function calculateLabelRotation(rotation, parallel, regularFlipRotation = 0, parallelFlipRotation = 0) {
  const configuredRotation = normalizeAngle360FromDegrees(rotation);
  const parallelFlipFlag = !configuredRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;
  const regularFlipFlag = !configuredRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;
  let defaultRotation = 0;
  if (parallel) {
    defaultRotation = parallelFlipFlag * Math.PI / 2;
  } else if (regularFlipFlag === -1) {
    defaultRotation = Math.PI;
  }
  return { configuredRotation, defaultRotation, parallelFlipFlag, regularFlipFlag };
}
function getLabelSpacing(minSpacing, rotated) {
  if (minSpacing != null) {
    return minSpacing;
  }
  return rotated ? 0 : 10;
}
function getTextBaseline(parallel, labelRotation, sideFlag, parallelFlipFlag, backwardsCompatibleTopBaseline) {
  if (parallel && !labelRotation) {
    const topBaseline = backwardsCompatibleTopBaseline ? "hanging" : "top";
    return sideFlag * parallelFlipFlag === -1 ? topBaseline : "bottom";
  }
  return "middle";
}
function getTextAlign(parallel, labelRotation, labelAutoRotation, sideFlag, regularFlipFlag) {
  const labelRotated = labelRotation > 0 && labelRotation <= Math.PI;
  const labelAutoRotated = labelAutoRotation > 0 && labelAutoRotation <= Math.PI;
  const alignFlag = labelRotated || labelAutoRotated ? -1 : 1;
  if (parallel) {
    if (labelRotation || labelAutoRotation) {
      if (sideFlag * alignFlag === -1) {
        return "end";
      }
    } else {
      return "center";
    }
  } else if (sideFlag * regularFlipFlag === -1) {
    return "end";
  }
  return "start";
}
function labelSpecifier(format, timeInterval) {
  if (format == null)
    return;
  if (typeof format === "string") {
    return format;
  } else if ((0, import_ag_charts_core47.isPlainObject)(format) && timeInterval != null) {
    return format[intervalUnit(timeInterval)];
  }
}
function timeIntervalMaxLabelSize(scale2, label, primaryLabel, domain, ticks, timeInterval, textMeasurer) {
  const specifier = labelSpecifier(label.format, timeInterval) ?? (typeof label.format === "string" ? label.format : void 0);
  const formatParams = {
    domain,
    ticks,
    fractionDigits: 0,
    specifier
  };
  const labelFormatter = scale2.tickFormatter(formatParams);
  const hierarchy = timeInterval ? intervalHierarchy(timeInterval) : void 0;
  const primarySpecifier = labelSpecifier(primaryLabel?.format, hierarchy);
  const primaryLabelFormatter = primarySpecifier ? scale2.tickFormatter({
    ...formatParams,
    specifier: primarySpecifier
  }) : labelFormatter;
  const d0 = new Date(domain[0]);
  const d1 = new Date(domain[domain.length - 1]);
  const hierarchyRange = hierarchy?.range(new Date(domain[0]), new Date(domain[domain.length - 1]), {
    extend: true
  });
  let maxWidth = 0;
  let maxHeight = 0;
  if (labelFormatter != null) {
    let l0;
    let l1;
    if (hierarchyRange != null && hierarchyRange.length > 1) {
      l0 = hierarchyRange[0];
      l1 = hierarchyRange[1];
    } else {
      l0 = d0;
      l1 = d1;
    }
    const labelRange = intervalRange(timeInterval, l0, l1, { limit: 50 });
    for (const date5 of labelRange) {
      const text = labelFormatter(date5);
      const { width: width2, height: height2 } = textMeasurer.measureLines(text);
      maxWidth = Math.max(maxWidth, width2);
      maxHeight = Math.max(maxHeight, height2);
    }
  }
  if (primaryLabelFormatter != null && hierarchyRange != null) {
    for (const date5 of hierarchyRange) {
      const text = primaryLabelFormatter(date5);
      const { width: width2, height: height2 } = textMeasurer.measureLines(text);
      maxWidth = Math.max(maxWidth, width2);
      maxHeight = Math.max(maxHeight, height2);
    }
  }
  return {
    width: Math.ceil(maxWidth),
    height: Math.ceil(maxHeight)
  };
}
function createLabelData(tickData, labelX, labelMatrix, textMeasurer) {
  const labelData = [];
  for (const { tickLabel: text, translationY } of tickData) {
    if (!text)
      continue;
    const { x, y } = labelMatrix.transformBBox(new BBox(labelX, translationY, 0, 0));
    const { width: width2, height: height2 } = textMeasurer.measureLines(text);
    labelData.push({
      point: { x, y },
      label: { text, width: width2, height: height2 }
    });
  }
  return labelData;
}
function createFixedLabelData({ width: width2, height: height2, spacing }, labelX, labelMatrix) {
  const labelData = [];
  for (const translationY of [0, spacing]) {
    const { x, y } = labelMatrix.transformBBox(new BBox(labelX, translationY, 0, 0));
    labelData.push({
      point: { x, y },
      label: { text: void 0, width: width2, height: height2 }
    });
  }
  return labelData;
}

// packages/ag-charts-community/src/chart/axis/axisGridLine.ts
var AxisGridLine = class {
  constructor() {
    this.enabled = true;
    this.width = 1;
    this.style = [
      {
        stroke: void 0,
        lineDash: []
      }
    ];
  }
};
__decorateClass([
  Property
], AxisGridLine.prototype, "enabled", 2);
__decorateClass([
  Property
], AxisGridLine.prototype, "width", 2);
__decorateClass([
  Property
], AxisGridLine.prototype, "style", 2);

// packages/ag-charts-community/src/chart/axis/axisInterval.ts
var AxisInterval = class extends BaseProperties {
};
__decorateClass([
  Property
], AxisInterval.prototype, "step", 2);
__decorateClass([
  Property
], AxisInterval.prototype, "values", 2);
__decorateClass([
  Property
], AxisInterval.prototype, "minSpacing", 2);
__decorateClass([
  Property
], AxisInterval.prototype, "maxSpacing", 2);

// packages/ag-charts-community/src/chart/axis/axisLabel.ts
var AxisLabel = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.spacing = 5;
    this.color = "#575757";
    this.avoidCollisions = true;
    this.mirrored = false;
    this.parallel = false;
  }
  /**
   * The side of the axis line to position the labels on.
   * -1 = left (default)
   * 1 = right
   */
  getSideFlag() {
    return this.mirrored ? 1 : -1;
  }
  getFont() {
    return TextUtils.toFontString(this);
  }
};
__decorateClass([
  Property
], AxisLabel.prototype, "enabled", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "fontStyle", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "fontWeight", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "fontSize", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "fontFamily", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "spacing", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "minSpacing", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "color", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "rotation", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "avoidCollisions", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "mirrored", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "parallel", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "itemStyler", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "formatter", 2);
__decorateClass([
  Property
], AxisLabel.prototype, "format", 2);

// packages/ag-charts-community/src/chart/axis/axisLine.ts
var AxisLine = class {
  constructor() {
    this.enabled = true;
    this.width = 1;
    this.stroke = void 0;
  }
};
__decorateClass([
  Property
], AxisLine.prototype, "enabled", 2);
__decorateClass([
  Property
], AxisLine.prototype, "width", 2);
__decorateClass([
  Property
], AxisLine.prototype, "stroke", 2);

// packages/ag-charts-community/src/chart/axis/axisTick.ts
var AxisTick = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.width = 1;
    this.size = 6;
  }
};
__decorateClass([
  Property
], AxisTick.prototype, "enabled", 2);
__decorateClass([
  Property
], AxisTick.prototype, "width", 2);
__decorateClass([
  Property
], AxisTick.prototype, "size", 2);
__decorateClass([
  Property
], AxisTick.prototype, "stroke", 2);

// packages/ag-charts-community/src/chart/axis/axisTitle.ts
var AxisTitle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.caption = new Caption();
    this.enabled = false;
    this.spacing = Caption.SMALL_PADDING;
    this.fontSize = 10;
    this.fontFamily = "sans-serif";
    this.wrapping = "always";
  }
};
__decorateClass([
  Property
], AxisTitle.prototype, "enabled", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "text", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "spacing", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "fontStyle", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "fontWeight", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "fontSize", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "fontFamily", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "color", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "wrapping", 2);
__decorateClass([
  Property
], AxisTitle.prototype, "formatter", 2);

// packages/ag-charts-community/src/chart/axis/axisUtil.ts
function prepareAxisAnimationContext(axis) {
  const [requestedRangeMin, requestedRangeMax] = findMinMax(axis.range);
  const min = Math.floor(requestedRangeMin);
  const max = Math.ceil(requestedRangeMax);
  return { min, max, visible: min !== max };
}
var fullCircle = Math.PI * 2;
var halfCircle = fullCircle / 2;
function normaliseEndRotation(start2, end2) {
  const directDistance = Math.abs(end2 - start2);
  if (directDistance < halfCircle) {
    return end2;
  } else if (start2 > end2) {
    return end2 + fullCircle;
  }
  return end2 - fullCircle;
}
function prepareAxisAnimationFunctions(ctx) {
  const { min, max } = ctx;
  const outOfBounds = (y) => {
    return y < min || y > max;
  };
  const tick = {
    fromFn(node, datum, status) {
      let { x1, x2, y1, y2 } = node;
      let opacity = node.opacity;
      if (status === "added" || outOfBounds(datum.offset)) {
        ({ x1, x2, y1, y2 } = datum);
        opacity = 0;
      }
      return {
        x1,
        x2,
        y1,
        y2,
        opacity,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]
      };
    },
    toFn(_node, datum, status) {
      const { x1, x2, y1, y2 } = datum;
      let opacity = 1;
      if (status === "removed") {
        opacity = 0;
      }
      return {
        x1,
        x2,
        y1,
        y2,
        opacity
      };
    },
    applyFn(node, props) {
      node.setProperties(props);
      node.visible = !outOfBounds(node.y);
    }
  };
  const label = {
    fromFn(node, newDatum, status) {
      const datum = node.previousDatum ?? newDatum;
      let { x, y, rotationCenterX, rotationCenterY, rotation } = datum;
      let opacity = node.opacity;
      if (status === "removed" || outOfBounds(datum.y)) {
        rotation = newDatum.rotation;
      } else if (status === "added" || outOfBounds(node.datum.y)) {
        ({ x, y, rotationCenterX, rotationCenterY, rotation } = newDatum);
        opacity = 0;
      }
      return {
        x,
        y,
        rotationCenterX,
        rotationCenterY,
        rotation,
        opacity,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]
      };
    },
    toFn(node, datum, status) {
      const { x, y, rotationCenterX, rotationCenterY } = datum;
      let rotation = 0;
      let opacity = 1;
      if (status === "added") {
        rotation = datum.rotation;
      } else if (status === "removed") {
        opacity = 0;
        rotation = datum.rotation;
      } else {
        rotation = normaliseEndRotation(node.previousDatum?.rotation ?? datum.rotation, datum.rotation);
      }
      return {
        x,
        y,
        rotationCenterX,
        rotationCenterY,
        rotation,
        opacity,
        finish: { rotation: datum.rotation }
      };
    }
  };
  const line = {
    fromFn(node, datum) {
      const { x1, x2, y1, y2 } = node.previousDatum ?? datum;
      return {
        x1,
        x2,
        y1,
        y2,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING["updated"]
      };
    },
    toFn(_node, datum) {
      const { x1, x2, y1, y2 } = datum;
      return { x1, x2, y1, y2 };
    }
  };
  const group = {
    fromFn(node, _datum) {
      const { translationX, translationY } = node;
      return {
        translationX,
        translationY,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING["updated"]
      };
    },
    toFn(_node, datum) {
      const { translationX, translationY } = datum;
      return {
        translationX,
        translationY
      };
    }
  };
  return { tick, line, label, group };
}
function resetAxisGroupFn() {
  return (_node, datum) => {
    return {
      translationX: datum.translationX,
      translationY: datum.translationY
    };
  };
}
function resetAxisLabelSelectionFn() {
  return (_node, datum) => {
    return {
      x: datum.x,
      y: datum.y,
      rotationCenterX: datum.rotationCenterX,
      rotationCenterY: datum.rotationCenterY,
      rotation: datum.rotation
    };
  };
}
function resetAxisLineSelectionFn() {
  return (_node, datum) => {
    const { x1, x2, y1, y2 } = datum;
    return { x1, x2, y1, y2 };
  };
}

// packages/ag-charts-community/src/chart/axis/timeFormatUtil.ts
var import_ag_charts_core48 = require("ag-charts-core");
var hardCodedTimeFormats = {
  millisecond: "%Y %b %e %H:%M:%S.%L",
  second: "%Y %b %e %H:%M:%S",
  minute: "%Y %b %e %H:%M",
  hour: "%Y %b %e %H:%M",
  day: "%Y %b %e",
  month: "%Y %b",
  year: "%Y"
};
var FORMAT_ORDERS = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5,
  millisecond: 6
};
var MILLISECOND_FORMAT = /%[-_0]?L/;
var SECOND_FORMAT = /%[-_0]?S/;
var MINUTE_FORMAT = /%[-_0]?M/;
var HOUR_FORMAT = /%[-_0]?[HI]/;
var DAY_FORMAT = /^%[-_0]?[de]$/;
var MONTH_FORMAT = /^%[-_0]?[Bbm]$/;
var YEAR_FORMAT = /^%[-_0]?[Yy]$/;
function deriveTimeSpecifier(format, timeInterval) {
  if (!(0, import_ag_charts_core48.isPlainObject)(format))
    return format;
  const unit = intervalUnit(timeInterval);
  const { millisecond: millisecond2, second: second2, minute: minute2, hour: hour2, day: day2, month: month2, year: year2 } = format;
  const formatOrder = FORMAT_ORDERS[unit];
  const hardcodedTimeFormat = hardCodedTimeFormats[unit];
  if (formatOrder >= FORMAT_ORDERS.year && !YEAR_FORMAT.test(year2) || formatOrder >= FORMAT_ORDERS.month && !MONTH_FORMAT.test(month2) || formatOrder >= FORMAT_ORDERS.day && !DAY_FORMAT.test(day2)) {
    return hardcodedTimeFormat;
  }
  let specifier;
  switch (unit) {
    case "year":
      return year2;
    case "month":
      return `${month2} ${year2}`;
    case "day":
      return `${month2} ${day2} ${year2}`;
    case "hour":
      specifier = hour2;
      break;
    case "minute":
      specifier = minute2;
      break;
    case "second":
      specifier = second2;
      break;
    case "millisecond":
      specifier = millisecond2;
      break;
    default:
      return hardcodedTimeFormat;
  }
  if (formatOrder >= FORMAT_ORDERS.hour && !HOUR_FORMAT.test(specifier) || formatOrder >= FORMAT_ORDERS.minute && !MINUTE_FORMAT.test(specifier) || formatOrder >= FORMAT_ORDERS.second && !SECOND_FORMAT.test(specifier) || formatOrder >= FORMAT_ORDERS.millisecond && !MILLISECOND_FORMAT.test(specifier)) {
    return hardcodedTimeFormat;
  }
  return `${specifier} ${month2} ${day2} ${year2}`;
}

// packages/ag-charts-community/src/chart/axis/axis.ts
var TranslatableLine = class extends Translatable(Line) {
};
var _Axis = class _Axis {
  constructor(moduleCtx, scale2) {
    this.moduleCtx = moduleCtx;
    this.scale = scale2;
    this.id = (0, import_ag_charts_core49.createId)(this);
    this.nice = true;
    this.reverse = false;
    this.keys = [];
    this.interval = new AxisInterval();
    this.dataDomain = { domain: [], clipped: false };
    this.layoutConstraints = {
      stacked: true,
      align: "start",
      width: 100,
      unit: "percent"
    };
    this.boundSeries = [];
    this.includeInvisibleDomains = false;
    this.interactionEnabled = true;
    this.axisGroup = new Group({ name: `${this.id}-axis` });
    // Order is important to apply the correct z-index.
    this.tickLineGroup = this.axisGroup.appendChild(
      new TransformableGroup({ name: `${this.id}-Axis-tick-lines`, zIndex: 0 /* TickLines */ })
    );
    this.tickLabelGroup = this.axisGroup.appendChild(
      new TransformableGroup({ name: `${this.id}-Axis-tick-labels`, zIndex: 2 /* TickLabels */ })
    );
    this.labelGroup = new Group({
      name: `${this.id}-Labels`,
      zIndex: 9 /* SERIES_ANNOTATION */
    });
    this.gridGroup = new TranslatableGroup({ name: `${this.id}-Axis-grid`, zIndex: 1 /* AXIS_GRID */ });
    this.gridLineGroup = this.gridGroup.appendChild(new Group({ name: `${this.id}-gridLines` }));
    this.crossLineRangeGroup = new TransformableGroup({
      name: `${this.id}-CrossLines-Range`,
      zIndex: 4 /* SERIES_CROSSLINE_RANGE */
    });
    this.crossLineLineGroup = new TransformableGroup({
      name: `${this.id}-CrossLines-Line`,
      zIndex: 8 /* SERIES_CROSSLINE_LINE */
    });
    this.crossLineLabelGroup = new TransformableGroup({
      name: `${this.id}-CrossLines-Label`,
      zIndex: 13 /* SERIES_LABEL */
    });
    this.tickLabelGroupSelection = Selection.select(
      this.tickLabelGroup,
      TransformableText,
      false
    );
    this._crossLines = [];
    this.line = new AxisLine();
    this.tick = new AxisTick();
    this.gridLine = new AxisGridLine();
    this.label = this.createLabel();
    this.defaultTickMinSpacing = _Axis.defaultTickMinSpacing;
    this.translation = { x: 0, y: 0 };
    this.layout = {
      label: {
        fractionDigits: 0,
        spacing: this.label.spacing,
        format: this.label.format
      }
    };
    this.axisContext = void 0;
    this.labelFormatter = void 0;
    this.datumFormatter = void 0;
    this.scaleFormatterParams = void 0;
    this.destroyFns = [];
    this.range = [0, 1];
    this.visibleRange = [0, 1];
    this.title = new AxisTitle();
    this.gridLength = 0;
    /**
     * The distance between the grid ticks and the axis ticks.
     */
    this.gridPadding = 0;
    /**
     * Is used to avoid collisions between axis labels and series.
     */
    this.seriesAreaPadding = 0;
    this.animatable = true;
    this._cachedUnzoomedInputDomain = void 0;
    this._cachedUnzoomedRangeExtent = NaN;
    this._cachedUnzoomedTickCount = 0;
    this.moduleMap = new ModuleMap();
    this.range = this.scale.range.slice();
    this.crossLines.forEach((crossLine) => this.initCrossLine(crossLine));
  }
  get type() {
    return this.constructor.type ?? "";
  }
  get labelNodes() {
    return this.tickLabelGroupSelection.nodes();
  }
  set crossLines(value) {
    const { CrossLineConstructor } = this.constructor;
    this._crossLines.forEach((crossLine) => this.detachCrossLine(crossLine));
    this._crossLines = value.map((crossLine) => {
      const instance = new CrossLineConstructor();
      instance.set(crossLine);
      return instance;
    });
    this._crossLines.forEach((crossLine) => {
      this.attachCrossLine(crossLine);
      this.initCrossLine(crossLine);
    });
  }
  get crossLines() {
    return this._crossLines;
  }
  resetAnimation(_phase) {
  }
  attachCrossLine(crossLine) {
    this.crossLineRangeGroup.appendChild(crossLine.rangeGroup);
    this.crossLineLineGroup.appendChild(crossLine.lineGroup);
    this.crossLineLabelGroup.appendChild(crossLine.labelGroup);
  }
  detachCrossLine(crossLine) {
    this.crossLineRangeGroup.removeChild(crossLine.rangeGroup);
    this.crossLineLineGroup.removeChild(crossLine.lineGroup);
    this.crossLineLabelGroup.removeChild(crossLine.labelGroup);
  }
  destroy() {
    this.moduleMap.destroy();
    this.destroyFns.forEach((f) => f());
  }
  updateScale() {
    const { range: rr, visibleRange: vr, scale: scale2 } = this;
    const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);
    const shift = span * vr[0];
    const start2 = rr[0] - shift;
    scale2.range = [start2, start2 + span];
    this.crossLines.forEach((crossLine) => {
      crossLine.clippedRange = [rr[0], rr[1]];
    });
  }
  setCrossLinesVisible(visible) {
    this.crossLineRangeGroup.visible = visible;
    this.crossLineLineGroup.visible = visible;
    this.crossLineLabelGroup.visible = visible;
  }
  attachAxis(groups) {
    groups.gridNode.appendChild(this.gridGroup);
    groups.axisNode.appendChild(this.axisGroup);
    groups.labelNode.appendChild(this.labelGroup);
    groups.crossLineRangeNode.appendChild(this.crossLineRangeGroup);
    groups.crossLineLineNode.appendChild(this.crossLineLineGroup);
    groups.crossLineLabelNode.appendChild(this.crossLineLabelGroup);
  }
  detachAxis(groups) {
    groups.gridNode.removeChild(this.gridGroup);
    groups.axisNode.removeChild(this.axisGroup);
    groups.labelNode.removeChild(this.labelGroup);
    groups.crossLineRangeNode.removeChild(this.crossLineRangeGroup);
    groups.crossLineLineNode.removeChild(this.crossLineLineGroup);
    groups.crossLineLabelNode.removeChild(this.crossLineLabelGroup);
  }
  attachLabel(axisLabelNode) {
    this.labelGroup.append(axisLabelNode);
  }
  /**
   * Checks if a point or an object is in range.
   * @param value A point (or object's starting point).
   * @param tolerance Expands the range on both ends by this amount.
   */
  inRange(value, tolerance = 0) {
    const [min, max] = findMinMax(this.range);
    return value >= min - tolerance && value <= max + tolerance;
  }
  /**
   * Get a point's overflow on the range, expanded to include the non-visible range.
   * @param value Point
   * @returns Overflow
   */
  getRangeOverflow(value) {
    const { range: rr, visibleRange: vr } = this;
    const size = (rr[1] - rr[0]) / (vr[1] - vr[0]);
    const [min, max] = findMinMax([rr[0] - size * vr[0], rr[0] - size * vr[0] + size]);
    if (value < min)
      return value - min;
    if (value > max)
      return value - max;
    return 0;
  }
  defaultDatumFormatter(datum, fractionDigits) {
    return formatValue(datum, fractionDigits + 1);
  }
  defaultLabelFormatter(datum, fractionDigits) {
    return formatValue(datum, fractionDigits);
  }
  onGridLengthChange(value, prevValue) {
    if (prevValue ^ value) {
      this.onGridVisibilityChange();
    }
    this.crossLines.forEach((crossLine) => this.initCrossLine(crossLine));
  }
  onGridVisibilityChange() {
  }
  createLabel() {
    return new AxisLabel();
  }
  /**
   * Creates/removes/updates the scene graph nodes that constitute the axis.
   */
  update() {
    this.updatePosition();
    this.updateSelections();
    this.tickLineGroup.visible = this.tick.enabled;
    this.gridLineGroup.visible = this.gridLine.enabled;
    this.tickLabelGroup.visible = this.label.enabled;
    this.updateLabels();
    this.updateCrossLines();
  }
  getLabelStyles(params, additionalStyles, label = this.label) {
    const defaultStyle = {
      color: label.color,
      spacing: label.spacing,
      fontFamily: label.fontFamily,
      fontSize: label.fontSize,
      fontStyle: label.fontStyle,
      fontWeight: label.fontWeight
    };
    let stylerOutput;
    if (label.itemStyler) {
      stylerOutput = this.callWithContext(label.itemStyler, {
        ...params,
        ...defaultStyle
      });
    }
    const {
      color: fill,
      fontFamily,
      fontSize,
      fontStyle,
      fontWeight,
      spacing
    } = mergeDefaults(stylerOutput, additionalStyles, defaultStyle);
    return { fill, fontFamily, fontSize, fontStyle, fontWeight, spacing };
  }
  getTickSize(tick = this.tick) {
    return tick.enabled ? tick.size : 0;
  }
  processData() {
    const { includeInvisibleDomains, boundSeries, direction } = this;
    const visibleSeries = includeInvisibleDomains ? boundSeries : boundSeries.filter((s) => s.isEnabled());
    const domains = visibleSeries.map((series) => series.getDomain(direction));
    this.setDomains(...domains);
  }
  setDomains(...domains) {
    let domain;
    let animatable;
    if (domains.length > 0) {
      ({ domain, animatable } = this.scale.normalizeDomains(...domains));
    } else {
      domain = [];
      animatable = true;
    }
    this.dataDomain = this.normaliseDataDomain(domain);
    if (this.reverse) {
      this.dataDomain.domain.reverse();
    }
    this.animatable = animatable;
  }
  calculateLayout(initialPrimaryTickCount, chartPadding) {
    const { scale: scale2, label, visibleRange, nice } = this;
    this.chartPadding = chartPadding;
    this.updateScale();
    const rangeExtent = findRangeExtent(this.range);
    const domain = this.dataDomain.domain;
    let tickLayoutDomain;
    let unzoomedTickCount;
    if (visibleRange[0] === 0 && visibleRange[1] === 1) {
      tickLayoutDomain = void 0;
      unzoomedTickCount = void 0;
    } else if (this._cachedUnzoomedInputDomain === domain && this._cachedUnzoomedRangeExtent === rangeExtent) {
      tickLayoutDomain = this.scale.domain;
      unzoomedTickCount = this._cachedUnzoomedTickCount;
    } else {
      const unzoomedTickLayout = this.calculateTickLayout(
        domain,
        nice ? 0 /* TickAndDomain */ : 2 /* Off */,
        [0, 1]
      );
      tickLayoutDomain = unzoomedTickLayout.niceDomain;
      unzoomedTickCount = unzoomedTickLayout.rawTickCount ?? 0;
    }
    let niceMode;
    if (!nice) {
      niceMode = 2 /* Off */;
    } else if (tickLayoutDomain == null) {
      niceMode = 0 /* TickAndDomain */;
    } else {
      niceMode = 1 /* TicksOnly */;
    }
    const {
      niceDomain,
      ticks,
      rawTickCount = 0,
      tickDomain,
      fractionDigits,
      bbox
    } = this.calculateTickLayout(tickLayoutDomain ?? domain, niceMode, visibleRange, initialPrimaryTickCount);
    unzoomedTickCount ?? (unzoomedTickCount = rawTickCount);
    const primaryTickCount = rawTickCount !== 0 && unzoomedTickCount !== 0 ? { zoomed: rawTickCount, unzoomed: unzoomedTickCount } : void 0;
    const timeInterval = UnitTimeScale.is(scale2) ? scale2.interval : void 0;
    this.scale.domain = niceDomain;
    this._cachedUnzoomedInputDomain = domain;
    this._cachedUnzoomedRangeExtent = rangeExtent;
    this._cachedUnzoomedTickCount = unzoomedTickCount;
    const specifier = labelSpecifier(
      timeInterval == null ? label.format : deriveTimeSpecifier(label.format, timeInterval),
      timeInterval
    );
    this.labelFormatter = scale2.tickFormatter({ domain: tickDomain, specifier, ticks, fractionDigits }) ?? ((value) => this.defaultLabelFormatter(value, fractionDigits));
    this.datumFormatter = scale2.datumFormatter({ domain: tickDomain, specifier, ticks, fractionDigits }) ?? ((value) => this.defaultDatumFormatter(value, fractionDigits));
    this.scaleFormatterParams = { domain: tickDomain, ticks, fractionDigits };
    this.layout.label = {
      fractionDigits,
      spacing: this.label.spacing,
      format: this.label.format
    };
    this.layoutCrossLines();
    return { primaryTickCount, bbox };
  }
  updateCrossLines() {
    const anySeriesActive = this.isAnySeriesActive();
    this.crossLines.forEach((crossLine) => {
      crossLine.update(anySeriesActive);
    });
  }
  updatePosition() {
    const { crossLineRangeGroup, crossLineLineGroup, crossLineLabelGroup, gridGroup, translation } = this;
    const translationX = Math.floor(translation.x);
    const translationY = Math.floor(translation.y);
    gridGroup.setProperties({ translationX, translationY });
    crossLineRangeGroup.setProperties({ translationX, translationY });
    crossLineLineGroup.setProperties({ translationX, translationY });
    crossLineLabelGroup.setProperties({ translationX, translationY });
  }
  // For formatting (nice rounded) tick values.
  formatTick(value, index, domain, fractionDigits, timeInterval, defaultFormatter) {
    const {
      labelFormatter,
      label: { formatter }
    } = this;
    let result;
    if (formatter) {
      const boundSeries = this.getFormatterBoundSeries();
      const unit = timeInterval ? intervalUnit(timeInterval) : void 0;
      const step = timeInterval ? intervalStep(timeInterval) : void 0;
      result = this.callWithContext(formatter, {
        value,
        index,
        domain,
        fractionDigits,
        unit,
        step,
        boundSeries
      });
    } else if (defaultFormatter) {
      result = defaultFormatter(value);
    } else if (labelFormatter) {
      result = labelFormatter(value);
    }
    return String(result ?? value);
  }
  // For formatting arbitrary values between the ticks.
  formatDatum(value) {
    const {
      label: { formatter },
      datumFormatter: valueFormatter = this.labelFormatter
    } = this;
    let result;
    if (formatter) {
      const { domain } = this.scale;
      const boundSeries = this.getFormatterBoundSeries();
      result = this.callWithContext(formatter, { value, index: NaN, domain, boundSeries });
    } else if (valueFormatter) {
      result = this.callWithContext(valueFormatter, value);
    } else if ((0, import_ag_charts_core49.isArray)(value)) {
      result = value.filter(Boolean).join(" - ");
    }
    return String(result ?? value);
  }
  getScaleValueFormatter(format) {
    const { scaleFormatterParams } = this;
    let formatter;
    try {
      if (format != null && scaleFormatterParams != null) {
        formatter = this.scale.tickFormatter({ ...scaleFormatterParams, specifier: format });
      }
    } catch {
      import_ag_charts_core49.Logger.warnOnce(`the format string ${format} is invalid, ignoring.`);
    }
    formatter ?? (formatter = (value) => this.formatDatum(value));
    return formatter;
  }
  getBBox() {
    return this.axisGroup.getBBox();
  }
  initCrossLine(crossLine) {
    crossLine.scale = this.scale;
    crossLine.gridLength = this.gridLength;
  }
  isAnySeriesActive() {
    return this.boundSeries.some((s) => this.includeInvisibleDomains || s.isEnabled());
  }
  clipTickLines(x, y, width2, height2) {
    this.tickLineGroup.setClipRect(new BBox(x, y, width2, height2));
  }
  clipGrid(x, y, width2, height2) {
    this.gridGroup.setClipRect(new BBox(x, y, width2, height2));
  }
  getFormatterBoundSeries() {
    const { direction } = this;
    const boundSeries = [];
    for (const series of this.boundSeries) {
      const keys = series.getKeys(direction);
      const names = series.getNames(direction);
      for (let idx = 0; idx < keys.length; idx++) {
        boundSeries.push({ key: keys[idx], name: names[idx] });
      }
    }
    return boundSeries;
  }
  getTitleFormatterParams(domain) {
    const { direction } = this;
    const boundSeries = this.getFormatterBoundSeries();
    return { domain, direction, boundSeries, defaultValue: this.title?.text };
  }
  normaliseDataDomain(d) {
    return { domain: [...d], clipped: false };
  }
  getLayoutState() {
    return {
      id: this.id,
      rect: this.getBBox(),
      gridPadding: this.gridPadding,
      seriesAreaPadding: this.seriesAreaPadding,
      tickSize: this.getTickSize(),
      direction: this.direction,
      domain: this.dataDomain.domain,
      scale: this.scale,
      ...this.layout
    };
  }
  getModuleMap() {
    return this.moduleMap;
  }
  createModuleContext() {
    this.axisContext ?? (this.axisContext = this.createAxisContext());
    return { ...this.moduleCtx, parent: this.axisContext };
  }
  createAxisContext() {
    const { scale: scale2 } = this;
    return {
      axisId: this.id,
      scale: this.scale,
      direction: this.direction,
      continuous: ContinuousScale.is(scale2) || DiscreteTimeScale.is(scale2),
      getCanvasBounds: () => {
        return Transformable.toCanvas(this.axisGroup);
      },
      seriesKeyProperties: () => this.boundSeries.reduce((keys, series) => {
        const seriesKeys = series.getKeyProperties(this.direction);
        seriesKeys.forEach((key) => keys.add(key));
        return keys;
      }, /* @__PURE__ */ new Set()),
      seriesIds: () => this.boundSeries.map((series) => series.id),
      scaleValueFormatter: (specifier) => this.getScaleValueFormatter(specifier),
      scaleInvert: (val) => scale2.invert(val, true),
      scaleInvertNearest: (val) => scale2.invert(val, true),
      attachLabel: (node) => this.attachLabel(node),
      inRange: (value, tolerance) => this.inRange(value, tolerance),
      getRangeOverflow: (value) => this.getRangeOverflow(value)
    };
  }
  isReversed() {
    return this.reverse;
  }
  callWithContext(fn, ...params) {
    const { callbackCache, chartService } = this.moduleCtx;
    return callbackCache.call(this, chartService, fn, ...params);
  }
};
_Axis.defaultTickMinSpacing = 50;
_Axis.CrossLineConstructor = CartesianCrossLine;
__decorateClass([
  Property
], _Axis.prototype, "nice", 2);
__decorateClass([
  Property
], _Axis.prototype, "reverse", 2);
__decorateClass([
  Property
], _Axis.prototype, "keys", 2);
__decorateClass([
  Property
], _Axis.prototype, "interval", 2);
__decorateClass([
  Property
], _Axis.prototype, "title", 2);
__decorateClass([
  ObserveChanges((target, value, oldValue) => target.onGridLengthChange(value, oldValue))
], _Axis.prototype, "gridLength", 2);
var Axis = _Axis;

// packages/ag-charts-community/src/chart/axis/axisTickGenerator.ts
var import_ag_charts_core51 = require("ag-charts-core");

// packages/ag-charts-community/src/scene/util/labelPlacement.ts
function circleRectOverlap(c, unitCenter, x, y, w, h) {
  if (c.size === 0) {
    return false;
  }
  let cx = c.x;
  let cy = c.y;
  if (unitCenter != null) {
    cx -= (unitCenter.x - 0.5) * c.size;
    cy -= (unitCenter.y - 0.5) * c.size;
  }
  let edgeX = cx;
  if (cx < x) {
    edgeX = x;
  } else if (cx > x + w) {
    edgeX = x + w;
  }
  let edgeY = cy;
  if (cy < y) {
    edgeY = y;
  } else if (cy > y + h) {
    edgeY = y + h;
  }
  const dx = cx - edgeX;
  const dy = cy - edgeY;
  const d = Math.sqrt(dx * dx + dy * dy);
  return d <= c.size * 0.5;
}
function rectRectOverlap(r1, x2, y2, w2, h2) {
  const xOverlap = r1.x + r1.width > x2 && r1.x < x2 + w2;
  const yOverlap = r1.y + r1.height > y2 && r1.y < y2 + h2;
  return xOverlap && yOverlap;
}
function rectContainsRect(r1, r2x, r2y, r2w, r2h) {
  return r2x + r2w < r1.x + r1.width && r2x > r1.x && r2y > r1.y && r2y + r2h < r1.y + r1.height;
}
function isPointLabelDatum(x) {
  return x != null && typeof x.point === "object" && typeof x.label === "object";
}
var labelPlacements = {
  top: { x: 0, y: -1 },
  bottom: { x: 0, y: 1 },
  left: { x: -1, y: 0 },
  right: { x: 1, y: 0 },
  "top-left": { x: -1, y: -1 },
  "top-right": { x: 1, y: -1 },
  "bottom-left": { x: -1, y: 1 },
  "bottom-right": { x: 1, y: 1 }
};
function placeLabels(data, bounds, padding = 5) {
  const result = /* @__PURE__ */ new Map();
  const previousResults = [];
  const sortedDataClone = new Map(
    [...data.entries()].map(([k, d]) => [k, d.toSorted((a, b) => b.point.size - a.point.size)])
  );
  const dataValues = [...sortedDataClone.values()].flat();
  for (const [seriesId, datums] of sortedDataClone.entries()) {
    const labels = [];
    if (!datums[0]?.label)
      continue;
    for (let index = 0, ln = datums.length; index < ln; index++) {
      const d = datums[index];
      const { point, label, anchor } = d;
      const { text, width: width2, height: height2 } = label;
      const r = point.size * 0.5;
      let dx = 0;
      let dy = 0;
      if (r > 0 && d.placement != null) {
        const placement = labelPlacements[d.placement];
        dx = (width2 * 0.5 + r + padding) * placement.x;
        dy = (height2 * 0.5 + r + padding) * placement.y;
      }
      const x = point.x - width2 * 0.5 + dx - ((anchor?.x ?? 0.5) - 0.5) * point.size;
      const y = point.y - height2 * 0.5 + dy - ((anchor?.y ?? 0.5) - 0.5) * point.size;
      const withinBounds = !bounds || rectContainsRect(bounds, x, y, width2, height2);
      if (!withinBounds)
        continue;
      const overlapPoints = dataValues.some(
        (dataDatum) => circleRectOverlap(dataDatum.point, dataDatum.anchor, x, y, width2, height2)
      );
      if (overlapPoints)
        continue;
      const overlapLabels = previousResults.some((pr) => rectRectOverlap(pr, x, y, width2, height2));
      if (overlapLabels)
        continue;
      const resultDatum = { index, text, x, y, width: width2, height: height2, datum: d };
      labels.push(resultDatum);
      previousResults.push(resultDatum);
    }
    result.set(seriesId, labels);
  }
  return result;
}
function axisLabelsOverlap(data, padding = 0) {
  const result = [];
  for (let index = 0; index < data.length; index++) {
    const datum = data[index];
    const {
      point: { x, y },
      label: { text }
    } = datum;
    let { width: width2, height: height2 } = datum.label;
    width2 += padding;
    height2 += padding;
    if (result.some((l) => rectRectOverlap(l, x, y, width2, height2))) {
      return true;
    }
    result.push({ index, text, x, y, width: width2, height: height2, datum });
  }
  return false;
}

// packages/ag-charts-community/src/util/secondaryAxisTicks.ts
var import_ag_charts_core50 = require("ag-charts-core");
function calculateNiceSecondaryAxis(scale2, domain, primaryTickCount, reverse, visibleRange) {
  let [d0, d1] = findMinMax(domain.map(Number));
  const unzoomedTickCount = Math.floor(primaryTickCount.unzoomed);
  if (unzoomedTickCount <= 1) {
    const [start3, stop2] = domainWithOddTickCount(d0, d1);
    const tickCount = 5 * Math.pow(2, -Math.ceil(Math.log2(visibleRange[1] - visibleRange[0])));
    const { ticks: ticks2 } = createTicks(start3, stop2, tickCount, void 0, void 0, visibleRange);
    const d2 = [scale2.toDomain(start3), scale2.toDomain(stop2)];
    if (reverse)
      d2.reverse();
    return { domain: d2, ticks: ticks2 };
  }
  if (d0 === d1) {
    const order = Math.floor(Math.log10(d0));
    const magnitude = Math.pow(10, order);
    const rangeOffsetStep = Math.min(magnitude, 1);
    const rangeOffset = unzoomedTickCount - 1;
    d0 -= rangeOffsetStep * Math.floor(rangeOffset / 2);
    d1 = d0 + rangeOffsetStep * rangeOffset;
  }
  let start2 = d0;
  let stop = d1;
  start2 = calculateNiceStart(start2, stop, unzoomedTickCount);
  const baseStep = getTickStep(start2, stop, unzoomedTickCount);
  const segments = unzoomedTickCount - 1;
  stop = start2 + segments * baseStep;
  const stepAlignedStart = Math.floor(start2 / baseStep) * baseStep;
  const stepAlignedStop = Math.floor(stop / baseStep) * baseStep;
  if (stepAlignedStart <= d0 && stepAlignedStop >= d1) {
    start2 = stepAlignedStart;
    stop = stepAlignedStop;
  }
  const d = [scale2.toDomain(start2), scale2.toDomain(stop)];
  if (reverse)
    d.reverse();
  const step = baseStep * ((primaryTickCount.unzoomed - 1) / (primaryTickCount.zoomed - 1));
  const ticks = getTicks(start2, step, Math.floor(primaryTickCount.zoomed));
  return { domain: d, ticks };
}
function domainWithOddTickCount(d0, d1) {
  let start2 = d0;
  let stop = d1;
  let iterations = 0;
  do {
    [start2, stop] = niceTicksDomain(start2, stop);
    const { ticks } = createTicks(start2, stop, 5);
    if (ticks.length % 2 === 1)
      return [start2, stop];
    start2 -= 1;
    stop += 1;
  } while (iterations++ < 10);
  return [d0, d1];
}
function calculateNiceStart(a, b, count) {
  a = Math.floor(a);
  const rawStep = Math.abs(b - a) / (count - 1);
  const order = Math.floor(Math.log10(rawStep));
  const magnitude = Math.pow(10, order);
  return Math.floor(a / magnitude) * magnitude;
}
function getTicks(start2, step, count) {
  const fractionDigits = (0, import_ag_charts_core50.countFractionDigits)(step);
  const f = Math.pow(10, fractionDigits);
  const ticks = [];
  for (let i = 0; i < count; i++) {
    const tick = start2 + step * i;
    ticks.push(Math.round(tick * f) / f);
  }
  return ticks;
}
function getTickStep(start2, stop, count) {
  const segments = count - 1;
  const rawStep = (stop - start2) / segments;
  return calculateNextNiceStep(rawStep);
}
function calculateNextNiceStep(rawStep) {
  const order = Math.floor(Math.log10(rawStep));
  const magnitude = Math.pow(10, order);
  const step = rawStep / magnitude;
  if (step > 0 && step <= 1)
    return magnitude;
  if (step > 1 && step <= 2)
    return 2 * magnitude;
  if (step > 2 && step <= 5)
    return 5 * magnitude;
  if (step > 5 && step <= 10)
    return 10 * magnitude;
  return rawStep;
}

// packages/ag-charts-community/src/util/tempUtils.ts
function createIdsGenerator() {
  const idsCounter = /* @__PURE__ */ new Map();
  return (name) => {
    const counter = idsCounter.get(name);
    if (counter) {
      idsCounter.set(name, counter + 1);
      return `${name}_${counter}`;
    }
    idsCounter.set(name, 1);
    return name;
  };
}

// packages/ag-charts-community/src/chart/axis/axisTickGenerator.ts
function ticksSpacing(ticks) {
  if (ticks.length < 2)
    return Infinity;
  let spacing = 0;
  let y0 = ticks[0].translationY;
  for (let i = 1; i < ticks.length; i++) {
    const y1 = ticks[i].translationY;
    const delta3 = Math.abs(y1 - y0);
    spacing = Math.max(spacing, delta3);
    y0 = y1;
  }
  return spacing;
}
var AxisTickGenerator = class {
  constructor(axis) {
    this.axis = axis;
  }
  estimateTickCount(visibleRange, minSpacing, maxSpacing) {
    const { scale: scale2, range: range3, defaultTickMinSpacing } = this.axis;
    const defaultTickCount = UnitTimeScale.is(scale2) ? UnitTimeScale.defaultTickCount : ContinuousScale.defaultTickCount;
    return estimateTickCount(
      findRangeExtent(range3),
      findRangeExtent(visibleRange),
      minSpacing,
      maxSpacing,
      defaultTickCount,
      defaultTickMinSpacing
    );
  }
  filterTicks(ticks, tickCount) {
    const { minSpacing, maxSpacing } = this.axis.interval;
    const tickSpacing = minSpacing != null || maxSpacing != null;
    const keepEvery = tickSpacing ? Math.ceil(ticks.length / tickCount) : 2;
    const offset4 = ticks.length % keepEvery ? -1 : 0;
    return ticks.filter((_, i) => (i + offset4) % keepEvery === 0);
  }
  generateTicks({
    domain,
    primaryTickCount,
    visibleRange,
    niceMode,
    parallelFlipRotation,
    regularFlipRotation,
    labelX,
    sideFlag,
    removeOverflowLabels,
    removeOverflowThreshold = 0
  }) {
    const {
      scale: scale2,
      label,
      primaryLabel,
      interval: { minSpacing, maxSpacing }
    } = this.axis;
    const { parallel, fontFamily, fontSize, fontStyle, fontWeight } = label;
    const secondaryAxis = primaryTickCount !== void 0;
    const { defaultRotation, configuredRotation, parallelFlipFlag, regularFlipFlag } = calculateLabelRotation(
      label.rotation,
      parallel,
      regularFlipRotation,
      parallelFlipRotation
    );
    const { maxTickCount } = this.estimateTickCount(visibleRange, minSpacing, maxSpacing);
    const continuous = ContinuousScale.is(scale2) || DiscreteTimeScale.is(scale2);
    const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;
    let textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);
    const textBaseline = getTextBaseline(
      parallel,
      configuredRotation,
      sideFlag,
      parallelFlipFlag,
      primaryLabel == null
    );
    const font2 = TextUtils.toFontString({ fontFamily, fontSize, fontStyle, fontWeight });
    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font: font2 });
    const textProps = {
      fontFamily,
      fontSize,
      fontStyle,
      fontWeight,
      textBaseline,
      textAlign
    };
    const checkLabelOverlap = label.enabled && label.avoidCollisions;
    const initialRotation = configuredRotation + defaultRotation;
    const labelMatrix = new Matrix();
    const updateLabelMatrix = (iterationRotation) => {
      const labelRotation = initialRotation + iterationRotation;
      Matrix.updateTransformMatrix(labelMatrix, 1, 1, labelRotation, 0, 0);
    };
    const getLabelData = ({ ticks }, iterationRotation) => {
      updateLabelMatrix(iterationRotation);
      return createLabelData(ticks, labelX, labelMatrix, textMeasurer);
    };
    const getTimeLabelData = (tickData2, iterationRotation) => {
      const { niceDomain, ticks, rawTicks, timeInterval } = tickData2;
      if (timeInterval == null)
        return [];
      updateLabelMatrix(iterationRotation);
      const spacing = ticksSpacing(ticks);
      const { width: width2, height: height2 } = timeIntervalMaxLabelSize(
        scale2,
        label,
        primaryLabel,
        niceDomain ?? domain,
        rawTicks,
        timeInterval,
        textMeasurer
      );
      return createFixedLabelData({ width: width2, height: height2, spacing }, labelX, labelMatrix);
    };
    const getLabelOverlap = (tickData2, iterationRotation) => {
      if (!checkLabelOverlap)
        return false;
      const rotated = configuredRotation !== 0 || iterationRotation !== 0;
      const labelSpacing = getLabelSpacing(label.minSpacing, rotated);
      const overlap = axisLabelsOverlap(getTimeLabelData(tickData2, iterationRotation), labelSpacing) || axisLabelsOverlap(getLabelData(tickData2, iterationRotation), labelSpacing);
      return overlap;
    };
    let tickData = {
      tickDomain: [],
      ticks: [],
      rawTicks: [],
      rawTickCount: void 0,
      timeInterval: void 0,
      fractionDigits: 0,
      niceDomain: void 0
    };
    let index = 0;
    let autoRotation = 0;
    let labelOverlap = true;
    let terminate = false;
    while (!terminate && labelOverlap && index <= maxIterations) {
      autoRotation = 0;
      for (const strategy of this.getTickStrategies({ domain, niceMode, secondaryAxis, index })) {
        ({ tickData, index, autoRotation, terminate } = strategy({
          index,
          tickData,
          textProps,
          terminate,
          primaryTickCount,
          visibleRange,
          labelsOverlap() {
            return getLabelOverlap(tickData, autoRotation);
          }
        }));
      }
      labelOverlap = getLabelOverlap(tickData, autoRotation);
    }
    textAlign = getTextAlign(parallel, configuredRotation, autoRotation, sideFlag, regularFlipFlag);
    const rotation = configuredRotation + autoRotation;
    if (removeOverflowLabels && tickData.ticks.length > 2) {
      const labelData = getLabelData(tickData, autoRotation);
      const lastTick = tickData.ticks.at(-1);
      const lastLabel = labelData.at(-1);
      if (lastTick != null && lastLabel != null && lastTick.translationY + lastLabel.label.width / 2 > this.axis.range[1] + removeOverflowThreshold) {
        lastTick.tickLabel = void 0;
        const firstTick = tickData.ticks[0];
        if (firstTick.translationY === 0 && visibleRange[0] === 0 && visibleRange[1] === 1) {
          firstTick.tickLabel = void 0;
        }
      }
    }
    return { tickData, rotation, textBaseline, textAlign };
  }
  getTickStrategies({
    domain,
    niceMode,
    index: iteration,
    secondaryAxis
  }) {
    const { scale: scale2, label, interval } = this.axis;
    const { minSpacing } = interval;
    const continuous = ContinuousScale.is(scale2) || DiscreteTimeScale.is(scale2);
    const avoidLabelCollisions = label.enabled && label.avoidCollisions;
    const filterTicks = !continuous && iteration !== 0 && avoidLabelCollisions;
    const autoRotate = label.autoRotate === true && label.rotation === void 0;
    const strategies = [];
    let tickGenerationType;
    if (interval.values) {
      tickGenerationType = 3 /* VALUES */;
    } else if (secondaryAxis) {
      tickGenerationType = 1 /* CREATE_SECONDARY */;
    } else if (filterTicks) {
      tickGenerationType = 2 /* FILTER */;
    } else {
      tickGenerationType = 0 /* CREATE */;
    }
    const tickGenerationStrategy = ({
      index,
      tickData,
      primaryTickCount,
      visibleRange,
      terminate
    }) => this.createTickData(
      domain,
      niceMode,
      visibleRange,
      primaryTickCount,
      tickGenerationType,
      index,
      tickData,
      terminate
    );
    strategies.push(tickGenerationStrategy);
    if (!continuous && minSpacing != null) {
      const tickFilterStrategy = ({
        index,
        tickData,
        primaryTickCount,
        visibleRange,
        terminate
      }) => this.createTickData(
        domain,
        niceMode,
        visibleRange,
        primaryTickCount,
        2 /* FILTER */,
        index,
        tickData,
        terminate
      );
      strategies.push(tickFilterStrategy);
    }
    if (avoidLabelCollisions && autoRotate) {
      const autoRotateStrategy = ({ index, tickData, labelsOverlap, terminate }) => ({
        index,
        tickData,
        autoRotation: labelsOverlap() ? normalizeAngle360FromDegrees(label.autoRotateAngle) : 0,
        terminate
      });
      strategies.push(autoRotateStrategy);
    }
    return strategies;
  }
  ticksEqual(a, b) {
    if (a.length !== b.length)
      return false;
    for (let i = 0; i < a.length; i += 1) {
      if (a[i]?.valueOf() !== b[i]?.valueOf())
        return false;
    }
    return true;
  }
  createTickData(domain, niceMode, visibleRange, primaryTickCount, tickGenerationType, index, tickData, terminate) {
    const { scale: scale2, interval } = this.axis;
    const { step, values, minSpacing, maxSpacing } = interval;
    const { maxTickCount, minTickCount, tickCount } = this.estimateTickCount(visibleRange, minSpacing, maxSpacing);
    const continuous = ContinuousScale.is(scale2) || DiscreteTimeScale.is(scale2);
    const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;
    const countTicks2 = (i) => continuous ? Math.max(tickCount - i, minTickCount) : maxTickCount;
    const previousTicks = tickData.rawTicks;
    const regenerateTicks = step == null && values == null && countTicks2(index) > minTickCount && (continuous || tickGenerationType === 2 /* FILTER */);
    const getTickParams = {
      domain,
      niceMode,
      visibleRange,
      primaryTickCount,
      tickGenerationType,
      previousTicks,
      minTickCount,
      maxTickCount,
      tickCount: 0
    };
    getTickParams.tickCount = countTicks2(index);
    tickData = this.getTicks(getTickParams);
    if (regenerateTicks && this.ticksEqual(tickData.rawTicks, previousTicks)) {
      let lowerBound = index;
      let upperBound = maxIterations;
      while (lowerBound <= upperBound) {
        index = (lowerBound + upperBound) / 2 | 0;
        getTickParams.tickCount = countTicks2(index);
        tickData = this.getTicks(getTickParams);
        if (this.ticksEqual(tickData.rawTicks, previousTicks)) {
          lowerBound = index + 1;
        } else {
          upperBound = index - 1;
        }
      }
    }
    index += 1;
    terminate || (terminate = step != null || values != null);
    return { tickData, index, autoRotation: 0, terminate };
  }
  getTimeIntervalTicks(visibleRange, tickParams, timeInterval) {
    const parentInterval = intervalHierarchy(timeInterval);
    if (parentInterval == null)
      return;
    const { scale: scale2, reverse } = this.axis;
    if (!TimeScale.is(scale2) && !DiscreteTimeScale.is(scale2))
      return;
    if (reverse) {
      visibleRange = [1 - visibleRange[1], 1 - visibleRange[0]];
    }
    const dv0 = Math.min(scale2.domain[0].valueOf(), scale2.domain[scale2.domain.length - 1].valueOf());
    const dv1 = Math.max(scale2.domain[0].valueOf(), scale2.domain[scale2.domain.length - 1].valueOf());
    let [dp0, dp1] = TimeInterval.extent(new Date(dv0), new Date(dv1), visibleRange);
    dp0 = parentInterval.floor(dp0);
    if (dp0.valueOf() >= dv0)
      dp0 = parentInterval.previous(dp0);
    dp1 = parentInterval.ceil(dp1);
    if (dp1.valueOf() <= dv1)
      dp1 = parentInterval.next(dp1);
    const primaryTicks = parentInterval.range(dp0, dp1);
    const milliseconds = intervalMilliseconds(timeInterval);
    const interpolate3 = UnitTimeScale.is(scale2) && scale2.interval != null && intervalMilliseconds(scale2.interval) < milliseconds;
    let ticks;
    let primaryTicksIndices = /* @__PURE__ */ new Set();
    if (TimeScale.is(scale2) || UnitTimeScale.is(scale2)) {
      ticks = [];
      const intervalTickParams = {
        ...tickParams,
        interval: timeInterval
      };
      const timeScaleTicks = !UnitTimeScale.is(scale2) || interpolate3;
      for (let i = 0; i < primaryTicks.length - 1; i += 1) {
        const p0 = primaryTicks[i];
        const p1 = primaryTicks[i + 1];
        const last = i === primaryTicks.length - 2;
        const dp = p1.valueOf() - p0.valueOf();
        const pVisibleRange = [
          Math.max((dv0 - p0.valueOf()) / dp, 0),
          Math.min((dv1 - p0.valueOf()) / dp, 1)
        ];
        const intervalTicks = timeScaleTicks ? this.timeScaleTicks(intervalTickParams, [p0, p1], pVisibleRange, true) : scale2.ticks(intervalTickParams, [p0, p1], pVisibleRange, true)?.ticks ?? [];
        (0, import_ag_charts_core51.dropFirstWhile)(intervalTicks, (firstTick2) => firstTick2.valueOf() < p0.valueOf());
        if (!last) {
          (0, import_ag_charts_core51.dropLastWhile)(intervalTicks, (lastTick) => {
            return timeScaleTicks ? lastTick.valueOf() + milliseconds > p1.valueOf() : lastTick.valueOf() >= p1.valueOf();
          });
        }
        if (intervalTicks.length === 0)
          continue;
        const firstTick = intervalTicks[0];
        const firstTickDiff = compareDates(firstTick, p0);
        const firstPrimary = timeScaleTicks ? firstTickDiff === 0 : firstTickDiff <= milliseconds;
        if (firstPrimary)
          primaryTicksIndices.add(ticks.length);
        ticks.push(...intervalTicks);
      }
    } else if (OrdinalTimeScale.is(scale2)) {
      ticks = scale2.ticks(tickParams, void 0, visibleRange, true)?.ticks ?? [];
      let primaryTickIndex = 0;
      for (let i = 0; i < ticks.length; i++) {
        const tick = ticks[i];
        let primary = false;
        while (primaryTickIndex < primaryTicks.length && compareDates(primaryTicks[primaryTickIndex], tick) <= 0) {
          primary = true;
          primaryTickIndex++;
        }
        if (primary)
          primaryTicksIndices.add(i);
      }
    } else {
      ticks = [];
    }
    if (primaryTicksIndices.size === 0 || // If there's only one primary tick and it's the first tick, don't show primary ticks
    primaryTicksIndices.size === 1 && primaryTicksIndices.has(0)) {
      primaryTicksIndices = void 0;
    }
    return { ticks, tickCount: void 0, primaryTicksIndices, interpolate: interpolate3 };
  }
  timeScaleTicks(params, domain, visibleRange, extend) {
    const { interval } = params;
    if (interval == null)
      return domain;
    const d0 = domain[0].valueOf();
    const d1 = domain[1].valueOf();
    if (typeof interval !== "number") {
      return intervalInstance(interval).every(1, { snapTo: domain[0] }).range(domain[0], domain[1], { visibleRange, extend });
    }
    const ticks = [];
    for (let intervalTickTime = d0; intervalTickTime <= d1; intervalTickTime += interval) {
      const intervalTick = new Date(intervalTickTime);
      ticks.push(intervalTick);
    }
    return ticks;
  }
  getTicks({
    domain,
    niceMode,
    visibleRange,
    tickGenerationType,
    previousTicks,
    tickCount,
    minTickCount,
    maxTickCount,
    primaryTickCount
  }) {
    const { axis } = this;
    const { label, primaryLabel, range: range3, scale: scale2, interval } = axis;
    const idGenerator = createIdsGenerator();
    const domainParams = {
      nice: niceMode === 0 /* TickAndDomain */,
      interval: interval.step,
      tickCount,
      minTickCount,
      maxTickCount
    };
    const tickParams = {
      ...domainParams,
      nice: niceMode === 0 /* TickAndDomain */ || niceMode === 1 /* TicksOnly */
    };
    let secondaryAxisTicks;
    if (tickGenerationType === 1 /* CREATE_SECONDARY */ && primaryTickCount != null && ContinuousScale.is(scale2)) {
      secondaryAxisTicks = calculateNiceSecondaryAxis(
        scale2,
        domain,
        primaryTickCount,
        axis.reverse,
        visibleRange
      );
    }
    const niceDomain = niceMode === 0 /* TickAndDomain */ ? secondaryAxisTicks?.domain ?? scale2.niceDomain(domainParams, domain) : domain;
    let tickDomain = niceDomain;
    let rawTicks;
    let rawTickCount;
    let timeInterval;
    let primaryTicksIndices;
    let interpolate3 = false;
    const scaleDomain = scale2.domain;
    scale2.domain = niceDomain;
    switch (tickGenerationType) {
      case 3 /* VALUES */:
        tickDomain = interval.values;
        rawTicks = interval.values;
        rawTickCount = rawTicks.length;
        interpolate3 = UnitTimeScale.is(scale2);
        if (ContinuousScale.is(scale2)) {
          const [d0, d1] = findMinMax(niceDomain.map(Number));
          rawTicks = rawTicks.filter((value) => Number(value) >= d0 && Number(value) <= d1).sort((a, b) => Number(a) - Number(b));
        }
        break;
      case 1 /* CREATE_SECONDARY */:
        if (secondaryAxisTicks) {
          rawTicks = secondaryAxisTicks.ticks;
          rawTickCount = secondaryAxisTicks.ticks.length;
        } else {
          const tickGeneration = scale2.ticks(tickParams, niceDomain, visibleRange);
          rawTicks = tickGeneration?.ticks ?? [];
          rawTickCount = tickGeneration?.count;
        }
        break;
      case 2 /* FILTER */:
        rawTicks = this.filterTicks(previousTicks, tickCount);
        rawTickCount = void 0;
        break;
      default: {
        if (niceDomain.length > 0 && tickParams.interval == null && (UnitTimeScale.is(scale2) || primaryLabel != null && (TimeScale.is(scale2) || OrdinalTimeScale.is(scale2)))) {
          const dates = niceDomain;
          const start2 = Math.min(dates[0].valueOf(), dates[dates.length - 1].valueOf());
          const end2 = Math.max(dates[0].valueOf(), dates[dates.length - 1].valueOf());
          timeInterval = getTickTimeInterval(start2, end2, tickCount, minTickCount, maxTickCount, {
            weekStart: primaryLabel == null ? sunday : void 0,
            primaryOnly: UnitTimeScale.is(scale2)
          });
        }
        const minTimeInterval = UnitTimeScale.is(scale2) ? scale2.interval : void 0;
        if (minTimeInterval != null && timeInterval != null && intervalMilliseconds(minTimeInterval) > intervalMilliseconds(timeInterval)) {
          timeInterval = minTimeInterval;
        }
        const intervalTicks = timeInterval ? this.getTimeIntervalTicks(visibleRange, tickParams, timeInterval) : void 0;
        if (intervalTicks) {
          ({ ticks: rawTicks, tickCount: rawTickCount, primaryTicksIndices, interpolate: interpolate3 } = intervalTicks);
        } else {
          const intervalTickParams = UnitTimeScale.is(scale2) && timeInterval != null ? { ...tickParams, interval: tickParams.interval ?? timeInterval } : tickParams;
          const tickGeneration = scale2.ticks(intervalTickParams, niceDomain, visibleRange);
          rawTicks = tickGeneration?.ticks ?? [];
          rawTickCount = tickGeneration?.count;
        }
      }
    }
    const fractionDigits = rawTicks.reduce(
      (max, tick) => Math.max(max, typeof tick === "number" ? (0, import_ag_charts_core51.countFractionDigits)(tick) : 0),
      0
    );
    const specifier = labelSpecifier(label.format, timeInterval) ?? (typeof label.format === "string" ? label.format : void 0);
    const formatParams = {
      domain: tickDomain,
      ticks: rawTicks,
      fractionDigits,
      specifier
    };
    const labelFormatter = scale2.tickFormatter(formatParams);
    const primarySpecifier = labelSpecifier(
      primaryLabel?.format,
      timeInterval ? intervalHierarchy(timeInterval) : void 0
    );
    const primaryLabelFormatter = primarySpecifier ? scale2.tickFormatter({
      ...formatParams,
      specifier: primarySpecifier
    }) : labelFormatter;
    const halfBandwidth = (scale2.bandwidth ?? 0) / 2;
    const ticks = [];
    for (let i = 0; i < rawTicks.length; i++) {
      const tick = rawTicks[i];
      const translationY = scale2.convert(tick, { interpolate: interpolate3 }) + halfBandwidth;
      const primary = primaryTicksIndices?.has(i) ?? false;
      if (range3.length > 0 && !axis.inRange(translationY, 1e-3))
        continue;
      const tickLabelFormatter = primary && primaryLabel?.enabled === true ? primaryLabelFormatter : labelFormatter;
      const tickLabel = label.enabled ? axis.formatTick(tick, i, niceDomain, fractionDigits, timeInterval, tickLabelFormatter) : "";
      ticks.push({
        tick,
        tickId: idGenerator(tickLabel),
        tickLabel,
        translationY: Math.floor(translationY),
        primary
      });
    }
    scale2.domain = scaleDomain;
    return {
      tickDomain,
      rawTicks,
      rawTickCount,
      fractionDigits,
      timeInterval,
      ticks,
      niceDomain
    };
  }
};

// packages/ag-charts-community/src/chart/axis/cartesianAxisLabel.ts
var CartesianAxisLabel = class extends AxisLabel {
  constructor() {
    super(...arguments);
    this.autoRotateAngle = 335;
  }
};
__decorateClass([
  Property
], CartesianAxisLabel.prototype, "autoRotate", 2);
__decorateClass([
  Property
], CartesianAxisLabel.prototype, "autoRotateAngle", 2);

// packages/ag-charts-community/src/chart/axis/cartesianAxis.ts
var _CartesianAxis = class _CartesianAxis extends Axis {
  constructor(moduleCtx, scale2) {
    super(moduleCtx, scale2);
    this.headingLabelGroup = this.axisGroup.appendChild(
      new TranslatableGroup({ name: `${this.id}-Axis-heading` })
    );
    this.lineNodeGroup = this.axisGroup.appendChild(
      new TranslatableGroup({ name: `${this.id}-Axis-line` })
    );
    this.lineNode = this.lineNodeGroup.appendChild(
      new Line({
        // name: `${this.id}-Axis-line`,
        zIndex: 1 /* AxisLine */
      })
    );
    this.tickLineGroupSelection = Selection.select(this.tickLineGroup, Line, false);
    this.gridLineGroupSelection = Selection.select(this.gridLineGroup, Line, false);
    this.tempText = new TransformableText({ debugDirty: false });
    this.tempCaption = new Caption();
    this.tickGenerator = new AxisTickGenerator(this);
    this.generatedTicks = void 0;
    this.animationManager = moduleCtx.animationManager;
    this.animationState = new StateMachine("empty", {
      empty: {
        update: {
          target: "ready",
          action: () => this.resetSelectionNodes()
        },
        reset: "empty"
      },
      ready: {
        update: (data) => this.animateReadyUpdate(data),
        resize: () => this.resetSelectionNodes(),
        reset: "empty"
      }
    });
    this.headingLabelGroup.appendChild(this.title.caption.node);
    let previousSize = void 0;
    this.destroyFns.push(
      moduleCtx.layoutManager.addListener("layout:complete", (e) => {
        const size = [e.chart.width, e.chart.height];
        if (previousSize != null && !(0, import_ag_charts_core52.arraysEqual)(size, previousSize)) {
          this.animationState.transition("resize");
        }
        previousSize = size;
      }),
      this.title.caption.registerInteraction(this.moduleCtx, "afterend")
    );
  }
  static is(value) {
    return value instanceof _CartesianAxis;
  }
  get primaryLabel() {
    return void 0;
  }
  get primaryTick() {
    return void 0;
  }
  get horizontal() {
    return this.position === "top" || this.position === "bottom";
  }
  onGridVisibilityChange() {
    this.gridLineGroupSelection.clear();
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    }
  }
  get direction() {
    return this.position === "top" || this.position === "bottom" ? "x" /* X */ : "y" /* Y */;
  }
  createAxisContext() {
    return { ...super.createAxisContext(), position: this.position };
  }
  createLabel() {
    return new CartesianAxisLabel();
  }
  updateDirection() {
    switch (this.position) {
      case "top":
        this.label.mirrored = true;
        this.label.parallel = true;
        break;
      case "right":
        this.label.mirrored = true;
        this.label.parallel = false;
        break;
      case "bottom":
        this.label.mirrored = false;
        this.label.parallel = true;
        break;
      case "left":
        this.label.mirrored = false;
        this.label.parallel = false;
        break;
    }
    if (this.axisContext) {
      this.axisContext.position = this.position;
      this.axisContext.direction = this.direction;
    }
  }
  calculateLayout(primaryTickCount, chartPadding) {
    this.updateDirection();
    return super.calculateLayout(primaryTickCount, chartPadding);
  }
  layoutCrossLines() {
    const anySeriesActive = this.isAnySeriesActive();
    this.crossLines.forEach((crossLine) => {
      crossLine.calculateLayout?.(anySeriesActive, this.reverse);
    });
  }
  calculateTickLayout(domain, niceMode, visibleRange, initialPrimaryTickCount) {
    const sideFlag = this.label.getSideFlag();
    const rotation = this.horizontal ? -0.5 * Math.PI : 0;
    const parallelFlipRotation = normalizeAngle360(rotation);
    const regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);
    const labelX = sideFlag * (this.getTickSize() + this.label.spacing + this.seriesAreaPadding);
    if (niceMode === 2 /* Off */ && this.label.enabled === false && this.tick.enabled === false && this.gridLine.enabled === false) {
      const { bbox: bbox2, spacing: spacing2 } = this.tickBBox(domain, [], []);
      this.generatedTicks = { ticks: [], tickLines: [], gridLines: [], labels: [], spacing: spacing2 };
      return {
        ticks: [],
        rawTickCount: 0,
        tickDomain: domain,
        niceDomain: domain,
        fractionDigits: 0,
        timeInterval: void 0,
        bbox: bbox2
      };
    }
    const removeOverflowLabels = this.horizontal && ContinuousScale.is(this.scale);
    const tickGenerationResult = this.tickGenerator.generateTicks({
      domain,
      niceMode,
      visibleRange,
      primaryTickCount: initialPrimaryTickCount,
      parallelFlipRotation,
      regularFlipRotation,
      labelX,
      sideFlag,
      removeOverflowLabels,
      removeOverflowThreshold: this.chartPadding?.right
    });
    const { tickData } = tickGenerationResult;
    const {
      ticks,
      tickDomain,
      rawTicks,
      rawTickCount,
      fractionDigits,
      timeInterval,
      niceDomain = domain
    } = tickData;
    const labels = ticks.map((d) => this.getTickLabelProps(d, tickGenerationResult));
    const { position, horizontal, gridPadding, gridLength } = this;
    const direction = position === "bottom" || position === "right" ? -1 : 1;
    const p1 = gridPadding;
    const p2 = direction * gridLength - gridPadding;
    const { gridLine } = this;
    const gridLines = ticks.map(({ tickId, translationY: offset4 }, index) => {
      const [x1, y1, x2, y2] = horizontal ? [offset4, p1, offset4, p2] : [p1, offset4, p2, offset4];
      const { style, width: strokeWidth } = gridLine;
      const { stroke: stroke2, lineDash } = style[index % style.length] ?? {};
      return { tickId, offset: offset4, x1, y1, x2, y2, stroke: stroke2, strokeWidth, lineDash };
    });
    const { tick, primaryTick } = this;
    const tickLines = ticks.map(({ primary, tickId, translationY: offset4 }) => {
      const datumTick = primary && primaryTick?.enabled ? primaryTick : tick;
      const h = -direction * this.getTickSize(datumTick);
      const [x1, y1, x2, y2] = horizontal ? [offset4, 0, offset4, h] : [0, offset4, h, offset4];
      const { stroke: stroke2, width: strokeWidth } = datumTick;
      const lineDash = void 0;
      return { tickId, offset: offset4, x1, y1, x2, y2, stroke: stroke2, strokeWidth, lineDash };
    });
    const { bbox, spacing } = this.tickBBox(tickDomain, ticks, labels);
    this.generatedTicks = { ticks, gridLines, tickLines, labels, spacing };
    return { ticks: rawTicks, rawTickCount, tickDomain, niceDomain, fractionDigits, timeInterval, bbox };
  }
  update() {
    this.updateDirection();
    const previousTicksIds = Array.from(this.tickLabelGroupSelection.nodes(), (node) => node.datum.tickId);
    super.update();
    this.tickLineGroup.visible = this.tick.enabled || (this.primaryTick?.enabled ?? false);
    this.tickLabelGroup.visible = this.label.enabled || (this.primaryTick?.enabled ?? false);
    const { generatedTicks } = this;
    this.updateTitle(this.scale.domain, generatedTicks?.spacing ?? 0);
    if (!this.animatable) {
      this.moduleCtx.animationManager.skipCurrentBatch();
    }
    if (this.generatedTicks) {
      const { ticks } = this.generatedTicks;
      if (this.animationManager.isSkipped()) {
        this.resetSelectionNodes();
      } else {
        const tickIds = ticks.map((datum) => datum.tickId);
        const diff2 = (0, import_ag_charts_core52.diffArrays)(previousTicksIds, tickIds);
        this.animationState.transition("update", diff2);
      }
    }
    const { enabled, stroke: stroke2, width: width2 } = this.line;
    this.lineNode.setProperties({ stroke: stroke2, strokeWidth: enabled ? width2 : 0 });
    this.updateTickLines();
    this.updateGridLines();
  }
  getAxisTransform() {
    return {
      translationX: Math.floor(this.translation.x),
      translationY: Math.floor(this.translation.y)
    };
  }
  updatePosition() {
    super.updatePosition();
    const axisTransform = this.getAxisTransform();
    this.tickLineGroup.datum = axisTransform;
    this.tickLabelGroup.datum = axisTransform;
    this.lineNodeGroup.datum = axisTransform;
    this.headingLabelGroup.datum = axisTransform;
  }
  getAxisLineCoordinates() {
    const { horizontal } = this;
    const [c1, c2] = findMinMax(this.range);
    return horizontal ? { x1: c1, x2: c2, y1: 0, y2: 0 } : { x1: 0, x2: 0, y1: c1, y2: c2 };
  }
  getTickLineBBox(datum) {
    const { position, primaryTick } = this;
    const tickSize = Math.max(this.getTickSize(), primaryTick?.enabled ? this.getTickSize(primaryTick) : 0);
    const { translationY } = datum;
    switch (position) {
      case "top":
        return new BBox(translationY, -tickSize, translationY, tickSize);
      case "bottom":
        return new BBox(translationY, 0, translationY, tickSize);
      case "left":
        return new BBox(-tickSize, translationY, tickSize, translationY);
      case "right":
        return new BBox(0, translationY, tickSize, translationY);
    }
  }
  lineNodeBBox() {
    const { position, seriesAreaPadding } = this;
    const { y1, y2 } = this.getAxisLineCoordinates();
    const dy = y2 - y1;
    switch (position) {
      case "top":
        return new BBox(y1, -seriesAreaPadding, dy, seriesAreaPadding);
      case "bottom":
        return new BBox(y1, 0, dy, seriesAreaPadding);
      case "left":
        return new BBox(-seriesAreaPadding, y1, seriesAreaPadding, dy);
      case "right":
        return new BBox(0, y1, seriesAreaPadding, dy);
    }
  }
  titleBBox(domain, spacing) {
    const { tempCaption } = this;
    tempCaption.node.setProperties(this.titleProps(tempCaption, domain, spacing));
    return tempCaption.node.getBBox();
  }
  tickBBox(domain, ticks, labels) {
    const { tick, primaryTick, label, primaryLabel, title, position, horizontal, seriesAreaPadding } = this;
    const boxes = [];
    boxes.push(this.lineNodeBBox());
    if (tick.enabled || primaryTick?.enabled) {
      for (const datum of ticks) {
        boxes.push(this.getTickLineBBox(datum));
      }
    }
    const { tempText } = this;
    if (label.enabled) {
      for (const datum of labels) {
        if (!datum.visible)
          continue;
        tempText.setProperties(datum);
        const box = tempText.getBBox();
        if (box) {
          boxes.push(box);
        }
      }
    }
    if (primaryLabel?.enabled && primaryLabel.format != null && position === "bottom") {
      const { fontSize, format } = primaryLabel;
      const formats = (0, import_ag_charts_core52.isPlainObject)(format) ? Object.values(format) : [format];
      const maxLines = formats.reduce((m, f) => Math.max(m, (0, import_ag_charts_core52.countLines)(f)), 0);
      const labelOffset = this.getTickSize(primaryTick ?? tick) + primaryLabel.spacing + seriesAreaPadding;
      const inexactMeasurementPadding = 2;
      const height2 = maxLines * TextUtils.getLineHeight(fontSize) + inexactMeasurementPadding;
      boxes.push(new BBox(0, labelOffset, 1, height2));
    }
    let spacing = 0;
    if (title.enabled) {
      const combined = BBox.merge(boxes);
      spacing = horizontal ? combined.height : combined.width;
      boxes.push(this.titleBBox(domain, spacing));
    }
    const bbox = BBox.merge(boxes);
    return { bbox, spacing };
  }
  titleProps(caption, domain, spacing) {
    const { title } = this;
    if (!title.enabled) {
      caption.enabled = false;
      return {
        visible: false,
        text: "",
        textBaseline: "bottom",
        x: 0,
        y: 0,
        rotationCenterX: 0,
        rotationCenterY: 0,
        rotation: 0
      };
    }
    caption.enabled = true;
    caption.color = title.color;
    caption.fontFamily = title.fontFamily;
    caption.fontSize = title.fontSize;
    caption.fontStyle = title.fontStyle;
    caption.fontWeight = title.fontWeight;
    caption.wrapping = title.wrapping;
    const padding = (title.spacing ?? 0) + spacing;
    const { range: range3 } = this;
    const midOffset = (range3[0] + range3[1]) / 2;
    let x;
    let y;
    let rotation;
    let textBaseline;
    switch (this.position) {
      case "top":
        x = midOffset;
        y = -padding;
        rotation = 0;
        textBaseline = "bottom";
        break;
      case "bottom":
        x = midOffset;
        y = padding;
        rotation = 0;
        textBaseline = "top";
        break;
      case "left":
        x = -padding;
        y = midOffset;
        rotation = -0.5 * Math.PI;
        textBaseline = "bottom";
        break;
      case "right":
        x = padding;
        y = midOffset;
        rotation = 0.5 * Math.PI;
        textBaseline = "bottom";
        break;
    }
    const { formatter = (p) => p.defaultValue } = title;
    const text = this.callWithContext(formatter, this.getTitleFormatterParams(domain));
    caption.text = text;
    return {
      visible: true,
      text,
      textBaseline,
      x,
      y,
      rotationCenterX: x,
      rotationCenterY: y,
      rotation
    };
  }
  getTickLabelProps(datum, tickGenerationResult) {
    const { horizontal, primaryLabel, primaryTick, seriesAreaPadding, scale: scale2 } = this;
    const { tickId, tickLabel: text = "", translationY, primary } = datum;
    const label = primary && primaryLabel?.enabled ? primaryLabel : this.label;
    const tick = primary && primaryTick?.enabled ? primaryTick : this.tick;
    const { rotation, textBaseline, textAlign } = tickGenerationResult;
    const { range: range3 } = scale2;
    const sideFlag = this.label.getSideFlag();
    const labelOffset = sideFlag * (this.getTickSize(tick) + label.spacing + seriesAreaPadding);
    const visible = text !== "";
    const x = horizontal ? translationY : labelOffset;
    const y = horizontal ? -labelOffset : translationY;
    return {
      ...this.getLabelStyles({ value: text }, void 0, label),
      tickId,
      rotation,
      text,
      textAlign,
      textBaseline,
      visible,
      x,
      y,
      rotationCenterX: x,
      rotationCenterY: y,
      range: range3
    };
  }
  updateSelections() {
    if (!this.generatedTicks)
      return;
    const lineData = this.getAxisLineCoordinates();
    const { tickLines, gridLines, labels } = this.generatedTicks;
    const getDatumId = (datum) => datum.tickId;
    this.lineNode.datum = lineData;
    this.gridLineGroupSelection.update(this.gridLine.enabled ? gridLines : [], void 0, getDatumId);
    this.tickLineGroupSelection.update(tickLines, void 0, getDatumId);
    this.tickLabelGroupSelection.update(labels, void 0, getDatumId);
  }
  updateGridLines() {
    this.gridLineGroupSelection.each((line, datum) => {
      line.stroke = datum.stroke;
      line.strokeWidth = datum.strokeWidth;
      line.lineDash = datum.lineDash;
    });
  }
  updateTickLines() {
    this.tickLineGroupSelection.each((line, datum) => {
      line.stroke = datum.stroke;
      line.strokeWidth = datum.strokeWidth;
      line.lineDash = datum.lineDash;
    });
  }
  updateTitle(domain, spacing) {
    const { caption } = this.title;
    const titleProps = this.titleProps(caption, domain, spacing);
    caption.node.visible = titleProps.visible;
    caption.node.text = titleProps.text;
    caption.node.textBaseline = titleProps.textBaseline;
    caption.node.datum = titleProps;
  }
  updateLabels() {
    if (!this.label.enabled)
      return;
    this.tickLabelGroupSelection.each((node, datum) => {
      node.fill = datum.fill;
      node.fontFamily = datum.fontFamily;
      node.fontSize = datum.fontSize;
      node.fontStyle = datum.fontStyle;
      node.fontWeight = datum.fontWeight;
      node.text = datum.text;
      node.textBaseline = datum.textBaseline;
      node.textAlign = datum.textAlign ?? "center";
    });
  }
  animateReadyUpdate(diff2) {
    const { animationManager } = this.moduleCtx;
    const selectionCtx = prepareAxisAnimationContext(this);
    const fns = prepareAxisAnimationFunctions(selectionCtx);
    fromToMotion(
      this.id,
      "axis-group",
      animationManager,
      [this.lineNodeGroup, this.tickLabelGroup, this.tickLineGroup, this.headingLabelGroup],
      fns.group
    );
    fromToMotion(this.id, "line", animationManager, [this.lineNode], fns.line);
    fromToMotion(
      this.id,
      "line-paths",
      animationManager,
      [this.gridLineGroupSelection, this.tickLineGroupSelection],
      fns.tick,
      (_, d) => d.tickId,
      diff2
    );
    fromToMotion(
      this.id,
      "tick-labels",
      animationManager,
      [this.tickLabelGroupSelection],
      fns.label,
      (_, d) => d.tickId,
      diff2
    );
    fromToMotion(
      this.id,
      "title",
      animationManager,
      [this.title.caption.node],
      fns.label,
      (_, d) => d.tickId,
      diff2
    );
  }
  resetSelectionNodes() {
    resetMotion(
      [this.lineNodeGroup, this.tickLabelGroup, this.tickLineGroup, this.headingLabelGroup],
      resetAxisGroupFn()
    );
    resetMotion([this.gridLineGroupSelection, this.tickLineGroupSelection], resetAxisLineSelectionFn());
    resetMotion([this.tickLabelGroupSelection], resetAxisLabelSelectionFn());
    resetMotion([this.title.caption.node], resetAxisLabelSelectionFn());
    resetMotion([this.lineNode], resetAxisLineSelectionFn());
  }
};
__decorateClass([
  Property
], _CartesianAxis.prototype, "thickness", 2);
__decorateClass([
  Property
], _CartesianAxis.prototype, "position", 2);
var CartesianAxis = _CartesianAxis;

// packages/ag-charts-community/src/chart/axis/categoryAxis.ts
var _CategoryAxis = class _CategoryAxis extends CartesianAxis {
  constructor(moduleCtx, scale2 = new CategoryScale()) {
    super(moduleCtx, scale2);
    this.groupPaddingInner = 0.1;
    this.includeInvisibleDomains = true;
    this.nice = false;
  }
  static is(value) {
    return value instanceof _CategoryAxis;
  }
  normaliseDataDomain(domain) {
    return { domain, clipped: false };
  }
  updateScale() {
    super.updateScale();
    let { paddingInner, paddingOuter } = this;
    if (!(0, import_ag_charts_core53.isFiniteNumber)(paddingInner) || !(0, import_ag_charts_core53.isFiniteNumber)(paddingOuter)) {
      const padding = this.reduceBandScalePadding();
      paddingInner ?? (paddingInner = padding.inner);
      paddingOuter ?? (paddingOuter = padding.outer);
    }
    this.scale.paddingInner = paddingInner ?? 0;
    this.scale.paddingOuter = paddingOuter ?? 0;
  }
  reduceBandScalePadding() {
    return this.boundSeries.reduce(
      (result, series) => {
        const padding = series.getBandScalePadding?.();
        if (padding) {
          if (result.inner > padding.inner) {
            result.inner = padding.inner;
          }
          if (result.outer < padding.outer) {
            result.outer = padding.outer;
          }
        }
        return result;
      },
      { inner: Infinity, outer: -Infinity }
    );
  }
};
_CategoryAxis.className = "CategoryAxis";
_CategoryAxis.type = "category";
__decorateClass([
  Property
], _CategoryAxis.prototype, "groupPaddingInner", 2);
__decorateClass([
  Property
], _CategoryAxis.prototype, "paddingInner", 2);
__decorateClass([
  Property
], _CategoryAxis.prototype, "paddingOuter", 2);
var CategoryAxis = _CategoryAxis;

// packages/ag-charts-community/src/chart/chart.ts
var import_ag_charts_core113 = require("ag-charts-core");

// packages/ag-charts-community/src/module/module.ts
var ModuleRegistry = class {
  constructor() {
    this.modules = [];
    this.dependencies = /* @__PURE__ */ new Map();
    this.modulesByOptionKey = /* @__PURE__ */ new Map();
  }
  register(...modules) {
    for (const module2 of modules) {
      this.registerDependencies(module2);
      const otherModule = this.modules.find(
        (other) => module2.type === other.type && ("optionsKey" in module2 && "optionsKey" in other ? module2.optionsKey === other.optionsKey : true) && module2.identifier === other.identifier
      );
      if (otherModule) {
        if (module2.packageType === "enterprise" && otherModule.packageType === "community") {
          const index = this.modules.indexOf(otherModule);
          this.modules.splice(index, 1, module2);
          if ("optionsKey" in module2) {
            this.modulesByOptionKey.set(module2.optionsKey, module2);
          }
        }
      } else {
        this.modules.push(module2);
        if ("optionsKey" in module2) {
          this.modulesByOptionKey.set(module2.optionsKey, module2);
        }
      }
    }
  }
  hasEnterpriseModules() {
    return this.modules.some((m) => m.packageType === "enterprise");
  }
  *byType(...types) {
    const yielded = /* @__PURE__ */ new Set();
    const modulesByType = this.modules.filter((module2) => types.includes(module2.type));
    const calculateDependencies = (module2) => {
      const deps = this.dependencies.get(module2);
      return deps?.flatMap(calculateDependencies).concat(deps) ?? [];
    };
    const unresolvable = [];
    for (const module2 of modulesByType) {
      const uniqueKey = "optionsKey" in module2 ? module2.optionsKey : module2.contextKey;
      if (yielded.has(uniqueKey))
        continue;
      for (const dependency of calculateDependencies(uniqueKey)) {
        if (yielded.has(dependency))
          continue;
        const dependencyModule = this.modulesByOptionKey.get(dependency);
        if (!dependencyModule) {
          unresolvable.push(dependency);
          continue;
        }
        if (!types.includes(dependencyModule.type))
          continue;
        yield dependencyModule;
        yielded.add(dependency);
      }
      yield module2;
      yielded.add(uniqueKey);
    }
    if (unresolvable.length > 0) {
      throw new Error(`Could not resolve module dependencies: ${unresolvable}`);
    }
  }
  registerDependencies(module2) {
    if (module2.dependencies == null || module2.dependencies.length === 0)
      return;
    const uniqueKey = "optionsKey" in module2 ? module2.optionsKey : module2.contextKey;
    this.dependencies.set(uniqueKey, module2.dependencies);
  }
};
var moduleRegistry = new ModuleRegistry();

// packages/ag-charts-community/src/util/dom.ts
var import_ag_charts_core54 = require("ag-charts-core");
function setElementBBox(element2, bbox) {
  if (!element2)
    return;
  bbox = BBoxValues.normalize(bbox);
  if (bbox.width == null) {
    element2.style.removeProperty("width");
  } else {
    element2.style.width = `${bbox.width}px`;
  }
  if (bbox.height == null) {
    element2.style.removeProperty("height");
  } else {
    element2.style.height = `${bbox.height}px`;
  }
  if (bbox.x == null) {
    element2.style.removeProperty("left");
  } else {
    element2.style.left = `${bbox.x}px`;
  }
  if (bbox.y == null) {
    element2.style.removeProperty("top");
  } else {
    element2.style.top = `${bbox.y}px`;
  }
}
function getElementBBox(element2) {
  const width2 = parseFloat(element2.style.width) || element2.offsetWidth;
  const height2 = parseFloat(element2.style.height) || element2.offsetHeight;
  const x = parseFloat(element2.style.left) || element2.offsetLeft;
  const y = parseFloat(element2.style.top) || element2.offsetTop;
  return { x, y, width: width2, height: height2 };
}
function isInputPending() {
  const navigator = (0, import_ag_charts_core54.getWindow)("navigator");
  if ("scheduling" in navigator) {
    const scheduling = navigator.scheduling;
    if ("isInputPending" in scheduling) {
      return scheduling.isInputPending({ includeContinuous: true });
    }
  }
  return false;
}

// packages/ag-charts-community/src/util/json.ts
var import_ag_charts_core55 = require("ag-charts-core");
var CLASS_INSTANCE_TYPE = "class-instance";
function jsonDiff(source, target, shallow) {
  if ((0, import_ag_charts_core55.isArray)(target)) {
    if (!(0, import_ag_charts_core55.isArray)(source) || source.length !== target.length || target.some((v, i) => jsonDiff(source[i], v, shallow) != null)) {
      return target;
    }
  } else if ((0, import_ag_charts_core55.isPlainObject)(target)) {
    if (!(0, import_ag_charts_core55.isPlainObject)(source)) {
      return target;
    }
    const result = {};
    const allKeys = /* @__PURE__ */ new Set([
      ...Object.keys(source),
      ...Object.keys(target)
    ]);
    for (const key of allKeys) {
      if (source[key] === target[key]) {
        continue;
      } else if (shallow?.has(key)) {
        result[key] = target[key];
      } else if (typeof source[key] === typeof target[key]) {
        const diff2 = jsonDiff(source[key], target[key], shallow);
        if (diff2 !== null) {
          result[key] = diff2;
        }
      } else {
        result[key] = target[key];
      }
    }
    return Object.keys(result).length ? result : null;
  } else if (source !== target) {
    return target;
  }
  return null;
}
function deepClone(source, opts) {
  if ((0, import_ag_charts_core55.isArray)(source)) {
    return cloneArray(source, opts);
  }
  if ((0, import_ag_charts_core55.isPlainObject)(source)) {
    return clonePlainObject(source, opts);
  }
  if (source instanceof Map) {
    return new Map(deepClone(Array.from(source)));
  }
  return shallowClone(source);
}
function cloneArray(source, opts) {
  const result = [];
  const seen = opts?.seen;
  for (const item of source) {
    if (typeof item === "object" && seen?.includes(item)) {
      import_ag_charts_core55.Logger.warn("cycle detected in array", item);
      continue;
    }
    seen?.push(item);
    result.push(deepClone(item, opts));
    seen?.pop();
  }
  return result;
}
function clonePlainObject(source, opts) {
  const target = {};
  for (const key of Object.keys(source)) {
    if (opts?.assign?.has(key)) {
      target[key] = source[key];
    } else if (opts?.shallow?.has(key)) {
      target[key] = shallowClone(source[key]);
    } else {
      target[key] = deepClone(source[key], opts);
    }
  }
  return target;
}
function shallowClone(source) {
  if ((0, import_ag_charts_core55.isArray)(source)) {
    return source.slice(0);
  }
  if ((0, import_ag_charts_core55.isPlainObject)(source)) {
    return { ...source };
  }
  if ((0, import_ag_charts_core55.isDate)(source)) {
    return new Date(source);
  }
  if ((0, import_ag_charts_core55.isRegExp)(source)) {
    return new RegExp(source.source, source.flags);
  }
  return source;
}
function jsonApply(target, source, params = {}) {
  const { path, matcherPath = path?.replace(/(\[[0-9+]+])/i, "[]"), skip = [] } = params;
  if (target == null) {
    throw new Error(`AG Charts - target is uninitialised: ${path ?? "<root>"}`);
  }
  if (source == null) {
    return target;
  }
  if (isProperties(target)) {
    return target.set(source);
  }
  const targetAny = target;
  const targetType = classify(target);
  for (const property of Object.keys(source)) {
    if (SKIP_JS_BUILTINS.has(property))
      continue;
    const propertyMatcherPath = `${matcherPath ? matcherPath + "." : ""}${property}`;
    if (skip.includes(propertyMatcherPath))
      continue;
    const newValue = source[property];
    const propertyPath = `${path ? path + "." : ""}${property}`;
    const targetClass = targetAny.constructor;
    const currentValue = targetAny[property];
    try {
      const currentValueType = classify(currentValue);
      const newValueType = classify(newValue);
      if (targetType === CLASS_INSTANCE_TYPE && !(property in target || property === "context")) {
        if (newValue === void 0)
          continue;
        import_ag_charts_core55.Logger.warn(`unable to set [${propertyPath}] in ${targetClass?.name} - property is unknown`);
        continue;
      }
      if (currentValueType != null && newValueType != null && newValueType !== currentValueType && (currentValueType !== CLASS_INSTANCE_TYPE || newValueType !== "object")) {
        import_ag_charts_core55.Logger.warn(
          `unable to set [${propertyPath}] in ${targetClass?.name} - can't apply type of [${newValueType}], allowed types are: [${currentValueType}]`
        );
        continue;
      }
      if (isProperties(currentValue)) {
        targetAny[property].set(newValue);
      } else if (newValueType === "object" && property !== "context") {
        if (currentValue == null) {
          import_ag_charts_core55.Logger.warn(`unable to set [${propertyPath}] in ${targetClass?.name} - property is unknown`);
          continue;
        }
        jsonApply(currentValue, newValue, {
          ...params,
          path: propertyPath,
          matcherPath: propertyMatcherPath
        });
      } else {
        targetAny[property] = newValue;
      }
    } catch (error) {
      import_ag_charts_core55.Logger.warn(`unable to set [${propertyPath}] in [${targetClass?.name}]; nested error is: ${error.message}`);
    }
  }
  return target;
}
function classify(value) {
  if (value == null) {
    return null;
  }
  if ((0, import_ag_charts_core55.isHtmlElement)(value) || (0, import_ag_charts_core55.isDate)(value)) {
    return "primitive";
  }
  if ((0, import_ag_charts_core55.isArray)(value)) {
    return "array";
  }
  if ((0, import_ag_charts_core55.isObject)(value)) {
    return (0, import_ag_charts_core55.isPlainObject)(value) ? "object" : CLASS_INSTANCE_TYPE;
  }
  if ((0, import_ag_charts_core55.isFunction)(value)) {
    return "function";
  }
  return "primitive";
}
var operationResolvedUndefined = Symbol("operation-resolved-undefined");
function getOperation(value) {
  if (!(0, import_ag_charts_core55.isPlainObject)(value))
    return;
  const [operation] = Object.keys(value);
  if (!isKey(operation, operations))
    return;
  return { operation, values: value[operation] };
}
function resolveOperation(operation, value, params, source, path, meta) {
  meta.referencedParams ?? (meta.referencedParams = /* @__PURE__ */ new Set());
  const resolveBranchFirst = ["$find" /* Find */, "$map" /* Map */];
  if ((0, import_ag_charts_core55.isArray)(value) && !resolveBranchFirst.includes(operation)) {
    value = value.map((v) => {
      const nestedOperation = getOperation(v);
      if (!nestedOperation)
        return v;
      return resolveOperation(nestedOperation.operation, nestedOperation.values, params, source, path, meta);
    });
  }
  const fn = operations[operation];
  return fn(value, path, params, source, meta);
}
function isKey(key, obj) {
  return (0, import_ag_charts_core55.isString)(key) && ((0, import_ag_charts_core55.isObject)(obj) || (0, import_ag_charts_core55.isArray)(obj)) && key in obj;
}
function isRatio(value) {
  return (0, import_ag_charts_core55.isNumber)(value) && value >= 0 && value <= 1;
}
function isGradientFill2(fill) {
  return (0, import_ag_charts_core55.isObject)(fill) && fill.type == "gradient";
}
function isPatternFill2(fill) {
  return fill !== null && (0, import_ag_charts_core55.isObject)(fill) && fill.type == "pattern";
}
function isImageFill2(fill) {
  return fill !== null && (0, import_ag_charts_core55.isObject)(fill) && fill.type == "image";
}
function resolvePath(root, path) {
  const relativePathParts = path.split("/");
  let resolvedPath = [...root];
  if (path.startsWith("/")) {
    resolvedPath = [];
    relativePathParts.shift();
  }
  let prevPartWasTwoDots = false;
  for (const part of relativePathParts) {
    if (part === "..") {
      resolvedPath.pop();
      if (!prevPartWasTwoDots)
        resolvedPath.pop();
    } else if (part === ".") {
      resolvedPath.pop();
    } else if (part === "$index") {
      const index = root.findLast((v) => !isNaN(Number(v)));
      if (index != null)
        resolvedPath.push(index);
    } else if (part === "$prevIndex") {
      const index = root.findLast((v) => !isNaN(Number(v)));
      if (index != null)
        resolvedPath.push(`${Number(index) - 1}`);
    } else if (part.length !== 0) {
      resolvedPath.push(part);
    }
    prevPartWasTwoDots = part === "..";
  }
  return resolvedPath;
}
var locationOperations = {
  $ref: ref,
  $path: pathOperation,
  $palette: palette
};
var logicOperations = {
  $if: ([condition, thenValue, elseValue]) => condition ? thenValue : elseValue,
  $eq: ([a, b]) => a === b,
  $not: ([a]) => !a,
  $or: (values) => (0, import_ag_charts_core55.isArray)(values) && values.some(Boolean),
  $and: (values) => (0, import_ag_charts_core55.isArray)(values) && values.every(Boolean),
  $switch: () => {
  },
  $isOperation: isOperationOperator
};
var numericOperations = {
  $isEven: isEven,
  $mul: mul,
  $round: round
};
var transformOperations = {
  $map: map,
  $find: find,
  $merge: merge2,
  $omit: omit,
  $value: valueOperation
};
var fontOperations = {
  $rem: rem
};
var colorOperations = {
  $mix: mix,
  $foregroundBackgroundMix: foregroundBackgroundMix,
  $foregroundBackgroundAccentMix: foregroundBackgroundAccentMix,
  $interpolate: interpolate2,
  $isGradient: ([value]) => isGradientFill2(value),
  $isPattern: ([value]) => isPatternFill2(value),
  $isImage: ([value]) => isImageFill2(value)
};
var operations = {
  ...locationOperations,
  ...logicOperations,
  ...numericOperations,
  ...transformOperations,
  ...fontOperations,
  ...colorOperations
};
function ref(value, path, params, source, meta) {
  if (!isKey(value, params)) {
    import_ag_charts_core55.Logger.warnOnce(
      `\`$ref\` json operation failed on [${String(value)}] at [${path.join(".")}], expecting one of [${Object.keys(params).join(", ")}].`
    );
    return;
  }
  const operation = getOperation(params[value]);
  if (operation?.operation !== "$ref" /* Ref */) {
    return params[value];
  }
  if (meta.referencedParams?.has(operation.values)) {
    import_ag_charts_core55.Logger.warnOnce(
      `\`$ref\` json operation failed on [${String(value)}] at [${path.join(".")}], circular reference detected with [${[...meta.referencedParams].join(", ")}].`
    );
    return;
  }
  meta.referencedParams?.add(operation.values);
  return ref(operation.values, path, params, source, meta);
}
function palette(value, path, params, source) {
  if (!(0, import_ag_charts_core55.isString)(value))
    return;
  const p = params.__palette;
  const indexPaletteParams = ["fill", "fillFallback", "stroke", "gradient", "range2"];
  if (indexPaletteParams.includes(value)) {
    const indexIndex = path.findLastIndex((v) => !isNaN(Number(v)));
    let index = Number(path[indexIndex]);
    if (isNaN(index))
      return;
    const seriesPath = path.slice(0, indexIndex);
    const ignoreIndexSeries = ["map-shape-background", "map-line-background"];
    const ignoreIndexOffset = getPath(source, seriesPath).slice(0, index).filter((s) => ignoreIndexSeries.includes(s.type)).length;
    index -= ignoreIndexOffset;
    switch (value) {
      case "fill":
        return (0, import_ag_charts_core55.circularSliceArray)(p.fills, 1, index)[0];
      case "fillFallback":
        return (0, import_ag_charts_core55.circularSliceArray)(p.fillsFallback, 1, index)[0];
      case "stroke":
        return (0, import_ag_charts_core55.circularSliceArray)(p.strokes, 1, index)[0];
      case "gradient":
        return (0, import_ag_charts_core55.circularSliceArray)(p.sequentialColors, 1, index)[0];
      case "range2":
        return (0, import_ag_charts_core55.circularSliceArray)(p.fills, 2, index);
    }
    return;
  }
  if (value === "gradients") {
    return p.sequentialColors;
  }
  return getPath(p, value);
}
function pathOperation(value, path, _params, source) {
  let hasDefaultValue = false;
  let defaultValue;
  let usingCustomBranch = false;
  let branch = source;
  if ((0, import_ag_charts_core55.isArray)(value)) {
    hasDefaultValue = true;
    defaultValue = value[1];
    usingCustomBranch = value.length === 3;
    branch = usingCustomBranch ? value[2] : branch;
    value = value[0];
  } else if (!(0, import_ag_charts_core55.isString)(value)) {
    import_ag_charts_core55.Logger.warnOnce(
      `\`$path\` json operation failed on [${String(value)}] at [${path.join(".")}], expecting a string.`
    );
    return;
  }
  const resolvedPath = resolvePath(usingCustomBranch ? [] : path, value);
  let resolvedValue = branch;
  for (const part of resolvedPath) {
    if (!isKey(part, resolvedValue)) {
      if (!hasDefaultValue) {
        import_ag_charts_core55.Logger.warnOnce(
          `\`$path\` json operation failed on [${String(value)}] at [${path.join(".")}] resolved to [${resolvedPath.join(".")}], could not find path in object.`
        );
        return;
      } else {
        return defaultValue;
      }
    }
    resolvedValue = resolvedValue[part];
  }
  return Object.isFrozen(resolvedValue) ? deepClone(resolvedValue) : resolvedValue;
}
function isOperationOperator(value, path, _params, source) {
  const resolvedPath = (0, import_ag_charts_core55.isString)(value) ? resolvePath(path, value) : path;
  const branch = resolvedPath.length === 0 ? source : getPath(source, resolvedPath);
  return getOperation(branch) != null;
}
function isEven([a], path) {
  if (typeof a === "number")
    return a % 2 === 0;
  import_ag_charts_core55.Logger.warnOnce(`\`$isEven\` json operation failed on [${String(a)}] at [${path.join(".")}], expecting a number.`);
}
function mul([a, b], path) {
  if (typeof a === "number" && typeof b === "number")
    return a * b;
  import_ag_charts_core55.Logger.warnOnce(
    `\`$mul\` json operation failed on [${String(a)}] and [${String(b)}] at [${path.join(".")}], expecting two numbers.`
  );
}
function round([a], path) {
  if (typeof a === "number")
    return Math.round(a);
  import_ag_charts_core55.Logger.warnOnce(`\`$round\` json operation failed on [${String(a)}] at [${path.join(".")}], expecting a number.`);
}
function map([mapOperation, mapValues], path, params, source, meta) {
  const valuesOperation = getOperation(mapValues);
  if (valuesOperation) {
    mapValues = resolveOperation(valuesOperation.operation, valuesOperation.values, params, source, path, meta);
  }
  if (!(0, import_ag_charts_core55.isArray)(mapValues))
    return [];
  const mappedOperation = getOperation(mapOperation);
  if (!mappedOperation)
    return [];
  meta.matches.set(path.join("."), mapValues);
  return mapValues.map(() => ({ [mappedOperation.operation]: mappedOperation.values }));
}
function find([findCondition, findValues], path, params, source, meta) {
  const valuesOperation = getOperation(findValues);
  if (valuesOperation) {
    findValues = resolveOperation(valuesOperation.operation, valuesOperation.values, params, source, path, meta);
  }
  if (!(0, import_ag_charts_core55.isArray)(findValues))
    return void 0;
  const conditionOperation = getOperation(findCondition);
  if (!conditionOperation) {
    return findCondition ? findValues[0] : void 0;
  }
  return findValues.find(
    (value) => resolveOperation(conditionOperation.operation, conditionOperation.values, params, value, [], meta)
  );
}
function merge2(values) {
  if (!(0, import_ag_charts_core55.isArray)(values))
    return;
  for (const value of values) {
    if (!(0, import_ag_charts_core55.isPlainObject)(value))
      return;
  }
  return mergeDefaults(...values);
}
function omit([keys, object3]) {
  if (!(0, import_ag_charts_core55.isArray)(keys) || !(0, import_ag_charts_core55.isPlainObject)(object3))
    return;
  return without(object3, keys);
}
function valueOperation(value, path, _params, _source, meta) {
  if (value !== "$1" && value !== "$index")
    return value;
  const indexIndex = path.findLastIndex((v) => !isNaN(Number(v)));
  if (indexIndex === -1)
    return value;
  const index = Number(path[indexIndex]);
  if (value === "$index")
    return index;
  const key = path.slice(0, indexIndex).join(".");
  return meta.matches.get(key)?.at(index);
}
function rem([a], path, params) {
  const fontSize = "fontSize";
  if (isKey(fontSize, params) && typeof params[fontSize] === "number" && typeof a === "number") {
    return Math.round(a * params[fontSize]);
  }
  import_ag_charts_core55.Logger.warnOnce(`\`$rem\` json operation failed on [${String(a)}] at [${path.join(".")}], expecting a number.`);
}
function mix([a, b, c], path) {
  const warningPrefix = `\`$mix\` json operation failed on [${String(a)}, ${String(b)}, ${String(c)}] at [${path.join(".")}], expecting`;
  const warningMessage = `${warningPrefix} two colors and a number between 0 and 1.`;
  if (typeof b !== "string" || !isRatio(c)) {
    import_ag_charts_core55.Logger.warnOnce(warningMessage);
    return;
  }
  if (typeof a === "string") {
    try {
      return Color.mix(Color.fromString(a), Color.fromString(b), c).toString();
    } catch {
      import_ag_charts_core55.Logger.warnOnce(warningMessage);
      return;
    }
  }
  if (!isGradientFill2(a)) {
    import_ag_charts_core55.Logger.warnOnce(warningMessage);
    return;
  }
  let colorStops = a.colorStops;
  try {
    colorStops = colorStops?.map((value) => {
      let color7;
      if (typeof value.color === "string") {
        color7 = Color.mix(Color.fromString(value.color), Color.fromString(b), c).toString();
      }
      return { ...value, color: color7 };
    });
  } catch {
    import_ag_charts_core55.Logger.warnOnce(`${warningPrefix} a gradient, a color and a number between 0 and 1.`);
    return;
  }
  return { ...a, colorStops };
}
function foregroundBackgroundMix([background], path, params) {
  const foregroundColor = "foregroundColor";
  const backgroundColor = "backgroundColor";
  if (isKey(foregroundColor, params) && isKey(backgroundColor, params) && typeof params[foregroundColor] === "string" && typeof params[backgroundColor] === "string" && isRatio(background)) {
    return Color.mix(
      Color.fromString(params[foregroundColor]),
      Color.fromString(params[backgroundColor]),
      background
    ).toString();
  }
  import_ag_charts_core55.Logger.warnOnce(
    `\`$foregroundBackgroundMix\` json operation failed on [${String(background)}}}] at [${path.join(".")}], expecting a number between 0 and 1.`
  );
}
function foregroundBackgroundAccentMix([background, accent], path, params) {
  const foregroundColor = "foregroundColor";
  const backgroundColor = "backgroundColor";
  const accentColor = "accentColor";
  if (isKey(foregroundColor, params) && isKey(backgroundColor, params) && isKey(accentColor, params) && typeof params[foregroundColor] === "string" && typeof params[backgroundColor] === "string" && typeof params[accentColor] === "string" && isRatio(background) && isRatio(accent)) {
    return Color.mix(
      Color.mix(Color.fromString(params[foregroundColor]), Color.fromString(params[backgroundColor]), background),
      Color.fromString(params[accentColor]),
      accent
    ).toString();
  }
  import_ag_charts_core55.Logger.warnOnce(
    `\`$foregroundBackgroundAccentMix\` json operation failed on [${String(background)}, ${String(accent)}}] at [${path.join(".")}], expecting two numbers between 0 and 1.`
  );
}
function interpolate2([colors, count]) {
  if (!(0, import_ag_charts_core55.isArray)(colors) || !(0, import_ag_charts_core55.isNumber)(count))
    return;
  return Color.interpolate(
    colors.map((color7) => Color.fromString(color7)),
    count
  ).map((color7) => color7.toString());
}

// packages/ag-charts-community/src/util/mutex.ts
var import_ag_charts_core56 = require("ag-charts-core");
var Mutex = class {
  constructor() {
    this.available = true;
    this.acquireQueue = [];
  }
  acquire(cb) {
    return new Promise((resolve) => {
      this.acquireQueue.push([cb, resolve]);
      if (this.available) {
        this.dispatchNext().catch((e) => import_ag_charts_core56.Logger.errorOnce(e));
      }
    });
  }
  async acquireImmediately(cb) {
    if (!this.available) {
      return false;
    }
    await this.acquire(cb);
    return true;
  }
  async waitForClearAcquireQueue() {
    return this.acquire(() => Promise.resolve(void 0));
  }
  async dispatchNext() {
    this.available = false;
    let [next, done] = this.acquireQueue.shift() ?? [];
    while (next) {
      try {
        await next();
        done?.();
      } catch (error) {
        import_ag_charts_core56.Logger.error("mutex callback error", error);
        done?.();
      }
      [next, done] = this.acquireQueue.shift() ?? [];
    }
    this.available = true;
  }
};

// packages/ag-charts-community/src/util/observable.ts
var Observable = class {
  constructor() {
    this.eventListeners = /* @__PURE__ */ new Map();
  }
  addEventListener(eventType, listener) {
    if (typeof listener !== "function") {
      throw new Error("AG Charts - listener must be a Function");
    }
    const eventTypeListeners = this.eventListeners.get(eventType);
    if (eventTypeListeners) {
      eventTypeListeners.add(listener);
    } else {
      this.eventListeners.set(eventType, /* @__PURE__ */ new Set([listener]));
    }
  }
  removeEventListener(type, listener) {
    const listeners = this.eventListeners.get(type);
    if (listeners == null)
      return;
    listeners.delete(listener);
    if (listeners.size === 0) {
      this.eventListeners.delete(type);
    }
  }
  hasEventListener(type) {
    return this.eventListeners.has(type);
  }
  clearEventListeners() {
    this.eventListeners.clear();
  }
  fireEvent(event) {
    this.eventListeners.get(event.type)?.forEach((listener) => listener(event));
  }
};

// packages/ag-charts-community/src/util/padding.ts
var Padding = class extends BaseProperties {
  constructor(top = 0, right = top, bottom = top, left = right) {
    super();
    this.top = top;
    this.right = right;
    this.bottom = bottom;
    this.left = left;
  }
};
__decorateClass([
  Property
], Padding.prototype, "top", 2);
__decorateClass([
  Property
], Padding.prototype, "right", 2);
__decorateClass([
  Property
], Padding.prototype, "bottom", 2);
__decorateClass([
  Property
], Padding.prototype, "left", 2);

// packages/ag-charts-community/src/util/render.ts
var import_ag_charts_core57 = require("ag-charts-core");
function debouncedAnimationFrame(cb) {
  return buildScheduler((innerCb, _delayMs) => (0, import_ag_charts_core57.getWindow)().requestAnimationFrame(innerCb), cb);
}
function debouncedCallback(cb) {
  return buildScheduler((innerCb, delayMs = 0) => {
    if (delayMs === 0) {
      queueMicrotask(innerCb);
    } else {
      setTimeout(innerCb, delayMs);
    }
  }, cb);
}
function buildScheduler(scheduleFn, cb) {
  let scheduleCount = 0;
  let promiseRunning = false;
  let awaitingPromise;
  let awaitingDone;
  const busy = () => {
    return promiseRunning;
  };
  const done = () => {
    promiseRunning = false;
    awaitingDone?.();
    awaitingDone = void 0;
    awaitingPromise = void 0;
    if (scheduleCount > 0) {
      scheduleFn(scheduleCb);
    }
  };
  const scheduleCb = () => {
    const count = scheduleCount;
    scheduleCount = 0;
    promiseRunning = true;
    const maybePromise = cb({ count });
    if (!maybePromise) {
      done();
      return;
    }
    maybePromise.then(done, done);
  };
  return {
    schedule(delayMs) {
      if (scheduleCount === 0 && !busy()) {
        scheduleFn(scheduleCb, delayMs);
      }
      scheduleCount++;
    },
    async await() {
      if (!busy()) {
        return;
      }
      if (awaitingPromise == null) {
        awaitingPromise = new Promise((resolve) => {
          awaitingDone = resolve;
        });
      }
      while (busy()) {
        await awaitingPromise;
      }
    }
  };
}

// packages/ag-charts-community/src/widget/widget.ts
var import_ag_charts_core62 = require("ag-charts-core");

// packages/ag-charts-community/src/widget/widgetEvents.ts
var WIDGET_HTML_EVENTS = [
  "blur",
  "change",
  "contextmenu",
  "focus",
  "keydown",
  "keyup",
  "click",
  "dblclick",
  "mouseenter",
  "mousemove",
  "mouseleave",
  "wheel",
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel"
];
function allocMouseEvent(type, sourceEvent, current) {
  const { offsetX, offsetY, clientX, clientY } = sourceEvent;
  const { currentX, currentY } = WidgetEventUtil.calcCurrentXY(current, sourceEvent);
  return { type, offsetX, offsetY, clientX, clientY, currentX, currentY, sourceEvent };
}
function allocTouchEvent(type, sourceEvent, _current) {
  return { type, sourceEvent };
}
var WidgetAllocators = {
  blur: (sourceEvent) => {
    return { type: "blur", sourceEvent };
  },
  change: (sourceEvent) => {
    return { type: "change", sourceEvent };
  },
  contextmenu: (sourceEvent, current) => {
    return allocMouseEvent("contextmenu", sourceEvent, current);
  },
  focus: (sourceEvent) => {
    return { type: "focus", sourceEvent };
  },
  keydown: (sourceEvent) => {
    return { type: "keydown", sourceEvent };
  },
  keyup: (sourceEvent) => {
    return { type: "keyup", sourceEvent };
  },
  click: (sourceEvent, current) => {
    return allocMouseEvent("click", sourceEvent, current);
  },
  dblclick: (sourceEvent, current) => {
    return allocMouseEvent("dblclick", sourceEvent, current);
  },
  mouseenter: (sourceEvent, current) => {
    return allocMouseEvent("mouseenter", sourceEvent, current);
  },
  mousemove: (sourceEvent, current) => {
    return allocMouseEvent("mousemove", sourceEvent, current);
  },
  mouseleave: (sourceEvent, current) => {
    return allocMouseEvent("mouseleave", sourceEvent, current);
  },
  wheel: (sourceEvent) => {
    const { offsetX, offsetY, clientX, clientY } = sourceEvent;
    const factor = sourceEvent.deltaMode === 0 ? 0.01 : 1;
    const deltaX = sourceEvent.deltaX * factor;
    const deltaY = sourceEvent.deltaY * factor;
    return { type: "wheel", offsetX, offsetY, clientX, clientY, deltaX, deltaY, sourceEvent };
  },
  touchstart: (sourceEvent, current) => {
    return allocTouchEvent("touchstart", sourceEvent, current);
  },
  touchmove: (sourceEvent, current) => {
    return allocTouchEvent("touchmove", sourceEvent, current);
  },
  touchend: (sourceEvent, current) => {
    return allocTouchEvent("touchend", sourceEvent, current);
  },
  touchcancel: (sourceEvent, current) => {
    return allocTouchEvent("touchcancel", sourceEvent, current);
  }
};
var WidgetEventUtil = class {
  static alloc(type, sourceEvent, current) {
    return WidgetAllocators[type](sourceEvent, current);
  }
  static isHTMLEvent(type) {
    const htmlTypes = WIDGET_HTML_EVENTS;
    return htmlTypes.includes(type);
  }
  static calcCurrentXY(current, event) {
    const currentRect = current.getBoundingClientRect();
    return { currentX: event.clientX - currentRect.x, currentY: event.clientY - currentRect.y };
  }
};

// packages/ag-charts-community/src/widget/widgetListenerHTML.ts
var import_ag_charts_core58 = require("ag-charts-core");
var WidgetListenerHTML = class {
  constructor() {
    this.widgetListeners = {};
    this.sourceListeners = {};
  }
  initSourceHandler(type, handler) {
    this.sourceListeners ?? (this.sourceListeners = {});
    this.sourceListeners[type] = handler;
  }
  lazyGetWidgetListeners(type, target) {
    var _a;
    if (!(type in (this.sourceListeners ?? {}))) {
      const sourceHandler = (sourceEvent) => {
        const widgetEvent = WidgetEventUtil.alloc(type, sourceEvent, target.getElement());
        for (const widgetListener of this.widgetListeners?.[type] ?? []) {
          widgetListener(widgetEvent, target);
        }
      };
      const opts = {};
      if (type.startsWith("touch"))
        opts.passive = false;
      this.initSourceHandler(type, sourceHandler);
      target.getElement().addEventListener(type, sourceHandler, opts);
    }
    this.widgetListeners ?? (this.widgetListeners = {});
    (_a = this.widgetListeners)[type] ?? (_a[type] = []);
    return this.widgetListeners[type];
  }
  add(type, target, handler) {
    const listeners = this.lazyGetWidgetListeners(type, target);
    listeners.push(handler);
  }
  remove(type, target, handler) {
    const listeners = this.lazyGetWidgetListeners(type, target);
    const index = listeners.indexOf(handler);
    if (index > -1)
      listeners.splice(index, 1);
  }
  destroy(target) {
    for (const [key, sourceHandler] of (0, import_ag_charts_core58.entries)(this.sourceListeners ?? {})) {
      target.getElement().removeEventListener(key, sourceHandler);
    }
    this.widgetListeners = void 0;
    this.sourceListeners = void 0;
  }
};

// packages/ag-charts-community/src/widget/widgetListenerInternal.ts
var import_ag_charts_core61 = require("ag-charts-core");

// packages/ag-charts-community/src/widget/mouseDragger.ts
var import_ag_charts_core59 = require("ag-charts-core");
var MouseDragger = class {
  constructor(glob, self, myCallbacks, downEvent) {
    this.glob = glob;
    this.self = self;
    this.window = (0, import_ag_charts_core59.getWindow)();
    this.mousegeneral = (generalEvent) => {
      generalEvent.stopPropagation();
      generalEvent.stopImmediatePropagation();
    };
    this.mousemove = (moveEvent) => {
      moveEvent.stopPropagation();
      moveEvent.stopImmediatePropagation();
      this.glob.globalMouseDragCallbacks?.mousemove(moveEvent);
    };
    this.mouseup = (upEvent) => {
      if (upEvent.button === 0) {
        upEvent.stopPropagation();
        upEvent.stopImmediatePropagation();
        this.glob.globalMouseDragCallbacks?.mouseup(upEvent);
        this.destroy();
      }
    };
    const { window: window2, mousegeneral, mousemove, mouseup } = this;
    window2.addEventListener("mousedown", mousegeneral, { capture: true });
    window2.addEventListener("mouseenter", mousegeneral, { capture: true });
    window2.addEventListener("mouseleave", mousegeneral, { capture: true });
    window2.addEventListener("mouseout", mousegeneral, { capture: true });
    window2.addEventListener("mouseover", mousegeneral, { capture: true });
    window2.addEventListener("mousemove", mousemove, { capture: true });
    window2.addEventListener("mouseup", mouseup, { capture: true });
    self.mouseDragger = this;
    glob.globalMouseDragCallbacks = myCallbacks;
    glob.globalMouseDragCallbacks.mousedown(downEvent);
  }
  destroy() {
    const { window: window2, mousegeneral, mousemove, mouseup } = this;
    window2.removeEventListener("mousedown", mousegeneral, { capture: true });
    window2.removeEventListener("mouseenter", mousegeneral, { capture: true });
    window2.removeEventListener("mouseleave", mousegeneral, { capture: true });
    window2.removeEventListener("mouseout", mousegeneral, { capture: true });
    window2.removeEventListener("mouseover", mousegeneral, { capture: true });
    window2.removeEventListener("mousemove", mousemove, { capture: true });
    window2.removeEventListener("mouseup", mouseup, { capture: true });
    this.glob.globalMouseDragCallbacks = void 0;
    this.self.mouseDragger = void 0;
  }
};
function startMouseDrag(glob, self, myCallbacks, downEvent) {
  if (glob.globalMouseDragCallbacks != null)
    return void 0;
  return new MouseDragger(glob, self, myCallbacks, downEvent);
}

// packages/ag-charts-community/src/widget/touchDragger.ts
var import_ag_charts_core60 = require("ag-charts-core");
var LONG_TAP_DURATION_MS = 500;
var LONG_TAP_INTERRUPT_MIN_TOUCHMOVE_PXPX = 100;
function deltaClientSquared(a, b) {
  const dx = a.clientX - b.clientX;
  const dy = a.clientY - b.clientY;
  return dx * dx + dy * dy;
}
var gIsInLongTap = false;
var TouchDragger = class {
  constructor(glob, self, myCallbacks, initialTouch, target) {
    this.glob = glob;
    this.self = self;
    this.initialTouch = initialTouch;
    this.target = target;
    this.longTapInterrupted = false;
    this.longtap = () => {
      const { target, initialTouch } = this;
      if (!this.longTapInterrupted) {
        target.dispatchEvent(new TouchEvent("touchcancel", { touches: [initialTouch], bubbles: true }));
        gIsInLongTap = true;
        const longTapMove = (e) => {
          e.preventDefault();
        };
        const longTapEnd = (e) => {
          gIsInLongTap = false;
          e.preventDefault();
          target.removeEventListener("touchmove", longTapMove);
          target.removeEventListener("touchend", longTapEnd);
          target.removeEventListener("touchcancel", longTapEnd);
        };
        target.addEventListener("touchmove", longTapMove, { passive: false });
        target.addEventListener("touchend", longTapEnd, { passive: false });
        target.addEventListener("touchcancel", longTapEnd, { passive: false });
        const { clientX, clientY } = initialTouch;
        const contextMenuEvent = new PointerEvent("contextmenu", {
          bubbles: true,
          cancelable: true,
          view: (0, import_ag_charts_core60.getWindow)(),
          clientX,
          clientY,
          pointerType: "touch"
        });
        target.dispatchEvent(contextMenuEvent);
      }
    };
    this.touchmove = (moveEvent) => {
      const { glob, self, initialTouch } = this;
      const touch = this.findInitialFinger(moveEvent.targetTouches);
      if (touch != null) {
        this.longTapInterrupted = this.longTapInterrupted || deltaClientSquared(initialTouch, touch) > LONG_TAP_INTERRUPT_MIN_TOUCHMOVE_PXPX;
        if (self.dragTouchEnabled && touch != null) {
          glob.globalTouchDragCallbacks?.touchmove(moveEvent, touch);
        }
      }
    };
    this.touchend = (endEvent) => {
      this.longTapInterrupted = true;
      const touch = this.findInitialFinger(endEvent.changedTouches, endEvent.touches);
      if (touch != null) {
        this.glob.globalTouchDragCallbacks?.touchend(endEvent, touch);
      }
      this.destroy();
    };
    this.longtapTimer = setTimeout(this.longtap, LONG_TAP_DURATION_MS);
    const { touchmove, touchend } = this;
    target.addEventListener("touchmove", touchmove, { passive: false });
    target.addEventListener("touchstart", touchend, { passive: false });
    target.addEventListener("touchend", touchend, { passive: false });
    target.addEventListener("touchcancel", touchend, { passive: false });
    self.touchDragger = this;
    glob.globalTouchDragCallbacks = myCallbacks;
  }
  destroy() {
    const { longtapTimer, touchmove, touchend } = this;
    clearTimeout(longtapTimer);
    this.target.removeEventListener("touchstart", touchend);
    this.target.removeEventListener("touchmove", touchmove);
    this.target.removeEventListener("touchend", touchend);
    this.target.removeEventListener("touchcancel", touchend);
    this.glob.globalTouchDragCallbacks = void 0;
    this.self.touchDragger = void 0;
  }
  findInitialFinger(...touchLists) {
    const touches = touchLists.map((touchList) => Array.from(touchList)).flat();
    return Array.from(touches).find((v) => v.identifier === this.initialTouch.identifier);
  }
};
function startOneFingerTouch(glob, self, myCallbacks, initialTouch, target) {
  if (glob.globalTouchDragCallbacks != null || gIsInLongTap)
    return void 0;
  return new TouchDragger(glob, self, myCallbacks, initialTouch, target);
}

// packages/ag-charts-community/src/widget/widgetListenerInternal.ts
function makeMouseDrag(current, type, origin2, sourceEvent) {
  const { currentX, currentY } = WidgetEventUtil.calcCurrentXY(current.getElement(), sourceEvent);
  const originDeltaX = sourceEvent.pageX - origin2.pageX;
  const originDeltaY = sourceEvent.pageY - origin2.pageY;
  return {
    type,
    device: "mouse",
    offsetX: origin2.offsetX + originDeltaX,
    offsetY: origin2.offsetY + originDeltaY,
    clientX: sourceEvent.clientX,
    clientY: sourceEvent.clientY,
    currentX,
    currentY,
    originDeltaX,
    originDeltaY,
    sourceEvent
  };
}
function getTouchOffsets(current, { pageX, pageY }) {
  const { x, y } = current.getElement().getBoundingClientRect();
  return { offsetX: pageX - x, offsetY: pageY - y };
}
function makeTouchDrag(current, type, origin2, sourceEvent, touch) {
  const { currentX, currentY } = WidgetEventUtil.calcCurrentXY(current.getElement(), touch);
  const originDeltaX = touch.pageX - origin2.pageX;
  const originDeltaY = touch.pageY - origin2.pageY;
  return {
    type,
    device: "touch",
    offsetX: origin2.offsetX + originDeltaX,
    offsetY: origin2.offsetY + originDeltaY,
    clientX: touch.clientX,
    clientY: touch.clientY,
    currentX,
    currentY,
    originDeltaX,
    originDeltaY,
    sourceEvent
  };
}
var GlobalCallbacks = {};
var WidgetListenerInternal = class {
  constructor(dispatchCallback) {
    this.dispatchCallback = dispatchCallback;
    this.dragTouchEnabled = true;
  }
  destroy() {
    this.dragTriggerRemover?.();
    this.dragTriggerRemover = void 0;
    this.listeners?.clear();
    this.mouseDragger?.destroy();
    this.touchDragger?.destroy();
  }
  getListenerSet(type) {
    this.listeners ?? (this.listeners = /* @__PURE__ */ new Map());
    let result = this.listeners.get(type);
    if (result === void 0) {
      result = /* @__PURE__ */ new Set();
      this.listeners.set(type, result);
    }
    return result;
  }
  add(type, target, handler) {
    this.getListenerSet(type).add(handler);
    switch (type) {
      case "drag-start":
      case "drag-move":
      case "drag-end": {
        this.registerDragTrigger(target);
        break;
      }
    }
  }
  remove(type, _target, handler) {
    this.getListenerSet(type).delete(handler);
  }
  registerDragTrigger(target) {
    if (this.dragTriggerRemover == null) {
      const mouseTrigger = (event) => this.triggerMouseDrag(target, event);
      const touchTrigger = (event) => this.triggerTouchDrag(target, event);
      target.getElement().addEventListener("mousedown", mouseTrigger);
      target.getElement().addEventListener("touchstart", touchTrigger, { passive: false });
      this.dragTriggerRemover = () => {
        target.getElement().removeEventListener("mousedown", mouseTrigger);
        target.getElement().removeEventListener("touchstart", touchTrigger);
      };
    }
  }
  triggerMouseDrag(current, downEvent) {
    if (downEvent.button === 0) {
      this.startMouseDrag(current, downEvent);
    }
  }
  startMouseDrag(current, initialDownEvent) {
    const origin2 = { pageX: NaN, pageY: NaN, offsetX: NaN, offsetY: NaN };
    partialAssign(["pageX", "pageY", "offsetX", "offsetY"], origin2, initialDownEvent);
    const dragCallbacks = {
      mousedown: (downEvent) => {
        const dragStartEvent = makeMouseDrag(current, "drag-start", origin2, downEvent);
        this.dispatch("drag-start", current, dragStartEvent);
      },
      mousemove: (moveEvent) => {
        const dragMoveEvent = makeMouseDrag(current, "drag-move", origin2, moveEvent);
        this.dispatch("drag-move", current, dragMoveEvent);
      },
      mouseup: (upEvent) => {
        const dragEndEvent = makeMouseDrag(current, "drag-end", origin2, upEvent);
        this.dispatch("drag-end", current, dragEndEvent);
        this.endDrag(current, dragEndEvent);
      }
    };
    this.mouseDragger = startMouseDrag(GlobalCallbacks, this, dragCallbacks, initialDownEvent);
  }
  endDrag(target, { sourceEvent, clientX, clientY }) {
    const elem = target.getElement();
    const rect = elem.getBoundingClientRect();
    if (!BBoxValues.containsPoint(rect, clientX, clientY)) {
      elem.dispatchEvent(new MouseEvent("mouseleave", sourceEvent));
      sourceEvent.target?.dispatchEvent(new MouseEvent("mouseenter", sourceEvent));
    }
  }
  triggerTouchDrag(current, startEvent) {
    const touch = startEvent.targetTouches[0];
    if (startEvent.targetTouches.length === 1 && touch != null) {
      this.startOneFingerTouch(current, startEvent, touch);
    }
  }
  startOneFingerTouch(current, initialEvent, initialTouch) {
    const origin2 = { pageX: NaN, pageY: NaN, ...getTouchOffsets(current, initialTouch) };
    partialAssign(["pageX", "pageY"], origin2, initialTouch);
    const dragCallbacks = {
      touchmove: (moveEvent, touch) => {
        const dragMoveEvent = makeTouchDrag(current, "drag-move", origin2, moveEvent, touch);
        this.dispatch("drag-move", current, dragMoveEvent);
      },
      touchend: (cancelEvent, touch) => {
        const dragMoveEvent = makeTouchDrag(current, "drag-end", origin2, cancelEvent, touch);
        this.dispatch("drag-end", current, dragMoveEvent);
      }
    };
    const target = current.getElement();
    this.touchDragger = startOneFingerTouch(GlobalCallbacks, this, dragCallbacks, initialTouch, target);
    const dragStartEvent = makeTouchDrag(current, "drag-start", origin2, initialEvent, initialTouch);
    this.dispatch("drag-start", current, dragStartEvent);
  }
  dispatch(type, current, event) {
    for (const handler of this.getListenerSet(type)) {
      handler(event, current);
    }
    this.dispatchCallback(type, event);
  }
};

// packages/ag-charts-community/src/widget/widget.ts
var WidgetBounds = class {
  constructor(elem) {
    this.elem = elem;
  }
  setBounds(bounds) {
    setElementBBox(this.elemContainer ?? this.elem, bounds);
  }
  getBounds() {
    return getElementBBox(this.elemContainer ?? this.elem);
  }
  static setElementContainer(widget, elemContainer) {
    const currentBounds = widget.getBounds();
    setElementBBox(elemContainer, currentBounds);
    (0, import_ag_charts_core62.setElementStyles)(widget.elem, { width: "100%", height: "100%" });
    widget.elem.remove();
    widget.elemContainer = elemContainer;
    widget.elemContainer.replaceChildren(widget.elem);
  }
};
var Widget = class extends WidgetBounds {
  constructor(elem) {
    super(elem);
    this.elem = elem;
    this.index = NaN;
    this.children = [];
  }
  set id(elementId) {
    (0, import_ag_charts_core62.setAttribute)(this.elem, "id", elementId);
  }
  get id() {
    return (0, import_ag_charts_core62.getAttribute)(this.elem, "id");
  }
  getElement() {
    return this.elem;
  }
  getBoundingClientRect() {
    return this.elem.getBoundingClientRect();
  }
  get clientWidth() {
    return this.elem.clientWidth;
  }
  get clientHeight() {
    return this.elem.clientHeight;
  }
  destroy() {
    this.parent?.removeChild(this);
    this.children.forEach((child) => {
      child.parent = void 0;
      child.destroy();
    });
    this.children.length = 0;
    this.destructor();
    this.remove();
    this.internalListener?.destroy();
    this.htmlListener?.destroy(this);
  }
  remove() {
    this.elem.remove();
    this.elemContainer?.remove();
  }
  setHidden(hidden) {
    (0, import_ag_charts_core62.setElementStyle)(this.elem, "display", hidden ? "none" : void 0);
  }
  isHidden() {
    return (0, import_ag_charts_core62.getWindow)()?.getComputedStyle?.(this.elem).display === "none";
  }
  setCursor(cursor) {
    (0, import_ag_charts_core62.setElementStyle)(this.elem, "cursor", cursor);
  }
  setTextContent(textContent) {
    this.elem.textContent = textContent ?? null;
  }
  setAriaDescribedBy(ariaDescribedBy) {
    (0, import_ag_charts_core62.setAttribute)(this.elem, "aria-describedby", ariaDescribedBy);
  }
  setAriaHidden(ariaHidden) {
    (0, import_ag_charts_core62.setAttribute)(this.elem, "aria-hidden", ariaHidden);
  }
  setAriaLabel(ariaLabel) {
    (0, import_ag_charts_core62.setAttribute)(this.elem, "aria-label", ariaLabel);
  }
  setAriaExpanded(ariaExpanded) {
    (0, import_ag_charts_core62.setAttribute)(this.elem, "aria-expanded", ariaExpanded);
  }
  setAriaControls(ariaControls) {
    (0, import_ag_charts_core62.setAttribute)(this.elem, "aria-controls", ariaControls);
  }
  setAriaHasPopup(ariaHasPopup) {
    (0, import_ag_charts_core62.setAttribute)(this.elem, "aria-haspopup", ariaHasPopup);
  }
  setInnerHTML(html) {
    this.elem.innerHTML = html;
  }
  setPointerEvents(pointerEvents) {
    (0, import_ag_charts_core62.setElementStyle)(this.elem, "pointer-events", pointerEvents);
  }
  isDisabled() {
    return (0, import_ag_charts_core62.getAttribute)(this.elem, "aria-disabled", false);
  }
  hasPopup() {
    const ariaHasPopup = (0, import_ag_charts_core62.getAttribute)(this.elem, "aria-haspopup");
    return ariaHasPopup !== void 0 && ariaHasPopup !== "false";
  }
  parseFloat(s) {
    return s === "" ? 0 : parseFloat(s);
  }
  cssLeft() {
    return this.parseFloat(this.elem.style.left);
  }
  cssTop() {
    return this.parseFloat(this.elem.style.top);
  }
  cssWidth() {
    return this.parseFloat(this.elem.style.width);
  }
  cssHeight() {
    return this.parseFloat(this.elem.style.height);
  }
  focus(opts) {
    this.elem.focus(opts);
  }
  setFocusOverride(focus) {
    (0, import_ag_charts_core62.setAttribute)(this.elem, "data-focus-override", focus);
  }
  setPreventsDefault(preventDefault) {
    (0, import_ag_charts_core62.setAttribute)(this.elem, "data-preventdefault", preventDefault);
  }
  setTabIndex(tabIndex) {
    (0, import_ag_charts_core62.setAttribute)(this.elem, "tabindex", tabIndex);
  }
  addChild(child) {
    this.addChildToDOM(child, this.getBefore(child));
    this.children.push(child);
    child.index = this.children.length - 1;
    child.parent = this;
    this.onChildAdded(child);
  }
  removeChild(child) {
    const i = this.children.findIndex((value) => value === child);
    this.children.splice(i, 1);
    this.removeChildFromDOM(child);
    this.onChildRemoved(child);
  }
  moveChild(child, domIndex) {
    if (child.domIndex === domIndex)
      return;
    child.domIndex = domIndex;
    this.removeChildFromDOM(child);
    this.addChildToDOM(child, this.getBefore(child));
  }
  addClass(...tokens) {
    this.elem.classList.add(...tokens);
  }
  removeClass(...tokens) {
    this.elem.classList.remove(...tokens);
  }
  toggleClass(token, force) {
    this.elem.classList.toggle(token, force);
  }
  appendOrInsert(child, before) {
    if (before) {
      before.getElement().insertAdjacentElement("beforebegin", child);
    } else {
      this.elem.appendChild(child);
    }
  }
  addChildToDOM(child, before) {
    this.appendOrInsert(child.getElement(), before);
  }
  removeChildFromDOM(child) {
    this.elem.removeChild(child.getElement());
  }
  onChildAdded(_child) {
  }
  onChildRemoved(_child) {
  }
  getBefore({ domIndex }) {
    if (domIndex === void 0)
      return void 0;
    return this.children.filter((child) => child.domIndex !== void 0 && child.domIndex > domIndex).reduce((prev, curr) => !prev || curr.domIndex < prev.domIndex ? curr : prev, void 0);
  }
  addListener(type, listener) {
    if (WidgetEventUtil.isHTMLEvent(type)) {
      this.htmlListener ?? (this.htmlListener = new WidgetListenerHTML());
      this.htmlListener.add(type, this, listener);
    } else {
      this.internalListener ?? (this.internalListener = new WidgetListenerInternal(this.onDispatch.bind(this)));
      this.internalListener.add(type, this, listener);
    }
    return () => this.removeListener(type, listener);
  }
  removeListener(type, listener) {
    if (WidgetEventUtil.isHTMLEvent(type)) {
      this.htmlListener?.remove(type, this, listener);
    } else if (this.htmlListener != null) {
      this.internalListener?.remove(type, this, listener);
    }
  }
  setDragTouchEnabled(dragTouchEnabled) {
    this.internalListener ?? (this.internalListener = new WidgetListenerInternal(this.onDispatch.bind(this)));
    this.internalListener.dragTouchEnabled = dragTouchEnabled;
  }
  onDispatch(type, event) {
    if (!event.sourceEvent?.bubbles)
      return;
    let { parent } = this;
    while (parent != null) {
      const { internalListener } = parent;
      if (internalListener != null) {
        const parentEvent = { ...event, ...WidgetEventUtil.calcCurrentXY(parent.getElement(), event) };
        internalListener.dispatch(type, parent, parentEvent);
      }
      parent = parent.parent;
    }
  }
  static addWindowEvent(_type, listener) {
    const pagehideHandler = (event) => {
      if (event.persisted) {
        return;
      }
      listener();
    };
    (0, import_ag_charts_core62.getWindow)().addEventListener("pagehide", pagehideHandler);
    return () => (0, import_ag_charts_core62.getWindow)().removeEventListener("pagehide", pagehideHandler);
  }
};

// packages/ag-charts-community/src/chart/layout/layoutManager.ts
var import_ag_charts_core63 = require("ag-charts-core");
var LayoutElement = /* @__PURE__ */ ((LayoutElement2) => {
  LayoutElement2[LayoutElement2["Caption"] = 0] = "Caption";
  LayoutElement2[LayoutElement2["Legend"] = 1] = "Legend";
  LayoutElement2[LayoutElement2["ToolbarLeft"] = 2] = "ToolbarLeft";
  LayoutElement2[LayoutElement2["ToolbarBottom"] = 3] = "ToolbarBottom";
  LayoutElement2[LayoutElement2["Navigator"] = 4] = "Navigator";
  LayoutElement2[LayoutElement2["Overlay"] = 5] = "Overlay";
  return LayoutElement2;
})(LayoutElement || {});
var LayoutManager = class {
  constructor() {
    this.events = new import_ag_charts_core63.EventEmitter();
    this.elements = /* @__PURE__ */ new Map();
  }
  addListener(eventName, listener) {
    return this.events.on(eventName, listener);
  }
  registerElement(element2, listener) {
    if (this.elements.has(element2)) {
      this.elements.get(element2).add(listener);
    } else {
      this.elements.set(element2, /* @__PURE__ */ new Set([listener]));
    }
    return () => this.elements.get(element2)?.delete(listener);
  }
  createContext(width2, height2) {
    const context = new LayoutContext(width2, height2);
    for (const element2 of Object.values(LayoutElement)) {
      if (typeof element2 !== "number")
        continue;
      this.elements.get(element2)?.forEach((listener) => listener(context));
    }
    return context;
  }
  emitLayoutComplete(context, options) {
    const eventType = "layout:complete";
    const { width: width2, height: height2 } = context;
    this.events.emit(eventType, {
      type: eventType,
      axes: options.axes ?? [],
      chart: { width: width2, height: height2 },
      clipSeries: options.clipSeries ?? false,
      series: options.series
    });
  }
};
var LayoutContext = class {
  constructor(width2, height2) {
    this.width = width2;
    this.height = height2;
    this.layoutBox = new BBox(0, 0, width2, height2);
  }
};

// packages/ag-charts-community/src/chart/chartCaptions.ts
var ChartCaptions = class {
  constructor() {
    this.title = new Caption();
    this.subtitle = new Caption();
    this.footnote = new Caption();
  }
  positionCaptions(ctx) {
    const { title, subtitle, footnote } = this;
    const maxHeight = ctx.layoutBox.height / 10;
    if (title.enabled) {
      const { spacing } = title;
      this.positionCaption("top", title, ctx.layoutBox, maxHeight);
      this.shrinkLayoutByCaption("top", title, ctx.layoutBox, spacing);
    }
    if (subtitle.enabled) {
      this.positionCaption("top", subtitle, ctx.layoutBox, maxHeight);
      this.shrinkLayoutByCaption("top", subtitle, ctx.layoutBox, subtitle.spacing);
    }
    if (footnote.enabled) {
      this.positionCaption("bottom", footnote, ctx.layoutBox, maxHeight);
      this.shrinkLayoutByCaption("bottom", footnote, ctx.layoutBox, footnote.spacing);
    }
  }
  positionAbsoluteCaptions(ctx) {
    const { title, subtitle, footnote } = this;
    const { rect } = ctx.series;
    for (const caption of [title, subtitle, footnote]) {
      if (caption.layoutStyle !== "overlay")
        continue;
      if (caption.textAlign === "left") {
        caption.node.x = rect.x + caption.padding;
      } else if (caption.textAlign === "right") {
        const bbox = caption.node.getBBox();
        caption.node.x = rect.x + rect.width - bbox.width - caption.padding;
      }
    }
  }
  computeX(align2, layoutBox) {
    if (align2 === "left") {
      return layoutBox.x;
    } else if (align2 === "right") {
      return layoutBox.x + layoutBox.width;
    }
    return layoutBox.x + layoutBox.width / 2;
  }
  positionCaption(vAlign, caption, layoutBox, maxHeight) {
    const containerHeight = Math.max(TextUtils.getLineHeight(caption.fontSize), maxHeight);
    caption.node.x = this.computeX(caption.textAlign, layoutBox) + caption.padding;
    caption.node.y = layoutBox.y + (vAlign === "top" ? 0 : layoutBox.height) + caption.padding;
    caption.node.textBaseline = vAlign;
    caption.computeTextWrap(layoutBox.width, containerHeight);
  }
  shrinkLayoutByCaption(vAlign, caption, layoutBox, spacing = 0) {
    if (caption.layoutStyle === "block") {
      const bbox = caption.node.getTextMeasureBBox();
      layoutBox.shrink(
        vAlign === "top" ? Math.ceil(bbox.y - layoutBox.y + bbox.height + spacing) : Math.ceil(layoutBox.y + layoutBox.height - bbox.y + spacing),
        vAlign
      );
    }
  }
};
__decorateClass([
  Property
], ChartCaptions.prototype, "title", 2);
__decorateClass([
  Property
], ChartCaptions.prototype, "subtitle", 2);
__decorateClass([
  Property
], ChartCaptions.prototype, "footnote", 2);

// packages/ag-charts-community/src/api/preset/chartTypeOriginator.ts
var import_ag_charts_core64 = require("ag-charts-core");
var chartTypes2 = [
  "candlestick",
  "hollow-candlestick",
  "ohlc",
  "line",
  "step-line",
  "hlc",
  "high-low"
];
var ChartTypeOriginator = class {
  constructor(chartService) {
    this.chartService = chartService;
    this.mementoOriginatorKey = "chartType";
  }
  createMemento() {
    let chartType = this.chartService.publicApi?.getOptions()?.chartType;
    if (chartType == null)
      chartType = "candlestick";
    return chartType;
  }
  guardMemento(blob) {
    return blob == null || chartTypes2.includes(blob);
  }
  restoreMemento(_version, _mementoVersion, memento) {
    if (memento == null)
      return;
    const options = { chartType: memento };
    this.chartService.publicApi?.updateDelta(options).catch((e) => import_ag_charts_core64.Logger.error("error restoring state", e));
  }
};

// packages/ag-charts-community/src/util/destroy.ts
var DestroyFns = class {
  constructor() {
    this.destroyFns = [];
  }
  destroy() {
    this.destroyFns.forEach((fn) => fn());
    this.destroyFns.length = 0;
  }
  setFns(destroyFns) {
    this.destroy();
    this.destroyFns = destroyFns;
  }
  push(...destroyFns) {
    this.destroyFns.push(...destroyFns);
  }
};

// packages/ag-charts-community/src/version.ts
var VERSION = "11.3.2";

// packages/ag-charts-community/src/api/state/historyManager.ts
var NOT_FOUND = Symbol("previous-memento-not-found");
var HistoryManager = class {
  constructor(chartEventManager) {
    this.history = [];
    this.historyIndex = -1;
    this.originators = /* @__PURE__ */ new Map();
    this.clearState = /* @__PURE__ */ new Map();
    this.maxHistoryLength = 100;
    this.debug = Debug.create(true, "history");
    this.destroyFns = new DestroyFns();
    this.destroyFns.setFns([
      chartEventManager.addListener("series-undo", this.undo.bind(this)),
      chartEventManager.addListener("series-redo", this.redo.bind(this))
    ]);
  }
  destroy() {
    this.destroyFns.destroy();
  }
  addMementoOriginator(originator) {
    this.originators.set(originator.mementoOriginatorKey, originator);
    this.clearState.set(originator.mementoOriginatorKey, originator.createMemento());
    this.debugEvent("History add originator:", originator.mementoOriginatorKey);
  }
  clear() {
    this.debug(`History clear:`, Object.keys(this.originators));
    this.history = [];
    this.historyIndex = -1;
    for (const [mementoOriginatorKey, originator] of this.originators.entries()) {
      this.clearState.set(mementoOriginatorKey, originator.createMemento());
    }
  }
  record(label, ...originators) {
    if (this.historyIndex < this.history.length - 1) {
      this.history = this.history.slice(0, this.historyIndex + 1);
    }
    if (this.history.length > this.maxHistoryLength) {
      this.history = this.history.slice(-this.maxHistoryLength);
    }
    const mementos = /* @__PURE__ */ new Map();
    for (const originator of originators) {
      if (!this.originators.has(originator.mementoOriginatorKey)) {
        throw new Error(
          `Originator [${originator.mementoOriginatorKey}] has not been added to the HistoryManager.`
        );
      }
      mementos.set(originator.mementoOriginatorKey, originator.createMemento());
    }
    this.history.push({ label, mementos });
    this.historyIndex = this.history.length - 1;
    this.debugEvent(`History record: [${label}]`);
  }
  undo() {
    const undoAction = this.history[this.historyIndex];
    if (!undoAction)
      return;
    for (const mementoOriginatorKey of undoAction.mementos.keys()) {
      const previousMemento = this.findPreviousMemento(mementoOriginatorKey);
      if (previousMemento === NOT_FOUND) {
        throw new Error(`Could not find previous memento for [${mementoOriginatorKey}].`);
      }
      this.restoreMemento(mementoOriginatorKey, previousMemento);
    }
    this.historyIndex -= 1;
    this.debugEvent(`History undo: [${undoAction.label}]`);
  }
  redo() {
    const redoAction = this.history[this.historyIndex + 1];
    if (!redoAction)
      return;
    for (const [mementoOriginatorKey, memento] of redoAction.mementos.entries()) {
      this.restoreMemento(mementoOriginatorKey, memento);
    }
    this.historyIndex += 1;
    this.debugEvent(`History redo: [${redoAction.label}]`);
  }
  findPreviousMemento(mementoOriginatorKey) {
    for (let i = this.historyIndex - 1; i >= 0; i--) {
      if (this.history[i].mementos.has(mementoOriginatorKey)) {
        return this.history[i].mementos.get(mementoOriginatorKey);
      }
    }
    if (this.clearState.has(mementoOriginatorKey)) {
      return this.clearState.get(mementoOriginatorKey);
    }
    return NOT_FOUND;
  }
  restoreMemento(mementoOriginatorKey, memento) {
    this.originators.get(mementoOriginatorKey)?.restoreMemento(VERSION, VERSION, memento);
  }
  debugEvent(...logContent) {
    this.debug(
      ...logContent,
      this.history.map((action, index) => index === this.historyIndex ? `** ${action.label} **` : action.label)
    );
  }
};

// packages/ag-charts-community/src/api/state/memento.ts
var import_ag_charts_core65 = require("ag-charts-core");
var MementoCaretaker = class _MementoCaretaker {
  constructor(version) {
    this.version = version.split("-")[0];
  }
  save(...originators) {
    const packet = { version: this.version };
    for (const originator of Object.values(originators)) {
      packet[originator.mementoOriginatorKey] = this.encode(originator, originator.createMemento());
    }
    return packet;
  }
  restore(blob, ...originators) {
    if (typeof blob !== "object") {
      import_ag_charts_core65.Logger.warnOnce(`Could not restore data of type [${typeof blob}], expecting an object, ignoring.`);
      return;
    }
    if (blob == null) {
      import_ag_charts_core65.Logger.warnOnce(`Could not restore data of type [null], expecting an object, ignoring.`);
      return;
    }
    if (!("version" in blob) || typeof blob.version !== "string") {
      import_ag_charts_core65.Logger.warnOnce(`Could not restore data, missing [version] string in object, ignoring.`);
      return;
    }
    for (const originator of originators) {
      const memento = this.decode(originator, blob[originator.mementoOriginatorKey]);
      const messages = [];
      if (!originator.guardMemento(memento, messages)) {
        const messagesString = messages.length > 0 ? `

${messages.join("\n\n")}

` : "";
        import_ag_charts_core65.Logger.warnOnce(
          `Could not restore [${originator.mementoOriginatorKey}] data, value was invalid, ignoring.${messagesString}`,
          memento
        );
        return;
      }
      originator.restoreMemento(this.version, blob.version, memento);
    }
  }
  /**
   * Encode a memento as a serializable object, encoding any non-serializble types.
   */
  encode(originator, memento) {
    try {
      return JSON.parse(JSON.stringify(memento, _MementoCaretaker.encodeTypes));
    } catch (error) {
      throw new Error(`Failed to encode [${originator.mementoOriginatorKey}] value [${error}].`, {
        cause: error
      });
    }
  }
  /**
   * Decode an encoded memento, decoding any non-serializable types.
   */
  decode(originator, encoded) {
    if (encoded == null)
      return encoded;
    try {
      return JSON.parse(JSON.stringify(encoded), _MementoCaretaker.decodeTypes);
    } catch (error) {
      throw new Error(`Failed to decode [${originator.mementoOriginatorKey}] value [${error}].`, {
        cause: error
      });
    }
  }
  static encodeTypes(key, value) {
    if ((0, import_ag_charts_core65.isDate)(this[key])) {
      return { __type: "date", value: this[key].toISOString() };
    }
    return value;
  }
  static decodeTypes(key, value) {
    if ((0, import_ag_charts_core65.isObject)(this[key]) && "__type" in this[key] && this[key].__type === "date") {
      return new Date(this[key].value);
    }
    return value;
  }
};

// packages/ag-charts-community/src/api/state/stateManager.ts
var StateManager = class {
  constructor() {
    this.caretaker = new MementoCaretaker(VERSION);
    this.state = /* @__PURE__ */ new Map();
  }
  setState(originator, value) {
    if (objectsEqual(this.state.get(originator.mementoOriginatorKey), value)) {
      return;
    }
    this.setStateAndRestore(originator, value);
  }
  setStateAndRestore(originator, value) {
    this.state.set(originator.mementoOriginatorKey, value);
    this.restoreState(originator);
  }
  restoreState(originator) {
    const { caretaker, state } = this;
    if (!state.has(originator.mementoOriginatorKey))
      return;
    const value = state.get(originator.mementoOriginatorKey);
    caretaker.restore({ version: caretaker.version, [originator.mementoOriginatorKey]: value }, originator);
  }
};

// packages/ag-charts-community/src/dom/domManager.ts
var import_ag_charts_core71 = require("ag-charts-core");

// packages/ag-charts-community/src/styles.css
var styles_default = '.ag-charts-wrapper,.ag-charts-wrapper:after,.ag-charts-wrapper:before,.ag-charts-wrapper *,.ag-charts-wrapper *:after,.ag-charts-wrapper *:before{box-sizing:border-box}.ag-charts-wrapper{--align-items: center;--justify-content: center;position:relative;user-select:none;-webkit-user-select:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.ag-charts-wrapper--safe-horizontal{--justify-content: flex-start}.ag-charts-wrapper--safe-vertical{--align-items: flex-start}.ag-charts-tab-guard{width:0%;height:0%;position:absolute;pointer-events:none}.ag-charts-canvas-center{width:100%;height:100%;position:absolute;touch-action:auto;pointer-events:auto;display:flex;align-items:var(--align-items);justify-content:var(--justify-content)}.ag-charts-canvas-container,.ag-charts-canvas{position:relative;user-select:none;-webkit-user-select:none}.ag-charts-canvas-container>*,.ag-charts-canvas>*{pointer-events:none}.ag-charts-canvas canvas{display:block}.ag-charts-series-area{outline:none;pointer-events:auto;position:absolute}.ag-charts-swapchain{top:0;left:0;outline:none;opacity:0;pointer-events:none;position:absolute;width:100%;height:100%}.ag-charts-swapchain:focus-visible{opacity:1}.ag-charts-canvas-proxy,.ag-charts-canvas-overlay{inset:0;pointer-events:none;position:absolute;user-select:none;-webkit-user-select:none}.ag-charts-canvas-overlay>*{position:absolute;pointer-events:auto}.ag-charts-theme-default,.ag-charts-theme-default-dark{--ag-charts-accent-color: #2196f3;--ag-charts-background-color: #fff;--ag-charts-border-color: #dddddd;--ag-charts-foreground-color: #464646;--ag-charts-font-family: Verdana, sans-serif;--ag-charts-font-size: 12px;--ag-charts-font-weight: 400;--ag-charts-padding: 20px;--ag-charts-shadow-color: #00000080;--ag-charts-subtle-text-color: #8c8c8c;--ag-charts-text-color: #464646;--ag-charts-chrome-background-color: #fafafa;--ag-charts-chrome-font-family: Verdana, sans-serif;--ag-charts-chrome-font-size: 12px;--ag-charts-chrome-font-weight: 400;--ag-charts-chrome-subtle-text-color: #8c8c8c;--ag-charts-chrome-text-color: #181d1f;--ag-charts-input-background-color: #fff;--ag-charts-input-text-color: #464646;--ag-charts-crosshair-label-background-color: #fff;--ag-charts-crosshair-label-text-color: #464646;--ag-charts-spacing: 4px;--ag-charts-border-radius: 4px;--ag-charts-icon-size: 16px;--ag-charts-shadow: 0 2px 8px 0 color-mix(in srgb, black 8%, transparent);--ag-charts-focus-shadow: 0 0 0 3px var(--ag-charts-accent-color);--ag-charts-focus-color: color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-accent-color) 12%);--ag-charts-input-border-color: var(--ag-charts-border-color);--ag-charts-input-border-radius: var(--ag-charts-border-radius);--ag-charts-input-focus-border-color: var(--ag-charts-accent-color);--ag-charts-input-focus-text-color: var(--ag-charts-accent-color);--ag-charts-input-disabled-background-color: color-mix( in srgb, var(--ag-charts-chrome-background-color), var(--ag-charts-foreground-color) 6% );--ag-charts-input-disabled-border-color: var(--ag-charts-border-color);--ag-charts-input-disabled-text-color: color-mix( in srgb, var(--ag-charts-chrome-background-color), var(--ag-charts-input-text-color) 50% );--ag-charts-input-placeholder-text-color: color-mix( in srgb, var(--ag-charts-input-background-color), var(--ag-charts-input-text-color) 60% );--ag-charts-button-background-color: var(--ag-charts-background-color);--ag-charts-button-border-color: var(--ag-charts-border-color);--ag-charts-button-border-radius: var(--ag-charts-border-radius);--ag-charts-button-text-color: var(--ag-charts-text-color);--ag-charts-button-focus-background-color: color-mix( in srgb, var(--ag-charts-button-background-color), var(--ag-charts-accent-color) 12% );--ag-charts-button-focus-border-color: var(--ag-charts-accent-color);--ag-charts-button-focus-text-color: var(--ag-charts-accent-color);--ag-charts-button-disabled-background-color: color-mix( in srgb, var(--ag-charts-chrome-background-color), var(--ag-charts-foreground-color) 6% );--ag-charts-button-disabled-border-color: var(--ag-charts-border-color);--ag-charts-button-disabled-text-color: color-mix( in srgb, var(--ag-charts-chrome-background-color), var(--ag-charts-chrome-text-color) 50% );--ag-charts-checkbox-background-color: color-mix( in srgb, var(--ag-charts-background-color), var(--ag-charts-foreground-color) 35% );--ag-charts-checkbox-checked-background-color: var(--ag-charts-accent-color);--ag-charts-chrome-font-size-small: var(--ag-charts-chrome-font-size);--ag-charts-chrome-font-size-medium: calc(var(--ag-charts-chrome-font-size) * (13 / 12));--ag-charts-chrome-font-size-large: calc(var(--ag-charts-chrome-font-size) * (14 / 12));--ag-charts-border: solid 1px var(--ag-charts-border-color);--ag-charts-focus-border: solid 1px var(--ag-charts-accent-color);--ag-charts-focus-border-shadow: 0 0 0 3px color-mix(in srgb, transparent, var(--ag-charts-accent-color) 20%);--ag-charts-layer-menu: 6;--ag-charts-layer-ui-overlay: 5;--ag-charts-layer-tooltip: 4;--ag-charts-layer-toolbar: 3;--ag-charts-layer-crosshair: 2;--ag-charts-layer-annotations: 1}.ag-charts-theme-default-dark{--ag-charts-shadow: 0 2px 12px 0 color-mix(in srgb, black 33.3%, transparent);--ag-charts-focus-color: color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-accent-color) 22%)}.ag-chart-canvas-wrapper .ag-charts-theme-default{--ag-charts-border-radius: var(--ag-border-radius, 4px);--ag-charts-border: var(--ag-borders-critical, solid 1px) var(--ag-charts-border-color);--ag-charts-focus-shadow: var(--ag-focus-shadow, 0 0 0 3px var(--ag-charts-accent-color));--ag-charts-focus-border-shadow: var( --ag-focus-shadow, 0 0 0 3px color-mix(in srgb, transparent, var(--ag-charts-accent-color) 20%) )}.ag-charts-icon{display:block;width:20px;height:20px;speak:none;speak:never;mask:var(--icon) center / contain no-repeat;background-color:currentColor;transition:background-color .25s ease-in-out}.ag-charts-icon-align-center{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNNyAxMGg2djFIN3pNNCA3aDEydjFINHptMSA2aDEwdjFINXoiLz48L3N2Zz4=)}.ag-charts-icon-align-left{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNNCAxMGg2djFINHptMC0zaDEydjFINHptMCA2aDEwdjFINHoiLz48L3N2Zz4=)}.ag-charts-icon-align-right{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTAgMTBoNnYxaC02ek00IDdoMTJ2MUg0em0yIDZoMTB2MUg2eiIvPjwvc3ZnPg==)}.ag-charts-icon-arrow-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE1LjI5MyA0LjVIMTIuNXYtMUgxN3Y0aC0xVjUuMjA3bC05LjY0NiA5LjY0Ny0uNzA4LS43MDh6IiBmaWxsPSIjMDAwIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik03IDE2YTIuNSAyLjUgMCAxIDEtNSAwIDIuNSAyLjUgMCAwIDEgNSAwbS0yLjUgMS41YTEuNSAxLjUgMCAxIDAgMC0zIDEuNSAxLjUgMCAwIDAgMCAzIiBmaWxsPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-arrow-down-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02IDhMMS41IDhMMTAgMThMMTguNSA4TDE0IDhMMTQgM0w2IDNMNiA4Wk03IDRMNyA5SDMuNjYyNDRMMTAgMTYuNDU2TDE2LjMzNzYgOUwxMyA5TDEzIDRMNyA0WiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-arrow-up-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNCAxMkgxOC41TDEwIDJMMS41IDEySDZMNi4wMDAwMiAxN0gxNFYxMlpNMTMgMTZWMTFIMTYuMzM3NkwxMCAzLjU0NDA1TDMuNjYyNDQgMTFIN0w3LjAwMDAyIDE2SDEzWiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-callout-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMyA0LjVBMS41IDEuNSAwIDAgMSA0LjUgM2gxMUExLjUgMS41IDAgMCAxIDE3IDQuNXY4YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtNC41MTRhMjYgMjYgMCAwIDAtMi4wMTcgMS41NGwtLjMxNC4yNmMtLjU1LjQ1Ny0xLjExNS45MjYtMS43NiAxLjQtLjY2OS40OTEtMS41NjItLjAxMi0xLjU2Mi0uOFYxNEg0LjVBMS41IDEuNSAwIDAgMSAzIDEyLjV6TTQuNSA0YS41LjUgMCAwIDAtLjUuNXY4YS41LjUgMCAwIDAgLjUuNWgxLjgzM3YzLjM3MmEzNiAzNiAwIDAgMCAxLjY3OC0xLjMzOGwuMzItLjI2NWEyNiAyNiAwIDAgMSAyLjIyNS0xLjY4NWwuMTI2LS4wODRIMTUuNWEuNS41IDAgMCAwIC41LS41di04YS41LjUgMCAwIDAtLjUtLjV6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-candlestick-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNyAxdjNoMnYxMkg3djNINnYtM0g0VjRoMlYxek01IDVoM3YxMEg1ek0xMSAxNFY2aDJWMy4yNWgxVjZoMnY4aC0ydjIuNzVoLTFWMTR6bTEtN2gzdjZoLTN6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-close{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtNSA1IDEwIDEwTTUgMTUgMTUgNSIgc3Ryb2tlPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-comment-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNy41MTMgMy45OTVhNi41IDYuNSAwIDAgMSA2LjA5OCAxMS40MWMtLjU4OC4zOTMtMS4yMTcuNTM2LTEuODI5LjU4NWExMyAxMyAwIDAgMS0xLjI3LjAxN0EyNyAyNyAwIDAgMCAxMCAxNkg0LjVhLjUuNSAwIDAgMS0uNS0uNVYxMHEwLS4yNDctLjAwNy0uNTEzYy0uMDA4LS40MTYtLjAxNi0uODU3LjAxNy0xLjI2OS4wNS0uNjEyLjE5Mi0xLjI0LjU4NS0xLjgzYTYuNSA2LjUgMCAwIDEgMi45MTgtMi4zOTNtMy41Ni42MWE1LjUgNS41IDAgMCAwLTUuNjQ2IDIuMzRjLS4yNjYuMzk3LS4zNzkuODQyLS40MiAxLjM1NC0uMDMuMzYtLjAyMi43MTgtLjAxNSAxLjEwOFE1IDkuNjg5IDUgMTB2NWg1cS4zMTEuMDAxLjU5My4wMDhjLjM5LjAwNy43NDcuMDE1IDEuMTA4LS4wMTUuNTEyLS4wNDEuOTU3LS4xNTQgMS4zNTUtLjQyYTUuNSA1LjUgMCAwIDAtMS45ODMtOS45NjciIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-crosshair-add-line{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTEwIDUuNWEuNS41IDAgMCAxIC41LjV2My41aDMuODc1YS41LjUgMCAwIDEgMCAxSDEwLjV2NC4yNWEuNS41IDAgMSAxLTEgMFYxMC41SDUuNjI1YS41LjUgMCAxIDEgMC0xSDkuNVY2YS41LjUgMCAwIDEgLjUtLjUiLz48L3N2Zz4=)}.ag-charts-icon-date-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMiAyaDF2MTZIMnptMTUgMGgxdjE2aC0xeiIgZmlsbD0iIzE4MUQxRiIvPjxwYXRoIGQ9Ik0xMy4xNTcgMTFINXYtMWg3Ljc5M0wxMSA4LjIwN2wuNzA3LS43MDcgMy4xODIgMy4xODItMy4xODIgMy4xODItLjcwNy0uNzA3eiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-date-price-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMyAySDJ2MTZoMXptMy41MDcgNC44OUw4LjUgNC44OTVWMTBINXYxaDMuNXY3aDF2LTdoNS4wODhsLTEuOTU3IDEuOTU3LjcwNy43MDcgMy4xODItMy4xODJMMTMuMzM4IDcuM2wtLjcwNy43MDdMMTQuNjI0IDEwSDkuNVY0LjkzMmwxLjk1NyAxLjk1Ny43MDctLjcwN0w4Ljk4MiAzIDUuOCA2LjE4MnoiIGZpbGw9IiMxODFEMUYiLz48L3N2Zz4=)}.ag-charts-icon-delete{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZD0iTTguNDk2IDguOTk2QS41LjUgMCAwIDEgOSA5LjQ5MnY0YS41LjUgMCAxIDEtMSAuMDA4di00YS41LjUgMCAwIDEgLjQ5Ni0uNTA0TTEyIDkuNWEuNS41IDAgMCAwLTEgMHY0YS41LjUgMCAwIDAgMSAweiIvPjxwYXRoIGZpbGw9IiMxMzE3MjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTYgNVYzLjVBMi41IDIuNSAwIDAgMSA4LjUgMWgzQTIuNSAyLjUgMCAwIDEgMTQgMy41VjVoMi44MzNhLjUuNSAwIDAgMSAwIDFIMTV2MTAuMjVjMCAuNDE1LS4wNjYuODYzLS4zIDEuMjIxLS4yNTcuMzk0LS42NzIuNjEyLTEuMi42MTJoLTdjLS41MjggMC0uOTQzLS4yMTgtMS4yLS42MTItLjIzNC0uMzU4LS4zLS44MDYtLjMtMS4yMjFWNkgzLjMzM2EuNS41IDAgMCAxIDAtMXptMS0xLjVBMS41IDEuNSAwIDAgMSA4LjUgMmgzQTEuNSAxLjUgMCAwIDEgMTMgMy41VjVIN3pNNiAxNi4yNVY2aDh2MTAuMjVjMCAuMzM1LS4wNTkuNTU0LS4xMzguNjc1LS4wNTUuMDg1LS4xNC4xNTgtLjM2Mi4xNThoLTdjLS4yMjIgMC0uMzA3LS4wNzMtLjM2Mi0uMTU4LS4wOC0uMTIxLS4xMzgtLjM0LS4xMzgtLjY3NSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-disjoint-channel,.ag-charts-icon-disjoint-channel-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTkuMDI4IDE3LjQ2YTIuMjUgMi4yNSAwIDAgMC00LjA5Mi0xLjg1bC05LjUxMS0yLjM3OGEyLjI1IDIuMjUgMCAxIDAtLjIyNS45NzRsOS40NzUgMi4zNjlhMi4yNTEgMi4yNTEgMCAwIDAgNC4zNTMuODg2bS0xLjY2Mi0xLjk2NWExLjI1IDEuMjUgMCAxIDEtLjg4NSAyLjMzOCAxLjI1IDEuMjUgMCAwIDEgLjg4NS0yLjMzOE00LjM0MyAxMy42NjlhMS4yNSAxLjI1IDAgMSAwLTIuMzM4LS44ODUgMS4yNSAxLjI1IDAgMCAwIDIuMzM4Ljg4NU0zLjk3IDguNzY5YTIuMjUgMi4yNSAwIDAgMCAxLjQ1NS0yLjExbDkuNTExLTIuMzc4YTIuMjUgMi4yNSAwIDEgMC0uMjYtLjk2NUw1LjIgNS42ODVhMi4yNSAyLjI1IDAgMSAwLTEuMjMgMy4wODRtLjM3My0yLjU0N2ExLjI1IDEuMjUgMCAxIDEtMi4zMzguODg1IDEuMjUgMS4yNSAwIDAgMSAyLjMzOC0uODg1bTEzLjc1LTMuNDM4YTEuMjUgMS4yNSAwIDEgMS0yLjMzOC44ODUgMS4yNSAxLjI1IDAgMCAxIDIuMzM4LS44ODUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-drag-handle{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSI1Ljc1IiBjeT0iNy43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iOS43NSIgY3k9IjcuNzUiIHI9Ii43NSIgZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuNSIvPjxjaXJjbGUgY3g9IjEzLjc1IiBjeT0iNy43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iMTMuNzUiIGN5PSIxMS43NSIgcj0iLjc1IiBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii41Ii8+PGNpcmNsZSBjeD0iOS43NSIgY3k9IjExLjc1IiByPSIuNzUiIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjUiLz48Y2lyY2xlIGN4PSI1Ljc1IiBjeT0iMTEuNzUiIHI9Ii43NSIgZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuNSIvPjwvc3ZnPg==)}.ag-charts-icon-fibonacci-retracement-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMiA1aDEydjFIMnoiLz48Y2lyY2xlIGN4PSIxNS43NSIgY3k9IjUuNSIgcj0iMS43NSIgc3Ryb2tlPSIjMDAwIi8+PGNpcmNsZSBjeD0iNC4yNSIgY3k9IjE0LjUiIHI9IjEuNzUiIHN0cm9rZT0iIzAwMCIvPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik0xOCAxNUg2di0xaDEyem0wLTQuNUgydi0xaDE2eiIvPjwvc3ZnPg==)}.ag-charts-icon-fibonacci-retracement-trend-based-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJtNC45OTYgMTIuNjc0IDMuMjkxLTUuNzQzLjg2OC40OTctMy4yOTEgNS43NDN6Ii8+PGNpcmNsZSBjeD0iOS43NSIgY3k9IjUuNSIgcj0iMS43NSIgc3Ryb2tlPSIjMDAwIi8+PGNpcmNsZSBjeD0iNC4zNTEiIGN5PSIxNC41IiByPSIxLjc1IiBzdHJva2U9IiMwMDAiLz48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMTggNmgtN1Y1aDd6bTAgNC41aC03di0xaDd6bTAgNC41SDZ2LTFoMTJ6Ii8+PC9zdmc+)}.ag-charts-icon-fill-color{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtOC4wNzEgNC4wNi0uOTI0LS45MjQuNzA3LS43MDcgNy4yODggNy4yODgtNC45NSA0Ljk1YTMuNSAzLjUgMCAwIDEtNC45NSAwbC0xLjQxNC0xLjQxNGEzLjUgMy41IDAgMCAxIDAtNC45NXptLjcwNy43MDhMNC41MzYgOS4wMWEyLjUgMi41IDAgMCAwIDAgMy41MzZMNS45NSAxMy45NmEyLjUgMi41IDAgMCAwIDMuNTM1IDBsNC4yNDMtNC4yNDN6bTYuOSA3LjIwMi0uMzQ1LjM2My0uMzQ0LS4zNjNhLjUuNSAwIDAgMSAuNjg4IDBtLS4zNDUgMS4wOGE4IDggMCAwIDAtLjI4LjMyMyA0LjMgNC4zIDAgMCAwLS40MDkuNTgyYy0uMTEzLjIwMS0uMTQ0LjMyNi0uMTQ0LjM3OGEuODMzLjgzMyAwIDAgMCAxLjY2NyAwYzAtLjA1Mi0uMDMxLS4xNzctLjE0NC0uMzc4YTQuMyA0LjMgMCAwIDAtLjQxLS41ODIgOCA4IDAgMCAwLS4yOC0uMzIybS0uMzQ0LTEuMDguMzQ0LjM2My4zNDQtLjM2My4wMDIuMDAyLjAwNC4wMDQuMDEzLjAxMmE2IDYgMCAwIDEgLjIwNi4yMDhjLjEzMS4xMzYuMzA4LjMyNy40ODUuNTQ1LjE3Ni4yMTUuMzYzLjQ2Ny41MDcuNzI0LjEzNy4yNDMuMjczLjU1My4yNzMuODY4YTEuODMzIDEuODMzIDAgMSAxLTMuNjY3IDBjMC0uMzE1LjEzNi0uNjI1LjI3My0uODY4LjE0NC0uMjU3LjMzLS41MDkuNTA3LS43MjRhOSA5IDAgMCAxIC42NDUtLjcwOGwuMDQ2LS4wNDUuMDEzLS4wMTIuMDA0LS4wMDR6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-hollow-candlestick-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1vcGFjaXR5PSIuMTUiIGQ9Ik01IDVoM3YxMEg1eiIvPjxwYXRoIGZpbGw9IiMxMzE3MjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTcgMXYzaDJ2MTJIN3YzSDZ2LTNINFY0aDJWMXpNNSA1aDN2MTBINXptNyAyaDN2NmgtM3ptLTEgN1Y2aDJWMy4yNWgxVjZoMnY4aC0ydjIuNzVoLTFWMTR6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-horizontal-line,.ag-charts-icon-horizontal-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNLjUgOS41aDcuMzA2YTIuMjUgMi4yNSAwIDAgMSA0LjM4OCAwSDE5LjV2MWgtNy4zMDZhMi4yNSAyLjI1IDAgMCAxLTQuMzg4IDBILjV6bTkuNSAxLjc1YTEuMjUgMS4yNSAwIDEgMCAwLTIuNSAxLjI1IDEuMjUgMCAwIDAgMCAyLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-line-color{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTQuMjQyIDIuNzIyYy0uNjEyIDAtMS4yLjI0My0xLjYzMi42NzVsLTEuMzQzIDEuMzQ0YS41LjUgMCAwIDAtLjExMi4xMTJMNC4wNSAxMS45NTljLS4yMDcuMjA3LS4zNi40Ni0uNDQ2Ljc0di4wMDFsLS42OSAyLjc2N3YuMDAyYS44Mi44MiAwIDAgMCAxLjAyMiAxLjAyMWguMDAybDIuNjM0LS44MjJjLjI4LS4wODUuNTM0LS4yMzcuNzQtLjQ0M2w3LjEwNy03LjEwOGEuNS41IDAgMCAwIC4xMTItLjExMmwxLjM0My0xLjM0M2EyLjMwOCAyLjMwOCAwIDAgMC0xLjYzMi0zLjk0TTE0LjEyMiA3bDEuMDQ0LTEuMDQ1YTEuMzA4IDEuMzA4IDAgMSAwLTEuODQ5LTEuODVMMTIuMjcxIDUuMTV6bS0yLjU1OC0xLjE0Mi02LjgwNyA2LjgwOWEuOC44IDAgMCAwLS4xOTYuMzI1bC0uNzUgMi40NjggMi40Ny0uNzQ5YS44LjggMCAwIDAgLjMyNS0uMTk0bDYuODA4LTYuODF6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-line-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTcuMzYyIDQuODczLTQuNTk0IDYuNjU0LTQuODUtMy4zMTctNC4yNTEgNi45NzctLjg1NC0uNTJMNy42MTIgNi43OWw0Ljg5OSAzLjM1IDQuMDI4LTUuODM2eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-line-style-dashed{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMiA5aDR2MUgyem0xMiAwaDR2MWgtNHpNOCA5aDR2MUg4eiIvPjwvc3ZnPg==)}.ag-charts-icon-line-style-dotted{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSIyLjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iNC41IiBjeT0iOS41IiByPSIuNSIgZmlsbD0iIzAwMCIvPjxjaXJjbGUgY3g9IjYuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48Y2lyY2xlIGN4PSI4LjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMTAuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48Y2lyY2xlIGN4PSIxMi41IiBjeT0iOS41IiByPSIuNSIgZmlsbD0iIzAwMCIvPjxjaXJjbGUgY3g9IjE0LjUiIGN5PSI5LjUiIHI9Ii41IiBmaWxsPSIjMDAwIi8+PGNpcmNsZSBjeD0iMTYuNSIgY3k9IjkuNSIgcj0iLjUiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-line-style-solid{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMiA5aDE2djFIMnoiLz48L3N2Zz4=)}.ag-charts-icon-line-with-markers-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTguMTk4IDQuODg4LTMuNTU2IDQuOTE4YTIuMjUgMi4yNSAwIDEgMS0zLjg2Ni43NWwtMS40MzItLjlhMi4yNCAyLjI0IDAgMCAxLTIuMDA5LjQzNWwtMy44MjggNi40MjgtLjg2LS41MTJMNi40NSA5LjYyM2EyLjI1IDIuMjUgMCAxIDEgMy41MS0uNzYxbDEuMzI5LjgzNWEyLjI0IDIuMjQgMCAwIDEgMi41NTctLjQ5N2wzLjU0Mi00Ljg5OHptLTQuOTYgNS4xNTNhMS4yNSAxLjI1IDAgMSAwLS42NCAyLjQxOSAxLjI1IDEuMjUgMCAwIDAgLjY0LTIuNDE5TTkuMSA4LjMyMXEuMDY2LS4xOTIuMDY3LS40MDRhMS4yNSAxLjI1IDAgMSAwLS4wNjcuNDA0IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-lock,.ag-charts-icon-locked{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuMjA3IDMuNzY0YTIuODk0IDIuODk0IDAgMCAwLTIuODk1IDIuODk0VjloNS43ODlWNi42NThhMi44OTQgMi44OTQgMCAwIDAtMi44OTUtMi44OTRNMTQuMSA5VjYuNjU4YTMuODk0IDMuODk0IDAgMSAwLTcuNzg5IDB2Mi4zNDlBMi41IDIuNSAwIDAgMCA0IDExLjV2M0EyLjUgMi41IDAgMCAwIDYuNSAxN2g4YTIuNSAyLjUgMCAwIDAgMi41LTIuNXYtM0EyLjUgMi41IDAgMCAwIDE0LjUgOXpNNi41IDEwQTEuNSAxLjUgMCAwIDAgNSAxMS41djNBMS41IDEuNSAwIDAgMCA2LjUgMTZoOGExLjUgMS41IDAgMCAwIDEuNS0xLjV2LTNhMS41IDEuNSAwIDAgMC0xLjUtMS41eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-measurer-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibTQuNDYxIDEyLjcxIDEuNTMyLTEuNTMxIDEuNDE0IDEuNDE0LjcwNy0uNzA3TDYuNyAxMC40NzJsMS41MzItMS41MzMgMiAyIC43MDctLjcwNy0yLTIgNi4wMS02LjAxIDIuODMgMi44MjhMNS4wNSAxNy43NzggMi4yMjIgMTQuOTVsMS41MzItMS41MzIgMS40MTQgMS40MTQuNzA3LS43MDd6TS44MDggMTQuOTVsLjcwNy0uNzA3TDE0LjI0MyAxLjUxNWwuNzA3LS43MDcuNzA3LjcwNyAyLjgyOCAyLjgyOC43MDcuNzA3LS43MDcuNzA3TDUuNzU3IDE4LjQ4NWwtLjcwNy43MDctLjcwNy0uNzA3LTIuODI4LTIuODI4em0xMS4wNzgtNi44MzVMMTAuNDcgNi43bC43MDctLjcwNyAxLjQxNSAxLjQxNHptLjgyNC0zLjY1NCAxIDEgLjcwOC0uNzA3LTEtMXoiIGZpbGw9IiMxODFEMUYiLz48L3N2Zz4=)}.ag-charts-icon-note-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMyA0LjVBMS41IDEuNSAwIDAgMSA0LjUgM2gxMUExLjUgMS41IDAgMCAxIDE3IDQuNXY4YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtMy4yMWwtMS40NjkgMi41N2ExIDEgMCAwIDEtMS42ODIuMDg1TDcuMjQzIDE0SDQuNUExLjUgMS41IDAgMCAxIDMgMTIuNXpNNC41IDRhLjUuNSAwIDAgMC0uNS41djhhLjUuNSAwIDAgMCAuNS41aDMuMjU3bDIuMTk2IDMuMDc0TDExLjcxIDEzaDMuNzlhLjUuNSAwIDAgMCAuNS0uNXYtOGEuNS41IDAgMCAwLS41LS41eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNi41IDYuNUEuNS41IDAgMCAxIDcgNmg2YS41LjUgMCAwIDEgMCAxSDdhLjUuNSAwIDAgMS0uNS0uNU02LjUgOS41QS41LjUgMCAwIDEgNyA5aDZhLjUuNSAwIDAgMSAwIDFIN2EuNS41IDAgMCAxLS41LS41IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-ohlc-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZD0iTTEzIDExaC0zdi0xaDNWM2gxdjJoNHYxaC00djExaC0xek02IDE3di0yaDN2LTFINlY0SDV2MUgydjFoM3YxMXoiLz48L3N2Zz4=)}.ag-charts-icon-pan-end{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0ibTYuNjQ2IDEzLjgxMy0uMzUzLjM1NC43MDcuNzA3LjM1NC0uMzU0ek0xMS4xNjYgMTBsLjM1NC4zNTQuMzU0LS4zNTQtLjM1NC0uMzU0ek03LjM1NSA1LjQ4IDcgNS4xMjZsLS43MDcuNzA3LjM1My4zNTR6bTAgOS4wNCA0LjE2Ni00LjE2Ni0uNzA3LS43MDgtNC4xNjcgNC4xNjd6bTQuMTY2LTQuODc0TDcuMzU0IDUuNDhsLS43MDguNzA3IDQuMTY3IDQuMTY3ek0xMy4wODMgNXYxMGgxVjV6Ii8+PC9zdmc+)}.ag-charts-icon-pan-left{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTIuNzkgNS44MzMgOC42MjUgMTBsNC4xNjYgNC4xNjctLjcwNy43MDdMNy4yMSAxMGw0Ljg3My00Ljg3NHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-right{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNy4yMSAxNC4xNjcgMTEuMzc2IDEwIDcuMjEgNS44MzNsLjcwNy0uNzA3TDEyLjc5IDEwbC00Ljg3MyA0Ljg3NHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-start{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTYgNXYxMGgxVjV6TTkuNjI0IDEwbDQuMTY2LTQuMTY3LS43MDctLjcwN0w4LjIxIDEwbDQuODc0IDQuODc0LjcwNy0uNzA3eiIvPjwvc3ZnPg==)}.ag-charts-icon-parallel-channel,.ag-charts-icon-parallel-channel-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTcuNzIgNS4zMzFBMi4yNSAyLjI1IDAgMSAwIDE0LjcwNSAzLjZsLTkuNDkgNC41NjJhMi4yNSAyLjI1IDAgMSAwIC4yMDkgMS4wMWw5LjY2Mi00LjY0NmEyLjI1IDIuMjUgMCAwIDAgMi42MzQuODA1bS4zNzMtMi41NDdhMS4yNSAxLjI1IDAgMSAxLTIuMzM4Ljg4NSAxLjI1IDEuMjUgMCAwIDEgMi4zMzgtLjg4NU00LjM0MyA4LjY3YTEuMjUgMS4yNSAwIDEgMS0yLjMzOC44ODUgMS4yNSAxLjI1IDAgMCAxIDIuMzM4LS44ODVNNS4zMDcgMTYuNzI4YTIuMjUgMi4yNSAwIDEgMS0uNTI1LS44NThsOS45MjMtNC43N2EyLjI1IDIuMjUgMCAxIDEgLjM4MS45MjZ6bS0uOTY0LjI3NGExLjI1IDEuMjUgMCAxIDEtMi4zMzguODg1IDEuMjUgMS4yNSAwIDAgMSAyLjMzOC0uODg1bTEzLjAyMy01LjEwNmExLjI1IDEuMjUgMCAxIDAtLjg4NS0yLjMzOSAxLjI1IDEuMjUgMCAwIDAgLjg4NSAyLjMzOSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-position-bottom{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii4yNSIgZD0iTTMgMTBoMTR2MUgzem0zLTNoOHYxSDZ6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTYgMTNoOHYxSDZ6Ii8+PC9zdmc+)}.ag-charts-icon-position-center{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBkPSJNMyAxMGgxNHYxSDN6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuMjUiIGQ9Ik02IDdoOHYxSDZ6bTAgNmg4djFINnoiLz48L3N2Zz4=)}.ag-charts-icon-position-top{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBmaWxsPSIjMDAwIiBmaWxsLW9wYWNpdHk9Ii4yNSIgZD0iTTMgMTBoMTR2MUgzeiIvPjxwYXRoIGZpbGw9IiMwMDAiIGQ9Ik02IDdoOHYxSDZ6Ii8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIuMjUiIGQ9Ik02IDEzaDh2MUg2eiIvPjwvc3ZnPg==)}.ag-charts-icon-price-label-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNC41IDNBMS41IDEuNSAwIDAgMCAzIDQuNVYxM2ExLjUgMS41IDAgMCAwIDEuNSAxLjVoLjgzM3YuMDU3Yy4yNDItLjI5OS41OTctLjUwMyAxLS41NDhWMTMuNUg0LjVBLjUuNSAwIDAgMSA0IDEzVjQuNWEuNS41IDAgMCAxIC41LS41aDExYS41LjUgMCAwIDEgLjUuNXY4YS41LjUgMCAwIDEtLjUuNWgtNC44MThsLS4xMjYuMDg0YTI2IDI2IDAgMCAwLTIuMjI1IDEuNjg1bC0uMzIuMjY1LS4wNjguMDU2YTEuNSAxLjUgMCAwIDEtMi42MDkgMS4zNTRjLjAzMy43NjMuOTA1IDEuMjM4IDEuNTYuNzU2LjY0Ni0uNDc0IDEuMjEtLjk0MyAxLjc2MS0xLjRsLjMxMy0uMjZBMjYgMjYgMCAwIDEgMTAuOTg2IDE0SDE1LjVhMS41IDEuNSAwIDAgMCAxLjUtMS41di04QTEuNSAxLjUgMCAwIDAgMTUuNSAzeiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNOC43MTYgMTQuODE1YTIuMjUgMi4yNSAwIDEgMS00LjIxIDEuNTkzIDIuMjUgMi4yNSAwIDAgMSA0LjIxLTEuNTkzbS0xLjY2MiAxLjk2NmExLjI1IDEuMjUgMCAxIDAtLjg4NS0yLjMzOSAxLjI1IDEuMjUgMCAwIDAgLjg4NSAyLjMzOSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-price-range-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNOS4wNDYgMTVWNS44NzdoLjk0MlYxNXoiIGZpbGw9IiMxODFEMUYiLz48cGF0aCBkPSJNOS4wNDYgMTVWNS44NzdoLjk0MlYxNXoiIGZpbGw9IiMxODFEMUYiLz48cGF0aCBkPSJNOS41IDYuMjI4IDcuMTY3IDguMzc2IDYuNSA3Ljc2MiA5LjUgNWwzIDIuNzYyLS42NjcuNjE0eiIgZmlsbD0iIzAwMCIvPjxwYXRoIGQ9Ik0yIDE4di0xaDE2djF6TTIgM1YyaDE2djF6IiBmaWxsPSIjMTgxRDFGIi8+PC9zdmc+)}.ag-charts-icon-reset{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTIuMDQgNC40NDVhNS44MSA1LjgxIDAgMCAwLTcuMjU3IDIuNDUzLjUuNSAwIDAgMS0uODY1LS41MDJBNi44MSA2LjgxIDAgMSAxIDMgOS44MTNhLjUuNSAwIDAgMSAxIDAgNS44MSA1LjgxIDAgMSAwIDguMDQtNS4zNjgiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTQuMjg5IDMuMDAyYS41LjUgMCAwIDEgLjUuNXYyLjY1NWgyLjY1NWEuNS41IDAgMCAxIDAgMUg0LjI5YS41LjUgMCAwIDEtLjUtLjVWMy41MDJhLjUuNSAwIDAgMSAuNS0uNSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-settings{--icon: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkIj48cGF0aCBkPSJNMTAgMTNhMyAzIDAgMSAwIDAtNiAzIDMgMCAwIDAgMCA2bTAtMWEyIDIgMCAxIDEtLjAwMS0zLjk5OUEyIDIgMCAwIDEgMTAgMTIiLz48cGF0aCBkPSJNMi4zMSAxNC4zNDVjLS44MTctMS40OTEuMDI3LTIuNDk5LjQ3NC0yLjg2NS41MzEtLjQzNC45NjktLjM2NS45NzItMS40OC0uMDAzLTEuMTE1LS40NDEtMS4wNDYtLjk3Mi0xLjQ4MS0uNDU0LS4zNzEtMS4zMTctMS40MDUtLjQzNC0yLjkzNmwuMDA1LS4wMDljLjg4NC0xLjUyIDIuMjA3LTEuMjkgMi43NTUtMS4wODMuNjQxLjI0My44MDEuNjU2IDEuNzY4LjEwMS45NjQtLjU2LjY4Ni0uOTA0Ljc5Ni0xLjU4Mi4wOTQtLjU3OC41NTktMS44NDMgMi4zMjYtMS44NDNoLjAxYzEuNzU5LjAwNSAyLjIyMiAxLjI2NiAyLjMxNiAxLjg0My4xMS42NzgtLjE2OCAxLjAyMi43OTYgMS41ODIuOTY3LjU1NSAxLjEyNy4xNDIgMS43NjgtLjEwMS41NDktLjIwOCAxLjg3Ni0uNDM4IDIuNzYgMS4wOTJzLjAyIDIuNTY1LS40MzQgMi45MzZjLS41MzEuNDM1LS45NjkuMzY2LS45NzIgMS40ODEuMDAzIDEuMTE1LjQ0MSAxLjA0Ni45NzIgMS40OC40NTQuMzcyIDEuMzE3IDEuNDA2LjQzNCAyLjkzN2wtLjAwNS4wMDljLS44ODQgMS41Mi0yLjIwNyAxLjI5LTIuNzU1IDEuMDgzLS42NDEtLjI0My0uODAxLS42NTYtMS43NjgtLjEwMS0uOTY0LjU2LS42ODYuOTA0LS43OTYgMS41ODEtLjA5NC41NzktLjU1OSAxLjg0NC0yLjMyNiAxLjg0NGgtLjAxYy0xLjc1OS0uMDA1LTIuMjIyLTEuMjY2LTIuMzE2LTEuODQ0LS4xMS0uNjc3LjE2OC0xLjAyMS0uNzk2LTEuNTgxLS45NjctLjU1NS0xLjEyNy0uMTQyLTEuNzY4LjEwMS0uNTQ5LjIwOC0xLjg3Ni40MzgtMi43Ni0xLjA5MmwtLjAyLS4wMzZ6TTkuOTg0IDIuMTYySDEwYzEuMzU1IDAgMS4zNDIgMS4wMzkgMS4zNTMgMS40MjUuMDA4LjMxMi4wNCAxLjE2IDEuMjU5IDEuODcybC4wMTUuMDA4YzEuMjI1LjcgMS45NzYuMzA0IDIuMjUxLjE1NS4zMzctLjE4MyAxLjIyNi0uNzExIDEuOTAyLjQ0NWwuMDA4LjAxNGMuNjc4IDEuMTczLS4yMjkgMS42ODItLjU1OCAxLjg4NC0uMjY2LjE2My0uOTg0LjYxNS0uOTkxIDIuMDI3di4wMTZjLjAwNyAxLjQxMi43MjUgMS44NjQuOTkxIDIuMDI3LjMyOC4yMDEgMS4yMjkuNzA3LjU2NiAxLjg3bC0uMDA4LjAxNGMtLjY3NyAxLjE3NC0xLjU3MS42NDMtMS45MS40NTktLjI3NS0uMTQ5LTEuMDI2LS41NDUtMi4yNTEuMTU0bC0uMDE1LjAwOWMtMS4yMTkuNzEyLTEuMjUxIDEuNTYtMS4yNTkgMS44NzItLjAxMS4zODYuMDAyIDEuNDI1LTEuMzUzIDEuNDI1cy0xLjM0Mi0xLjAzOS0xLjM1My0xLjQyNWMtLjAwOC0uMzEyLS4wNC0xLjE2LTEuMjU5LTEuODcybC0uMDE1LS4wMDljLTEuMjI1LS42OTktMS45NzYtLjMwMy0yLjI1MS0uMTU0LS4zMzYuMTgzLTEuMjE5LjcwNi0xLjg5NC0uNDMybC0uMDE2LS4wMjdjLS42NzgtMS4xNzQuMjI5LTEuNjgyLjU1OC0xLjg4NC4yNjYtLjE2My45ODQtLjYxNS45OTEtMi4wMjd2LS4wMTZjLS4wMDctMS40MTItLjcyNS0xLjg2NC0uOTkxLTIuMDI3LS4zMjgtLjIwMS0xLjIyOS0uNzA3LS41NjYtMS44N2wuMDA4LS4wMTRjLjY3Ny0xLjE3NCAxLjU3MS0uNjQzIDEuOTEtLjQ1OS4yNzUuMTQ5IDEuMDI2LjU0NSAyLjI1MS0uMTU1bC4wMTUtLjAwOGMxLjIxOS0uNzEyIDEuMjUxLTEuNTYgMS4yNTktMS44NzIuMDEtLjM4NC0uMDAyLTEuNDE3IDEuMzM3LTEuNDI1Ii8+PC9zdmc+)}.ag-charts-icon-step-line-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzE4MUQxRiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNiA0aDV2OGgzVjhoNXYxaC00djRoLTVWNUg3djEwSDJ2LTFoNHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-text-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00IDRIMTZWN0gxNVY1SDEwLjVWMTVIMTRWMTZINlYxNUg5LjVWNUg1VjdINFY0WiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-trend-line,.ag-charts-icon-trend-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNS4zMTQgMTAuOTM4YTIuMjUgMi4yNSAwIDEgMSAuMDEtMWg5LjM1MmEyLjI1IDIuMjUgMCAxIDEgLjAxIDF6bS0yLjE4OS43MjlhMS4yNSAxLjI1IDAgMSAwIDAtMi41IDEuMjUgMS4yNSAwIDAgMCAwIDIuNW0xMy43NSAwYTEuMjUgMS4yNSAwIDEgMCAwLTIuNSAxLjI1IDEuMjUgMCAwIDAgMCAyLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-unlock,.ag-charts-icon-unlocked{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuNjUxIDMuNWEyLjg5NCAyLjg5NCAwIDAgMC0yLjg5NCAyLjg5NFY5SDE0LjVhMi41IDIuNSAwIDAgMSAyLjUgMi41djNhMi41IDIuNSAwIDAgMS0yLjUgMi41aC04QTIuNSAyLjUgMCAwIDEgNCAxNC41di0zQTIuNSAyLjUgMCAwIDEgNi41IDloLjI1N1Y2LjM5NGEzLjg5NCAzLjg5NCAwIDEgMSA3Ljc4OSAwIC41LjUgMCAwIDEtMSAwQTIuODk0IDIuODk0IDAgMCAwIDEwLjY1IDMuNU02LjUgMTBBMS41IDEuNSAwIDAgMCA1IDExLjV2M0ExLjUgMS41IDAgMCAwIDYuNSAxNmg4YTEuNSAxLjUgMCAwIDAgMS41LTEuNXYtM2ExLjUgMS41IDAgMCAwLTEuNS0xLjV6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-vertical-line,.ag-charts-icon-vertical-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuNSA3LjgwNmEyLjI1IDIuMjUgMCAwIDEgMCA0LjM4OFYxOS41aC0xdi03LjMwNmEyLjI1IDIuMjUgMCAwIDEgMC00LjM4OFYuNWgxem0tLjUuOTQ0YTEuMjUgMS4yNSAwIDEgMSAwIDIuNSAxLjI1IDEuMjUgMCAwIDEgMC0yLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-zoom-in{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTEwIDUuNWEuNS41IDAgMCAxIC41LjV2My41aDMuODc1YS41LjUgMCAwIDEgMCAxSDEwLjV2NC4yNWEuNS41IDAgMSAxLTEgMFYxMC41SDUuNjI1YS41LjUgMCAxIDEgMC0xSDkuNVY2YS41LjUgMCAwIDEgLjUtLjUiLz48L3N2Zz4=)}.ag-charts-icon-zoom-out{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNS41IDEwYS41LjUgMCAwIDEgLjUtLjVoOGEuNS41IDAgMCAxIDAgMUg2YS41LjUgMCAwIDEtLjUtLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-high-low-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNyA0aDJ2MTJINFY0aDNNNSA1aDN2MTBINXpNMTEgMTRWNmg1djhoLTVtMS03aDN2NmgtM3oiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-hlc-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTguMTYzIDEuODM3LTUuMzM0IDExLjYyMUw2Ljk1NyA4LjEybC00LjE5OSA5LjYyMi0uOTE2LS40IDQuNzU2LTEwLjlMMTIuNDkgMTEuOCAxNy4yNTQgMS40MnoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTUuODI1IDIuNzA0LjU1IDEzLjc4NWwuOTAyLjQzIDQuNzI0LTkuOTE5IDYuMDM0IDUuMDI5IDMuMjU1LTguMTQtLjkyOC0uMzctMi43NDUgNi44NnptNy44NTIgMTQuNjM2IDUuNzgtMTMuMTM5LS45MTUtLjQwMi01LjIxOSAxMS44Ni02LjAwNS01LjUwNC0zLjI3OCA3LjY0OC45Mi4zOTQgMi43MjItNi4zNTJ6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-zoom-in-alt{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20taW4iPjxjaXJjbGUgY3g9IjExIiBjeT0iMTEiIHI9IjgiLz48bGluZSB4MT0iMjEiIHgyPSIxNi42NSIgeTE9IjIxIiB5Mj0iMTYuNjUiLz48bGluZSB4MT0iMTEiIHgyPSIxMSIgeTE9IjgiIHkyPSIxNCIvPjxsaW5lIHgxPSI4IiB4Mj0iMTQiIHkxPSIxMSIgeTI9IjExIi8+PC9zdmc+)}.ag-charts-icon-zoom-out-alt{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20tb3V0Ij48Y2lyY2xlIGN4PSIxMSIgY3k9IjExIiByPSI4Ii8+PGxpbmUgeDE9IjIxIiB4Mj0iMTYuNjUiIHkxPSIyMSIgeTI9IjE2LjY1Ii8+PGxpbmUgeDE9IjgiIHgyPSIxNCIgeTE9IjExIiB5Mj0iMTEiLz48L3N2Zz4=)}.ag-charts-input{--input-layer-active: 1;--input-layer-focus: 2;--input-padding: calc(var(--ag-charts-spacing) * 2);--input-padding-large: calc(var(--ag-charts-spacing) * 2.5);color:var(--ag-charts-input-text-color);font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size-large);transition-duration:.25s;transition-property:none;transition-timing-function:ease-out}.ag-charts-input:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:var(--input-layer-focus)}.ag-charts-button{background:var(--ag-charts-button-background-color);border:1px solid var(--ag-charts-border-color);border-radius:var(--ag-charts-button-border-radius);color:var(--ag-charts-button-text-color);cursor:pointer;padding:var(--input-padding);transition-property:background,border-color}.ag-charts-button:hover{background:var(--ag-charts-focus-color)}.ag-charts-button:has(.ag-charts-icon){padding:2px}.ag-charts-checkbox{--checkbox-transition-duration: .1s;appearance:none;background:var(--ag-charts-checkbox-background-color);border-radius:calc(var(--ag-charts-border-radius) * 9);cursor:pointer;height:18px;margin:0;transition-duration:var(--checkbox-transition-duration);transition-property:margin;width:29px}.ag-charts-checkbox:before{display:block;background:var(--ag-charts-input-background-color);border-radius:calc(var(--ag-charts-border-radius) * 7);content:" ";height:14px;margin:2px;transition-duration:var(--checkbox-transition-duration);transition-property:margin;transition-timing-function:var(--ag-charts-input-transition-easing);width:14px}.ag-charts-checkbox:checked{background:var(--ag-charts-checkbox-checked-background-color)}.ag-charts-checkbox:checked:before{margin-left:13px}.ag-charts-select{background:var(--ag-charts-input-background-color);border:1px solid var(--ag-charts-input-border-color);border-radius:var(--ag-charts-input-border-radius);padding:3px 2px 4px;font-size:inherit}.ag-charts-textarea{--textarea-line-height: 1.38;background:var(--ag-charts-input-background-color);border:1px solid var(--ag-charts-border-color);border-radius:var(--ag-charts-input-border-radius);line-height:var(--textarea-line-height);font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size-large);padding:var(--input-padding-large) var(--input-padding)}.ag-charts-textarea::placeholder{color:var(--ag-charts-input-placeholder-text-color)}.ag-charts-proxy-container{pointer-events:none;position:absolute}.ag-charts-proxy-elem{-webkit-appearance:none;appearance:none;background:none;border:none;color:#0000;overflow:hidden;pointer-events:auto;position:absolute}.ag-charts-proxy-elem::-moz-range-thumb,.ag-charts-proxy-elem::-moz-range-track{opacity:0}.ag-charts-proxy-elem::-webkit-slider-runnable-track,.ag-charts-proxy-elem::-webkit-slider-thumb{opacity:0}.ag-charts-proxy-elem:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow)}.ag-charts-focus-indicator{position:absolute;display:block;pointer-events:none;user-select:none;-webkit-user-select:none;width:100%;height:100%}.ag-charts-focus-indicator>div{position:absolute;outline:solid 1px var(--ag-charts-chrome-background-color);box-shadow:var(--ag-charts-focus-shadow)}.ag-charts-focus-indicator>svg{width:100%;height:100%;fill:none;overflow:visible}.ag-charts-focus-svg-outer-path{stroke:var(--ag-charts-chrome-background-color);stroke-width:4px}.ag-charts-focus-svg-inner-path{stroke:var(--ag-charts-accent-color);stroke-width:2px}.ag-charts-overlay{color:#181d1f;pointer-events:none}.ag-charts-overlay.ag-charts-dark-overlay{color:#fff}.ag-charts-overlay--loading{color:#8c8c8c}.ag-charts-overlay__loading-background{background:#fff;pointer-events:none}.ag-charts-overlay.ag-charts-dark-overlay .ag-charts-overlay__loading-background{background:#192232}.ag-charts-tooltip{--tooltip-arrow-size: 8px;--tooltip-row-spacing: 8px;--tooltip-column-spacing: 16px;position:fixed;inset:unset;margin:0;padding:0;overflow:visible;top:var(--top, 0px);left:var(--left, 0px);width:max-content;max-width:100%;font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size);font-weight:var(--ag-charts-chrome-font-weight);color:var(--ag-charts-chrome-text-color);background:var(--ag-charts-chrome-background-color);border:var(--ag-charts-border);border-radius:var(--ag-charts-border-radius);box-shadow:var(--ag-charts-shadow)}.ag-charts-tooltip--compact .ag-charts-tooltip-content{--tooltip-row-spacing: 2px;--tooltip-column-spacing: 8px;padding:3px 6px}.ag-charts-tooltip--arrow-top:before,.ag-charts-tooltip--arrow-right:before,.ag-charts-tooltip--arrow-bottom:before,.ag-charts-tooltip--arrow-left:before{content:"";position:absolute;display:block;width:var(--tooltip-arrow-size);height:var(--tooltip-arrow-size);border:inherit;border-bottom-color:transparent;border-right-color:transparent;background:inherit;clip-path:polygon(0 0,100% 0,100% 1px,1px 100%,0 100%)}.ag-charts-tooltip--arrow-top:before{bottom:100%;left:50%;transform:translate(-50%) translateY(calc(var(--tooltip-arrow-size) * .5)) rotate(45deg)}.ag-charts-tooltip--arrow-bottom:before{top:100%;left:50%;transform:translate(-50%) translateY(calc(var(--tooltip-arrow-size) * -.5)) rotate(225deg)}.ag-charts-tooltip--arrow-left:before{right:100%;top:50%;transform:translateY(-50%) translate(calc(var(--tooltip-arrow-size) * .5)) rotate(315deg)}.ag-charts-tooltip--arrow-right:before{left:100%;top:50%;transform:translateY(-50%) translate(calc(var(--tooltip-arrow-size) * -.5)) rotate(135deg)}.ag-charts-tooltip--no-interaction{pointer-events:none;user-select:none;-webkit-user-select:none}.ag-charts-tooltip--wrap-always{overflow-wrap:break-word;word-break:break-word;hyphens:none}.ag-charts-tooltip--wrap-hyphenate{overflow-wrap:break-word;word-break:break-word;hyphens:auto}.ag-charts-tooltip--wrap-on-space{overflow-wrap:normal;word-break:normal}.ag-charts-tooltip--wrap-never{white-space:nowrap}.ag-charts-tooltip-heading,.ag-charts-tooltip-title,.ag-charts-tooltip-label,.ag-charts-tooltip-value{overflow:hidden;text-overflow:ellipsis}.ag-charts-tooltip-content{display:grid;grid:auto-flow minmax(1em,auto) / 1fr;padding:8px 12px;gap:var(--tooltip-row-spacing)}.ag-charts-tooltip-content:has(.ag-charts-tooltip-symbol){grid:auto-flow minmax(1em,auto) / auto 1fr}.ag-charts-tooltip-heading{grid-column:1 / -1}.ag-charts-tooltip-symbol{grid-column:1 / 2;place-self:center}.ag-charts-tooltip-symbol svg{display:block}.ag-charts-tooltip-title{grid-column:-2 / -1}.ag-charts-tooltip-row{grid-column:1 / -1;display:flex;gap:var(--tooltip-column-spacing);align-items:baseline;justify-content:space-between;overflow:hidden}.ag-charts-tooltip-row--inline{grid-column:-2 / -1}.ag-charts-tooltip-label{flex:1;min-width:0}.ag-charts-tooltip-value{min-width:0}.ag-charts-tooltip-footer{grid-column:1 / -1;color:var(--ag-charts-chrome-subtle-text-color);text-align:center}.ag-charts-popover{position:absolute;border:var(--ag-charts-border);border-radius:var(--ag-charts-border-radius);background:var(--ag-charts-chrome-background-color);color:var(--ag-charts-chrome-text-color);font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size);font-weight:var(--ag-charts-chrome-font-weight);box-shadow:var(--ag-charts-shadow);z-index:var(--ag-charts-layer-ui-overlay)}.ag-charts-menu{--item-padding: 6px 12px;--icon-color: var(--ag-charts-chrome-text-color);display:grid;grid:auto-flow auto / 1fr;column-gap:12px;font-size:var(--ag-charts-chrome-font-size)}.ag-charts-menu:has(.ag-charts-menu__icon,.ag-charts-menu__row--stroke-width-visible){grid:auto-flow auto / auto 1fr}.ag-charts-menu__row--stroke-width-visible:before{content:"";height:var(--strokeWidth);width:12px;background:var(--icon-color)}.ag-charts-menu__row--stroke-width-visible[aria-disabled=true]:before{filter:grayscale(1);opacity:.5}.ag-charts-menu__row{display:grid;grid-column:1 / -1;grid-template-columns:subgrid;align-items:center;padding:var(--item-padding)}.ag-charts-menu__row:not(.ag-charts-menu__row--active){cursor:pointer}.ag-charts-menu__row:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.ag-charts-menu__row:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.ag-charts-menu__row:focus{background:var(--ag-charts-focus-color)}.ag-charts-menu__row:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:var(--ag-charts-layer-menu)}.ag-charts-menu__row--active{--icon-color: var(--ag-charts-accent-color);background:var(--ag-charts-focus-color);color:var(--ag-charts-accent-color)}.ag-charts-menu__label{grid-column:-1 / span 1}.ag-charts-toolbar{--toolbar-gap: calc(var(--ag-charts-spacing) * 2);--toolbar-size: 34px;--toolbar-button-padding: 6px;align-items:center;display:flex;flex-wrap:nowrap;position:absolute}.ag-charts-toolbar__button{align-items:center;background:var(--ag-charts-chrome-background-color);border:var(--ag-charts-border);color:var(--ag-charts-chrome-text-color);cursor:pointer;display:flex;font-family:var(--ag-charts-chrome-font-family);font-size:var(--ag-charts-chrome-font-size-medium);font-weight:var(--ag-charts-chrome-font-weight);justify-content:center;min-height:var(--toolbar-size);min-width:var(--toolbar-size);padding:var(--toolbar-button-padding);position:relative;transition:background-color .25s ease-in-out,border-color .25s ease-in-out,color .25s ease-in-out;white-space:nowrap}.ag-charts-toolbar__button:hover{background:var(--ag-charts-focus-color);z-index:1}.ag-charts-toolbar__button:focus-visible{outline:var(--ag-charts-focus-border);box-shadow:var(--ag-charts-focus-border-shadow);z-index:calc(var(--ag-charts-layer-ui-overlay) + 1)}.ag-charts-toolbar__button--active{background:var(--ag-charts-focus-color);border-color:var(--ag-charts-accent-color);color:var(--ag-charts-accent-color);z-index:2}.ag-charts-toolbar__button[aria-disabled=true]{background:var(--ag-charts-button-disabled-background-color);color:var(--ag-charts-button-disabled-text-color);cursor:default}.ag-charts-toolbar--horizontal{flex-direction:row;.ag-charts-toolbar__button{margin:0 0 0 -1px}.ag-charts-toolbar__button--first{border-bottom-left-radius:var(--ag-charts-border-radius);border-top-left-radius:var(--ag-charts-border-radius);margin:0}.ag-charts-toolbar__button--last{border-bottom-right-radius:var(--ag-charts-border-radius);border-top-right-radius:var(--ag-charts-border-radius)}}.ag-charts-toolbar--vertical{flex-direction:column;.ag-charts-toolbar__button{margin:-1px 0 0;max-width:100%}.ag-charts-toolbar__button--first{border-top-left-radius:var(--ag-charts-border-radius);border-top-right-radius:var(--ag-charts-border-radius);margin:0}.ag-charts-toolbar__button--last{border-bottom-left-radius:var(--ag-charts-border-radius);border-bottom-right-radius:var(--ag-charts-border-radius)}}.ag-charts-toolbar__icon+.ag-charts-toolbar__label{margin-left:var(--toolbar-gap)}.ag-charts-toolbar__icon,.ag-charts-toolbar__label{pointer-events:none}.ag-charts-floating-toolbar{border:none;display:flex;.ag-charts-toolbar{align-items:unset;position:unset}}.ag-charts-floating-toolbar__drag-handle{align-items:center;background:var(--ag-charts-chrome-background-color);border:var(--ag-charts-border);border-bottom-left-radius:var(--ag-charts-border-radius);border-top-left-radius:var(--ag-charts-border-radius);cursor:grab;display:flex;justify-content:center;min-width:24px;padding-left:0;padding-right:0}.ag-charts-floating-toolbar__drag-handle--dragging{cursor:grabbing}\n';

// packages/ag-charts-community/src/util/listeners.ts
var import_ag_charts_core66 = require("ag-charts-core");
var Listeners = class {
  constructor() {
    this.registeredListeners = /* @__PURE__ */ new Map();
  }
  addListener(eventType, handler) {
    const record = { symbol: Symbol(eventType), handler };
    if (this.registeredListeners.has(eventType)) {
      this.registeredListeners.get(eventType).push(record);
    } else {
      this.registeredListeners.set(eventType, [record]);
    }
    return () => this.removeListener(record.symbol);
  }
  removeListener(eventSymbol) {
    for (const [type, listeners] of this.registeredListeners.entries()) {
      const matchIndex = listeners.findIndex((listener) => listener.symbol === eventSymbol);
      if (matchIndex >= 0) {
        listeners.splice(matchIndex, 1);
        if (listeners.length === 0) {
          this.registeredListeners.delete(type);
        }
        break;
      }
    }
  }
  dispatch(eventType, ...params) {
    for (const listener of this.getListenersByType(eventType)) {
      try {
        listener.handler(...params);
      } catch (e) {
        import_ag_charts_core66.Logger.errorOnce(e);
      }
    }
  }
  getListenersByType(eventType) {
    return this.registeredListeners.get(eventType) ?? [];
  }
  destroy() {
    this.registeredListeners.clear();
  }
};

// packages/ag-charts-community/src/util/baseManager.ts
var BaseManager = class {
  constructor() {
    this.listeners = new Listeners();
    this.destroyFns = [];
    this.destroyed = false;
  }
  addListener(type, handler) {
    return this.listeners.addListener(type, handler);
  }
  destroy() {
    this.listeners.destroy();
    this.destroyFns.forEach((fn) => fn());
    this.destroyed = true;
  }
};

// packages/ag-charts-community/src/util/guardedElement.ts
var import_ag_charts_core67 = require("ag-charts-core");
var GuardedElement = class _GuardedElement {
  constructor(element2, topTabGuard, bottomTabGuard) {
    this.element = element2;
    this.topTabGuard = topTabGuard;
    this.bottomTabGuard = bottomTabGuard;
    this.destroyFns = [];
    this.guardTabIndex = 0;
    this.hasFocus = false;
    this.initTabGuard(this.topTabGuard, (el) => this.onTab(el, false));
    this.initTabGuard(this.bottomTabGuard, (el) => this.onTab(el, true));
    this.element.addEventListener("focus", () => this.onFocus(), { capture: true });
    this.element.addEventListener("blur", (ev) => this.onBlur(ev), { capture: true });
  }
  set tabIndex(index) {
    this.guardTabIndex = index;
    if (this.guardTabIndex === 0) {
      this.setGuardIndices(void 0);
    } else if (!this.hasFocus) {
      this.setGuardIndices(this.guardTabIndex);
    }
  }
  destroy() {
    for (const fn of this.destroyFns)
      fn();
    this.destroyFns.length = 0;
  }
  initTabGuard(guard, handler) {
    const handlerBinding = () => handler(guard);
    guard.addEventListener("focus", handlerBinding);
    this.destroyFns.push(() => guard.removeEventListener("focus", handlerBinding));
  }
  setGuardIndices(index) {
    const tabindex = index;
    (0, import_ag_charts_core67.setAttribute)(this.topTabGuard, "tabindex", tabindex);
    (0, import_ag_charts_core67.setAttribute)(this.bottomTabGuard, "tabindex", tabindex);
  }
  onFocus() {
    this.hasFocus = true;
    if (this.guardTabIndex !== 0) {
      this.setGuardIndices(0);
    }
  }
  onBlur({ relatedTarget }) {
    const { topTabGuard: top, bottomTabGuard: bot } = this;
    this.hasFocus = false;
    if (this.guardTabIndex !== 0 && relatedTarget !== top && relatedTarget !== bot) {
      this.setGuardIndices(this.guardTabIndex);
    }
  }
  onTab(guard, reverse) {
    if (this.guardTabIndex !== 0) {
      let focusTarget;
      if (guard.tabIndex === 0) {
        focusTarget = this.findExitTarget(!reverse);
        this.setGuardIndices(this.guardTabIndex);
      } else {
        focusTarget = this.findEnterTarget(reverse);
      }
      focusTarget?.focus();
    }
  }
  static queryFocusable(element2, selectors) {
    const myWindow = (0, import_ag_charts_core67.getWindow)();
    return Array.from(element2.querySelectorAll(selectors)).filter((e) => {
      if (e instanceof HTMLElement) {
        const style = myWindow.getComputedStyle(e);
        return style.display !== "none" && style.visibility !== "none";
      }
      return false;
    });
  }
  findEnterTarget(reverse) {
    const focusables = _GuardedElement.queryFocusable(this.element, '[tabindex="0"]');
    const index = reverse ? focusables.length - 1 : 0;
    return focusables[index];
  }
  findExitTarget(reverse) {
    const focusables = _GuardedElement.queryFocusable((0, import_ag_charts_core67.getDocument)(), "[tabindex]").filter((e) => e.tabIndex > 0).sort((a, b) => a.tabIndex - b.tabIndex);
    const { before, after } = _GuardedElement.findBeforeAndAfter(focusables, this.guardTabIndex);
    return reverse ? before : after;
  }
  static findBeforeAndAfter(elements, targetTabIndex) {
    let left = 0;
    let right = elements.length - 1;
    let before = void 0;
    let after = void 0;
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      const currentTabIndex = elements[mid].tabIndex;
      if (currentTabIndex === targetTabIndex) {
        before = elements[mid - 1] || void 0;
        after = elements[mid + 1] || void 0;
        break;
      } else if (currentTabIndex < targetTabIndex) {
        before = elements[mid];
        left = mid + 1;
      } else {
        after = elements[mid];
        right = mid - 1;
      }
    }
    return { before, after };
  }
};

// packages/ag-charts-community/src/util/keynavUtil.ts
var import_ag_charts_core68 = require("ag-charts-core");
function hasNoModifiers(event) {
  return !(event.shiftKey || event.altKey || event.ctrlKey || event.metaKey);
}
function matchesKey(event, ...keys) {
  return hasNoModifiers(event) && keys.some((key) => event.key === key);
}
var PREV_NEXT_KEYS = {
  horizontal: { nextKey: "ArrowRight", prevKey: "ArrowLeft" },
  vertical: { nextKey: "ArrowDown", prevKey: "ArrowUp" }
};
function stopPageScrolling(element2) {
  const handler = (event) => {
    if (event.defaultPrevented)
      return;
    const shouldPrevent = (0, import_ag_charts_core68.getAttribute)(event.target, "data-preventdefault", true);
    if (shouldPrevent && matchesKey(event, "ArrowRight", "ArrowLeft", "ArrowDown", "ArrowUp")) {
      event.preventDefault();
    }
  };
  element2.addEventListener("keydown", handler);
  return () => element2.removeEventListener("keydown", handler);
}

// packages/ag-charts-community/src/util/sizeMonitor.ts
var import_ag_charts_core70 = require("ag-charts-core");

// packages/ag-charts-community/src/util/pixelRatioObserver.ts
var import_ag_charts_core69 = require("ag-charts-core");
var PixelRatioObserver = class {
  constructor(callback5) {
    this.callback = callback5;
    this.devicePixelRatio = (0, import_ag_charts_core69.getWindow)("devicePixelRatio") ?? 1;
    this.devicePixelRatioMediaQuery = void 0;
    this.devicePixelRatioListener = (e) => {
      if (e.matches)
        return;
      this.devicePixelRatio = (0, import_ag_charts_core69.getWindow)("devicePixelRatio") ?? 1;
      this.unregisterDevicePixelRatioListener();
      this.registerDevicePixelRatioListener();
      this.callback(this.pixelRatio);
    };
  }
  get pixelRatio() {
    return this.devicePixelRatio;
  }
  observe() {
    this.registerDevicePixelRatioListener();
  }
  disconnect() {
    this.unregisterDevicePixelRatioListener();
  }
  unregisterDevicePixelRatioListener() {
    this.devicePixelRatioMediaQuery?.removeEventListener("change", this.devicePixelRatioListener);
    this.devicePixelRatioMediaQuery = void 0;
  }
  registerDevicePixelRatioListener() {
    const devicePixelRatioMediaQuery = (0, import_ag_charts_core69.getWindow)("matchMedia")?.(`(resolution: ${this.pixelRatio}dppx)`);
    devicePixelRatioMediaQuery?.addEventListener("change", this.devicePixelRatioListener);
    this.devicePixelRatioMediaQuery = devicePixelRatioMediaQuery;
  }
};

// packages/ag-charts-community/src/util/sizeMonitor.ts
var SizeMonitor = class {
  constructor() {
    this.elements = /* @__PURE__ */ new Map();
    this.documentReady = false;
    this.queuedObserveRequests = [];
    this.onLoad = () => {
      this.documentReady = true;
      this.queuedObserveRequests.forEach(([el, cb]) => this.observe(el, cb));
      this.queuedObserveRequests = [];
      this.observeWindow();
    };
    if (typeof ResizeObserver !== "undefined") {
      this.resizeObserver = new ResizeObserver((entries7) => {
        for (const {
          target,
          contentRect: { width: width2, height: height2 }
        } of entries7) {
          const entry = this.elements.get(target);
          this.checkSize(entry, target, width2, height2);
        }
      });
    }
    let animationFrame;
    this.pixelRatioObserver = new PixelRatioObserver(() => {
      clearTimeout(animationFrame);
      animationFrame = setTimeout(() => this.checkPixelRatio(), 0);
    });
    this.documentReady = (0, import_ag_charts_core70.getDocument)("readyState") === "complete";
    if (this.documentReady) {
      this.observeWindow();
    } else {
      (0, import_ag_charts_core70.getWindow)()?.addEventListener("load", this.onLoad);
    }
  }
  destroy() {
    (0, import_ag_charts_core70.getWindow)()?.removeEventListener("load", this.onLoad);
    this.resizeObserver?.disconnect();
    this.resizeObserver = void 0;
    this.pixelRatioObserver?.disconnect();
    this.pixelRatioObserver = void 0;
  }
  observeWindow() {
    this.pixelRatioObserver?.observe();
  }
  checkPixelRatio() {
    const pixelRatio = this.pixelRatioObserver?.pixelRatio ?? 1;
    for (const [element2, entry] of this.elements) {
      if (entry.size != null && entry.size.pixelRatio !== pixelRatio) {
        const { width: width2, height: height2 } = entry.size;
        entry.size = { width: width2, height: height2, pixelRatio };
        entry.cb(entry.size, element2);
      }
    }
  }
  checkSize(entry, element2, width2, height2) {
    if (!entry)
      return;
    if (width2 !== entry.size?.width || height2 !== entry.size?.height) {
      const pixelRatio = this.pixelRatioObserver?.pixelRatio ?? 1;
      entry.size = { width: width2, height: height2, pixelRatio };
      entry.cb(entry.size, element2);
    }
  }
  // Only a single callback is supported.
  observe(element2, cb) {
    if (!this.documentReady) {
      this.queuedObserveRequests.push([element2, cb]);
      return;
    }
    if (this.elements.has(element2)) {
      this.removeFromQueue(element2);
    } else {
      this.resizeObserver?.observe(element2);
    }
    const entry = { cb };
    this.elements.set(element2, entry);
  }
  unobserve(element2) {
    this.resizeObserver?.unobserve(element2);
    this.elements.delete(element2);
    this.removeFromQueue(element2);
    if (!this.elements.size) {
      this.destroy();
    }
  }
  removeFromQueue(element2) {
    this.queuedObserveRequests = this.queuedObserveRequests.filter(([el]) => el !== element2);
  }
};

// packages/ag-charts-community/src/util/stateTracker.ts
var StateTracker = class extends Map {
  constructor(defaultValue, defaultState) {
    super();
    this.defaultValue = defaultValue;
    this.defaultState = defaultState;
  }
  set(key, value) {
    this.delete(key);
    if (typeof value !== "undefined") {
      super.set(key, value);
    }
    return this;
  }
  stateId() {
    return Array.from(this.keys()).pop() ?? this.defaultState;
  }
  stateValue() {
    return Array.from(this.values()).pop() ?? this.defaultValue;
  }
};

// packages/ag-charts-community/src/dom/domLayout.html
var domLayout_default = '<div role="presentation" class="ag-charts-wrapper ag-charts-styles" data-ag-charts><div role="presentation" class="ag-charts-canvas-center"><div role="presentation" class="ag-charts-canvas-container"><div role="presentation" class="ag-charts-canvas" aria-hidden="true"></div><div role="figure" class="ag-charts-canvas-proxy"><div role="presentation" class="ag-charts-series-area"></div></div><div role="presentation" class="ag-charts-canvas-overlay ag-charts-tooltip-container"></div></div></div></div>';

// packages/ag-charts-community/src/dom/domManager.ts
var DOM_ELEMENT_CLASSES = [
  "styles",
  "canvas",
  "canvas-center",
  "canvas-container",
  "canvas-overlay",
  "canvas-proxy",
  "series-area",
  "tooltip-container"
];
var MINIMAL_DOM_ELEMENT_ROLES = /* @__PURE__ */ new Set(["canvas-container", "canvas", "tooltip-container"]);
var CONTAINER_MODIFIERS = {
  safeHorizontal: "ag-charts-wrapper--safe-horizontal",
  safeVertical: "ag-charts-wrapper--safe-vertical"
};
var domElementConfig = /* @__PURE__ */ new Map([
  ["styles", { childElementType: "style" }],
  ["canvas", { childElementType: "canvas" }],
  ["canvas-proxy", { childElementType: "div" }],
  ["canvas-overlay", { childElementType: "div" }],
  ["canvas-center", { childElementType: "div" }],
  ["series-area", { childElementType: "div" }],
  ["tooltip-container", { childElementType: "div" }]
]);
function setupObserver(element2, cb) {
  if (typeof IntersectionObserver === "undefined")
    return;
  const observer = new IntersectionObserver(
    (observedEntries) => {
      for (const entry of observedEntries) {
        if (entry.target === element2) {
          cb(entry.intersectionRatio);
        }
      }
    },
    { root: element2 }
  );
  observer.observe(element2);
  return observer;
}
var NULL_DOMRECT = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  top: 0,
  bottom: 0,
  left: 0,
  right: 0,
  toJSON() {
    return NULL_DOMRECT;
  }
};
function createTabGuardElement(guardedElem, where) {
  const div = (0, import_ag_charts_core71.createElement)("div");
  div.className = "ag-charts-tab-guard";
  guardedElem.insertAdjacentElement(where, div);
  return div;
}
var _DOMManager = class _DOMManager extends BaseManager {
  constructor(chart, initialContainer, styleContainer, mode = "normal") {
    super();
    this.chart = chart;
    this.styleContainer = styleContainer;
    this.mode = mode;
    this.anchorName = `--${(0, import_ag_charts_core71.createId)(this)}`;
    this.styles = /* @__PURE__ */ new Map();
    this.pendingContainer = void 0;
    this.container = void 0;
    this.documentRoot = void 0;
    this.initiallyConnected = void 0;
    this.containerSize = void 0;
    this.sizeMonitor = new SizeMonitor();
    this.cursorState = new StateTracker("default");
    this.minWidth = 0;
    this.minHeight = 0;
    this.element = this.initDOM();
    this.rootElements = this.initRootElements();
    this.rootElements["canvas"].element.style.setProperty("anchor-name", this.anchorName);
    let hidden = false;
    this.observer = setupObserver(this.element, (intersectionRatio) => {
      if (intersectionRatio === 0 && !hidden) {
        this.listeners.dispatch("hidden", { type: "hidden" });
      }
      hidden = intersectionRatio === 0;
    });
    this.setSizeOptions();
    this.updateContainerSize();
    this.addStyles("ag-charts-community", styles_default);
    this.setContainer(initialContainer);
    this.destroyFns.push(stopPageScrolling(this.element));
    if (this.mode === "normal") {
      const guardedElement = this.rootElements["canvas-center"].element;
      if (guardedElement == null)
        throw new Error("Error initializing tab guards");
      const topGuard = createTabGuardElement(guardedElement, "beforebegin");
      const botGuard = createTabGuardElement(guardedElement, "afterend");
      this.tabGuards = new GuardedElement(guardedElement, topGuard, botGuard);
    }
  }
  initDOM() {
    if (this.mode === "normal") {
      const templateEl = (0, import_ag_charts_core71.createElement)("div");
      templateEl.innerHTML = domLayout_default;
      return templateEl.firstChild;
    }
    const element2 = (0, import_ag_charts_core71.createElement)("div");
    element2.role = "presentation";
    element2.dataset.agCharts = "";
    element2.classList.add("ag-charts-wrapper");
    const seriesArea = (0, import_ag_charts_core71.createElement)("div");
    element2.appendChild(seriesArea);
    seriesArea.role = "presentation";
    seriesArea.classList.add("ag-charts-series-area");
    return element2;
  }
  initRootElements() {
    const { mode, element: element2 } = this;
    const rootElements = {};
    for (const domElement of DOM_ELEMENT_CLASSES) {
      const className = `ag-charts-${domElement}`;
      let el;
      if (mode === "normal") {
        el = element2.classList.contains(className) ? element2 : element2.getElementsByClassName(className)[0];
      } else if (MINIMAL_DOM_ELEMENT_ROLES.has(domElement)) {
        el = element2;
      } else {
        el = element2.getElementsByClassName(className)[0] ?? (0, import_ag_charts_core71.createElement)("div");
      }
      if (el == null) {
        throw new Error(`AG Charts - unable to find DOM element ${className}`);
      }
      rootElements[domElement] = {
        element: el,
        children: /* @__PURE__ */ new Map(),
        listeners: []
      };
    }
    return rootElements;
  }
  destroy() {
    super.destroy();
    this.observer?.unobserve(this.element);
    if (this.container) {
      this.sizeMonitor.unobserve(this.container);
    }
    this.pendingContainer = void 0;
    Object.values(this.rootElements).forEach((el) => {
      el.children.forEach((c) => c.remove());
      el.element.remove();
    });
    this.element.remove();
  }
  postRenderUpdate() {
    if (this.mode === "minimal")
      return;
    if (this.pendingContainer == null || this.pendingContainer === this.container)
      return;
    if (_DOMManager.batchedUpdateContainer.length === 0) {
      (0, import_ag_charts_core71.getWindow)().setTimeout(this.applyBatchedUpdateContainer.bind(this), 0);
    }
    _DOMManager.batchedUpdateContainer.push(this);
  }
  applyBatchedUpdateContainer() {
    for (const manager of _DOMManager.batchedUpdateContainer) {
      if (!manager.destroyed) {
        manager.updateContainer();
      }
    }
    _DOMManager.batchedUpdateContainer.splice(0);
  }
  setSizeOptions(minWidth = 300, minHeight = 300, optionsWidth, optionsHeight) {
    const { style } = this.element;
    style.width = `${optionsWidth ?? minWidth}px`;
    style.height = `${optionsHeight ?? minHeight}px`;
    this.minWidth = optionsWidth ?? minWidth;
    this.minHeight = optionsHeight ?? minHeight;
    this.updateContainerClassName();
  }
  updateContainerSize() {
    const { style: centerStyle } = this.rootElements["canvas-center"].element;
    centerStyle.visibility = this.containerSize == null ? "hidden" : "";
    if (this.containerSize) {
      centerStyle.width = `${this.containerSize.width ?? 0}px`;
      centerStyle.height = `${this.containerSize.height ?? 0}px`;
    } else {
      centerStyle.width = "";
      centerStyle.height = "";
    }
    this.updateContainerClassName();
  }
  setTabGuardIndex(tabIndex) {
    if (!this.tabGuards)
      return;
    this.tabGuards.tabIndex = tabIndex;
  }
  setContainer(newContainer) {
    if (newContainer === this.container)
      return;
    this.pendingContainer = newContainer;
    if (this.mode === "minimal" || this.container == null) {
      this.updateContainer();
    }
  }
  updateContainer() {
    const { pendingContainer } = this;
    if (pendingContainer == null || pendingContainer === this.container)
      return;
    if (this.container) {
      this.container.removeChild(this.element);
      this.sizeMonitor.unobserve(this.container);
    }
    if (this.documentRoot != null) {
      for (const id of this.rootElements["styles"].children.keys()) {
        this.removeChild("styles", id);
      }
    }
    this.container = pendingContainer;
    this.pendingContainer = void 0;
    this.documentRoot = this.getShadowDocumentRoot(pendingContainer);
    this.initiallyConnected = this.mode === "minimal" || pendingContainer.isConnected;
    for (const [id, styles] of this.styles) {
      this.addStyles(id, styles);
    }
    pendingContainer.appendChild(this.element);
    this.sizeMonitor.observe(pendingContainer, (size) => {
      this.containerSize = size;
      this.updateContainerSize();
      this.listeners.dispatch("resize", { type: "resize" });
    });
    this.listeners.dispatch("container-changed", { type: "container-changed" });
  }
  setThemeClass(themeClassName) {
    const themeClassNamePrefix = "ag-charts-theme-";
    this.element.classList.forEach((className) => {
      if (className.startsWith(themeClassNamePrefix) && className !== themeClassName) {
        this.element.classList.remove(className);
      }
    });
    this.element.classList.add(themeClassName);
  }
  setThemeParameters(params) {
    const keysMap = {
      accentColor: "accent-color",
      axisColor: "axis-color",
      backgroundColor: "background-color",
      borderColor: "border-color",
      foregroundColor: "foreground-color",
      fontFamily: "font-family",
      fontSize: "font-size",
      fontWeight: "font-weight",
      gridLineColor: "grid-line-color",
      padding: "padding",
      subtleTextColor: "subtle-text-color",
      textColor: "text-color",
      chromeBackgroundColor: "chrome-background-color",
      chromeFontFamily: "chrome-font-family",
      chromeFontSize: "chrome-font-size",
      chromeFontWeight: "chrome-font-weight",
      chromeSubtleTextColor: "chrome-subtle-text-color",
      chromeTextColor: "chrome-text-color",
      inputBackgroundColor: "input-background-color",
      inputTextColor: "input-text-color",
      crosshairLabelBackgroundColor: "crosshair-label-background-color",
      crosshairLabelTextColor: "crosshair-label-text-color"
    };
    const lengthKeys = ["fontSize", "chromeFontSize"];
    for (const [key, value] of (0, import_ag_charts_core71.entries)(params)) {
      let formattedValue = `${value}`;
      if (lengthKeys.includes(key)) {
        formattedValue = `${value}px`;
      }
      this.element.style.setProperty(`--ag-charts-${keysMap[key]}`, formattedValue);
    }
  }
  updateCanvasLabel(ariaLabel) {
    (0, import_ag_charts_core71.setAttribute)(this.rootElements["canvas-proxy"].element, "aria-label", ariaLabel);
  }
  getEventElement(defaultElem, eventType) {
    const events = ["focus", "blur", "keydown", "keyup"];
    return events.includes(eventType) ? this.rootElements["series-area"].element : defaultElem;
  }
  addEventListener(type, listener, options) {
    this.getEventElement(this.element, type).addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    this.getEventElement(this.element, type).removeEventListener(type, listener, options);
  }
  /** Get the main chart area client bound rect. */
  getBoundingClientRect() {
    return this.rootElements["canvas"].element.getBoundingClientRect();
  }
  /**
   * Get the client bounding rect for overlay elements that might float outside the bounds of the
   * main chart area.
   */
  getOverlayClientRect() {
    const window2 = (0, import_ag_charts_core71.getWindow)();
    const windowBBox = new BBox(0, 0, window2.innerWidth, window2.innerHeight);
    const containerBBox = this.getRawOverlayClientRect();
    return windowBBox.intersection(containerBBox)?.toDOMRect() ?? NULL_DOMRECT;
  }
  getRawOverlayClientRect() {
    let element2 = this.element;
    const fullScreenElement = this.element.getRootNode()?.fullscreenElement;
    while (element2 != null) {
      let isContainer;
      if (fullScreenElement != null && element2 === fullScreenElement) {
        isContainer = true;
      } else {
        const styleMap = element2.computedStyleMap?.();
        const overflowY = styleMap?.get("overflow-y")?.toString();
        isContainer = overflowY === "auto" || overflowY === "scroll";
      }
      if (isContainer) {
        return BBox.fromDOMRect(element2.getBoundingClientRect());
      }
      element2 = element2.parentElement;
    }
    if (this.documentRoot != null)
      return BBox.fromDOMRect(this.documentRoot.getBoundingClientRect());
    const { innerWidth, innerHeight } = (0, import_ag_charts_core71.getWindow)();
    return new BBox(0, 0, innerWidth, innerHeight);
  }
  getShadowDocumentRoot(current = this.container) {
    const docRoot = current?.ownerDocument?.body ?? (0, import_ag_charts_core71.getDocument)("body");
    while (current != null) {
      if (current === docRoot) {
        return void 0;
      }
      if (current.parentNode instanceof DocumentFragment) {
        return current;
      }
      current = current.parentNode;
    }
  }
  getParent(domElementClass) {
    return this.rootElements[domElementClass].element;
  }
  getChildBoundingClientRect(type) {
    const { children } = this.rootElements[type];
    const childRects = [];
    for (const child of children.values()) {
      childRects.push(BBox.fromDOMRect(child.getBoundingClientRect()));
    }
    return BBox.merge(childRects);
  }
  isManagedChildDOMElement(el, domElementClass, id) {
    const { children } = this.rootElements[domElementClass];
    const search = children?.get(id);
    return search != null && el.contains(search);
  }
  contains(element2, domElementClass) {
    if (domElementClass == null)
      return this.element.contains(element2);
    return this.rootElements[domElementClass].element.contains(element2);
  }
  addStyles(id, styles) {
    const dataAttribute = "data-ag-charts";
    this.styles.set(id, styles);
    if (this.container == null)
      return;
    const checkId = (el) => {
      return el.getAttribute(dataAttribute) === id;
    };
    const addStyleElement = (el) => {
      const metaElements = /* @__PURE__ */ new Set(["TITLE", "META"]);
      let skippingMetaElements = true;
      let insertAfterEl;
      for (const child of el.children) {
        if (skippingMetaElements && metaElements.has(child.tagName)) {
          insertAfterEl = child;
          continue;
        }
        skippingMetaElements = false;
        if (checkId(child))
          return;
        if (child.hasAttribute(dataAttribute)) {
          insertAfterEl = child;
        }
      }
      const styleEl = (0, import_ag_charts_core71.createElement)("style");
      if (this.chart.styleNonce != null) {
        styleEl.nonce = this.chart.styleNonce;
      }
      if (insertAfterEl == null) {
        el.prepend(styleEl);
      } else {
        el.insertBefore(styleEl, insertAfterEl.nextSibling);
      }
      return styleEl;
    };
    let styleElement;
    if (this.styleContainer) {
      styleElement = addStyleElement(this.styleContainer);
    } else if (this.initiallyConnected === false) {
      styleElement = this.addChild("styles", id);
    } else if (this.documentRoot == null && !_DOMManager.headStyles.has(id)) {
      styleElement = addStyleElement((0, import_ag_charts_core71.getDocument)("head"));
      _DOMManager.headStyles.add(id);
    } else if (this.documentRoot != null) {
      styleElement = this.addChild("styles", id);
    }
    if (styleElement == null || checkId(styleElement))
      return;
    styleElement.setAttribute(dataAttribute, id);
    styleElement.innerHTML = styles;
  }
  removeStyles(id) {
    this.removeChild("styles", id);
  }
  updateCursor(callerId, style) {
    this.cursorState.set(callerId, style);
    this.element.style.cursor = this.cursorState.stateValue();
  }
  getCursor() {
    return this.element.style.cursor;
  }
  addChild(domElementClass, id, child, insert) {
    const { element: element2, children, listeners } = this.rootElements[domElementClass];
    if (!children) {
      throw new Error("AG Charts - unable to create DOM elements after destroy()");
    }
    if (children.has(id)) {
      return children.get(id);
    }
    const { childElementType = "div" } = domElementConfig.get(domElementClass) ?? {};
    if (child && child.tagName.toLowerCase() !== childElementType.toLowerCase()) {
      throw new Error("AG Charts - mismatching DOM element type");
    }
    const newChild = child ?? (0, import_ag_charts_core71.createElement)(childElementType);
    for (const [type, fn, opts] of listeners) {
      newChild.addEventListener(type, fn, opts);
    }
    children.set(id, newChild);
    if (childElementType === "style" && this.chart.styleNonce != null) {
      newChild.nonce = this.chart.styleNonce;
    }
    if (insert) {
      const queryResult = element2.querySelector(insert.query);
      if (queryResult == null) {
        throw new Error(`AG Charts - addChild query failed ${insert.query}`);
      }
      queryResult.insertAdjacentElement(insert.where, newChild);
    } else {
      element2?.appendChild(newChild);
    }
    return newChild;
  }
  removeChild(domElementClass, id) {
    const { children } = this.rootElements[domElementClass];
    if (!children)
      return;
    children.get(id)?.remove();
    children.delete(id);
  }
  incrementDataCounter(name) {
    const { dataset } = this.element;
    dataset[name] ?? (dataset[name] = "0");
    dataset[name] = String(Number(dataset[name]) + 1);
  }
  setDataBoolean(name, value) {
    this.element.dataset[name] = String(value);
  }
  updateContainerClassName() {
    const { element: element2, containerSize, minWidth, minHeight } = this;
    element2.classList.toggle(CONTAINER_MODIFIERS.safeHorizontal, minWidth >= (containerSize?.width ?? Infinity));
    element2.classList.toggle(CONTAINER_MODIFIERS.safeVertical, minHeight >= (containerSize?.height ?? Infinity));
  }
};
_DOMManager.batchedUpdateContainer = [];
_DOMManager.headStyles = /* @__PURE__ */ new Set();
var DOMManager = _DOMManager;

// packages/ag-charts-community/src/dom/proxyInteractionService.ts
var import_ag_charts_core80 = require("ag-charts-core");

// packages/ag-charts-community/src/widget/boundedTextWidget.ts
var import_ag_charts_core72 = require("ag-charts-core");
var BoundedTextWidget = class extends Widget {
  constructor() {
    super((0, import_ag_charts_core72.createElement)("div"));
    this.textElement = (0, import_ag_charts_core72.createSvgElement)("text");
    this.textElement.role = "presentation";
    this.svgElement = (0, import_ag_charts_core72.createSvgElement)("svg");
    this.svgElement.appendChild(this.textElement);
    this.svgElement.style.width = "100%";
    this.svgElement.style.opacity = "0";
    this.svgElement.role = "presentation";
    this.elem.appendChild(this.svgElement);
    this.elem.role = "presentation";
  }
  set textContent(text) {
    this.textElement.textContent = text;
    const bboxCalculator = this.textElement;
    const bbox = bboxCalculator.getBBox?.();
    if (bbox) {
      this.svgElement.setAttribute("viewBox", `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`);
    }
  }
  get textContent() {
    return this.textElement.textContent;
  }
  destructor() {
  }
};

// packages/ag-charts-community/src/widget/buttonWidget.ts
var import_ag_charts_core74 = require("ag-charts-core");

// packages/ag-charts-community/src/widget/abstractButtonWidget.ts
var import_ag_charts_core73 = require("ag-charts-core");
var AbstractButtonWidget = class extends Widget {
  constructor(element2, role) {
    super(element2);
    (0, import_ag_charts_core73.setAttribute)(this.elem, "role", role);
    this.setEnabled(true);
  }
  destructor() {
  }
  setEnabled(enabled) {
    (0, import_ag_charts_core73.setAttribute)(this.elem, "aria-disabled", !enabled);
  }
  addListener(type, listener) {
    return super.addListener(type, (ev, current) => {
      if ((type === "click" || type === "dblclick") && this.isDisabled())
        return;
      listener(ev, current);
    });
  }
};

// packages/ag-charts-community/src/widget/buttonWidget.ts
var ButtonWidget = class extends AbstractButtonWidget {
  constructor() {
    super((0, import_ag_charts_core74.createElement)("button"));
  }
};

// packages/ag-charts-community/src/widget/groupWidget.ts
var import_ag_charts_core75 = require("ag-charts-core");
var GroupWidget = class extends Widget {
  constructor() {
    super((0, import_ag_charts_core75.createElement)("div"));
    (0, import_ag_charts_core75.setAttribute)(this.elem, "role", "group");
  }
  destructor() {
  }
};

// packages/ag-charts-community/src/widget/listWidget.ts
var import_ag_charts_core77 = require("ag-charts-core");

// packages/ag-charts-community/src/widget/rovingTabContainerWidget.ts
var import_ag_charts_core76 = require("ag-charts-core");
var RovingTabContainerWidget = class extends Widget {
  constructor(initialOrientation, role) {
    super((0, import_ag_charts_core76.createElement)("div"));
    this.focusedChildIndex = 0;
    this.onChildFocus = (_event, child) => {
      const oldFocus = this.children[this.focusedChildIndex];
      this.focusedChildIndex = child.index;
      oldFocus?.setTabIndex(-1);
      child.setTabIndex(0);
    };
    this.onChildKeyDown = (event, child) => {
      const rovingOrientation = this.orientation;
      const [primaryKeys, secondaryKeys] = rovingOrientation === "both" ? [PREV_NEXT_KEYS["horizontal"], PREV_NEXT_KEYS["vertical"]] : [PREV_NEXT_KEYS[rovingOrientation], void 0];
      let targetIndex = -1;
      if (hasNoModifiers(event.sourceEvent)) {
        const key = event.sourceEvent.key;
        if (key === primaryKeys.nextKey || key === secondaryKeys?.nextKey) {
          targetIndex = child.index + 1;
        } else if (key === primaryKeys.prevKey || key === secondaryKeys?.prevKey) {
          targetIndex = child.index - 1;
        }
      }
      this.children[targetIndex]?.focus();
    };
    (0, import_ag_charts_core76.setAttribute)(this.elem, "role", role);
    this.orientation = initialOrientation;
  }
  get orientation() {
    return (0, import_ag_charts_core76.getAttribute)(this.elem, "aria-orientation") ?? "both";
  }
  set orientation(orientation) {
    (0, import_ag_charts_core76.setAttribute)(this.elem, "aria-orientation", orientation !== "both" ? orientation : void 0);
  }
  focus() {
    this.children[this.focusedChildIndex]?.focus();
  }
  clear() {
    this.focusedChildIndex = 0;
    for (const child of this.children) {
      this.removeChildListeners(child);
      child.parent = void 0;
    }
    this.elem.textContent = "";
    this.children.length = 0;
  }
  addChildListeners(child) {
    child.addListener("focus", this.onChildFocus);
    child.addListener("keydown", this.onChildKeyDown);
  }
  removeChildListeners(child) {
    child.removeListener("focus", this.onChildFocus);
    child.removeListener("keydown", this.onChildKeyDown);
  }
  onChildAdded(child) {
    this.addChildListeners(child);
    child.setTabIndex(this.children.length === 1 ? 0 : -1);
  }
  onChildRemoved(removedChild) {
    this.removeChildListeners(removedChild);
    const { focusedChildIndex, children } = this;
    const removedFocusedChild = focusedChildIndex === removedChild.index;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.index === focusedChildIndex) {
        this.focusedChildIndex = i;
      }
      child.index = i;
    }
    if (removedFocusedChild) {
      const newFocusChild = children[focusedChildIndex] ?? children[focusedChildIndex - 1];
      if (newFocusChild) {
        this.focusedChildIndex = newFocusChild.index;
        newFocusChild.setTabIndex(0);
      } else {
        this.focusedChildIndex = 0;
      }
    }
  }
};

// packages/ag-charts-community/src/widget/listWidget.ts
var ListWidget = class extends RovingTabContainerWidget {
  constructor() {
    super("both", "list");
    this.setHidden(true);
  }
  destructor() {
    this.children.forEach((c) => c.getElement().parentElement.remove());
  }
  addChildToDOM(child, before) {
    const listItem = (0, import_ag_charts_core77.createElement)("div");
    (0, import_ag_charts_core77.setAttribute)(listItem, "role", "listitem");
    (0, import_ag_charts_core77.setElementStyle)(listItem, "position", "absolute");
    Widget.setElementContainer(child, listItem);
    this.appendOrInsert(listItem, before);
    this.setHidden(false);
  }
  removeChildFromDOM(child) {
    child.getElement().parentElement.remove();
    this.setHidden(this.children.length === 0);
  }
  setHidden(hidden) {
    if (this.children.length === 0) {
      hidden = true;
    }
    super.setHidden(hidden);
  }
};

// packages/ag-charts-community/src/widget/nativeWidget.ts
var NativeWidget = class extends Widget {
  constructor(elem) {
    super(elem);
  }
  destructor() {
  }
};

// packages/ag-charts-community/src/widget/sliderWidget.ts
var import_ag_charts_core78 = require("ag-charts-core");
var _SliderWidget = class _SliderWidget extends Widget {
  constructor() {
    super((0, import_ag_charts_core78.createElement)("input"));
    this._step = _SliderWidget.STEP_ONE;
    this.orientation = "both";
  }
  get step() {
    return this._step;
  }
  set step(step) {
    this._step = step;
    this.getElement().step = step.attributeValue;
  }
  get keyboardStep() {
    return this._keyboardStep?.step ?? this._step;
  }
  set keyboardStep(step) {
    if (step === this._keyboardStep?.step)
      return;
    if (this._keyboardStep !== void 0) {
      this.removeListener("keydown", this._keyboardStep.onKeyDown);
      this.removeListener("keyup", this._keyboardStep.onKeyUp);
      this.removeListener("blur", this._keyboardStep.onBlur);
      this._keyboardStep = void 0;
    }
    if (step !== void 0) {
      const onKeyDown = () => this.getElement().step = step.attributeValue;
      const resetStep = () => this.getElement().step = this._step.attributeValue;
      this._keyboardStep = { step, onKeyDown, onKeyUp: resetStep, onBlur: resetStep };
      this.addListener("keydown", this._keyboardStep.onKeyDown);
      this.addListener("keyup", this._keyboardStep.onKeyUp);
      this.addListener("blur", this._keyboardStep.onBlur);
    }
  }
  get orientation() {
    return (0, import_ag_charts_core78.getAttribute)(this.elem, "aria-orientation") ?? "both";
  }
  set orientation(orientation) {
    (0, import_ag_charts_core78.setAttribute)(this.elem, "aria-orientation", orientation !== "both" ? orientation : void 0);
    _SliderWidget.registerDefaultPreventers(this, orientation);
  }
  destructor() {
  }
  clampValueRatio(clampMin, clampMax) {
    const ratio8 = this.getValueRatio();
    const clampedRatio = (0, import_ag_charts_core78.clamp)(clampMin, ratio8, clampMax);
    if (clampedRatio !== ratio8) {
      this.setValueRatio(clampedRatio);
    }
    return clampedRatio;
  }
  setValueRatio(ratio8, opts) {
    const { divider } = this.step;
    const value = Math.round(ratio8 * 1e4) / divider;
    const { ariaValueText = formatPercent(value / divider) } = opts ?? {};
    const elem = this.getElement();
    elem.value = `${value}`;
    elem.ariaValueText = ariaValueText;
  }
  getValueRatio() {
    return parseFloat(this.getElement().value) / this.step.divider;
  }
  static registerDefaultPreventers(target, orientation) {
    if (orientation === "both") {
      target.removeListener("keydown", _SliderWidget.onKeyDown);
    } else {
      target.addListener("keydown", _SliderWidget.onKeyDown);
    }
  }
  static onKeyDown(ev, current) {
    let ignoredKeys = [];
    const { orientation } = current;
    if (orientation === "horizontal") {
      ignoredKeys = ["ArrowUp", "ArrowDown"];
    } else if (orientation === "vertical") {
      ignoredKeys = ["ArrowLeft", "ArrowRight"];
    }
    if (ignoredKeys.includes(ev.sourceEvent.code)) {
      ev.sourceEvent.preventDefault();
    }
  }
};
_SliderWidget.STEP_ONE = { attributeValue: "1", divider: 1 };
_SliderWidget.STEP_HUNDRETH = { attributeValue: "0.01", divider: 100 };
var SliderWidget = _SliderWidget;

// packages/ag-charts-community/src/widget/switchWidget.ts
var import_ag_charts_core79 = require("ag-charts-core");
var SwitchWidget = class extends ButtonWidget {
  constructor() {
    super();
    (0, import_ag_charts_core79.setAttribute)(this.elem, "role", "switch");
    this.setChecked(false);
  }
  setChecked(checked) {
    (0, import_ag_charts_core79.setAttribute)(this.elem, "aria-checked", checked);
  }
};

// packages/ag-charts-community/src/widget/toolbarWidget.ts
var ToolbarWidget = class extends RovingTabContainerWidget {
  constructor(orientation = "horizontal") {
    super(orientation, "toolbar");
  }
  destructor() {
  }
};

// packages/ag-charts-community/src/dom/proxyInteractionService.ts
function checkType(type, meta) {
  return meta.params?.type === type;
}
function allocateResult(type) {
  if ("button" === type) {
    return new ButtonWidget();
  } else if ("slider" === type) {
    return new SliderWidget();
  } else if ("toolbar" === type) {
    return new ToolbarWidget();
  } else if ("group" === type) {
    return new GroupWidget();
  } else if ("list" === type) {
    return new ListWidget();
  } else if ("region" === type) {
    return new NativeWidget((0, import_ag_charts_core80.createElement)("div"));
  } else if ("text" === type) {
    return new BoundedTextWidget();
  } else if ("listswitch" === type) {
    return new SwitchWidget();
  } else {
    throw Error("AG Charts - error allocating meta");
  }
}
function allocateMeta(params) {
  const meta = { params, result: void 0 };
  meta.result = allocateResult(meta.params.type);
  return meta;
}
var ProxyInteractionService = class {
  constructor(localeManager, domManager) {
    this.localeManager = localeManager;
    this.domManager = domManager;
    this.destroyFns = [];
  }
  destroy() {
    this.destroyFns.forEach((fn) => fn());
  }
  addLocalisation(fn) {
    fn();
    this.destroyFns.push(this.localeManager.addListener("locale-changed", fn));
  }
  createProxyContainer(args) {
    const meta = allocateMeta(args);
    const { params, result } = meta;
    const div = result.getElement();
    this.domManager.addChild("canvas-proxy", params.domManagerId, div);
    div.classList.add(...params.classList, "ag-charts-proxy-container");
    div.role = params.type;
    if ("ariaOrientation" in params) {
      div.ariaOrientation = params.ariaOrientation;
    }
    if (checkType("toolbar", meta)) {
      meta.result.orientation = meta.params.orientation;
    }
    this.addLocalisation(() => {
      div.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);
    });
    return result;
  }
  createProxyElement(args) {
    const meta = allocateMeta(args);
    if (checkType("button", meta)) {
      const { params, result } = meta;
      const button = result.getElement();
      this.initInteract(params, result);
      if (typeof params.textContent === "string") {
        button.textContent = params.textContent;
      } else {
        const { textContent } = params;
        this.addLocalisation(() => {
          button.textContent = this.localeManager.t(textContent.id, textContent.params);
        });
      }
      this.setParent(meta.params, meta.result);
    }
    if (checkType("slider", meta)) {
      const { params, result } = meta;
      const slider = result.getElement();
      this.initInteract(params, result);
      slider.type = "range";
      slider.role = "presentation";
      slider.style.margin = "0px";
      this.addLocalisation(() => {
        slider.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);
      });
      this.setParent(meta.params, meta.result);
    }
    if (checkType("text", meta)) {
      const { params, result } = meta;
      this.initElement(params, result);
      this.setParent(meta.params, meta.result);
    }
    if (checkType("listswitch", meta)) {
      const { params, result: button } = meta;
      this.initInteract(params, button);
      button.setTextContent(params.textContent);
      button.setChecked(params.ariaChecked);
      button.setAriaDescribedBy(params.ariaDescribedBy);
      this.setParent(meta.params, meta.result);
    }
    if (checkType("region", meta)) {
      const { params, result } = meta;
      const region = result.getElement();
      this.initInteract(params, result);
      region.role = "region";
      this.setParent(meta.params, meta.result);
    }
    return meta.result;
  }
  initElement(params, widget) {
    const element2 = widget.getElement();
    (0, import_ag_charts_core80.setElementStyle)(element2, "cursor", params.cursor);
    element2.classList.toggle("ag-charts-proxy-elem", true);
    return element2;
  }
  initInteract(params, widget) {
    const { tabIndex, domIndex } = params;
    const element2 = this.initElement(params, widget);
    if (tabIndex !== void 0) {
      element2.tabIndex = tabIndex;
    }
    if (domIndex !== void 0) {
      widget.domIndex = domIndex;
    }
  }
  setParent(params, element2) {
    if ("parent" in params) {
      params.parent?.addChild(element2);
    } else {
      const insert = { where: params.where, query: ".ag-charts-series-area" };
      this.domManager.addChild("canvas-proxy", params.domManagerId, element2.getElement(), insert);
    }
  }
};

// packages/ag-charts-locale/src/en-US.ts
var AG_CHARTS_LOCALE_EN_US = {
  // Screen reader announcement when focusing an item in the chart
  ariaAnnounceHoverDatum: "${datum}",
  // Screen reader announcement when focusing a chart
  ariaAnnounceChart: "chart, ${seriesCount}[number] series",
  // Screen reader announcement when focusing a hierarchy chart
  ariaAnnounceHierarchyChart: "hierarchy chart, ${caption}",
  // Screen reader announcement when focusing a gauge chart
  ariaAnnounceGaugeChart: "gauge chart, ${caption}",
  // Screen reader announcement when focusing an item in a treemap or sunburst chart
  ariaAnnounceHierarchyDatum: "level ${level}[number], ${count}[number] children, ${description}",
  // Screen reader announcement when focusing a link in a Sankey or chord chart
  ariaAnnounceFlowProportionLink: "link ${index} of ${count}, from ${from} to ${to}, ${sizeName} ${size}",
  // Screen reader announcement when focusing a node in a Sankey or chord chart
  ariaAnnounceFlowProportionNode: "node ${index} of ${count}, ${description}",
  // Screen reader description for legend items
  ariaDescriptionLegendItem: "Press Space or Enter to toggle visibility",
  // Screen reader for the '+' horizontal line button on the Y-axis
  ariaLabelAddHorizontalLine: "Add Horizontal Line",
  // Screen reader text for annotation-options toolbar
  ariaLabelAnnotationOptionsToolbar: "Annotation Options",
  // Screen reader text for annotation-settings dialog
  ariaLabelAnnotationSettingsDialog: "Annotation Settings",
  // Screen reader text for the color picker dialog
  ariaLabelColorPicker: "Color picker",
  // Screen reader text for the financial charts toolbar
  ariaLabelFinancialCharts: "Financial Charts",
  // Screen reader text for the legend toolbar
  ariaLabelLegend: "Legend",
  // Screen reader text for the legend pagination button
  ariaLabelLegendPagination: "Legend Pagination",
  // Screen reader text for the previous legend page button
  ariaLabelLegendPagePrevious: "Previous Legend Page",
  // Screen reader text for the next legend page button
  ariaLabelLegendPageNext: "Next Legend Page",
  // Screen reader text for the an item in the legend
  ariaLabelLegendItem: "${label}, Legend item ${index}[number] of ${count}[number]",
  // Screen reader text for the an unknown item in the legend
  ariaLabelLegendItemUnknown: "Unknown legend item",
  // Screen reader text for the navigator element
  ariaLabelNavigator: "Navigator",
  // Screen reader text for an accessibility control that changes the position of the navigator's range
  ariaLabelNavigatorRange: "Range",
  // Screen reader text for an accessibility control that changes the start of the navigator's range
  ariaLabelNavigatorMinimum: "Minimum",
  // Screen reader text for an accessibility control that changes the end of the navigator's range
  ariaLabelNavigatorMaximum: "Maximum",
  // Screen reader text for ranges toolbar
  ariaLabelRangesToolbar: "Ranges",
  // Screen reader text for the settings dialog tab-bar
  ariaLabelSettingsTabBar: "Settings",
  // Screen reader text for zoom toolbar
  ariaLabelZoomToolbar: "Zoom",
  // Screen reader text for the value of the navigator's range
  ariaValuePanRange: "${min}[percent0to2dp] to ${max}[percent0to2dp]",
  // Alt-text for the solid line dash style menu item icon
  iconAltTextLineStyleSolid: "Solid",
  // Alt-text for the long-dashed line dash style menu item icon
  iconAltTextLineStyleDashed: "Long-dashed",
  // Alt-text for the short-dashed line dash style menu item icon
  iconAltTextLineStyleDotted: "Short-dashed",
  // Alt-text for the 'position-top' icon
  iconAltTextPositionTop: "Top",
  // Alt-text for the 'position-center' icon
  iconAltTextPositionCenter: "Center",
  // Alt-text for the 'position-bottom' icon
  iconAltTextPositionBottom: "Bottom",
  // Alt-text for the 'position-left' icon
  iconAltTextAlignLeft: "Left",
  // Alt-text for the 'align-center' icon
  iconAltTextAlignCenter: "Center",
  // Alt-text for the 'position-right' icon
  iconAltTextAlignRight: "Right",
  // Alt-text for the 'close' icon
  iconAltTextClose: "Close",
  // Default text for the 'loading data' overlay
  overlayLoadingData: "Loading data...",
  // Default text for the 'no data' overlay
  overlayNoData: "No data to display",
  // Default text for the 'no visible series' overlay
  overlayNoVisibleSeries: "No visible series",
  // Default text for the 'unsupported browser' overlay
  overlayUnsupportedBrowser: "Incompatible browser version. Please upgrade your browser.",
  // Text for frequency label in Histogram Series tooltip
  seriesHistogramTooltipFrequency: "Frequency",
  // Text for sum label in Histogram Series tooltip
  seriesHistogramTooltipSum: "${yName} (sum)",
  // Text for sum label in Histogram Series tooltip
  seriesHistogramTooltipCount: "${yName} (count)",
  // Text for sum label in Histogram Series tooltip
  seriesHistogramTooltipMean: "${yName} (mean)",
  // Text for the series type toolbar's chart type button
  toolbarSeriesTypeDropdown: "Chart Type",
  // Text for the series type toolbar's OHLC chart type button
  toolbarSeriesTypeOHLC: "OHLC",
  // Text for the series type toolbar's HLC chart type button
  toolbarSeriesTypeHLC: "HLC",
  // Text for the series type toolbar's high low chart type button
  toolbarSeriesTypeHighLow: "High Low",
  // Text for the series type toolbar's candles chart type button
  toolbarSeriesTypeCandles: "Candles",
  // Text for the series type toolbar's hollow candles chart type button
  toolbarSeriesTypeHollowCandles: "Hollow Candles",
  // Text for the series type toolbar's line chart type button
  toolbarSeriesTypeLine: "Line",
  // Text for the series type toolbar's line with markers chart type button
  toolbarSeriesTypeLineWithMarkers: "Line with Markers",
  // Text for the series type toolbar's line with step line chart type button
  toolbarSeriesTypeStepLine: "Step Line",
  // Text for the annotation toolbar's trend line button
  toolbarAnnotationsTrendLine: "Trend Line",
  // Text for the annotation toolbar's Fibonacci Retracement button
  toolbarAnnotationsFibonacciRetracement: "Fib Retracement",
  // Text for the annotation toolbar's Fibonacci Retracement Trend Based button
  toolbarAnnotationsFibonacciRetracementTrendBased: "Fib Trend Based",
  // Text for the annotation toolbar's horizontal line button
  toolbarAnnotationsHorizontalLine: "Horizontal Line",
  // Text for the annotation toolbar's vertical line button
  toolbarAnnotationsVerticalLine: "Vertical Line",
  // Text for the annotation toolbar's parallel channel button
  toolbarAnnotationsParallelChannel: "Parallel Channel",
  // Text for the annotation toolbar's disjoint channel button
  toolbarAnnotationsDisjointChannel: "Disjoint Channel",
  // Text for the annotation toolbar's clear all button
  toolbarAnnotationsClearAll: "Clear All",
  // Text for the annotation toolbar's fill color picker annotation button
  toolbarAnnotationsFillColor: "Fill Color",
  // Text for the annotation toolbar's line color picker annotation button
  toolbarAnnotationsLineColor: "Line Color",
  // Text for the annotation toolbar's line style type button
  toolbarAnnotationsLineStyle: "Line Style",
  // Text for the annotation toolbar's line stroke width button
  toolbarAnnotationsLineStrokeWidth: "Line Stroke Width",
  // Text for the annotation toolbar's settings annotation button
  toolbarAnnotationsSettings: "Settings",
  // Text for the annotation toolbar's text color picker annotation button
  toolbarAnnotationsTextColor: "Text Color",
  // Text for the annotation toolbar's text size picker annotation button
  toolbarAnnotationsTextSize: "Text Size",
  // Text for the annotation toolbar's lock annotation button
  toolbarAnnotationsLock: "Lock",
  // Text for the annotation toolbar's unlock annotation button
  toolbarAnnotationsUnlock: "Unlock",
  // Text for the annotation toolbar's delete annotation button
  toolbarAnnotationsDelete: "Delete",
  // Text for the annotation toolbar's drag handle
  toolbarAnnotationsDragHandle: "Drag Toolbar",
  // Text for the annotation toolbar's line drawings menu button
  toolbarAnnotationsLineAnnotations: "Trend Lines",
  // Text for the annotation toolbar's Fibonacci drawings menu button
  toolbarAnnotationsFibonacciAnnotations: "Fibonacci",
  // Text for the annotation toolbar's text annotations menu button
  toolbarAnnotationsTextAnnotations: "Text Annotations",
  // Text for the annotation toolbar's shapes menu button
  toolbarAnnotationsShapeAnnotations: "Arrows",
  // Text for the annotation toolbar's measurers menu button
  toolbarAnnotationsMeasurerAnnotations: "Measurers",
  // Text for the annotation toolbar's callout button
  toolbarAnnotationsCallout: "Callout",
  // Text for the annotation toolbar's comment button
  toolbarAnnotationsComment: "Comment",
  // Text for the annotation toolbar's note button
  toolbarAnnotationsNote: "Note",
  // Text for the annotation toolbar's text button
  toolbarAnnotationsText: "Text",
  // Text for the annotation toolbar's arrow button
  toolbarAnnotationsArrow: "Arrow",
  // Text for the annotation toolbar's arrow up button
  toolbarAnnotationsArrowUp: "Arrow Up",
  // Text for the annotation toolbar's arrow down button
  toolbarAnnotationsArrowDown: "Arrow Down",
  // Text for the annotation toolbar's date range button
  toolbarAnnotationsDateRange: "Date Range",
  // Text for the annotation toolbar's price range button
  toolbarAnnotationsPriceRange: "Price Range",
  // Text for the annotation toolbar's date and price range button
  toolbarAnnotationsDatePriceRange: "Date and Price",
  // Text for the annotation toolbar's quick date and price range button
  toolbarAnnotationsQuickDatePriceRange: "Measure",
  // Text for the range toolbar's 1 month button
  toolbarRange1Month: "1M",
  // Aria label for the range toolbar's 1 month button
  toolbarRange1MonthAria: "1 month",
  // Text for the range toolbar's 3 month button
  toolbarRange3Months: "3M",
  // Aria label for the range toolbar's 3 month button
  toolbarRange3MonthsAria: "3 months",
  // Text for the range toolbar's 6 month button
  toolbarRange6Months: "6M",
  // Aria label for the range toolbar's 6 month button
  toolbarRange6MonthsAria: "6 months",
  // Text for the range toolbar's year to date button
  toolbarRangeYearToDate: "YTD",
  // Aria label for the range toolbar's year to date month button
  toolbarRangeYearToDateAria: "Year to date",
  // Text for the range toolbar's 1 year button
  toolbarRange1Year: "1Y",
  // Aria label for the range toolbar's 1 year button
  toolbarRange1YearAria: "1 year",
  // Text for the range toolbar's full range button
  toolbarRangeAll: "All",
  // Aria label for the range toolbar's full range button
  toolbarRangeAllAria: "All",
  // Text for the zoom toolbar's zoom out button
  toolbarZoomZoomOut: "Zoom out",
  // Text for the zoom toolbar's zoom in button
  toolbarZoomZoomIn: "Zoom in",
  // Text for the zoom toolbar's pan left button
  toolbarZoomPanLeft: "Pan left",
  // Text for the zoom toolbar's pan right button
  toolbarZoomPanRight: "Pan right",
  // Text for the zoom toolbar's pan to the start button
  toolbarZoomPanStart: "Pan to the start",
  // Text for the zoom toolbar's pan to the end button
  toolbarZoomPanEnd: "Pan to the end",
  // Text for the zoom toolbar's pan reset button
  toolbarZoomReset: "Reset the zoom",
  // Text for the context menu's download button
  contextMenuDownload: "Download",
  // Text for the context menu's toggle series visibility button
  contextMenuToggleSeriesVisibility: "Toggle Visibility",
  // Text for the context menu's toggle other series visibility button
  contextMenuToggleOtherSeries: "Toggle Other Series",
  // Text for the context menu's zoom to point button
  contextMenuZoomToCursor: "Zoom to here",
  // Text for the context menu's pan to point button
  contextMenuPanToCursor: "Pan to here",
  // Text for the annotation dialog's header channel tab label
  dialogHeaderChannel: "Channel",
  // Text for the annotation dialog's header line tab label
  dialogHeaderLine: "Line",
  // Text for the annotation dialog's header fibonacci retracement line tab label
  dialogHeaderFibonacciRange: "Fib Retracement",
  // Text for the annotation dialog's header date range tab label
  dialogHeaderDateRange: "Date Range",
  // Text for the annotation dialog's header price range tab label
  dialogHeaderPriceRange: "Price Range",
  // Text for the annotation dialog's header date and price range tab label
  dialogHeaderDatePriceRange: "Date and Price",
  // Text for the annotation dialog's header text tab label
  dialogHeaderText: "Text",
  // Text for the annotation dialog's text alignment radio label
  dialogInputAlign: "Align",
  // Text for the annotation dialog's color picker label
  dialogInputColorPicker: "Color",
  // Text for the annotation dialog's color picker alt text
  dialogInputColorPickerAltText: "Text Color",
  // Text for the annotation dialog's fill color picker label
  dialogInputFillColorPicker: "Fill",
  // Text for the annotation dialog's fill color picker alt text
  dialogInputFillColorPickerAltText: "Fill Color",
  // Text for the annotation dialog's extend channel start checkbox
  dialogInputExtendChannelStart: "Extend channel start",
  // Text for the annotation dialog's extend channel end checkbox
  dialogInputExtendChannelEnd: "Extend channel end",
  // Text for the annotation dialog's extend line start checkbox
  dialogInputExtendLineStart: "Extend line start",
  // Text for the annotation dialog's extend line end checkbox
  dialogInputExtendLineEnd: "Extend line end",
  // Text for the annotation dialog's extend above checkbox
  dialogInputExtendAbove: "Extend above",
  // Text for the annotation dialog's extend below checkbox
  dialogInputExtendBelow: "Extend below",
  // Text for the annotation dialog's extend left checkbox
  dialogInputExtendLeft: "Extend left",
  // Text for the annotation dialog's extend right checkbox
  dialogInputExtendRight: "Extend right",
  // Text for the annotation dialog's reverse checkbox
  dialogInputReverse: "Reverse",
  // Text for the annotation dialog's show fill checkbox
  dialogInputShowFill: "Show Fill",
  // Text for the annotation dialog's font size select box label
  dialogInputFontSize: "Size",
  // Text for the annotation dialog's font size select box alt text
  dialogInputFontSizeAltText: "Font Size",
  // Text for the annotation dialog's line style radio label
  dialogInputLineStyle: "Dash",
  // Text for the annotation dialog's text position radio label
  dialogInputPosition: "Position",
  // Text for the annotation dialog's stroke width label
  dialogInputStrokeWidth: "Weight",
  // Text for the annotation dialog's stroke width label
  dialogInputStrokeWidthAltText: "Line Weight",
  // Text for the annotation dialog's Fibonacci bands label
  dialogInputFibonacciBands: "Bands",
  // Text for the annotation dialog's Fibonacci bands label
  dialogInputFibonacciBandsAltText: "Fibonacci Bands",
  // Text for text area input placeholders
  inputTextareaPlaceholder: "Add Text",
  // Text for the measurer statistics date range bars value
  measurerDateRangeBars: "${value}[number] bars",
  // Text for the measurer statistics price range value
  measurerPriceRangeValue: "${value}[number]",
  // Text for the measurer statistics price range percentage
  measurerPriceRangePercent: "${value}[percent]",
  // Text for the measurer statistics volume value
  measurerVolume: "Vol ${value}",
  // Status when multiple data are under the cursor, and the user can click to cycle through which one appears in the tooltip
  tooltipPaginationStatus: "${index}[number] of ${count}[number]"
};

// packages/ag-charts-community/src/locale/defaultMessageFormatter.ts
var import_ag_charts_core81 = require("ag-charts-core");
var messageRegExp = /\$\{(\w+)}(?:\[(\w+)])?/gi;
var formatters = {
  number: new Intl.NumberFormat("en-US"),
  percent: new Intl.NumberFormat("en-US", { style: "percent", minimumFractionDigits: 2, maximumFractionDigits: 2 }),
  percent0to2dp: new Intl.NumberFormat("en-US", {
    style: "percent",
    minimumFractionDigits: 0,
    maximumFractionDigits: 2
  }),
  date: new Intl.DateTimeFormat("en-US", { dateStyle: "full" }),
  time: new Intl.DateTimeFormat("en-US", { timeStyle: "full" }),
  datetime: new Intl.DateTimeFormat("en-US", { dateStyle: "full", timeStyle: "full" })
};
var defaultMessageFormatter = ({ defaultValue, variables }) => {
  return defaultValue?.replaceAll(messageRegExp, (_, match, format) => {
    const value = variables[match];
    const formatter = format != null ? formatters[format] : null;
    if (format != null && formatter == null) {
      import_ag_charts_core81.Logger.warnOnce(`Format style [${format}] is not supported`);
    }
    if (formatter != null) {
      return formatter.format(value);
    } else if (typeof value === "number") {
      return formatters.number.format(value);
    } else if (value instanceof Date) {
      return formatters.datetime.format(value);
    }
    return String(value);
  });
};

// packages/ag-charts-community/src/locale/localeManager.ts
var LocaleManager = class extends Listeners {
  constructor() {
    super(...arguments);
    this.localeText = void 0;
    this.getLocaleText = void 0;
  }
  setLocaleText(localeText) {
    if (this.localeText !== localeText) {
      this.localeText = localeText;
      this.dispatch("locale-changed");
    }
  }
  setLocaleTextFormatter(getLocaleText) {
    this.getLocaleText = getLocaleText;
    if (this.getLocaleText !== getLocaleText) {
      this.getLocaleText = getLocaleText;
      this.dispatch("locale-changed");
    }
  }
  t(key, variables = {}) {
    const { localeText = AG_CHARTS_LOCALE_EN_US, getLocaleText } = this;
    const defaultValue = localeText[key];
    return getLocaleText?.({ key, defaultValue, variables }) ?? defaultMessageFormatter({ key, defaultValue, variables }) ?? key;
  }
};

// packages/ag-charts-community/src/scene/scene.ts
var import_ag_charts_core85 = require("ag-charts-core");

// packages/ag-charts-community/src/scene/canvas/hdpiCanvas.ts
var import_ag_charts_core82 = require("ag-charts-core");
var HdpiCanvas = class {
  constructor(options) {
    this.enabled = true;
    this.width = 600;
    this.height = 300;
    const { width: width2, height: height2, canvasElement, willReadFrequently = false } = options;
    this.pixelRatio = options.pixelRatio ?? (0, import_ag_charts_core82.getWindow)("devicePixelRatio") ?? 1;
    this.element = canvasElement ?? (0, import_ag_charts_core82.createElement)("canvas");
    this.element.style.display = "block";
    this.element.style.width = (width2 ?? this.width) + "px";
    this.element.style.height = (height2 ?? this.height) + "px";
    this.element.width = Math.round((width2 ?? this.width) * this.pixelRatio);
    this.element.height = Math.round((height2 ?? this.height) * this.pixelRatio);
    this.context = this.element.getContext("2d", { willReadFrequently });
    this.onEnabledChange();
    this.resize(width2 ?? 0, height2 ?? 0, this.pixelRatio);
    debugContext(this.context);
  }
  drawImage(context, dx = 0, dy = 0) {
    return context.drawImage(this.context.canvas, dx, dy);
  }
  toDataURL(type) {
    return this.element.toDataURL(type);
  }
  resize(width2, height2, pixelRatio) {
    if (!(width2 > 0 && height2 > 0))
      return;
    const { element: element2, context } = this;
    element2.width = Math.round(width2 * pixelRatio);
    element2.height = Math.round(height2 * pixelRatio);
    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    element2.style.width = width2 + "px";
    element2.style.height = height2 + "px";
    this.width = width2;
    this.height = height2;
    this.pixelRatio = pixelRatio;
  }
  clear() {
    clearContext(this);
  }
  destroy() {
    this.element.remove();
    this.element.width = 0;
    this.element.height = 0;
    this.context.clearRect(0, 0, 0, 0);
    Object.freeze(this);
  }
  reset() {
    this.context.resetTransform();
  }
  onEnabledChange() {
    if (this.element) {
      this.element.style.display = this.enabled ? "" : "none";
    }
  }
};
__decorateClass([
  ObserveChanges((target) => target.onEnabledChange())
], HdpiCanvas.prototype, "enabled", 2);

// packages/ag-charts-community/src/scene/image/imageLoader.ts
var import_ag_charts_core83 = require("ag-charts-core");
var ImageLoader = class extends import_ag_charts_core83.EventEmitter {
  constructor() {
    super(...arguments);
    this.cache = /* @__PURE__ */ new Map();
    this.imageLoadingCount = 0;
  }
  loadImage(uri, node) {
    const entry = this.cache.get(uri);
    if (entry?.image) {
      return entry.image;
    } else if (entry != null && node) {
      entry.nodes.add(node);
      return;
    }
    if (!node) {
      return;
    }
    const nextEntry = { image: void 0, nodes: /* @__PURE__ */ new Set([node]) };
    const image = new Image();
    this.imageLoadingCount++;
    image.onload = () => {
      nextEntry.image = image;
      nextEntry.nodes.forEach((n) => n.markDirty());
      nextEntry.nodes.clear();
      this.imageLoadingCount--;
      this.emit("image-loaded", { uri });
    };
    image.onerror = () => {
      this.imageLoadingCount--;
      nextEntry.nodes.clear();
      this.emit("image-error", { uri });
    };
    image.src = uri;
    this.cache.set(uri, nextEntry);
    return nextEntry.image;
  }
  waitingToLoad() {
    return this.imageLoadingCount > 0;
  }
  destroy() {
    this.cache.forEach((entry) => {
      entry.nodes.clear();
    });
    this.cache.clear();
  }
};

// packages/ag-charts-community/src/scene/layersManager.ts
var LayersManager = class {
  constructor(canvas) {
    this.canvas = canvas;
    this.debug = Debug.create(true, "scene");
    this.layersMap = /* @__PURE__ */ new Map();
    this.nextLayerId = 0;
  }
  get size() {
    return this.layersMap.size;
  }
  resize(width2, height2, pixelRatio) {
    this.canvas.resize(width2, height2, pixelRatio);
    this.layersMap.forEach(({ canvas }) => canvas.resize(width2, height2, pixelRatio));
  }
  addLayer(opts) {
    const { width: width2, height: height2, pixelRatio } = this.canvas;
    const { name } = opts;
    const canvas = new HdpiOffscreenCanvas({ width: width2, height: height2, pixelRatio });
    this.layersMap.set(canvas, {
      id: this.nextLayerId++,
      name,
      canvas
    });
    this.debug("Scene.addLayer() - layers", this.layersMap);
    return canvas;
  }
  removeLayer(canvas) {
    if (this.layersMap.has(canvas)) {
      this.layersMap.delete(canvas);
      canvas.destroy();
      this.debug("Scene.removeLayer() -  layers", this.layersMap);
    }
  }
  clear() {
    for (const layer of this.layersMap.values()) {
      layer.canvas.destroy();
    }
    this.layersMap.clear();
  }
};

// packages/ag-charts-community/src/scene/sceneDebug.ts
var import_ag_charts_core84 = require("ag-charts-core");
function formatBytes(value) {
  for (const unit of ["B", "KB", "MB", "GB"]) {
    if (value < 1536) {
      return `${value.toFixed(1)}${unit}`;
    }
    value /= 1024;
  }
  return `${value.toFixed(1)}TB}`;
}
function memoryUsage() {
  if (!("memory" in performance))
    return;
  const { totalJSHeapSize, usedJSHeapSize, jsHeapSizeLimit } = performance.memory;
  const result = [];
  for (const amount of [usedJSHeapSize, totalJSHeapSize, jsHeapSizeLimit]) {
    if (typeof amount !== "number")
      continue;
    result.push(formatBytes(amount));
  }
  return `Heap ${result.join(" / ")}`;
}
function debugStats(layersManager, debugSplitTimes, ctx, renderCtxStats, extraDebugStats = {}, seriesRect = BBox.zero) {
  if (!Debug.check("scene:stats" /* SCENE_STATS */, "scene:stats:verbose" /* SCENE_STATS_VERBOSE */))
    return;
  const {
    layersRendered = 0,
    layersSkipped = 0,
    nodesRendered = 0,
    nodesSkipped = 0,
    opsPerformed = 0,
    opsSkipped = 0
  } = renderCtxStats ?? {};
  const end2 = performance.now();
  const { start: start2, ...durations } = debugSplitTimes;
  const splits = Object.entries(durations).map(([n, t]) => {
    return time(n, t);
  }).filter((v) => v != null).join(" + ");
  const extras = Object.entries(extraDebugStats).map(([k, v]) => `${k}: ${JSON.stringify(v)}`).join(" ; ");
  const detailedStats = Debug.check("scene:stats:verbose" /* SCENE_STATS_VERBOSE */);
  const memUsage = memoryUsage();
  const stats = [
    `${time("\u23F1\uFE0F", start2, end2)} (${splits})`,
    `${extras}`,
    `Layers: ${detailedStats ? pct(layersRendered, layersSkipped) : layersManager.size}`,
    detailedStats ? `Nodes: ${pct(nodesRendered, nodesSkipped)}` : null,
    detailedStats ? `Ops: ${pct(opsPerformed, opsSkipped)}` : null,
    detailedStats && memUsage ? memUsage : null
  ].filter(import_ag_charts_core84.isString);
  const measurer2 = new SimpleTextMeasurer((t) => ctx.measureText(t));
  const statsSize = new Map(stats.map((t) => [t, measurer2.measureLines(t)]));
  const width2 = Math.max(...Array.from(statsSize.values(), (s) => s.width));
  const height2 = accumulate(statsSize.values(), (s) => s.height);
  const x = 2 + seriesRect.x;
  ctx.save();
  ctx.fillStyle = "white";
  ctx.fillRect(x, 0, width2, height2);
  ctx.fillStyle = "black";
  let y = 0;
  for (const [stat, size] of statsSize.entries()) {
    y += size.height;
    ctx.fillText(stat, x, y);
  }
  ctx.restore();
}
function prepareSceneNodeHighlight(ctx) {
  const config = (0, import_ag_charts_core84.toArray)((0, import_ag_charts_core84.getWindow)("agChartsSceneDebug"));
  const result = [];
  for (const name of config) {
    if (name === "layout") {
      result.push("seriesRoot", "legend", "root", /.*Axis-\d+-axis.*/);
    } else {
      result.push(name);
    }
  }
  ctx.debugNodeSearch = result;
}
function debugSceneNodeHighlight(ctx, debugNodes) {
  ctx.save();
  for (const [name, node] of Object.entries(debugNodes)) {
    const bbox = Transformable.toCanvas(node);
    if (!bbox) {
      import_ag_charts_core84.Logger.log(`Scene.render() - no bbox for debugged node [${name}].`);
      continue;
    }
    ctx.globalAlpha = 0.8;
    ctx.strokeStyle = "red";
    ctx.lineWidth = 1;
    ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);
    ctx.fillStyle = "red";
    ctx.strokeStyle = "white";
    ctx.font = "16px sans-serif";
    ctx.textBaseline = "top";
    ctx.textAlign = "left";
    ctx.lineWidth = 2;
    ctx.strokeText(name, bbox.x, bbox.y, bbox.width);
    ctx.fillText(name, bbox.x, bbox.y, bbox.width);
  }
  ctx.restore();
}
var skippedProperties = /* @__PURE__ */ new Set();
var allowedProperties = /* @__PURE__ */ new Set([
  "gradient",
  // '_datum',
  "zIndex",
  "clipRect",
  "cachedBBox",
  "childNodeCounts",
  "path",
  "__zIndex",
  "name",
  "__scalingCenterX",
  "__scalingCenterY",
  "__rotationCenterX",
  "__rotationCenterY",
  "_previousDatum",
  "__fill",
  "__lineDash",
  "borderPath",
  "borderClipPath",
  "_clipPath"
]);
function nodeProps(node) {
  const { ...allProps } = node;
  for (const prop of Object.keys(allProps)) {
    if (allowedProperties.has(prop))
      continue;
    if (typeof allProps[prop] === "number")
      continue;
    if (typeof allProps[prop] === "string")
      continue;
    if (typeof allProps[prop] === "boolean")
      continue;
    skippedProperties.add(prop);
    delete allProps[prop];
  }
  return allProps;
}
function buildTree(node, mode) {
  if (!Debug.check(true, "scene" /* SCENE */)) {
    return {};
  }
  let order = 0;
  return {
    node: mode === "json" ? nodeProps(node) : node,
    name: node.name ?? node.id,
    dirty: node.dirty,
    ...Array.from(node.children(), (c) => buildTree(c, mode)).reduce(
      (result, childTree) => {
        let { name: treeNodeName } = childTree;
        const {
          node: { visible, opacity, zIndex, translationX, translationY, rotation, scalingX, scalingY },
          node: childNode
        } = childTree;
        if (!visible || opacity <= 0) {
          treeNodeName = `(${treeNodeName})`;
        }
        if (Group.is(childNode) && childNode.renderToOffscreenCanvas) {
          treeNodeName = `*${treeNodeName}*`;
        }
        const zIndexString = Array.isArray(zIndex) ? `(${zIndex.join(", ")})` : zIndex;
        const key = [
          `${(order++).toString().padStart(3, "0")}|`,
          `${treeNodeName ?? "<unknown>"}`,
          `z: ${zIndexString}`,
          translationX && `x: ${translationX}`,
          translationY && `y: ${translationY}`,
          rotation && `r: ${rotation}`,
          scalingX != null && scalingX !== 1 && `sx: ${scalingX}`,
          scalingY != null && scalingY !== 1 && `sy: ${scalingY}`
        ].filter((v) => !!v).join(" ");
        let selectedKey = key;
        let index = 1;
        while (result[selectedKey] != null && index < 100) {
          selectedKey = `${key} (${index++})`;
        }
        result[selectedKey] = childTree;
        return result;
      },
      {}
    )
  };
}
function buildDirtyTree(node) {
  if (!node.dirty) {
    return { dirtyTree: {}, paths: [] };
  }
  const childrenDirtyTree = Array.from(node.children(), (c) => buildDirtyTree(c)).filter((c) => c.paths.length > 0);
  const name = Group.is(node) ? node.name ?? node.id : node.id;
  const paths = childrenDirtyTree.length ? childrenDirtyTree.flatMap((c) => c.paths).map((p) => `${name}.${p}`) : [name];
  return {
    dirtyTree: {
      name,
      node,
      dirty: node.dirty,
      ...childrenDirtyTree.map((c) => c.dirtyTree).filter((t) => t.dirty != null).reduce((result, childTree) => {
        result[childTree.name ?? "<unknown>"] = childTree;
        return result;
      }, {})
    },
    paths
  };
}
function pct(rendered, skipped) {
  const total = rendered + skipped;
  return `${rendered} / ${total} (${Math.round(100 * rendered / total)}%)`;
}
function time(name, start2, end2) {
  const duration = end2 != null ? end2 - start2 : start2;
  return `${name}: ${Math.round(duration * 100) / 100}ms`;
}
function accumulate(iterator, mapper) {
  let sum = 0;
  for (const item of iterator) {
    sum += mapper(item);
  }
  return sum;
}

// packages/ag-charts-community/src/scene/scene.ts
var Scene = class extends import_ag_charts_core85.EventEmitter {
  constructor(canvasOptions) {
    super();
    this.debug = Debug.create(true, "scene" /* SCENE */);
    this.id = (0, import_ag_charts_core85.createId)(this);
    this.imageLoader = new ImageLoader();
    this.root = null;
    this.pendingSize = null;
    this.isDirty = false;
    this.destroyFns = [];
    this.updateDebugFlags();
    this.canvas = new HdpiCanvas(canvasOptions);
    this.layersManager = new LayersManager(this.canvas);
    this.destroyFns.push(
      this.imageLoader.on("image-loaded", () => {
        this.emit("scene-changed", {});
      }),
      this.imageLoader.on("image-error", ({ uri }) => {
        import_ag_charts_core85.Logger.warnOnce(`Unable to load image ${uri}`);
      })
    );
  }
  waitingForUpdate() {
    return this.imageLoader?.waitingToLoad() ?? false;
  }
  get width() {
    return this.pendingSize?.[0] ?? this.canvas.width;
  }
  get height() {
    return this.pendingSize?.[1] ?? this.canvas.height;
  }
  get pixelRatio() {
    return this.pendingSize?.[2] ?? this.canvas.pixelRatio;
  }
  /** @deprecated v10.2.0 Only used by AG Grid Sparklines */
  setContainer(value) {
    const { element: element2 } = this.canvas;
    element2.parentElement?.removeChild(element2);
    value.appendChild(element2);
    return this;
  }
  setRoot(node) {
    if (this.root === node) {
      return this;
    }
    this.isDirty = true;
    this.root?.setScene();
    this.root = node;
    if (node) {
      node.visible = true;
      node.setScene(this);
    }
    return this;
  }
  updateDebugFlags() {
    Debug.inDevelopmentMode(() => Node2._debugEnabled = true);
  }
  clearCanvas() {
    this.canvas.clear();
  }
  attachNode(node) {
    this.appendChild(node);
    return () => this.removeChild(node);
  }
  appendChild(node) {
    this.root?.appendChild(node);
    return this;
  }
  removeChild(node) {
    this.root?.removeChild(node);
    return this;
  }
  download(fileName, fileFormat) {
    (0, import_ag_charts_core85.downloadUrl)(this.canvas.toDataURL(fileFormat), fileName?.trim() ?? "image");
  }
  /** NOTE: Integrated Charts undocumented image download method. */
  getDataURL(fileFormat) {
    return this.canvas.toDataURL(fileFormat);
  }
  resize(width2, height2, pixelRatio) {
    width2 = Math.round(width2);
    height2 = Math.round(height2);
    pixelRatio ?? (pixelRatio = this.pixelRatio);
    if (width2 > 0 && height2 > 0 && (width2 !== this.width || height2 !== this.height || pixelRatio !== this.pixelRatio)) {
      this.pendingSize = [width2, height2, pixelRatio];
      this.isDirty = true;
      return true;
    }
    return false;
  }
  render(opts) {
    const { debugSplitTimes = { start: performance.now() }, extraDebugStats, seriesRect } = opts ?? {};
    const {
      canvas,
      canvas: { context: ctx } = {},
      root,
      pendingSize,
      width: width2,
      height: height2,
      pixelRatio: devicePixelRatio
    } = this;
    if (!ctx) {
      return;
    }
    const renderStartTime = performance.now();
    let resized = false;
    if (pendingSize) {
      resized = true;
      this.layersManager.resize(...pendingSize);
      this.pendingSize = null;
    }
    if (root && !root.visible) {
      this.isDirty = false;
      return;
    }
    if (root?.dirty === false && !this.isDirty) {
      if (this.debug.check()) {
        this.debug("Scene.render() - no-op", {
          tree: buildTree(root, "console")
        });
      }
      debugStats(this.layersManager, debugSplitTimes, ctx, void 0, extraDebugStats, seriesRect);
      return;
    }
    const renderCtx = {
      ctx,
      width: width2,
      height: height2,
      devicePixelRatio,
      debugNodes: {}
    };
    if (Debug.check("scene:stats:verbose" /* SCENE_STATS_VERBOSE */)) {
      renderCtx.stats = {
        layersRendered: 0,
        layersSkipped: 0,
        nodesRendered: 0,
        nodesSkipped: 0,
        opsPerformed: 0,
        opsSkipped: 0
      };
    }
    prepareSceneNodeHighlight(renderCtx);
    let canvasCleared = false;
    if (root?.dirty !== false || resized) {
      canvasCleared = true;
      canvas.clear();
    }
    if (root && Debug.check("scene:dirtyTree" /* SCENE_DIRTY_TREE */)) {
      const { dirtyTree, paths } = buildDirtyTree(root);
      Debug.create("scene:dirtyTree" /* SCENE_DIRTY_TREE */)("Scene.render() - dirtyTree", { dirtyTree, paths });
    }
    if (root && canvasCleared) {
      if (root.visible) {
        root.preRender(renderCtx);
      }
      if (this.debug.check()) {
        const tree = buildTree(root, "console");
        this.debug("Scene.render() - before", {
          canvasCleared,
          tree
        });
      }
      if (root.visible) {
        try {
          ctx.save();
          root.render(renderCtx);
          ctx.restore();
        } catch (e) {
          this.canvas.reset();
          throw e;
        }
      }
    }
    debugSplitTimes["\u270D\uFE0F"] = performance.now() - renderStartTime;
    ctx.verifyDepthZero?.();
    this.isDirty = false;
    debugStats(this.layersManager, debugSplitTimes, ctx, renderCtx.stats, extraDebugStats, seriesRect);
    debugSceneNodeHighlight(ctx, renderCtx.debugNodes);
    if (root && this.debug.check()) {
      this.debug("Scene.render() - after", {
        tree: buildTree(root, "console"),
        canvasCleared
      });
    }
  }
  toSVG() {
    const { root, width: width2, height: height2 } = this;
    if (root == null)
      return;
    return Node2.toSVG(root, width2, height2);
  }
  /** Alternative to destroy() that preserves re-usable resources. */
  strip() {
    const { context, pixelRatio } = this.canvas;
    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    this.layersManager.clear();
    this.setRoot(null);
    this.isDirty = false;
    this.clear();
  }
  destroy() {
    this.strip();
    this.canvas.destroy();
    this.imageLoader.destroy();
    this.destroyFns.forEach((fn) => fn());
    Object.assign(this, { canvas: void 0 });
  }
};
Scene.className = "Scene";

// packages/ag-charts-community/src/util/callbackCache.ts
var import_ag_charts_core86 = require("ag-charts-core");
function needsContext(caller, _params) {
  return "context" in caller;
}
function maybeSetContext(caller, params) {
  if (needsContext(caller, params)) {
    if (params[0] != null && typeof params[0] === "object") {
      params[0].context = caller.context;
      return true;
    }
  }
  return false;
}
function callWithContext(caller1, caller2, fn, params) {
  if (!maybeSetContext(caller1, params)) {
    if (caller2) {
      maybeSetContext(caller2, params);
    }
  }
  return fn(...params);
}
var CallbackCache = class {
  constructor() {
    this.cache = /* @__PURE__ */ new WeakMap();
  }
  call(caller1, caller2, fn, ...params) {
    let serialisedParams;
    let paramCache = this.cache.get(fn);
    try {
      serialisedParams = JSON.stringify(params);
    } catch {
      return this.invoke(caller1, caller2, fn, params, paramCache);
    }
    if (paramCache == null) {
      paramCache = /* @__PURE__ */ new Map();
      this.cache.set(fn, paramCache);
    }
    if (!paramCache.has(serialisedParams)) {
      return this.invoke(caller1, caller2, fn, params, paramCache, serialisedParams);
    }
    return paramCache.get(serialisedParams);
  }
  invoke(caller1, caller2, fn, params, paramCache, serialisedParams) {
    try {
      const result = callWithContext(caller1, caller2, fn, params);
      if (paramCache && serialisedParams != null) {
        paramCache.set(serialisedParams, result);
      }
      return result;
    } catch (e) {
      import_ag_charts_core86.Logger.warnOnce(`User callback errored, ignoring`, e);
      return;
    }
  }
  invalidateCache() {
    this.cache = /* @__PURE__ */ new WeakMap();
  }
};

// packages/ag-charts-community/src/chart/annotation/annotationManager.ts
var import_ag_charts_core87 = require("ag-charts-core");
var AnnotationManager = class extends BaseManager {
  constructor(annotationRoot, fireChartEvent) {
    super();
    this.annotationRoot = annotationRoot;
    this.fireChartEvent = fireChartEvent;
    this.mementoOriginatorKey = "annotations";
    this.annotations = [];
  }
  createMemento() {
    return this.annotations;
  }
  guardMemento(blob) {
    return blob == null || (0, import_ag_charts_core87.isArray)(blob);
  }
  restoreMemento(_version, _mementoVersion, memento) {
    this.annotations = this.cleanData(memento ?? []).map((annotation) => {
      const annotationTheme = this.getAnnotationTypeStyles(annotation.type);
      return mergeDefaults(annotation, annotationTheme);
    });
    this.listeners.dispatch("restore-annotations", {
      type: "restore-annotations",
      annotations: this.annotations
    });
  }
  updateData(annotations) {
    this.annotations = this.cleanData(annotations ?? []);
  }
  fireChangedEvent() {
    this.fireChartEvent({ type: "annotations", annotations: deepClone([...this.annotations]) });
  }
  attachNode(node) {
    this.annotationRoot.append(node);
    return () => {
      this.annotationRoot?.removeChild(node);
      return this;
    };
  }
  setAnnotationStyles(styles) {
    this.styles = styles;
  }
  getAnnotationTypeStyles(type) {
    return this.styles?.[type];
  }
  cleanData(annotations) {
    for (const annotation of annotations) {
      if ("textAlign" in annotation)
        delete annotation.textAlign;
    }
    return annotations;
  }
};

// packages/ag-charts-community/src/chart/axis/axisManager.ts
var AxisManager = class {
  constructor(sceneRoot) {
    this.sceneRoot = sceneRoot;
    this.axes = /* @__PURE__ */ new Map();
    this.axisGridGroup = new Group({ name: "Axes-Grids", zIndex: 1 /* AXIS_GRID */ });
    this.axisGroup = new Group({ name: "Axes", zIndex: 2 /* AXIS */ });
    this.axisLabelGroup = new Group({ name: "Axes-Labels", zIndex: 13 /* SERIES_LABEL */ });
    this.axisCrosslineRangeGroup = new Group({
      name: "Axes-Crosslines-Range",
      zIndex: 4 /* SERIES_CROSSLINE_RANGE */
    });
    this.axisCrosslineLineGroup = new Group({
      name: "Axes-Crosslines-Line",
      zIndex: 8 /* SERIES_CROSSLINE_LINE */
    });
    this.axisCrosslineLabelGroup = new Group({
      name: "Axes-Crosslines-Label",
      zIndex: 13 /* SERIES_LABEL */
    });
    this.sceneRoot.appendChild(this.axisGroup);
    this.sceneRoot.appendChild(this.axisGridGroup);
    this.sceneRoot.appendChild(this.axisLabelGroup);
    this.sceneRoot.appendChild(this.axisCrosslineRangeGroup);
    this.sceneRoot.appendChild(this.axisCrosslineLineGroup);
    this.sceneRoot.appendChild(this.axisCrosslineLabelGroup);
  }
  updateAxes(oldAxes, newAxes) {
    const axisNodes = {
      axisNode: this.axisGroup,
      gridNode: this.axisGridGroup,
      labelNode: this.axisLabelGroup,
      crossLineRangeNode: this.axisCrosslineRangeGroup,
      crossLineLineNode: this.axisCrosslineLineGroup,
      crossLineLabelNode: this.axisCrosslineLabelGroup
    };
    for (const axis of oldAxes) {
      if (newAxes.includes(axis))
        continue;
      axis.detachAxis(axisNodes);
      axis.destroy();
    }
    for (const axis of newAxes) {
      if (oldAxes?.includes(axis))
        continue;
      axis.attachAxis(axisNodes);
    }
    this.axes.clear();
    for (const axis of newAxes) {
      const ctx = axis.createAxisContext();
      if (this.axes.has(ctx.direction)) {
        this.axes.get(ctx.direction)?.push(ctx);
      } else {
        this.axes.set(ctx.direction, [ctx]);
      }
    }
  }
  getAxisContext(direction) {
    return this.axes.get(direction) ?? [];
  }
  destroy() {
    this.axes.clear();
    this.sceneRoot.removeChild(this.axisGroup);
    this.sceneRoot.removeChild(this.axisGridGroup);
  }
};

// packages/ag-charts-community/src/chart/chartUpdateType.ts
var ChartUpdateType = /* @__PURE__ */ ((ChartUpdateType2) => {
  ChartUpdateType2[ChartUpdateType2["FULL"] = 0] = "FULL";
  ChartUpdateType2[ChartUpdateType2["UPDATE_DATA"] = 1] = "UPDATE_DATA";
  ChartUpdateType2[ChartUpdateType2["PROCESS_DATA"] = 2] = "PROCESS_DATA";
  ChartUpdateType2[ChartUpdateType2["PROCESS_DOMAIN"] = 3] = "PROCESS_DOMAIN";
  ChartUpdateType2[ChartUpdateType2["PERFORM_LAYOUT"] = 4] = "PERFORM_LAYOUT";
  ChartUpdateType2[ChartUpdateType2["SERIES_UPDATE"] = 5] = "SERIES_UPDATE";
  ChartUpdateType2[ChartUpdateType2["PRE_SCENE_RENDER"] = 6] = "PRE_SCENE_RENDER";
  ChartUpdateType2[ChartUpdateType2["SCENE_RENDER"] = 7] = "SCENE_RENDER";
  ChartUpdateType2[ChartUpdateType2["NONE"] = 8] = "NONE";
  return ChartUpdateType2;
})(ChartUpdateType || {});

// packages/ag-charts-community/src/chart/data/dataService.ts
var import_ag_charts_core88 = require("ag-charts-core");
var DataService = class extends Listeners {
  constructor(animationManager) {
    super();
    this.animationManager = animationManager;
    this.dispatchOnlyLatest = true;
    this.dispatchThrottle = 0;
    this.requestThrottle = 300;
    this.isLoadingInitialData = false;
    this.isLoadingData = false;
    this.freshRequests = [];
    this.requestCounter = 0;
    this.debug = Debug.create(true, "data-model", "data-source");
    this.throttledFetch = this.createThrottledFetch(this.requestThrottle);
    this.throttledDispatch = this.createThrottledDispatch(this.dispatchThrottle);
  }
  updateCallback(dataSourceCallback) {
    if (typeof dataSourceCallback !== "function")
      return;
    this.debug("DataService - updated data source callback");
    this.dataSourceCallback = dataSourceCallback;
    this.isLoadingInitialData = true;
    this.animationManager.skip();
    this.dispatch("data-source-change");
  }
  clearCallback() {
    this.dataSourceCallback = void 0;
  }
  load(params) {
    this.isLoadingData = true;
    this.throttledFetch(params);
  }
  isLazy() {
    return this.dataSourceCallback != null;
  }
  isLoading() {
    return this.isLazy() && (this.isLoadingInitialData || this.isLoadingData);
  }
  createThrottledFetch(requestThrottle) {
    return (0, import_ag_charts_core88.throttle)(
      (params) => this.fetch(params).catch((e) => import_ag_charts_core88.Logger.error("callback failed", e)),
      requestThrottle,
      {
        leading: false,
        trailing: true
      }
    );
  }
  createThrottledDispatch(dispatchThrottle) {
    return (0, import_ag_charts_core88.throttle)(
      (id, data) => {
        this.debug(`DataService - dispatching 'data-load' | ${id}`);
        this.dispatch("data-load", { type: "data-load", data });
      },
      dispatchThrottle,
      {
        leading: true,
        trailing: true
      }
    );
  }
  async fetch(params) {
    if (!this.dataSourceCallback) {
      throw new Error("DataService - [dataSource.getData] callback not initialised");
    }
    const start2 = performance.now();
    const id = this.requestCounter++;
    this.debug(`DataService - requesting | ${id}`);
    this.freshRequests.push(id);
    let response;
    try {
      response = await this.dataSourceCallback(params);
      this.debug(`DataService - response | ${performance.now() - start2}ms | ${id}`);
    } catch (error) {
      this.debug(`DataService - request failed | ${id}`);
      import_ag_charts_core88.Logger.errorOnce(`DataService - request failed | [${error}]`);
    }
    this.isLoadingInitialData = false;
    const requestIndex = this.freshRequests.findIndex((rid) => rid === id);
    if (requestIndex === -1 || this.dispatchOnlyLatest && requestIndex !== this.freshRequests.length - 1) {
      this.debug(`DataService - discarding stale request | ${id}`);
      return;
    }
    this.freshRequests = this.freshRequests.slice(requestIndex + 1);
    if (this.freshRequests.length === 0) {
      this.isLoadingData = false;
    }
    if (Array.isArray(response)) {
      this.throttledDispatch(id, response);
    } else {
      this.dispatch("data-error");
    }
  }
};
__decorateClass([
  ActionOnSet({
    newValue(dispatchThrottle) {
      this.throttledDispatch = this.createThrottledDispatch(dispatchThrottle);
    }
  })
], DataService.prototype, "dispatchThrottle", 2);
__decorateClass([
  ActionOnSet({
    newValue(requestThrottle) {
      this.throttledFetch = this.createThrottledFetch(requestThrottle);
    }
  })
], DataService.prototype, "requestThrottle", 2);

// packages/ag-charts-community/src/chart/fonts/fontManager.ts
var FontManager = class {
  constructor(domManager, updateService) {
    this.domManager = domManager;
    this.updateService = updateService;
    this.observers = [];
  }
  updateFonts(fonts) {
    if (!fonts || fonts.size === 0)
      return;
    this.loadFonts(fonts);
    fonts.forEach((font2) => {
      this.observeFontStatus(font2);
    });
  }
  destroy() {
    for (const observer of this.observers) {
      observer.disconnect();
    }
    this.observers = [];
  }
  loadFonts(fonts) {
    const fontStrings = Array.from(fonts).map((font2) => encodeURIComponent(font2));
    const fontStyle = ":wght@100;200;300;400;500;600;700;800;900";
    const joinString = `${fontStyle}&family=`;
    const css = `@import url('https://fonts.googleapis.com/css2?family=${fontStrings.join(joinString)}${fontStyle}&display=swap');
`;
    this.domManager.addStyles(`google-font-${fontStrings.join("-")}`, css);
  }
  observeFontStatus(font2) {
    const fontCheckElement = window.document.createElement("div");
    fontCheckElement.style.setProperty("position", "absolute");
    fontCheckElement.style.setProperty("top", "0");
    fontCheckElement.style.setProperty("margin", "0");
    fontCheckElement.style.setProperty("padding", "0");
    fontCheckElement.style.setProperty("overflow", "hidden");
    fontCheckElement.style.setProperty("visibility", "hidden");
    fontCheckElement.style.setProperty("width", "auto");
    fontCheckElement.style.setProperty("max-width", "none");
    fontCheckElement.style.setProperty("font-synthesis", "none");
    fontCheckElement.style.setProperty("font-family", font2);
    fontCheckElement.style.setProperty("font-size", "16px");
    fontCheckElement.style.setProperty("white-space", "nowrap");
    fontCheckElement.textContent = "UVWxyz";
    this.domManager.addChild("canvas-container", `font-check-${encodeURIComponent(font2)}`, fontCheckElement);
    const fontCheckObserver = new ResizeObserver((entries7) => {
      const width2 = entries7?.at(0)?.contentBoxSize.at(0)?.inlineSize;
      if (width2 != null && width2 > 0) {
        CachedTextMeasurerPool.clear();
        this.updateService.update(4 /* PERFORM_LAYOUT */);
      }
    });
    fontCheckObserver.observe(fontCheckElement);
    this.observers.push(fontCheckObserver);
  }
};

// packages/ag-charts-community/src/chart/interaction/animationManager.ts
var import_ag_charts_core90 = require("ag-charts-core");

// packages/ag-charts-community/src/chart/interaction/animationBatch.ts
var import_ag_charts_core89 = require("ag-charts-core");
var AnimationBatch = class {
  constructor(maxAnimationTime) {
    this.maxAnimationTime = maxAnimationTime;
    this.debug = Debug.create(true, "animation");
    this.controllers = /* @__PURE__ */ new Map();
    this.stoppedCbs = /* @__PURE__ */ new Set();
    this.currentPhase = 0;
    this.phases = new Map(PHASE_ORDER.map((p) => [p, []]));
    this.skipAnimations = false;
    this.animationTimeConsumed = 0;
    /** Guard against premature animation execution. */
    this.isReady = false;
  }
  get size() {
    return this.controllers.size;
  }
  get consumedTimeMs() {
    return this.animationTimeConsumed;
  }
  isActive() {
    return this.controllers.size > 0;
  }
  getActiveControllers() {
    return this.phases.get(PHASE_ORDER[this.currentPhase]) ?? [];
  }
  checkOverlappingId(id) {
    if (id != null && this.controllers.has(id)) {
      this.controllers.get(id).stop();
      this.debug(`Skipping animation batch due to update of existing animation: ${id}`);
      this.skip();
    }
  }
  addAnimation(animation) {
    if (animation.isComplete)
      return;
    const animationPhaseIdx = PHASE_ORDER.indexOf(animation.phase);
    if (animationPhaseIdx < this.currentPhase) {
      this.debug(`Skipping animation due to being for an earlier phase`, animation.id);
      animation.stop();
      return;
    }
    this.controllers.set(animation.id, animation);
    this.phases.get(animation.phase)?.push(animation);
  }
  removeAnimation(animation) {
    this.controllers.delete(animation.id);
    const phase = this.phases.get(animation.phase);
    const index = phase?.indexOf(animation);
    if (index != null && index >= 0) {
      phase?.splice(index, 1);
    }
  }
  progress(deltaTime) {
    if (!this.isReady)
      return;
    let unusedTime = deltaTime === 0 ? 0.01 : deltaTime;
    const refresh = () => {
      const phase2 = PHASE_ORDER[this.currentPhase];
      return {
        phaseControllers: [...this.getActiveControllers()],
        phase: phase2,
        phaseMeta: PHASE_METADATA[phase2]
      };
    };
    let { phase, phaseControllers, phaseMeta } = refresh();
    const arePhasesComplete = () => PHASE_ORDER[this.currentPhase] == null;
    const progressPhase = () => {
      ({ phase, phaseControllers, phaseMeta } = refresh());
      while (!arePhasesComplete() && phaseControllers.length === 0) {
        this.currentPhase++;
        ({ phase, phaseControllers, phaseMeta } = refresh());
        this.debug(`AnimationBatch - phase changing to ${phase}`, { unusedTime }, phaseControllers);
      }
    };
    const total = this.controllers.size;
    this.debug(`AnimationBatch - ${deltaTime}ms; phase ${phase} with ${phaseControllers?.length} of ${total}`);
    do {
      const phaseDeltaTime = unusedTime;
      const skipPhase = phaseMeta.skipIfNoEarlierAnimations && this.animationTimeConsumed === 0;
      let completeCount = 0;
      for (const controller of phaseControllers) {
        if (skipPhase) {
          controller.stop();
        } else {
          unusedTime = Math.min(controller.update(phaseDeltaTime), unusedTime);
        }
        if (controller.isComplete) {
          completeCount++;
          this.removeAnimation(controller);
        }
      }
      this.animationTimeConsumed += phaseDeltaTime - unusedTime;
      this.debug(`AnimationBatch - updated ${phaseControllers.length} controllers; ${completeCount} completed`);
      this.debug(`AnimationBatch - animationTimeConsumed: ${this.animationTimeConsumed}`);
      progressPhase();
    } while (unusedTime > 0 && !arePhasesComplete());
    if (this.animationTimeConsumed > this.maxAnimationTime) {
      this.debug(`Animation batch exceeded max animation time, skipping`, [...this.controllers]);
      this.stop();
    }
  }
  ready() {
    if (this.isReady)
      return;
    this.isReady = true;
    this.debug(`AnimationBatch - ready; skipped: ${this.skipAnimations}`, [...this.controllers]);
    let skipAll = true;
    for (const [, controller] of this.controllers) {
      if (controller.duration > 0 && PHASE_METADATA[controller.phase].skipIfNoEarlierAnimations !== true) {
        skipAll = false;
        break;
      }
    }
    if (!skipAll) {
      for (const [, controller] of this.controllers) {
        if (controller.autoplay) {
          controller.play(true);
        }
      }
    }
  }
  skip(skip = true) {
    if (this.skipAnimations === false && skip === true) {
      for (const controller of this.controllers.values()) {
        controller.stop();
      }
      this.controllers.clear();
    }
    this.skipAnimations = skip;
  }
  play() {
    for (const controller of this.controllers.values()) {
      controller.play();
    }
  }
  stop() {
    for (const controller of this.controllers.values()) {
      try {
        controller.stop();
        this.removeAnimation(controller);
      } catch (error) {
        import_ag_charts_core89.Logger.error("Error during animation stop", error);
      }
    }
    this.dispatchStopped();
  }
  stopByAnimationId(id) {
    if (id != null && this.controllers.has(id)) {
      const controller = this.controllers.get(id);
      if (controller) {
        controller.stop();
        this.removeAnimation(controller);
      }
    }
  }
  stopByAnimationGroupId(id) {
    for (const controller of this.controllers.values()) {
      if (controller.groupId === id) {
        this.stopByAnimationId(controller.id);
      }
    }
  }
  dispatchStopped() {
    this.stoppedCbs.forEach((cb) => cb());
    this.stoppedCbs.clear();
  }
  isSkipped() {
    return this.skipAnimations;
  }
  getRemainingTime(restrictPhase) {
    if (!this.isActive())
      return 0;
    let total = 0;
    for (const [phase, controllers] of this.phases) {
      if (controllers.length === 0)
        continue;
      if (restrictPhase != null && restrictPhase !== phase)
        continue;
      total += Math.max(...controllers.map((c) => c.isComplete ? 0 : c.delay + c.duration - (c.elapsed ?? 0)));
    }
    return total;
  }
  destroy() {
    this.stop();
    this.controllers.clear();
  }
};

// packages/ag-charts-community/src/chart/interaction/interactionManager.ts
var InteractionManager = class {
  constructor() {
    this.stateQueue = 32 /* Default */ | 2 /* Animation */;
  }
  pushState(state) {
    this.stateQueue |= state;
  }
  popState(state) {
    this.stateQueue &= ~state;
  }
  isState(allowedStates) {
    return !!(this.stateQueue & -this.stateQueue & allowedStates);
  }
};

// packages/ag-charts-community/src/chart/interaction/animationManager.ts
function validAnimationDuration(testee) {
  if (testee == null)
    return true;
  return !isNaN(testee) && testee >= 0 && testee <= 2;
}
var AnimationManager = class {
  constructor(interactionManager, chartUpdateMutex) {
    this.interactionManager = interactionManager;
    this.chartUpdateMutex = chartUpdateMutex;
    this.defaultDuration = 1e3;
    this.batch = new AnimationBatch(this.defaultDuration * 1.5);
    this.debug = Debug.create(true, "animation");
    this.events = new import_ag_charts_core90.EventEmitter();
    this.rafAvailable = typeof requestAnimationFrame !== "undefined";
    this.isPlaying = true;
    this.requestId = null;
    this.skipAnimations = true;
    this.currentAnonymousAnimationId = 0;
  }
  addListener(eventName, listener) {
    return this.events.on(eventName, listener);
  }
  /**
   * Create an animation to tween a value between the `from` and `to` properties. If an animation already exists
   * with the same `id`, immediately stop it.
   */
  animate(opts) {
    const batch = this.batch;
    try {
      batch.checkOverlappingId(opts.id);
    } catch (error) {
      this.failsafeOnError(error);
      return;
    }
    let { id } = opts;
    if (id == null) {
      id = `__${this.currentAnonymousAnimationId}`;
      this.currentAnonymousAnimationId += 1;
    }
    const skip = this.isSkipped() || opts.phase === "none";
    if (skip) {
      this.debug("AnimationManager - skipping animation");
    }
    const { delay, duration } = opts;
    if (!validAnimationDuration(delay)) {
      throw new Error(`Animation delay of ${delay} is unsupported (${id})`);
    }
    if (!validAnimationDuration(duration)) {
      throw new Error(`Animation duration of ${duration} is unsupported (${id})`);
    }
    const animation = new Animation({
      ...opts,
      id,
      skip,
      autoplay: this.isPlaying ? opts.autoplay : false,
      phase: opts.phase,
      defaultDuration: this.defaultDuration
    });
    if (this.forceTimeJump(animation, this.defaultDuration)) {
      return;
    }
    this.batch.addAnimation(animation);
    return animation;
  }
  play() {
    if (this.isPlaying) {
      return;
    }
    this.isPlaying = true;
    this.debug("AnimationManager.play()");
    try {
      this.batch.play();
    } catch (error) {
      this.failsafeOnError(error);
    }
    this.requestAnimation();
  }
  stop() {
    this.isPlaying = false;
    this.cancelAnimation();
    this.debug("AnimationManager.stop()");
    this.batch.stop();
  }
  stopByAnimationId(id) {
    try {
      this.batch.stopByAnimationId(id);
    } catch (error) {
      this.failsafeOnError(error);
    }
  }
  stopByAnimationGroupId(id) {
    try {
      this.batch.stopByAnimationGroupId(id);
    } catch (error) {
      this.failsafeOnError(error);
    }
  }
  reset() {
    if (this.isPlaying) {
      this.stop();
      this.play();
    } else {
      this.stop();
    }
  }
  skip(skip = true) {
    this.skipAnimations = skip;
  }
  isSkipped() {
    return !this.rafAvailable || this.skipAnimations || this.batch.isSkipped();
  }
  isActive() {
    return this.isPlaying && this.batch.isActive();
  }
  getRemainingTime(phase) {
    return this.batch.getRemainingTime(phase);
  }
  skipCurrentBatch() {
    if (this.debug.check()) {
      this.debug(`AnimationManager - skipCurrentBatch()`, { stack: new Error().stack });
    }
    this.batch.skip();
  }
  /** Mocking point for tests to guarantee that animation updates happen. */
  isSkippingFrames() {
    return true;
  }
  /** Mocking point for tests to capture requestAnimationFrame callbacks. */
  scheduleAnimationFrame(cb) {
    this.requestId = (0, import_ag_charts_core90.getWindow)().requestAnimationFrame((t) => {
      cb(t).catch((e) => import_ag_charts_core90.Logger.error(e));
    });
  }
  /** Mocking point for tests to skip animations to a specific point in time. */
  forceTimeJump(_animation, _defaultDuration) {
    return false;
  }
  requestAnimation() {
    if (!this.rafAvailable)
      return;
    if (!this.batch.isActive() || this.requestId !== null)
      return;
    let prevTime;
    const onAnimationFrame = async (time2) => {
      const executeAnimationFrame = () => {
        const deltaTime = time2 - (prevTime ?? time2);
        prevTime = time2;
        this.debug("AnimationManager - onAnimationFrame()", {
          controllersCount: this.batch.size,
          deltaTime
        });
        this.interactionManager.pushState(2 /* Animation */);
        try {
          this.batch.progress(deltaTime);
        } catch (error) {
          this.failsafeOnError(error);
        }
        this.events.emit("animation-frame", {
          type: "animation-frame",
          deltaMs: deltaTime
        });
      };
      if (this.isSkippingFrames()) {
        await this.chartUpdateMutex.acquireImmediately(executeAnimationFrame);
      } else {
        await this.chartUpdateMutex.acquire(executeAnimationFrame);
      }
      if (this.batch.isActive()) {
        this.scheduleAnimationFrame(onAnimationFrame);
      } else {
        this.batch.stop();
        this.events.emit("animation-stop", {
          type: "animation-stop",
          deltaMs: this.batch.consumedTimeMs
        });
      }
    };
    this.events.emit("animation-start", {
      type: "animation-start",
      deltaMs: 0
    });
    this.scheduleAnimationFrame(onAnimationFrame);
  }
  cancelAnimation() {
    if (this.requestId === null)
      return;
    cancelAnimationFrame(this.requestId);
    this.requestId = null;
    this.startBatch();
  }
  failsafeOnError(error, cancelAnimation = true) {
    import_ag_charts_core90.Logger.error("Error during animation, skipping animations", error);
    if (cancelAnimation) {
      this.cancelAnimation();
    }
  }
  startBatch(skipAnimations) {
    this.debug(`AnimationManager - startBatch() with skipAnimations=${skipAnimations}.`);
    this.reset();
    this.batch.destroy();
    this.batch = new AnimationBatch(this.defaultDuration * 1.5);
    if (skipAnimations === true) {
      this.batch.skip();
    }
  }
  endBatch() {
    if (this.batch.isActive()) {
      this.batch.ready();
      this.requestAnimation();
    } else {
      this.interactionManager.popState(2 /* Animation */);
      if (this.batch.isSkipped()) {
        this.batch.skip(false);
      }
    }
  }
  onBatchStop(cb) {
    this.batch.stoppedCbs.add(cb);
  }
  destroy() {
    this.stop();
    this.events.clear();
  }
};

// packages/ag-charts-community/src/chart/interaction/chartEventManager.ts
var ChartEventManager = class extends BaseManager {
  seriesEvent(type) {
    this.listeners.dispatch(type, { type });
  }
  seriesKeyNavZoom(delta3, widgetEvent) {
    const event = { type: "series-keynav-zoom", delta: delta3, widgetEvent };
    this.listeners.dispatch("series-keynav-zoom", event);
  }
  legendItemClick(legendType, series, itemId, enabled, legendItemName) {
    const event = {
      type: "legend-item-click",
      legendType,
      series,
      itemId,
      enabled,
      legendItemName
    };
    this.listeners.dispatch("legend-item-click", event);
  }
  legendItemDoubleClick(legendType, series, itemId, enabled, numVisibleItems, legendItemName) {
    const event = {
      type: "legend-item-double-click",
      legendType,
      series,
      itemId,
      enabled,
      legendItemName,
      numVisibleItems
    };
    this.listeners.dispatch("legend-item-double-click", event);
  }
};

// packages/ag-charts-community/src/chart/interaction/contextMenuTypes.ts
var ContextMenuBuiltinItems = class {
  constructor() {
    this.download = {
      type: "action",
      showOn: "always",
      label: "contextMenuDownload",
      enabled: true,
      action: void 0,
      items: void 0
    };
    this["zoom-to-cursor"] = {
      type: "action",
      showOn: "series-area",
      label: "contextMenuZoomToCursor",
      enabled: true,
      action: void 0,
      items: void 0
    };
    this["pan-to-cursor"] = {
      type: "action",
      showOn: "series-area",
      label: "contextMenuPanToCursor",
      enabled: true,
      action: void 0,
      items: void 0
    };
    this["toggle-series-visibility"] = {
      type: "action",
      showOn: "legend-item",
      label: "contextMenuToggleSeriesVisibility",
      enabled: true,
      action: void 0,
      items: void 0
    };
    this["toggle-other-series"] = {
      type: "action",
      showOn: "legend-item",
      label: "contextMenuToggleOtherSeries",
      enabled: true,
      action: void 0,
      items: void 0
    };
    this["separator"] = {
      type: "separator",
      showOn: "always",
      label: "separator",
      enabled: true,
      action: void 0,
      items: void 0
    };
  }
};
var ContextMenuBuiltinItemLists = class {
  constructor() {
    this.defaults = [
      "download",
      "zoom-to-cursor",
      "pan-to-cursor",
      "toggle-series-visibility",
      "toggle-other-series"
    ];
  }
};
var ContextMenuBuiltins = class {
  constructor() {
    this.items = new ContextMenuBuiltinItems();
    this.lists = new ContextMenuBuiltinItemLists();
  }
};

// packages/ag-charts-community/src/chart/interaction/contextMenuRegistry.ts
var ContextMenuRegistry = class extends BaseManager {
  constructor() {
    super();
    this.builtins = new ContextMenuBuiltins();
    this.hiddenActions = /* @__PURE__ */ new Set();
    this.setVisible("zoom-to-cursor", false);
    this.setVisible("pan-to-cursor", false);
  }
  static check(showOn, event) {
    return event.showOn == showOn;
  }
  static checkCallback(desiredShowOn, showOn, _callback) {
    return desiredShowOn === showOn;
  }
  dispatchContext(showOn, pointerEvent, context, position) {
    const { widgetEvent } = pointerEvent;
    if (widgetEvent.sourceEvent.defaultPrevented) {
      return;
    }
    const x = position?.x ?? pointerEvent.canvasX;
    const y = position?.y ?? pointerEvent.canvasY;
    const event = { type: "context-setup", showOn, x, y, context, widgetEvent };
    this.listeners.dispatch("context-setup", event);
    event.type = "context-complete";
    this.listeners.dispatch("context-complete", event);
  }
  isVisible(id) {
    return !this.hiddenActions.has(id);
  }
  setVisible(id, visible) {
    if (visible) {
      this.hiddenActions.delete(id);
    } else {
      this.hiddenActions.add(id);
    }
  }
};

// packages/ag-charts-community/src/chart/interaction/highlightManager.ts
var HighlightManager = class extends BaseManager {
  constructor() {
    super(...arguments);
    this.highlightStates = new StateTracker();
  }
  updateHighlight(callerId, highlightedDatum) {
    const { activeHighlight: previousHighlight } = this;
    this.highlightStates.set(callerId, highlightedDatum);
    this.activeHighlight = this.highlightStates.stateValue();
    if (!this.isEqual(this.activeHighlight, previousHighlight)) {
      this.listeners.dispatch("highlight-change", {
        type: "highlight-change",
        currentHighlight: this.activeHighlight,
        previousHighlight,
        callerId
      });
    }
  }
  getActiveHighlight() {
    return this.activeHighlight;
  }
  isEqual(a, b) {
    return a === b || a != null && b != null && a?.series === b?.series && a?.itemId === b?.itemId && a?.datum === b?.datum;
  }
};

// packages/ag-charts-community/src/chart/series/util.ts
var import_ag_charts_core91 = require("ag-charts-core");
function datumBoundaryPoints(datum, domain) {
  if (datum == null || domain.length === 0) {
    return [false, false];
  }
  const datumValue = datum.valueOf();
  const d0 = domain[0];
  const d1 = domain[domain.length - 1];
  if (typeof d0 === "string") {
    return [datumValue === d0, datumValue === d1];
  }
  let min = d0.valueOf();
  let max = d1.valueOf();
  if (min > max) {
    [min, max] = [max, min];
  }
  return [datumValue === min, datumValue === max];
}
function datumStylerProperties(datum, xKey, yKey, xDomain, yDomain) {
  const { xValue, yValue } = datum;
  const [min, max] = datumBoundaryPoints(yValue, yDomain);
  const [first2, last] = datumBoundaryPoints(xValue, xDomain);
  return {
    xKey,
    yKey,
    xValue,
    yValue,
    first: first2,
    last,
    min,
    max
  };
}
function visibleRangeIndices(length, [range0, range1], xRange) {
  const xMinIndex = (0, import_ag_charts_core91.findMinIndex)(0, length - 1, (index) => {
    const x1 = xRange(index)?.[1] ?? NaN;
    return !Number.isFinite(x1) || x1 > range0;
  }) ?? 0;
  let xMaxIndex = (0, import_ag_charts_core91.findMaxIndex)(0, length - 1, (index) => {
    const x0 = xRange(index)?.[0] ?? NaN;
    return !Number.isFinite(x0) || x0 < range1;
  }) ?? length - 1;
  xMaxIndex = Math.min(xMaxIndex + 1, length);
  return [xMinIndex, xMaxIndex];
}
function getDatumRefPoint(series, datum, movedBounds) {
  if (movedBounds) {
    const { x, y, width: width2, height: height2 } = movedBounds;
    return { canvasX: x + width2 / 2, canvasY: y + height2 / 2 };
  }
  const refPoint = datum.yBar?.upperPoint ?? datum.midPoint ?? series.datumMidPoint?.(datum);
  if (refPoint) {
    const { x, y } = Transformable.toCanvasPoint(series.contentGroup, refPoint.x, refPoint.y);
    return { canvasX: Math.round(x), canvasY: Math.round(y) };
  }
}
function countExpandingSearch(min, max, start2, countUntil, iteratee) {
  let i = -1;
  let count = 0;
  let shift = 0;
  let reachedAnEnd = false;
  while (count < countUntil && i <= max - min) {
    i += 1;
    const index = start2 + shift;
    if (!reachedAnEnd)
      shift *= -1;
    if (shift >= 0)
      shift += 1;
    if (reachedAnEnd && shift < 0)
      shift -= 1;
    if (index < min || index > max) {
      reachedAnEnd = true;
      continue;
    }
    if (iteratee(index))
      count += 1;
  }
  return count;
}

// packages/ag-charts-community/src/chart/interaction/tooltipManager.ts
var TooltipManager = class {
  constructor(localeManager, domManager, tooltip) {
    this.domManager = domManager;
    this.tooltip = tooltip;
    this.stateTracker = new StateTracker();
    this.suppressState = new StateTracker(false);
    this.appliedState = null;
    this.destroyFns = [];
    this.destroyFns.push(
      tooltip.setup(localeManager, domManager),
      domManager.addListener("hidden", () => this.tooltip.hide())
    );
  }
  destroy() {
    this.destroyFns.forEach((fn) => fn());
  }
  updateTooltip(callerId, meta, content, pagination) {
    content ?? (content = this.stateTracker.get(callerId)?.content);
    this.stateTracker.set(callerId, { meta, content, pagination });
    this.applyStates();
  }
  removeTooltip(callerId) {
    this.stateTracker.delete(callerId);
    this.applyStates();
  }
  suppressTooltip(callerId) {
    this.suppressState.set(callerId, true);
  }
  unsuppressTooltip(callerId) {
    this.suppressState.delete(callerId);
  }
  applyStates() {
    const id = this.stateTracker.stateId();
    const state = id ? this.stateTracker.get(id) : void 0;
    if (this.suppressState.stateValue() || state?.meta == null || state?.content == null) {
      this.appliedState = null;
      this.tooltip.hide();
      return;
    }
    const canvasRect = this.domManager.getBoundingClientRect();
    const boundingRect = this.tooltip.bounds === "extended" ? this.domManager.getOverlayClientRect() : canvasRect;
    if (this.appliedState?.content === state?.content) {
      const renderInstantly = this.tooltip.isVisible();
      this.tooltip.show(boundingRect, canvasRect, state?.meta, null, void 0, renderInstantly);
    } else {
      this.tooltip.show(boundingRect, canvasRect, state?.meta, state?.content, state?.pagination);
    }
    this.appliedState = state;
  }
  static makeTooltipMeta(event, series, datum, movedBounds) {
    const { canvasX, canvasY } = event;
    const tooltip = series.properties.tooltip;
    const { placement, defaultPlacement, anchorTo, defaultAnchorTo, xOffset, yOffset } = tooltip.position;
    const refPoint = getDatumRefPoint(series, datum, movedBounds);
    const meta = {
      canvasX,
      canvasY,
      nodeCanvasX: refPoint?.canvasX ?? canvasX,
      nodeCanvasY: refPoint?.canvasY ?? canvasY,
      enableInteraction: tooltip.interaction?.enabled ?? false,
      showArrow: tooltip.showArrow,
      position: {
        placement,
        defaultPlacement,
        anchorTo,
        defaultAnchorTo,
        xOffset,
        yOffset
      }
    };
    return meta;
  }
  isEnteringInteractiveTooltip(event) {
    const { tooltip } = this;
    const relatedTarget = event.relatedTarget;
    return tooltip.interactive && tooltip.enabled && tooltip.isVisible() && tooltip.contains(relatedTarget);
  }
};

// packages/ag-charts-community/src/chart/interaction/dragInterpreter.ts
var DRAG_THRESHOLD_PX = 3;
var DOUBLE_TAP_TIMER_MS = 505;
var DOUBLE_TAP_THRESHOLD_PX = 30;
function makeSynthetic(device, type, event) {
  const { offsetX, offsetY, clientX, clientY, currentX, currentY, sourceEvent } = event;
  return { type, device, offsetX, offsetY, clientX, clientY, currentX, currentY, sourceEvent };
}
function checkDragDistance(dx, dy) {
  const distanceSquared = dx * dx + dy * dy;
  const thresholdSquared = DRAG_THRESHOLD_PX * DRAG_THRESHOLD_PX;
  return distanceSquared >= thresholdSquared;
}
function checkDoubleTapDistance(t1, t2) {
  const dx = t1.clientX - t2.clientX;
  const dy = t1.clientY - t2.clientY;
  const distanceSquared = dx * dx + dy * dy;
  const thresholdSquared = DOUBLE_TAP_THRESHOLD_PX * DOUBLE_TAP_THRESHOLD_PX;
  return distanceSquared < thresholdSquared;
}
var DragInterpreter = class {
  constructor(widget) {
    this.destroyFns = [];
    this.listeners = new Listeners();
    this.isDragging = false;
    this.touch = { distanceTravelledX: 0, distanceTravelledY: 0, clientX: 0, clientY: 0 };
    this.destroyFns.push(
      widget.addListener("touchstart", this.onTouchStart.bind(this)),
      widget.addListener("touchmove", this.onTouchMove.bind(this)),
      widget.addListener("touchend", this.onTouchEnd.bind(this)),
      widget.addListener("mousemove", this.onMouseMove.bind(this)),
      widget.addListener("dblclick", this.onDblClick.bind(this)),
      widget.addListener("drag-start", this.onDragStart.bind(this)),
      widget.addListener("drag-move", this.onDragMove.bind(this)),
      widget.addListener("drag-end", this.onDragEnd.bind(this))
    );
  }
  destroy() {
    this.destroyFns.forEach((fn) => fn());
    this.listeners.destroy();
  }
  addListener(type, handler) {
    return this.listeners.addListener(type, handler);
  }
  dispatch(event) {
    this.listeners.dispatch(event.type, event);
  }
  onTouchStart(e) {
    const { clientX, clientY } = e.sourceEvent.targetTouches[0] ?? { clientX: Infinity, clientY: Infinity };
    this.touch.distanceTravelledX = 0;
    this.touch.distanceTravelledY = 0;
    this.touch.clientX = clientX;
    this.touch.clientY = clientY;
  }
  onTouchMove(e) {
    const { clientX, clientY } = e.sourceEvent.targetTouches[0] ?? { clientX: Infinity, clientY: Infinity };
    this.touch.distanceTravelledX += Math.abs(this.touch.clientX - clientX);
    this.touch.distanceTravelledY += Math.abs(this.touch.clientY - clientY);
    this.touch.clientX = clientX;
    this.touch.clientY = clientY;
  }
  onTouchEnd(event) {
    event.sourceEvent.preventDefault();
  }
  onMouseMove(event) {
    this.dispatch(event);
  }
  onDblClick(event) {
    this.dispatch({ device: "mouse", ...event });
  }
  onDragStart(event) {
    this.dragStartEvent = event;
  }
  onDragMove(event) {
    if (this.dragStartEvent != null) {
      if (checkDragDistance(event.originDeltaX, event.originDeltaY)) {
        this.dispatch(this.dragStartEvent);
        this.dispatch({ ...this.dragStartEvent, type: "drag-move" });
        this.dragStartEvent = void 0;
        this.isDragging = true;
      }
    }
    if (this.isDragging) {
      this.dispatch(event);
    }
  }
  onDragEnd(event) {
    if (this.isDragging) {
      this.dispatch(event);
      this.isDragging = false;
      return;
    }
    if (event.device === "mouse") {
      const click = makeSynthetic("mouse", "click", event);
      this.dispatch(click);
    } else if (event.sourceEvent.type === "touchend") {
      if (checkDragDistance(this.touch.distanceTravelledX, this.touch.distanceTravelledY)) {
        return;
      }
      const click = makeSynthetic("touch", "click", event);
      this.dispatch(click);
      const now = Date.now();
      if (this.lastClick !== void 0 && now - this.lastClick.time <= DOUBLE_TAP_TIMER_MS && checkDoubleTapDistance(this.lastClick, event)) {
        const dblClick = makeSynthetic(event.device, "dblclick", event);
        this.dispatch(dblClick);
        this.lastClick = void 0;
      } else {
        this.lastClick = { time: now, clientX: event.clientX, clientY: event.clientY };
      }
    }
  }
};

// packages/ag-charts-community/src/chart/interaction/widgetSet.ts
var DOMManagerWidget = class extends NativeWidget {
  constructor(elem) {
    super(elem);
  }
  addChildToDOM() {
  }
  removeChildFromDOM() {
  }
};
var WidgetSet = class {
  constructor(domManager) {
    this.seriesWidget = new DOMManagerWidget(domManager.getParent("series-area"));
    this.chartWidget = new DOMManagerWidget(domManager.getParent("canvas-proxy"));
    this.containerWidget = new DOMManagerWidget(domManager.getParent("canvas-container"));
    this.containerWidget.addChild(this.chartWidget);
    this.chartWidget.addChild(this.seriesWidget);
    this.seriesDragInterpreter = new DragInterpreter(this.seriesWidget);
  }
  destroy() {
    this.seriesDragInterpreter.destroy();
    this.seriesWidget.destroy();
    this.chartWidget.destroy();
    this.containerWidget.destroy();
  }
};

// packages/ag-charts-community/src/chart/interaction/zoomManager.ts
var import_ag_charts_core93 = require("ag-charts-core");

// packages/ag-charts-community/src/util/panToBBox.ts
var import_ag_charts_core92 = require("ag-charts-core");

// packages/ag-charts-community/src/util/vector4.ts
var Vec4 = {
  bottomCenter,
  center,
  clone,
  collides,
  end,
  from,
  height,
  round: round2,
  start,
  topCenter,
  origin,
  width
};
function start(a) {
  return { x: a.x1, y: a.y1 };
}
function end(a) {
  return { x: a.x2, y: a.y2 };
}
function topCenter(a) {
  return { x: (a.x1 + a.x2) / 2, y: Math.min(a.y1, a.y2) };
}
function center(a) {
  return { x: (a.x1 + a.x2) / 2, y: (a.y1 + a.y2) / 2 };
}
function bottomCenter(a) {
  return { x: (a.x1 + a.x2) / 2, y: Math.max(a.y1, a.y2) };
}
function width(a) {
  return Math.abs(a.x2 - a.x1);
}
function height(a) {
  return Math.abs(a.y2 - a.y1);
}
function round2(a) {
  return { x1: Math.round(a.x1), y1: Math.round(a.y1), x2: Math.round(a.x2), y2: Math.round(a.y2) };
}
function clone(a) {
  return { x1: a.x1, y1: a.y1, x2: a.x2, y2: a.y2 };
}
function collides(a, b) {
  const an = normalise(a);
  const bn = normalise(b);
  return an.x1 <= bn.x2 && an.x2 >= bn.x1 && an.y1 <= bn.y2 && an.y2 >= bn.y1;
}
function normalise(a) {
  return { x1: Math.min(a.x1, a.x2), x2: Math.max(a.x1, a.x2), y1: Math.min(a.y1, a.y2), y2: Math.max(a.y1, a.y2) };
}
function from(a, b, c, d) {
  if (typeof a === "number") {
    return { x1: a, y1: b, x2: c, y2: d };
  }
  if ("width" in a) {
    return normalise({
      x1: a.x,
      y1: a.y,
      x2: a.x + a.width,
      y2: a.y + a.height
    });
  }
  throw new Error(`Values can not be converted into a vector4: [${JSON.stringify(a)}] [${b}] [${c}] [${d}]`);
}
function origin() {
  return { x1: 0, y1: 0, x2: 0, y2: 0 };
}

// packages/ag-charts-community/src/util/panToBBox.ts
function normalize2(screenMin, min, screenMax, max, target) {
  return min + (max - min) * ((target - screenMin) / (screenMax - screenMin));
}
function unnormalize(screenMin, min, screenMax, max, ratio8) {
  return screenMin + (ratio8 - min) * ((screenMax - screenMin) / (max - min));
}
function calcWorldAxis(viewportMin, viewportMax, ratio8) {
  return [
    unnormalize(viewportMin, ratio8.min, viewportMax, ratio8.max, 0),
    unnormalize(viewportMin, ratio8.min, viewportMax, ratio8.max, 1)
  ];
}
function calcWorldVec4(viewport, ratioX, ratioY) {
  const [x1, x2] = calcWorldAxis(viewport.x1, viewport.x2, ratioX);
  const [y1, y2] = calcWorldAxis(viewport.y1, viewport.y2, ratioY);
  return { x1, x2, y1, y2 };
}
function panAxesUnnormalized(worldMin, worldMax, viewportMin, viewportMax, targetMin, targetMax) {
  if (viewportMin <= targetMin && targetMax <= viewportMax)
    return viewportMin;
  const minDiff = targetMin - viewportMin;
  const maxDiff = targetMax - viewportMax;
  const diff2 = Math.abs(minDiff) < Math.abs(maxDiff) ? minDiff : maxDiff;
  return (0, import_ag_charts_core92.clamp)(worldMin, viewportMin + diff2, worldMax);
}
function calcPanToBBoxRatios(viewportBBox, ratios, targetBBox) {
  const { x: ratioX = { min: 0, max: 1 }, y: ratioY = { min: 0, max: 1 } } = ratios;
  const target = Vec4.from(targetBBox);
  const viewport = Vec4.from(viewportBBox);
  const world = calcWorldVec4(viewport, ratioX, ratioY);
  const x = panAxesUnnormalized(world.x1, world.x2, viewport.x1, viewport.x2, target.x1, target.x2);
  const y = panAxesUnnormalized(world.y1, world.y2, viewport.y1, viewport.y2, target.y1, target.y2);
  const result = {
    x: {
      min: normalize2(viewport.x1, ratioX.min, viewport.x2, ratioX.max, x),
      max: normalize2(viewport.x1, ratioX.min, viewport.x2, ratioX.max, x + viewportBBox.width)
    },
    y: {
      min: normalize2(viewport.y1, ratioY.min, viewport.y2, ratioY.max, y),
      max: normalize2(viewport.y1, ratioY.min, viewport.y2, ratioY.max, y + viewportBBox.height)
    }
  };
  const diffX = result.x.max - result.x.min;
  const diffY = result.y.max - result.y.min;
  result.x.min = (0, import_ag_charts_core92.clamp)(0, result.x.min, 1 - diffX);
  result.x.max = result.x.min + diffX;
  result.y.min = (0, import_ag_charts_core92.clamp)(0, result.y.min, 1 - diffY);
  result.y.max = result.y.min + diffY;
  return result;
}

// packages/ag-charts-community/src/chart/interaction/zoomManager.ts
var expectedMementoKeys = ["rangeX", "rangeY", "ratioX", "ratioY", "autoScaledAxes"];
var ZoomManagerAutoScaleAxis = class {
  constructor() {
    this.enabled = false;
    this.padding = 0;
    this.manuallyAdjusted = false;
  }
};
var rangeValidator2 = (axis) => (0, import_ag_charts_core93.attachDescription)((value, { options }) => {
  if (!ContinuousScale.is(axis?.scale) && !DiscreteTimeScale.is(axis?.scale))
    return true;
  if (value == null || options.end == null)
    return true;
  return value <= options.end;
}, `to be less than end`);
var ZoomManager = class extends BaseManager {
  constructor(fireChartEvent, layoutManager) {
    super();
    this.fireChartEvent = fireChartEvent;
    this.mementoOriginatorKey = "zoom";
    this.axisZoomManagers = /* @__PURE__ */ new Map();
    this.state = new StateTracker(void 0, "initial");
    this.axes = [];
    this.didLayoutAxes = false;
    this.autoScaleYAxis = new ZoomManagerAutoScaleAxis();
    this.lastRestoredState = void 0;
    this.independentAxes = false;
    this.navigatorModule = false;
    this.zoomModule = false;
    // The initial state memento can not be restored until the chart has performed its first layout. Instead save it as
    // pending and restore then delete it on the first layout.
    this.pendingMemento = void 0;
    this.destroyFns.push(
      layoutManager.addListener("layout:complete", () => {
        const { pendingMemento } = this;
        const shouldPerformInitialLayout = !this.didLayoutAxes;
        this.didLayoutAxes = true;
        if (pendingMemento) {
          this.restoreMemento(pendingMemento.version, pendingMemento.mementoVersion, pendingMemento.memento);
        } else if (shouldPerformInitialLayout) {
          this.autoScaleYZoom("zoom-manager");
        }
      })
    );
  }
  createMemento() {
    return this.getMementoRanges();
  }
  guardMemento(blob, messages) {
    if (blob == null)
      return true;
    if (!(0, import_ag_charts_core93.isObject)(blob))
      return false;
    for (const key of Object.keys(blob)) {
      if (!expectedMementoKeys.includes(key)) {
        return false;
      }
    }
    const primaryX = this.getPrimaryAxis("x" /* X */);
    const primaryY = this.getPrimaryAxis("y" /* Y */);
    const zoomMementoDefs = {
      rangeX: { start: (0, import_ag_charts_core93.and)((0, import_ag_charts_core93.or)(import_ag_charts_core93.number, import_ag_charts_core93.date), rangeValidator2(primaryX)), end: (0, import_ag_charts_core93.or)(import_ag_charts_core93.number, import_ag_charts_core93.date) },
      rangeY: { start: (0, import_ag_charts_core93.and)((0, import_ag_charts_core93.or)(import_ag_charts_core93.number, import_ag_charts_core93.date), rangeValidator2(primaryY)), end: (0, import_ag_charts_core93.or)(import_ag_charts_core93.number, import_ag_charts_core93.date) },
      ratioX: { start: (0, import_ag_charts_core93.and)(import_ag_charts_core93.ratio, (0, import_ag_charts_core93.lessThan)("end")), end: import_ag_charts_core93.ratio },
      ratioY: { start: (0, import_ag_charts_core93.and)(import_ag_charts_core93.ratio, (0, import_ag_charts_core93.lessThan)("end")), end: import_ag_charts_core93.ratio },
      autoScaledAxes: (0, import_ag_charts_core93.arrayOf)((0, import_ag_charts_core93.union)("y"))
    };
    const { invalid } = (0, import_ag_charts_core93.validate)(blob, zoomMementoDefs);
    if (invalid.length > 0) {
      messages.push(...invalid.map(String));
      return false;
    }
    return true;
  }
  restoreMemento(version, mementoVersion, memento) {
    const { independentAxes } = this;
    if (!this.axes || !this.didLayoutAxes) {
      this.pendingMemento = { version, mementoVersion, memento };
      return;
    }
    this.pendingMemento = void 0;
    const zoom = this.getDefinedZoom();
    if (memento?.rangeX) {
      zoom.x = this.rangeToRatio(memento.rangeX, "x" /* X */) ?? { min: 0, max: 1 };
    } else if (memento?.ratioX) {
      zoom.x = {
        min: memento.ratioX.start ?? 0,
        max: memento.ratioX.end ?? 1
      };
    } else {
      zoom.x = { min: 0, max: 1 };
    }
    if (!this.navigatorModule || this.zoomModule) {
      let yAutoScale = memento?.autoScaledAxes?.includes("y");
      if (memento?.rangeY) {
        zoom.y = this.rangeToRatio(memento.rangeY, "y" /* Y */) ?? { min: 0, max: 1 };
        yAutoScale ?? (yAutoScale = false);
      } else if (memento?.ratioY) {
        zoom.y = {
          min: memento.ratioY.start ?? 0,
          max: memento.ratioY.end ?? 1
        };
        yAutoScale ?? (yAutoScale = false);
      } else {
        zoom.y = { min: 0, max: 1 };
        yAutoScale ?? (yAutoScale = true);
      }
      zoom.autoScaleYAxis = yAutoScale;
    }
    this.lastRestoredState = zoom;
    if (independentAxes !== true) {
      this.updateZoom("zoom-manager", zoom);
      return;
    }
    const primaryX = this.getPrimaryAxis("x" /* X */);
    const primaryY = this.getPrimaryAxis("y" /* Y */);
    for (const axis of [primaryX, primaryY]) {
      if (!axis)
        continue;
      this.updateAxisZoom("zoom-manager", axis.id, zoom[axis.direction]);
    }
  }
  updateAxes(axes) {
    this.axes = axes;
    const zoomManagers = new Map(axes.map((axis) => [axis.id, this.axisZoomManagers.get(axis.id)]));
    this.axisZoomManagers.clear();
    for (const axis of axes) {
      this.axisZoomManagers.set(axis.id, zoomManagers.get(axis.id) ?? new AxisZoomManager(axis));
    }
    if (this.state.size > 0 && axes.length > 0) {
      this.updateZoom(this.state.stateId(), this.state.stateValue());
    }
  }
  setIndependentAxes(independent = true) {
    this.independentAxes = independent;
  }
  setAutoScaleYAxis(enabled, padding) {
    this.autoScaleYAxis.enabled = enabled;
    this.autoScaleYAxis.padding = padding;
  }
  setNavigatorEnabled(enabled = true) {
    this.navigatorModule = enabled;
  }
  setZoomModuleEnabled(enabled = true) {
    this.zoomModule = enabled;
  }
  isNavigatorEnabled() {
    return this.navigatorModule;
  }
  isZoomEnabled() {
    return this.zoomModule;
  }
  updateZoom(callerId, newZoom) {
    if (newZoom?.x && (newZoom.x.min < 0 || newZoom.x.max > 1)) {
      import_ag_charts_core93.Logger.warnOnce(
        `Attempted to update x-axis zoom to an invalid ratio of [{ min: ${newZoom.x.min}, max: ${newZoom.x.max} }], expecting a ratio of 0 to 1, ignoring.`
      );
      newZoom.x = void 0;
    }
    if (newZoom?.y && (newZoom.y.min < 0 || newZoom.y.max > 1)) {
      import_ag_charts_core93.Logger.warnOnce(
        `Attempted to update y-axis zoom to an invalid ratio of [{ min: ${newZoom.y.min}, max: ${newZoom.y.max} }], expecting a ratio of 0 to 1, ignoring.`
      );
      newZoom.y = void 0;
    }
    if (this.axisZoomManagers.size === 0) {
      const stateId = this.state.stateId();
      if (stateId === "initial" || stateId === callerId) {
        this.state.set(callerId, newZoom);
      }
      return;
    }
    this.state.set(callerId, newZoom);
    const autoScaleYAxis = newZoom?.autoScaleYAxis;
    if (autoScaleYAxis != null) {
      this.autoScaleYAxis.manuallyAdjusted = !autoScaleYAxis;
    }
    this.axisZoomManagers.forEach((axis) => {
      axis.updateZoom(callerId, newZoom?.[axis.getDirection()]);
    });
    this.applyChanges(callerId);
  }
  updateAxisZoom(callerId, axisId, newZoom) {
    this.axisZoomManagers.get(axisId)?.updateZoom(callerId, newZoom);
    this.applyChanges(callerId);
  }
  resetZoom(callerId) {
    this.autoScaleYAxis.manuallyAdjusted = false;
    const zoom = this.getRestoredZoom();
    this.updateZoom(callerId, {
      x: { min: zoom?.x?.min ?? 0, max: zoom?.x?.max ?? 1 },
      y: { min: zoom?.y?.min ?? 0, max: zoom?.y?.max ?? 1 },
      autoScaleYAxis: zoom?.autoScaleYAxis ?? true
    });
  }
  resetAxisZoom(callerId, axisId) {
    const axisZoomManager = this.axisZoomManagers.get(axisId);
    const direction = axisZoomManager?.getDirection();
    if (direction == null)
      return;
    const restoredZoom = this.getRestoredZoom();
    if (direction === "y" /* Y */) {
      const autoScaleYAxis = restoredZoom?.autoScaleYAxis ?? true;
      this.autoScaleYAxis.manuallyAdjusted = !autoScaleYAxis;
    }
    for (const axis of this.axes) {
      if (axis.direction !== direction)
        continue;
      this.updateAxisZoom(callerId, axis.id, restoredZoom?.[direction] ?? { min: 0, max: 1 });
    }
  }
  setAxisManuallyAdjusted(_callerId, axisId) {
    const direction = this.axisZoomManagers.get(axisId)?.getDirection();
    if (direction !== "y" /* Y */)
      return;
    this.autoScaleYAxis.manuallyAdjusted = true;
  }
  updatePrimaryAxisZoom(callerId, direction, newZoom) {
    const primaryAxis = this.getPrimaryAxis(direction);
    if (!primaryAxis)
      return;
    this.updateAxisZoom(callerId, primaryAxis.id, newZoom);
  }
  panToBBox(callerId, seriesRect, target) {
    if (!this.isZoomEnabled() && !this.isNavigatorEnabled())
      return false;
    const zoom = this.getZoom();
    if (zoom === void 0 || !zoom.x && !zoom.y)
      return false;
    const panIsPossible = seriesRect.width > 0 && seriesRect.height > 0 && Math.abs(target.width) <= Math.abs(seriesRect.width) && Math.abs(target.height) <= Math.abs(seriesRect.height);
    if (!panIsPossible) {
      import_ag_charts_core93.Logger.warnOnce(`cannot pan to target BBox - chart too small?`);
      return false;
    }
    const newZoom = calcPanToBBoxRatios(seriesRect, zoom, target);
    if (this.independentAxes) {
      this.updatePrimaryAxisZoom(callerId, "x" /* X */, newZoom.x);
      this.updatePrimaryAxisZoom(callerId, "y" /* Y */, newZoom.y);
    } else {
      this.updateZoom(callerId, newZoom);
    }
    return true;
  }
  // Fire this event to signal to listeners that the view is changing through a zoom and/or pan change.
  fireZoomPanStartEvent(callerId) {
    this.listeners.dispatch("zoom-pan-start", { type: "zoom-pan-start", callerId });
  }
  extendToEnd(callerId, direction, extent2) {
    return this.extendWith(callerId, direction, (end2) => Number(end2) - extent2);
  }
  extendWith(callerId, direction, fn) {
    const axis = this.getPrimaryAxis(direction);
    if (!axis)
      return;
    const extents = this.getDomainExtents(axis);
    if (!extents)
      return;
    const [, end2] = extents;
    const start2 = fn(end2);
    const ratio8 = this.rangeToRatio({ start: start2, end: end2 }, direction);
    if (!ratio8)
      return;
    this.updateZoom(callerId, { [direction]: ratio8 });
  }
  updateWith(callerId, direction, fn) {
    const axis = this.getPrimaryAxis(direction);
    if (!axis)
      return;
    const extents = this.getDomainExtents(axis);
    if (!extents)
      return;
    let [start2, end2] = extents;
    [start2, end2] = fn(start2, end2);
    const ratio8 = this.rangeToRatio({ start: start2, end: end2 }, direction);
    if (!ratio8)
      return;
    this.updateZoom(callerId, { [direction]: ratio8 });
  }
  getZoom() {
    let x;
    let y;
    this.axisZoomManagers.forEach((axis) => {
      if (axis.getDirection() === "x" /* X */) {
        x ?? (x = axis.getZoom());
      } else if (axis.getDirection() === "y" /* Y */) {
        y ?? (y = axis.getZoom());
      }
    });
    if (x || y) {
      return { x, y };
    }
  }
  getAxisZoom(axisId) {
    return this.axisZoomManagers.get(axisId)?.getZoom() ?? { min: 0, max: 1 };
  }
  getAxisZooms() {
    const axes = {};
    for (const [axisId, axis] of this.axisZoomManagers.entries()) {
      axes[axisId] = {
        direction: axis.getDirection(),
        zoom: axis.getZoom()
      };
    }
    return axes;
  }
  getRestoredZoom() {
    return this.lastRestoredState;
  }
  getPrimaryAxisId(direction) {
    return this.getPrimaryAxis(direction)?.id;
  }
  isVisibleItemsCountAtLeast(zoom, minVisibleItems) {
    const xAxis = this.getPrimaryAxis("x" /* X */);
    const yAxis = this.getPrimaryAxis("y" /* Y */);
    const processedSeriesIds = /* @__PURE__ */ new Set();
    let visibleItemsCount = 0;
    const xVisibleRange = [zoom.x.min, zoom.x.max];
    const yVisibleRange = [zoom.y.min, zoom.y.max];
    for (const series of xAxis?.boundSeries ?? []) {
      processedSeriesIds.add(series.id);
      const remainingItems = minVisibleItems - (visibleItemsCount ?? 0);
      const seriesVisibleItems = series.getVisibleItems(xVisibleRange, yVisibleRange, remainingItems);
      visibleItemsCount += seriesVisibleItems;
      if (visibleItemsCount >= minVisibleItems)
        return true;
    }
    for (const series of yAxis?.boundSeries ?? []) {
      if (processedSeriesIds.has(series.id))
        continue;
      const remainingItems = minVisibleItems - (visibleItemsCount ?? 0);
      const seriesVisibleItems = series.getVisibleItems(xVisibleRange, yVisibleRange, remainingItems);
      visibleItemsCount += seriesVisibleItems;
      if (visibleItemsCount >= minVisibleItems)
        return true;
    }
    return processedSeriesIds.size === 0;
  }
  getMementoRanges() {
    const zoom = this.getDefinedZoom();
    let autoScaledAxes;
    if (this.autoScaleYAxis.enabled) {
      autoScaledAxes = this.autoScaleYAxis.manuallyAdjusted ? [] : ["y"];
    }
    const memento = {
      rangeX: this.getRangeDirection(zoom.x, "x" /* X */),
      rangeY: this.getRangeDirection(zoom.y, "y" /* Y */),
      ratioX: { start: zoom.x.min, end: zoom.x.max },
      ratioY: { start: zoom.y.min, end: zoom.y.max },
      autoScaledAxes
    };
    return memento;
  }
  autoScaleYZoom(callerId, applyChanges = true) {
    if (!this.isZoomEnabled())
      return;
    const { independentAxes, autoScaleYAxis } = this;
    const zoom = this.getZoom();
    if (zoom?.x == null || !autoScaleYAxis.enabled || autoScaleYAxis.manuallyAdjusted)
      return;
    const { padding } = autoScaleYAxis;
    let zoomY;
    if (zoom.x?.min === 0 && zoom.x?.max === 1) {
      zoomY = { min: 0, max: 1 };
    } else if (independentAxes) {
      zoomY = this.primaryAxisZoom("y" /* Y */, zoom.x, { padding });
    } else {
      zoomY = this.combinedAxisZoom("y" /* Y */, zoom.x, { padding });
    }
    if (zoomY == null)
      return;
    if (independentAxes) {
      const primaryAxis = this.getPrimaryAxis("y" /* Y */);
      const primaryAxisManager = primaryAxis == null ? void 0 : this.axisZoomManagers.get(primaryAxis.id);
      primaryAxisManager?.updateZoom("zoom-manager", zoomY);
    } else {
      for (const axisZoomManager of this.axisZoomManagers.values()) {
        if (axisZoomManager.getDirection() === "y" /* Y */) {
          axisZoomManager.updateZoom("zoom-manager", zoomY);
        }
      }
    }
    if (applyChanges) {
      this.applyChanges(callerId);
    }
  }
  applyChanges(callerId) {
    this.autoScaleYZoom(callerId, false);
    const changed = Array.from(this.axisZoomManagers.values(), (axis) => axis.applyChanges()).includes(true);
    if (!changed) {
      return;
    }
    const axes = {};
    for (const [axisId, axis] of this.axisZoomManagers.entries()) {
      axes[axisId] = axis.getZoom();
    }
    this.listeners.dispatch("zoom-change", { type: "zoom-change", ...this.getZoom(), axes, callerId });
    this.fireChartEvent({ type: "zoom", ...this.getMementoRanges() });
  }
  getRangeDirection(ratio8, direction) {
    const axis = this.getPrimaryAxis(direction);
    if (!axis || !ContinuousScale.is(axis.scale) && !DiscreteTimeScale.is(axis.scale))
      return;
    const extents = this.getDomainPixelExtents(axis);
    if (!extents)
      return;
    const [d0, d1] = extents;
    let start2;
    let end2;
    if (d0 <= d1) {
      start2 = axis.scale.invert(0);
      end2 = axis.scale.invert(d0 + (d1 - d0) * ratio8.max);
    } else {
      start2 = axis.scale.invert(d0 - (d0 - d1) * ratio8.min);
      end2 = axis.scale.invert(0);
    }
    return { start: start2, end: end2 };
  }
  rangeToRatio(range3, direction) {
    const axis = this.getPrimaryAxis(direction);
    if (!axis)
      return;
    const extents = this.getDomainPixelExtents(axis);
    if (!extents)
      return;
    const [d0, d1] = extents;
    let r0 = range3.start == null ? d0 : axis.scale.convert?.(range3.start);
    let r1 = range3.end == null ? d1 : axis.scale.convert?.(range3.end);
    if (!(0, import_ag_charts_core93.isFiniteNumber)(r0) || !(0, import_ag_charts_core93.isFiniteNumber)(r1))
      return;
    const [dMin, dMax] = [Math.min(d0, d1), Math.max(d0, d1)];
    if (r0 < dMin || r0 > dMax) {
      import_ag_charts_core93.Logger.warnOnce(
        `Invalid range start [${range3.start}], expecting a value between [${axis.scale.invert?.(d0)}] and [${axis.scale.invert?.(d1)}], ignoring.`
      );
      return;
    }
    if (r1 < dMin || r1 > dMax) {
      import_ag_charts_core93.Logger.warnOnce(
        `Invalid range end [${range3.end}], expecting a value between [${axis.scale.invert?.(d0)}] and [${axis.scale.invert?.(d1)}], ignoring.`
      );
      return;
    }
    r0 = Math.min(dMax, Math.max(dMin, r0));
    r1 = Math.min(dMax, Math.max(dMin, r1));
    const diff2 = d1 - d0;
    const min = Math.abs((r0 - d0) / diff2);
    const max = Math.abs((r1 - d0) / diff2);
    return { min, max };
  }
  getPrimaryAxis(direction) {
    return this.axes?.find((a) => a.direction === direction);
  }
  getDomainExtents(axis) {
    const { domain } = axis.scale;
    const d0 = domain.at(0);
    const d1 = domain.at(-1);
    if (d0 == null || d1 == null)
      return;
    return [d0, d1];
  }
  getDomainPixelExtents(axis) {
    const { domain } = axis.scale;
    const d0 = axis.scale.convert?.(domain.at(0));
    const d1 = axis.scale.convert?.(domain.at(-1));
    if (!(0, import_ag_charts_core93.isFiniteNumber)(d0) || !(0, import_ag_charts_core93.isFiniteNumber)(d1))
      return;
    return [d0, d1];
  }
  getDefinedZoom() {
    const zoom = this.getZoom();
    return {
      x: { min: zoom?.x?.min ?? 0, max: zoom?.x?.max ?? 1 },
      y: { min: zoom?.y?.min ?? 0, max: zoom?.y?.max ?? 1 }
    };
  }
  zoomBounds(xAxis, yAxis, zoom, padding) {
    const xScale = xAxis.scale;
    const xScaleRange = xScale.range;
    xScale.range = [0, 1];
    const yScale = yAxis.scale;
    const yScaleRange = yScale.range;
    yScale.range = [0, 1];
    let min = 1;
    let minPadding = false;
    let max = 0;
    let maxPadding = false;
    for (const series of yAxis.boundSeries) {
      const { connectsToYAxis } = series;
      const yValues = series.getRange("y" /* Y */, [zoom.min, zoom.max]);
      for (const yValue of yValues) {
        const y = yScale.convert(yValue);
        if (!Number.isFinite(y))
          continue;
        if (y < min) {
          min = y;
          minPadding = !connectsToYAxis || yValue < 0;
        }
        if (y > max) {
          max = y;
          maxPadding = !connectsToYAxis || yValue > 0;
        }
      }
    }
    if ((0, import_ag_charts_core93.isFiniteNumber)(yAxis.min)) {
      min = 0;
    }
    if ((0, import_ag_charts_core93.isFiniteNumber)(yAxis.max)) {
      max = 1;
    }
    xScale.range = xScaleRange;
    yScale.range = yScaleRange;
    if (min >= max)
      return;
    const totalPadding = (minPadding ? padding : 0) + (maxPadding ? padding : 0);
    const paddedDelta = Math.min((max - min) * (1 + totalPadding), 1);
    if (paddedDelta <= 0)
      return;
    if (minPadding && maxPadding) {
      const mid = (max + min) / 2;
      min = mid - paddedDelta / 2;
      max = mid + paddedDelta / 2;
    } else if (!minPadding && maxPadding) {
      max = min + paddedDelta;
    } else if (minPadding && !maxPadding) {
      min = max - paddedDelta;
    }
    if (min < 0) {
      max += -min;
      min = 0;
    } else if (max > 1) {
      min -= max - 1;
      max = 1;
    }
    return { min, max };
  }
  primaryAxisZoom(direction, zoom, { padding = 0 } = {}) {
    const crossDirection = direction === "x" /* X */ ? "y" /* Y */ : "x" /* X */;
    const xAxis = this.getPrimaryAxis(crossDirection);
    const yAxis = this.getPrimaryAxis(direction);
    if (xAxis == null || yAxis == null)
      return;
    return this.zoomBounds(xAxis, yAxis, zoom, padding);
  }
  combinedAxisZoom(direction, zoom, { padding = 0 } = {}) {
    const crossDirection = direction === "x" /* X */ ? "y" /* Y */ : "x" /* X */;
    const seriesXAxes = /* @__PURE__ */ new Map();
    for (const xAxis of this.axes) {
      if (xAxis.direction !== crossDirection)
        continue;
      for (const series of xAxis.boundSeries) {
        seriesXAxes.set(series, xAxis);
      }
    }
    let min = 1;
    let max = 0;
    for (const yAxis of this.axes) {
      if (yAxis.direction !== direction)
        continue;
      for (const series of yAxis.boundSeries) {
        const xAxis = seriesXAxes.get(series);
        if (xAxis == null)
          continue;
        const bounds = this.zoomBounds(xAxis, yAxis, zoom, padding);
        if (bounds == null)
          return;
        min = Math.min(min, bounds.min);
        max = Math.max(max, bounds.max);
      }
    }
    const delta3 = 1e-6;
    if (min < delta3)
      min = 0;
    if (max > 1 - delta3)
      max = 1;
    if (min > max)
      return;
    return { min, max };
  }
};
var AxisZoomManager = class {
  constructor(axis) {
    this.axis = axis;
    const [min = 0, max = 1] = axis.visibleRange;
    this.state = new StateTracker({ min, max });
    this.currentZoom = this.state.stateValue();
  }
  getDirection() {
    return this.axis.direction;
  }
  updateZoom(callerId, newZoom) {
    this.state.set(callerId, newZoom);
  }
  getZoom() {
    return deepClone(this.state.stateValue());
  }
  hasChanges() {
    const currentZoom = this.currentZoom;
    const pendingZoom = this.state.stateValue();
    return currentZoom.min !== pendingZoom.min || currentZoom.max !== pendingZoom.max;
  }
  applyChanges() {
    const hasChanges = this.hasChanges();
    this.currentZoom = this.state.stateValue();
    return hasChanges;
  }
};

// packages/ag-charts-community/src/chart/layout/seriesLabelLayoutManager.ts
var SeriesLabelLayoutManager = class {
  constructor() {
    this.labelData = /* @__PURE__ */ new Map();
  }
  updateLabels(placedLabelSeries, padding, seriesRect = BBox.zero) {
    const bounds = {
      x: -padding.left,
      y: -padding.top,
      width: seriesRect.width + padding.left + padding.right,
      height: seriesRect.height + padding.top + padding.bottom
    };
    const expectedSeriesId = new Set(placedLabelSeries.map((s) => s.id));
    for (const seriesId of this.labelData.keys()) {
      if (!expectedSeriesId.has(seriesId)) {
        this.labelData.delete(seriesId);
      }
    }
    for (const series of placedLabelSeries) {
      const labelData = series.getLabelData();
      if (labelData.every(isPointLabelDatum)) {
        this.labelData.set(series.id, labelData);
      }
    }
    const placedLabels = placeLabels(this.labelData, bounds, 5);
    for (const series of placedLabelSeries) {
      series.updatePlacedLabelData?.(placedLabels.get(series.id) ?? []);
    }
  }
};

// packages/ag-charts-community/src/chart/legend/legendManager.ts
var import_ag_charts_core94 = require("ag-charts-core");
var LegendManager = class extends BaseManager {
  constructor() {
    super(...arguments);
    this.mementoOriginatorKey = "legend";
    this.legendDataMap = /* @__PURE__ */ new Map();
  }
  createMemento() {
    return this.getData().filter(({ hideInLegend, isFixed }) => !hideInLegend && !isFixed).map(({ enabled, seriesId, itemId, legendItemName }) => ({
      visible: enabled,
      seriesId,
      itemId,
      legendItemName
    }));
  }
  guardMemento(blob) {
    return blob == null || (0, import_ag_charts_core94.isArray)(blob);
  }
  restoreMemento(_version, _mementoVersion, memento) {
    memento?.forEach((datum) => {
      const { seriesId, data } = this.getRestoredData(datum) ?? {};
      if (!seriesId || !data) {
        return;
      }
      this.updateData(seriesId, data);
    });
    this.update();
  }
  getRestoredData(datum) {
    const { seriesId, itemId, legendItemName, visible } = datum;
    if (seriesId) {
      const legendData = this.legendDataMap.get(seriesId) ?? [];
      const data = legendData.map((d) => {
        const match = d.seriesId === seriesId && (!itemId || d.itemId === itemId);
        if (match && d.isFixed) {
          this.warnFixed(d.seriesId, d.itemId);
        }
        return !d.isFixed && match ? { ...d, enabled: visible } : d;
      });
      return { seriesId, data };
    }
    if (itemId == null && legendItemName == null) {
      return;
    }
    for (const legendDatum of this.getData()) {
      if (itemId != null && legendDatum.itemId !== itemId || legendItemName != null && legendDatum.legendItemName !== legendItemName) {
        continue;
      }
      if (legendDatum.isFixed) {
        this.warnFixed(legendDatum.seriesId, itemId);
        return;
      }
      const seriesLegendData = (this.legendDataMap.get(legendDatum.seriesId) ?? []).map(
        (d) => d.itemId === itemId || d.legendItemName === legendItemName ? { ...d, enabled: visible } : d
      );
      return {
        seriesId: legendDatum.seriesId,
        data: seriesLegendData
      };
    }
  }
  warnFixed(seriesId, itemId) {
    import_ag_charts_core94.Logger.warnOnce(
      `The legend item with seriesId [${seriesId}] and itemId [${itemId}] is not configurable, this series item cannot be toggled through the legend.`
    );
  }
  update(data) {
    this.listeners.dispatch("legend-change", {
      type: "legend-change",
      legendData: data ?? this.getData()
    });
  }
  updateData(seriesId, data = []) {
    this.legendDataMap.set(seriesId, data);
  }
  clearData() {
    this.legendDataMap.clear();
  }
  toggleItem(enabled, seriesId, itemId, legendItemName) {
    if (legendItemName) {
      this.getData().forEach((datum) => {
        const newData = (this.legendDataMap.get(datum.seriesId) ?? []).map(
          (d) => d.legendItemName === legendItemName ? { ...d, enabled } : d
        );
        this.updateData(datum.seriesId, newData);
      });
      return;
    }
    const seriesLegendData = this.getData(seriesId);
    const singleLegendItem = seriesLegendData.length === 1;
    const data = seriesLegendData.map(
      (datum) => itemId == null && singleLegendItem || datum.itemId === itemId ? { ...datum, enabled } : datum
    );
    this.updateData(seriesId, data);
  }
  getData(seriesId) {
    if (seriesId) {
      return this.legendDataMap.get(seriesId) ?? [];
    }
    return [...this.legendDataMap].reduce(
      (data, [_, legendData]) => data.concat(legendData),
      []
    );
  }
  getDatum({ seriesId, itemId } = {}) {
    return this.getData(seriesId).find((datum) => datum.itemId === itemId);
  }
  getSeriesEnabled(seriesId) {
    const data = this.getData(seriesId);
    if (data.length > 0) {
      return data.some((d) => d.enabled);
    }
  }
  getItemEnabled({ seriesId, itemId } = {}) {
    return this.getDatum({ seriesId, itemId })?.enabled ?? true;
  }
};

// packages/ag-charts-community/src/chart/series/seriesStateManager.ts
var SeriesStateManager = class {
  constructor() {
    this.groups = {};
  }
  registerSeries({ internalId, seriesGrouping, visible, type }) {
    var _a;
    if (!seriesGrouping)
      return;
    (_a = this.groups)[type] ?? (_a[type] = {});
    this.groups[type][internalId] = { grouping: seriesGrouping, visible };
  }
  updateSeries({ internalId, seriesGrouping, visible, type }) {
    if (!seriesGrouping)
      return;
    const entry = this.groups[type]?.[internalId];
    if (entry) {
      entry.grouping = seriesGrouping;
      entry.visible = visible;
    }
  }
  deregisterSeries({ internalId, type }) {
    if (this.groups[type]) {
      delete this.groups[type][internalId];
    }
    if (this.groups[type] && Object.keys(this.groups[type]).length === 0) {
      delete this.groups[type];
    }
  }
  getVisiblePeerGroupIndex({ type, seriesGrouping, visible }) {
    if (!seriesGrouping) {
      return { visibleGroupCount: visible ? 1 : 0, visibleSameStackCount: visible ? 1 : 0, index: 0 };
    }
    const visibleGroupsSet = /* @__PURE__ */ new Set();
    const visibleSameStackSet = /* @__PURE__ */ new Set();
    for (const entry of Object.values(this.groups[type] ?? {})) {
      if (!entry.visible)
        continue;
      visibleGroupsSet.add(entry.grouping.groupIndex);
      if (entry.grouping.groupIndex === seriesGrouping.groupIndex) {
        visibleSameStackSet.add(entry.grouping.stackIndex);
      }
    }
    const visibleGroups = Array.from(visibleGroupsSet);
    visibleGroups.sort((a, b) => a - b);
    return {
      visibleGroupCount: visibleGroups.length,
      visibleSameStackCount: visibleSameStackSet.size,
      index: visibleGroups.indexOf(seriesGrouping.groupIndex)
    };
  }
};

// packages/ag-charts-community/src/chart/updateService.ts
var import_ag_charts_core95 = require("ag-charts-core");
var UpdateService = class {
  constructor(updateCallback) {
    this.updateCallback = updateCallback;
    this.events = new import_ag_charts_core95.EventEmitter();
  }
  addListener(eventName, listener) {
    return this.events.on(eventName, listener);
  }
  removeListener(eventName, listener) {
    return this.events.on(eventName, listener);
  }
  destroy() {
    this.events.clear();
  }
  update(type = 0 /* FULL */, options) {
    this.updateCallback(type, options);
  }
  dispatchUpdateComplete(apiUpdate) {
    this.events.emit("update-complete", { type: "update-complete", apiUpdate });
  }
  dispatchPreDomUpdate() {
    this.events.emit("pre-dom-update", { type: "pre-dom-update" });
  }
  dispatchPreSceneRender() {
    this.events.emit("pre-scene-render", { type: "pre-scene-render" });
  }
  dispatchProcessData({ series }) {
    this.events.emit("process-data", { type: "process-data", series });
  }
};

// packages/ag-charts-community/src/chart/chartContext.ts
var ChartContext = class {
  constructor(chart, vars) {
    this.callbackCache = new CallbackCache();
    this.chartEventManager = new ChartEventManager();
    this.highlightManager = new HighlightManager();
    this.layoutManager = new LayoutManager();
    this.localeManager = new LocaleManager();
    this.seriesStateManager = new SeriesStateManager();
    this.stateManager = new StateManager();
    this.seriesLabelLayoutManager = new SeriesLabelLayoutManager();
    this.destroyFns = [];
    this.contextModules = [];
    const {
      scene,
      root,
      syncManager,
      container,
      fireEvent,
      updateCallback,
      updateMutex,
      styleContainer,
      chartType,
      domMode
    } = vars;
    this.chartService = chart;
    this.syncManager = syncManager;
    this.domManager = new DOMManager(this.chartService, container, styleContainer, domMode);
    this.widgets = new WidgetSet(this.domManager);
    const canvasElement = this.domManager.addChild(
      "canvas",
      "scene-canvas",
      scene?.canvas.element
    );
    this.scene = scene ?? new Scene({ canvasElement });
    this.scene.setRoot(root);
    this.destroyFns.push(
      this.scene.on("scene-changed", () => {
        this.updateService.update(7 /* SCENE_RENDER */);
      })
    );
    this.axisManager = new AxisManager(root);
    this.legendManager = new LegendManager();
    this.annotationManager = new AnnotationManager(chart.annotationRoot, fireEvent);
    this.chartTypeOriginator = new ChartTypeOriginator(chart);
    this.interactionManager = new InteractionManager();
    this.contextMenuRegistry = new ContextMenuRegistry();
    this.updateService = new UpdateService(updateCallback);
    this.proxyInteractionService = new ProxyInteractionService(this.localeManager, this.domManager);
    this.fontManager = new FontManager(this.domManager, this.updateService);
    this.historyManager = new HistoryManager(this.chartEventManager);
    this.animationManager = new AnimationManager(this.interactionManager, updateMutex);
    this.dataService = new DataService(this.animationManager);
    this.tooltipManager = new TooltipManager(this.localeManager, this.domManager, chart.tooltip);
    this.zoomManager = new ZoomManager(fireEvent, this.layoutManager);
    for (const module2 of moduleRegistry.byType("context")) {
      if (!module2.chartTypes.includes(chartType))
        continue;
      const moduleInstance = module2.moduleFactory(this);
      this.contextModules.push(moduleInstance);
      this[module2.contextKey] = moduleInstance;
    }
  }
  destroy() {
    this.animationManager.destroy();
    this.highlightManager.destroy();
    this.axisManager.destroy();
    this.callbackCache.invalidateCache();
    this.chartEventManager.destroy();
    this.domManager.destroy();
    this.fontManager.destroy();
    this.highlightManager.destroy();
    this.proxyInteractionService.destroy();
    this.syncManager.destroy();
    this.tooltipManager.destroy();
    this.zoomManager.destroy();
    this.widgets.destroy();
    this.contextModules.forEach((m) => m.destroy());
    this.destroyFns.forEach((fn) => fn());
  }
};

// packages/ag-charts-community/src/chart/chartHighlight.ts
var ChartHighlight = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.range = "tooltip";
  }
};
__decorateClass([
  Property
], ChartHighlight.prototype, "range", 2);

// packages/ag-charts-community/src/chart/data/caching.ts
var import_ag_charts_core96 = require("ag-charts-core");
function setsEqual(a, b) {
  if (a.size !== b.size)
    return false;
  for (const value of a) {
    if (!b.has(value))
      return false;
  }
  return true;
}
function idsMapEqual(a, b) {
  if (a == null || b == null)
    return a === b;
  if (a.size !== b.size)
    return false;
  for (const [key, aValue] of a) {
    const bValue = b.get(key);
    if (bValue == null)
      return false;
    if (!setsEqual(aValue, bValue))
      return false;
  }
  return true;
}
function propsEqual(a, b) {
  if (a.length !== b.length)
    return false;
  for (let i = 0; i < a.length; i += 1) {
    const { type: typeA, idsMap: idsMapA, scopes: scopesA, data: dataA, ...propA } = a[i];
    const { type: typeB, idsMap: idsMapB, scopes: scopesB, data: dataB, ...propB } = b[i];
    if (typeA !== typeB)
      return false;
    if (scopesA && scopesB && !(0, import_ag_charts_core96.arraysEqual)(scopesA, scopesB))
      return false;
    if (dataA && dataB && dataA !== dataB)
      return false;
    if (!objectsEqual(propA, propB) || !idsMapEqual(idsMapA, idsMapB))
      return false;
  }
  return true;
}
function optsEqual(a, b) {
  const { props: propsA, ...restA } = a;
  const { props: propsB, ...restB } = b;
  return objectsEqual(restA, restB) && propsEqual(propsA, propsB);
}
function canReuseCachedData(cachedDataItem, data, ids, opts) {
  return data === cachedDataItem.data && (0, import_ag_charts_core96.arraysEqual)(ids, cachedDataItem.ids) && optsEqual(opts, cachedDataItem.opts);
}

// packages/ag-charts-community/src/chart/data/dataController.ts
var import_ag_charts_core98 = require("ag-charts-core");

// packages/ag-charts-community/src/chart/data/dataModel.ts
var import_ag_charts_core97 = require("ag-charts-core");

// packages/ag-charts-community/src/chart/data/dataDomain.ts
var DiscreteDomain = class _DiscreteDomain {
  constructor() {
    this.domain = /* @__PURE__ */ new Set();
  }
  static is(value) {
    return value instanceof _DiscreteDomain;
  }
  extend(val) {
    this.domain.add(val);
  }
  getDomain() {
    return Array.from(this.domain);
  }
};
var ContinuousDomain = class _ContinuousDomain {
  constructor() {
    this.domain = [Infinity, -Infinity];
  }
  static is(value) {
    return value instanceof _ContinuousDomain;
  }
  static extendDomain(values, domain = [Infinity, -Infinity]) {
    for (const value of values) {
      if (typeof value !== "number") {
        continue;
      }
      if (domain[0] > value) {
        domain[0] = value;
      }
      if (domain[1] < value) {
        domain[1] = value;
      }
    }
    return domain;
  }
  extend(value) {
    if (this.domain[0] > value) {
      this.domain[0] = value;
    }
    if (this.domain[1] < value) {
      this.domain[1] = value;
    }
  }
  getDomain() {
    return [...this.domain];
  }
};

// packages/ag-charts-community/src/chart/data/rangeLookup.ts
var MIN = 0;
var MAX = 1;
var SPAN = 2;
var RangeLookup = class {
  constructor(allValues) {
    const dataLength = allValues.reduce((acc, v) => Math.max(acc, v.length), 0);
    const sizePower = 32 - Math.clz32(dataLength);
    let maxLevelSize = 1 << sizePower;
    if (dataLength === maxLevelSize / 2) {
      maxLevelSize = maxLevelSize >>> 1;
    }
    this.maxLevelSize = maxLevelSize;
    const buffer = new Float64Array((maxLevelSize * 2 - 1) * 2).fill(NaN);
    for (const values of allValues) {
      for (let i = 0; i < values.length; i += 1) {
        const value = Number(values[i]);
        const bufferIndex = maxLevelSize + i - 1;
        const bufferMinIndex = (bufferIndex * SPAN | 0) + MIN;
        const bufferMaxIndex = (bufferIndex * SPAN | 0) + MAX;
        const prevMinValue = buffer[bufferMinIndex];
        const prevMaxValue = buffer[bufferMaxIndex];
        if (!Number.isFinite(prevMinValue) || value < prevMinValue) {
          buffer[bufferMinIndex] = value;
        }
        if (!Number.isFinite(prevMaxValue) || value > prevMaxValue) {
          buffer[bufferMaxIndex] = value;
        }
      }
    }
    for (let size = maxLevelSize / 2 | 0; size >= 1; size = size / 2 | 0) {
      const start2 = size - 1 | 0;
      const end2 = start2 + size | 0;
      for (let i = 0; i < size; i += 1) {
        const nodeIndex = start2 + i;
        const leftIndex = end2 + i * 2;
        const rightIndex = leftIndex + 1;
        const aMin = buffer[(leftIndex * SPAN | 0) + MIN];
        const bMin = buffer[(rightIndex * SPAN | 0) + MIN];
        buffer[(nodeIndex * SPAN | 0) + MIN] = !Number.isFinite(bMin) || aMin < bMin ? aMin : bMin;
        const aMax = buffer[(leftIndex * SPAN | 0) + MAX];
        const bMax = buffer[(rightIndex * SPAN | 0) + MAX];
        buffer[(nodeIndex * SPAN | 0) + MAX] = !Number.isFinite(bMax) || aMax > bMax ? aMax : bMax;
      }
    }
    this.buffer = buffer;
  }
  computeRangeInto(buffer, start2, end2, bufferIndex, currentStart, step, into) {
    const currentEnd = currentStart + step - 1;
    if (currentEnd < start2 || currentStart >= end2)
      return into;
    if (currentStart >= start2 && currentEnd < end2) {
      const min = buffer[(bufferIndex * SPAN | 0) + MIN];
      const max = buffer[(bufferIndex * SPAN | 0) + MAX];
      if (Number.isFinite(min))
        into[0] = Math.min(into[0], min);
      if (Number.isFinite(max))
        into[1] = Math.max(into[1], max);
    } else if (step > 1) {
      bufferIndex = bufferIndex * 2 | 0;
      step = step / 2 | 0;
      this.computeRangeInto(buffer, start2, end2, bufferIndex + 1 | 0, currentStart, step, into);
      this.computeRangeInto(buffer, start2, end2, bufferIndex + 2 | 0, currentStart + step, step, into);
    }
    return into;
  }
  rangeBetween(start2, end2) {
    if (start2 > end2)
      return [NaN, NaN];
    const { maxLevelSize, buffer } = this;
    const range3 = [Infinity, -Infinity];
    this.computeRangeInto(buffer, start2, end2, 0, 0, maxLevelSize, range3);
    return range3;
  }
  get range() {
    const { buffer } = this;
    return [buffer[MIN], buffer[MAX]];
  }
};

// packages/ag-charts-community/src/chart/data/dataModel.ts
var DOMAIN_RANGES = Symbol("domain-ranges");
function toKeyString(keys) {
  return keys.map((key) => (0, import_ag_charts_core97.isObject)(key) ? JSON.stringify(key) : key).join("-");
}
function fixNumericExtent(extent2) {
  const numberExtent = extent2?.map(Number);
  return numberExtent?.every(Number.isFinite) ? numberExtent : [];
}
function getMissCount(scopeProvider, missMap) {
  return missMap?.get(scopeProvider.id) ?? 0;
}
function isScoped(obj) {
  return "scopes" in obj && Array.isArray(obj.scopes);
}
function createArray(length, value) {
  const out = [];
  for (let i = 0; i < length; i += 1) {
    out[i] = value;
  }
  return out;
}
function datumKeys(keys, columnScope, datumIndex) {
  const out = [];
  for (const k of keys) {
    const key = k.get(columnScope)?.[datumIndex];
    if (key == null)
      return;
    out.push(key);
  }
  return out;
}
function getPathComponents(path) {
  const components = [];
  let matchIndex = 0;
  let matchGroup;
  const regExp = /((?:(?:^|\.)\s*\w+|\[\s*(?:'(?:[^']|(?<!\\)\\')*'|"(?:[^"]|(?<!\\)\\")*"|-?\d+)\s*\])\s*)/g;
  while (matchGroup = regExp.exec(path)) {
    if (matchGroup.index !== matchIndex) {
      return;
    }
    matchIndex = matchGroup.index + matchGroup[0].length;
    const match = matchGroup[1].trim();
    if (match.startsWith(".")) {
      components.push(match.slice(1).trim());
    } else if (match.startsWith("[")) {
      const accessor = match.slice(1, -1).trim();
      if (accessor.startsWith(`'`)) {
        components.push(accessor.slice(1, -1).replace(/(?<!\\)\\'/g, `'`));
      } else if (accessor.startsWith(`"`)) {
        components.push(accessor.slice(1, -1).replace(/(?<!\\)\\"/g, `"`));
      } else {
        components.push(accessor);
      }
    } else {
      components.push(match);
    }
  }
  if (matchIndex !== path.length)
    return;
  return components;
}
function createPathAccessor(components) {
  return (datum) => {
    let current = datum;
    for (const component of components) {
      current = current[component];
    }
    return current;
  };
}
var DataModel = class {
  constructor(opts, mode = "standalone", suppressFieldDotNotation = false) {
    this.opts = opts;
    this.mode = mode;
    this.suppressFieldDotNotation = suppressFieldDotNotation;
    this.debug = Debug.create(true, "data-model");
    this.scopeCache = /* @__PURE__ */ new Map();
    this.keys = [];
    this.values = [];
    this.aggregates = [];
    this.groupProcessors = [];
    this.propertyProcessors = [];
    this.reducers = [];
    this.processors = [];
    this.markScopeDatumInvalid = function(scopes, data, datumIndex, invalidData) {
      for (const scope of scopes) {
        if (!invalidData.has(scope)) {
          invalidData.set(scope, createArray(data.length, false));
        }
        invalidData.get(scope)[datumIndex] = true;
      }
    };
    let keys = true;
    for (const next of opts.props) {
      if (next.type === "key" && !keys) {
        throw new Error("AG Charts - internal config error: keys must come before values.");
      }
      if (next.type === "value" && keys) {
        keys = false;
      }
    }
    const verifyMatchGroupId = ({ matchGroupIds = [] }) => {
      for (const matchGroupId of matchGroupIds) {
        if (this.values.every((def) => def.groupId !== matchGroupId)) {
          throw new Error(
            `AG Charts - internal config error: matchGroupIds properties must match defined groups (${matchGroupId}).`
          );
        }
      }
    };
    const keyScopes = /* @__PURE__ */ new Set();
    const valueScopes = /* @__PURE__ */ new Set();
    for (const def of opts.props) {
      const scopes = def.type === "key" ? keyScopes : valueScopes;
      if (isScoped(def)) {
        def.scopes?.forEach((s) => scopes.add(s));
      }
      switch (def.type) {
        case "key":
          this.keys.push({ ...def, index: this.keys.length, missing: /* @__PURE__ */ new Map() });
          break;
        case "value":
          if (def.property == null) {
            throw new Error(
              `AG Charts - internal config error: no properties specified for value definitions: ${JSON.stringify(
                def
              )}`
            );
          }
          this.values.push({ ...def, index: this.values.length, missing: /* @__PURE__ */ new Map() });
          break;
        case "aggregate":
          verifyMatchGroupId(def);
          this.aggregates.push({ ...def, index: this.aggregates.length });
          break;
        case "group-value-processor":
          verifyMatchGroupId(def);
          this.groupProcessors.push({ ...def, index: this.groupProcessors.length });
          break;
        case "property-value-processor":
          this.propertyProcessors.push({ ...def, index: this.propertyProcessors.length });
          break;
        case "reducer":
          this.reducers.push({ ...def, index: this.reducers.length });
          break;
        case "processor":
          this.processors.push({ ...def, index: this.processors.length });
          break;
      }
    }
    if (!!this.opts.groupByKeys || this.opts.groupByFn != null) {
      const ungroupedScopes = new Set(valueScopes.values());
      keyScopes.forEach((s) => ungroupedScopes.delete(s));
      if (ungroupedScopes.size > 0) {
        throw new Error(
          `AG Charts - scopes missing key for grouping, illegal configuration: ${[...ungroupedScopes.values()]}`
        );
      }
    }
  }
  resolveProcessedDataDefById(scope, searchId) {
    const def = this.scopeCache.get(scope.id)?.get(searchId);
    if (!def) {
      throw new Error(`AG Charts - didn't find property definition for [${searchId}, ${scope.id}]`);
    }
    return { index: def.index, def };
  }
  resolveProcessedDataIndexById(scope, searchId) {
    return this.resolveProcessedDataDefById(scope, searchId).index;
  }
  resolveKeysById(scope, searchId, processedData) {
    const index = this.resolveProcessedDataIndexById(scope, searchId);
    const keys = processedData.keys[index];
    if (keys == null) {
      throw new Error(`AG Charts - didn't find keys for [${searchId}, ${scope.id}]`);
    }
    return keys.get(scope.id);
  }
  hasColumnById(scope, searchId) {
    return this.scopeCache.get(scope.id)?.get(searchId) != null;
  }
  resolveColumnById(scope, searchId, processedData) {
    const index = this.resolveProcessedDataIndexById(scope, searchId);
    const column = processedData.columns?.[index];
    if (column == null) {
      throw new Error(`AG Charts - didn't find column for [${searchId}, ${scope.id}]`);
    }
    return column;
  }
  /**
   * Provides a convenience iterator to iterate over all of the extract datum values in a
   * specific DataGroup.
   *
   * @param scope to which datums should belong
   * @param group containing the datums
   * @param processedData containing the group
   */
  *forEachDatum(scope, processedData, group) {
    const columnIndex = processedData.columnScopes.findIndex((s) => s.has(scope.id));
    for (const datumIndex of group.datumIndices[columnIndex] ?? []) {
      yield processedData.columns[columnIndex][datumIndex];
    }
  }
  /**
   * Provides a convenience iterator to iterate over all of the extracted datum values in a
   * GroupedData.
   *
   * @param scope to which datums should belong
   * @param processedData to iterate through
   */
  *forEachGroupDatum(scope, processedData) {
    const columnIndex = processedData.columnScopes.findIndex((s) => s.has(scope.id));
    const output = {
      groupIndex: 0,
      columnIndex
    };
    const empty = [];
    for (const group of processedData.groups) {
      output.group = group;
      let valueIndex = 0;
      for (const datumIndex of group.datumIndices[columnIndex] ?? empty) {
        output.datumIndex = datumIndex;
        output.valueIndex = valueIndex++;
        yield output;
      }
      output.groupIndex++;
    }
  }
  /**
   * Provides a window-based convenience iterator to iterate over all of the extracted datum
   * values in a GroupedData, including the previous and next entries relative to each datum.
   *
   * @param scope to which datums should belong
   * @param processedData to iterate through
   */
  *forEachGroupDatumTuple(scope, processedData) {
    const columnIndex = processedData.columnScopes.findIndex((s) => s.has(scope.id));
    const output = { columnIndex, datumIndexes: [void 0, void 0, void 0] };
    for (const next of this.forEachGroupDatum(scope, processedData)) {
      output.group = output.nextGroup;
      output.groupIndex = output.nextGroupIndex;
      output.nextGroup = next.group;
      output.nextGroupIndex = next.groupIndex;
      output.datumIndexes[0] = output.datumIndexes[1];
      output.datumIndexes[1] = output.datumIndexes[2];
      output.datumIndexes[2] = next.datumIndex;
      if (output.group != null && output.datumIndexes[1] != null) {
        yield output;
      }
    }
    output.group = output.nextGroup;
    output.groupIndex = output.nextGroupIndex;
    output.nextGroup = void 0;
    output.nextGroupIndex = void 0;
    output.datumIndexes[0] = output.datumIndexes[1];
    output.datumIndexes[1] = output.datumIndexes[2];
    output.datumIndexes[2] = void 0;
    if (output.group != null && output.datumIndexes[1] != null) {
      yield output;
    }
  }
  getDomain(scope, searchId, type, processedData) {
    const domains = this.getDomainsByType(type ?? "value", processedData);
    return domains?.[this.resolveProcessedDataIndexById(scope, searchId)] ?? [];
  }
  getDomainBetweenRange(scope, searchIds, [i0, i1], processedData) {
    const columnIndices = searchIds.map((searchId) => this.resolveProcessedDataIndexById(scope, searchId));
    const cacheKey = columnIndices.join(":");
    const domainRanges = processedData[DOMAIN_RANGES];
    let rangeLookup = domainRanges.get(cacheKey);
    if (rangeLookup == null) {
      const values = columnIndices.map((columnIndex) => processedData.columns[columnIndex]);
      rangeLookup = new RangeLookup(values);
      domainRanges.set(cacheKey, rangeLookup);
    }
    return rangeLookup.rangeBetween(i0, i1);
  }
  getDomainsByType(type, processedData) {
    switch (type) {
      case "key":
        return processedData.domain.keys;
      case "value":
        return processedData.domain.values;
      case "aggregate":
        return processedData.domain.aggValues;
      case "group-value-processor":
        return processedData.domain.groups;
      default:
        return null;
    }
  }
  processData(sources) {
    const {
      opts: { groupByKeys, groupByFn },
      aggregates,
      groupProcessors,
      reducers,
      processors,
      propertyProcessors
    } = this;
    const start2 = performance.now();
    if (groupByKeys && this.keys.length === 0) {
      return;
    }
    let processedData = this.extractData(sources);
    if (groupByKeys) {
      processedData = this.groupData(processedData);
    } else if (groupByFn) {
      processedData = this.groupData(processedData, groupByFn(processedData));
    }
    if (groupProcessors.length > 0 && processedData.type === "grouped") {
      this.postProcessGroups(processedData);
    }
    if (aggregates.length > 0 && processedData.type === "ungrouped") {
      this.aggregateUngroupedData(processedData);
    } else if (aggregates.length > 0 && processedData.type === "grouped") {
      this.aggregateGroupedData(processedData);
    }
    if (propertyProcessors.length > 0) {
      this.postProcessProperties(processedData);
    }
    if (reducers.length > 0) {
      this.reduceData(processedData);
    }
    if (processors.length > 0) {
      this.postProcessData(processedData);
    }
    this.warnDataMissingProperties(sources);
    const end2 = performance.now();
    processedData.time = end2 - start2;
    if (this.debug.check()) {
      logProcessedData(processedData);
    }
    this.processScopeCache();
    return processedData;
  }
  warnDataMissingProperties(sources) {
    if (sources.size === 0)
      return;
    for (const def of (0, import_ag_charts_core97.iterate)(this.keys, this.values)) {
      for (const [scope, missCount] of def.missing) {
        if (missCount < (sources.get(scope)?.length ?? Infinity))
          continue;
        const scopeHint = scope == null ? "" : ` for ${scope}`;
        import_ag_charts_core97.Logger.warnOnce(`the key '${def.property}' was not found in any data element${scopeHint}.`);
      }
    }
  }
  processScopeCache() {
    this.scopeCache.clear();
    for (const def of (0, import_ag_charts_core97.iterate)(this.keys, this.values, this.aggregates)) {
      if (!def.idsMap)
        continue;
      for (const [scope, ids] of def.idsMap) {
        for (const id of ids) {
          if (!this.scopeCache.has(scope)) {
            this.scopeCache.set(scope, /* @__PURE__ */ new Map([[id, def]]));
          } else if (this.scopeCache.get(scope)?.has(id)) {
            throw new Error("duplicate definition ids on the same scope are not allowed.");
          } else {
            this.scopeCache.get(scope).set(id, def);
          }
        }
      }
    }
  }
  valueGroupIdxLookup({ matchGroupIds }) {
    const result = [];
    for (const [index, def] of this.values.entries()) {
      if (!matchGroupIds || def.groupId && matchGroupIds.includes(def.groupId)) {
        result.push(index);
      }
    }
    return result;
  }
  valueIdxLookup(scopes, prop) {
    const noScopesToMatch = scopes == null || scopes.length === 0;
    const propId = typeof prop === "string" ? prop : prop.id;
    const hasMatchingScopeId = (def) => {
      if (def.idsMap) {
        for (const [scope, ids] of def.idsMap) {
          if (scopes?.includes(scope) && ids.has(propId)) {
            return true;
          }
        }
      }
      return false;
    };
    const result = this.values.reduce((res, def, index) => {
      const validDefScopes = def.scopes == null || noScopesToMatch && !def.scopes.length || def.scopes.some((s) => scopes?.includes(s));
      if (validDefScopes && (def.property === propId || def.id === propId || hasMatchingScopeId(def))) {
        res.push(index);
      }
      return res;
    }, []);
    if (result.length === 0) {
      throw new Error(
        `AG Charts - configuration error, unknown property ${JSON.stringify(prop)} in scope(s) ${JSON.stringify(
          scopes
        )}`
      );
    }
    return result;
  }
  extractData(sources) {
    const { dataDomain, processValue, allScopesHaveSameDefs } = this.initDataDomainProcessor();
    const { keys: keyDefs, values: valueDefs } = this;
    const { invalidData, invalidKeys, allKeyMappings } = this.extractKeys(keyDefs, sources, processValue);
    const { columns, columnScopes, partialValidDataCount, maxDataLength } = this.extractValues(
      invalidData,
      valueDefs,
      sources,
      invalidKeys,
      processValue
    );
    const propertyDomain = (def) => {
      const defDomain = dataDomain.get(def);
      const result = defDomain.getDomain();
      if (ContinuousDomain.is(defDomain) && result[0] > result[1]) {
        return [];
      }
      return result;
    };
    return {
      type: "ungrouped",
      input: { count: maxDataLength },
      scopes: new Set(sources.keys()),
      dataSources: sources,
      aggregation: void 0,
      keys: [...allKeyMappings.values()],
      columns,
      columnScopes,
      invalidKeys,
      invalidData,
      domain: {
        keys: keyDefs.map(propertyDomain),
        values: valueDefs.map(propertyDomain)
      },
      defs: {
        allScopesHaveSameDefs,
        keys: keyDefs,
        values: valueDefs
      },
      partialValidDataCount,
      time: 0,
      [DOMAIN_RANGES]: /* @__PURE__ */ new Map()
    };
  }
  extractKeys(keyDefs, sources, processValue) {
    const invalidKeys = /* @__PURE__ */ new Map();
    const invalidData = /* @__PURE__ */ new Map();
    const allKeys = /* @__PURE__ */ new Map();
    let keyDefKeys;
    let scopeDataProcessed;
    const cloneScope = (source, target) => {
      const sourceScope = scopeDataProcessed.get(source);
      keyDefKeys.set(target, keyDefKeys.get(sourceScope));
      if (invalidKeys.has(sourceScope)) {
        invalidKeys.set(target, invalidKeys.get(sourceScope));
        invalidData.set(target, invalidData.get(sourceScope));
      }
    };
    for (const keyDef of keyDefs) {
      const { invalidValue, scopes: keyScopes } = keyDef;
      keyDefKeys = /* @__PURE__ */ new Map();
      scopeDataProcessed = /* @__PURE__ */ new Map();
      allKeys.set(keyDef, keyDefKeys);
      for (const scope of keyScopes ?? []) {
        const data = sources.get(scope) ?? [];
        if (scopeDataProcessed.has(data)) {
          cloneScope(data, scope);
          continue;
        }
        const keys = [];
        keyDefKeys.set(scope, keys);
        scopeDataProcessed.set(data, scope);
        let invalidScopeKeys;
        let invalidScopeData;
        for (let datumIndex = 0; datumIndex < data.length; datumIndex++) {
          if (data[datumIndex] == null || typeof data[datumIndex] !== "object")
            continue;
          const result = processValue(keyDef, data[datumIndex], datumIndex, scope);
          if (result.valid) {
            keys.push(result.value);
            continue;
          }
          keys.push(invalidValue);
          invalidScopeKeys ?? (invalidScopeKeys = createArray(data.length, false));
          invalidScopeData ?? (invalidScopeData = createArray(data.length, false));
          invalidScopeKeys[datumIndex] = true;
          invalidScopeData[datumIndex] = true;
        }
        if (invalidScopeKeys && invalidScopeData) {
          invalidKeys.set(scope, invalidScopeKeys);
          invalidData.set(scope, invalidScopeData);
        }
      }
    }
    return { invalidData, invalidKeys, allKeyMappings: allKeys };
  }
  extractValues(invalidData, valueDefs, sources, invalidKeys, processValue) {
    let partialValidDataCount = 0;
    const columns = [];
    const allColumnScopes = [];
    let maxDataLength = 0;
    for (const def of valueDefs) {
      const { invalidValue } = def;
      const valueSources = new Set(def.scopes.map((s) => sources.get(s)));
      if (valueSources.size > 1) {
        throw new Error(`AG Charts - more than one data source for: ${JSON.stringify(def)}`);
      }
      const columnScopes = new Set(def.scopes);
      const columnScope = (0, import_ag_charts_core97.first)(def.scopes);
      const columnSource = sources.get(columnScope);
      const column = new Array();
      for (let datumIndex = 0; datumIndex < columnSource.length; datumIndex++) {
        if (columnSource[datumIndex] == null || typeof columnSource[datumIndex] !== "object")
          continue;
        const valueDatum = columnSource[datumIndex];
        const invalidKey = invalidKeys.get(columnScope)?.[datumIndex];
        const result = processValue(def, valueDatum, datumIndex, def.scopes);
        let value = result.value;
        if (invalidKey || !result.valid) {
          this.markScopeDatumInvalid(def.scopes, columnSource, datumIndex, invalidData);
        }
        if (invalidKey) {
          value = invalidValue;
        } else if (!result.valid) {
          partialValidDataCount += 1;
          value = invalidValue;
        }
        column[datumIndex] = value;
      }
      columns.push(column);
      allColumnScopes.push(columnScopes);
      maxDataLength = Math.max(maxDataLength, column.length);
    }
    return { columns, columnScopes: allColumnScopes, partialValidDataCount, maxDataLength };
  }
  groupData(data, groupingFn) {
    var _a;
    const groups = /* @__PURE__ */ new Map();
    const { keys: dataKeys, columns: allColumns, columnScopes, invalidKeys, invalidData } = data;
    const allScopes = data.scopes;
    const processedColumnIndexes = /* @__PURE__ */ new Set();
    for (const scope of allScopes) {
      const scopeColumnIndexes = allColumns.map((_, idx) => idx).filter((idx) => !processedColumnIndexes.has(idx) && columnScopes[idx].has(scope));
      if (scopeColumnIndexes.length === 0)
        continue;
      for (const idx of scopeColumnIndexes) {
        processedColumnIndexes.add(idx);
      }
      const siblingScopes = /* @__PURE__ */ new Set();
      for (const columnIdx of scopeColumnIndexes) {
        for (const columnScope of columnScopes[columnIdx]) {
          siblingScopes.add(columnScope);
        }
      }
      const scopeKeys = dataKeys.map((k) => k.get(scope)).filter((k) => k != null);
      const firstColumn = allColumns[(0, import_ag_charts_core97.first)(scopeColumnIndexes)];
      const scopeInvalidData = invalidData?.get(scope);
      const scopeInvalidKeys = invalidKeys?.get(scope);
      for (let datumIndex = 0; datumIndex < firstColumn.length; datumIndex++) {
        if (scopeInvalidKeys?.[datumIndex] === true)
          continue;
        const keys = scopeKeys.map((k) => k[datumIndex]);
        if (keys == null || keys.length === 0) {
          throw new Error("AG Charts - no keys found for scope: " + scope);
        }
        const group = groupingFn?.(keys) ?? keys;
        const groupStr = toKeyString(group);
        const outputGroup = groups.get(groupStr) ?? {
          keys: group,
          datumIndices: [],
          validScopes: allScopes
        };
        if (!groups.has(groupStr)) {
          groups.set(groupStr, outputGroup);
        }
        if (scopeInvalidData?.[datumIndex] === true) {
          if (outputGroup.validScopes === allScopes) {
            outputGroup.validScopes = new Set(allScopes.values());
          }
          for (const invalidScope of siblingScopes) {
            outputGroup.validScopes.delete(invalidScope);
          }
        }
        for (const columnIdx of scopeColumnIndexes) {
          (_a = outputGroup.datumIndices)[columnIdx] ?? (_a[columnIdx] = []);
          outputGroup.datumIndices[columnIdx].push(datumIndex);
        }
      }
    }
    const resultGroups = [];
    const resultData = [];
    for (const { keys, datumIndices, validScopes } of groups.values()) {
      resultGroups.push(keys);
      resultData.push({
        datumIndices,
        keys,
        aggregation: [],
        validScopes
      });
    }
    return {
      ...data,
      type: "grouped",
      domain: {
        ...data.domain,
        groups: resultGroups
      },
      groups: resultData
    };
  }
  aggregateUngroupedData(processedData) {
    const domainAggValues = this.aggregates.map(() => [Infinity, -Infinity]);
    processedData.domain.aggValues = domainAggValues;
    const { keys, columns, dataSources } = processedData;
    const onlyScope = (0, import_ag_charts_core97.first)(dataSources.keys());
    const rawData = dataSources.get(onlyScope);
    processedData.aggregation = rawData?.map((_, datumIndex) => {
      const aggregation = [];
      for (const [index, def] of this.aggregates.entries()) {
        const indices = this.valueGroupIdxLookup(def);
        let groupAggValues = def.groupAggregateFunction?.() ?? [Infinity, -Infinity];
        const valuesToAgg = indices.map((columnIndex) => columns[columnIndex][datumIndex]);
        const k = datumKeys(keys, onlyScope, datumIndex);
        const valuesAgg = k != null ? def.aggregateFunction(valuesToAgg, k) : void 0;
        if (valuesAgg) {
          groupAggValues = def.groupAggregateFunction?.(valuesAgg, groupAggValues) ?? ContinuousDomain.extendDomain(valuesAgg, groupAggValues);
        }
        const finalValues = def.finalFunction?.(groupAggValues) ?? groupAggValues;
        aggregation[index] = finalValues;
        ContinuousDomain.extendDomain(finalValues, domainAggValues[index]);
      }
      return aggregation;
    });
  }
  aggregateGroupedData(processedData) {
    const domainAggValues = this.aggregates.map(() => [Infinity, -Infinity]);
    processedData.domain.aggValues = domainAggValues;
    const { columns } = processedData;
    for (const [index, def] of this.aggregates.entries()) {
      const indices = this.valueGroupIdxLookup(def);
      for (const group of processedData.groups) {
        group.aggregation ?? (group.aggregation = []);
        const groupKeys = group.keys;
        let groupAggValues = def.groupAggregateFunction?.() ?? [Infinity, -Infinity];
        const maxDatumIndex = Math.max(
          ...indices.map((columnIndex) => group.datumIndices[columnIndex]?.length ?? 0)
        );
        for (let datumIndex = 0; datumIndex < maxDatumIndex; datumIndex++) {
          const valuesToAgg = indices.map(
            (columnIndex) => columns[columnIndex][group.datumIndices[columnIndex]?.[datumIndex]]
          );
          const valuesAgg = def.aggregateFunction(valuesToAgg, groupKeys);
          if (valuesAgg) {
            groupAggValues = def.groupAggregateFunction?.(valuesAgg, groupAggValues) ?? ContinuousDomain.extendDomain(valuesAgg, groupAggValues);
          }
        }
        const finalValues = def.finalFunction?.(groupAggValues) ?? groupAggValues;
        group.aggregation[index] = finalValues;
        ContinuousDomain.extendDomain(finalValues, domainAggValues[index]);
      }
    }
  }
  postProcessGroups(processedData) {
    const { groupProcessors } = this;
    const { columnScopes, columns, invalidData } = processedData;
    for (const processor of groupProcessors) {
      const valueIndexes = this.valueGroupIdxLookup(processor);
      const adjustFn = processor.adjust()();
      for (const dataGroup of processedData.groups) {
        adjustFn(columns, valueIndexes, dataGroup);
      }
      for (const valueIndex of valueIndexes) {
        const valueDef = this.values[valueIndex];
        const isDiscrete = valueDef.valueType === "category";
        const column = columns[valueIndex];
        const columnScope = (0, import_ag_charts_core97.first)(columnScopes[valueIndex]);
        const invalidDatums = invalidData?.get(columnScope);
        const domain = isDiscrete ? new DiscreteDomain() : new ContinuousDomain();
        for (let datumIndex = 0; datumIndex < column.length; datumIndex += 1) {
          if (invalidDatums?.[datumIndex] === true)
            continue;
          domain.extend(column[datumIndex]);
        }
        processedData.domain.values[valueIndex] = domain.getDomain();
      }
    }
  }
  postProcessProperties(processedData) {
    for (const { adjust, property, scopes } of this.propertyProcessors) {
      for (const idx of this.valueIdxLookup(scopes, property)) {
        adjust()(processedData, idx);
      }
    }
  }
  reduceData(processedData) {
    processedData.reduced ?? (processedData.reduced = {});
    const { dataSources, keys } = processedData;
    for (const def of this.reducers) {
      const reducer = def.reducer();
      let accValue = def.initialValue;
      if (processedData.type === "grouped") {
        for (const group of processedData.groups) {
          accValue = reducer(accValue, group.keys);
        }
      } else {
        const onlyScope = (0, import_ag_charts_core97.first)(dataSources.keys());
        const keyColumns = keys.map((k) => k.get(onlyScope)).filter((k) => k != null);
        const keysParam = keyColumns.map(() => void 0);
        const rawData = dataSources.get(onlyScope);
        for (let datumIndex = 0; datumIndex < rawData.length; datumIndex += 1) {
          for (let keyIdx = 0; keyIdx < keysParam.length; keyIdx++) {
            keysParam[keyIdx] = keyColumns[keyIdx]?.[datumIndex];
          }
          accValue = reducer(accValue, keysParam);
        }
      }
      processedData.reduced[def.property] = accValue;
    }
  }
  postProcessData(processedData) {
    processedData.reduced ?? (processedData.reduced = {});
    for (const def of this.processors) {
      processedData.reduced[def.property] = def.calculate(
        processedData,
        processedData.reduced[def.property]
      );
    }
  }
  initDataDomainProcessor() {
    const { keys: keyDefs, values: valueDefs } = this;
    const scopes = /* @__PURE__ */ new Set();
    for (const valueDef of valueDefs) {
      if (!valueDef.scopes)
        continue;
      for (const scope of valueDef.scopes) {
        scopes.add(scope);
      }
    }
    const dataDomain = /* @__PURE__ */ new Map();
    const processorFns = /* @__PURE__ */ new Map();
    let allScopesHaveSameDefs = true;
    const initDataDomain = () => {
      for (const def of (0, import_ag_charts_core97.iterate)(keyDefs, valueDefs)) {
        if (def.valueType === "category") {
          dataDomain.set(def, new DiscreteDomain());
        } else {
          dataDomain.set(def, new ContinuousDomain());
          allScopesHaveSameDefs && (allScopesHaveSameDefs = (def.scopes ?? []).length === scopes.size);
        }
      }
    };
    initDataDomain();
    const accessors = this.buildAccessors((0, import_ag_charts_core97.iterate)(keyDefs, valueDefs));
    const reusableResult = {
      value: void 0,
      missing: false,
      valid: false
    };
    const processValue = (def, datum, idx, valueScopes) => {
      let valueInDatum;
      let value;
      if (accessors.has(def.property)) {
        try {
          value = accessors.get(def.property)(datum);
        } catch {
        }
        valueInDatum = value != null;
      } else {
        valueInDatum = def.property in datum;
        value = valueInDatum ? datum[def.property] : def.missingValue;
      }
      if (def.forceValue != null) {
        const valueNegative = valueInDatum && (0, import_ag_charts_core97.isNegative)(value);
        value = valueNegative ? -1 * def.forceValue : def.forceValue;
        valueInDatum = true;
      }
      reusableResult.missing = !valueInDatum;
      const missingValueDef = "missingValue" in def;
      if (!valueInDatum && !missingValueDef) {
        if (typeof valueScopes === "string") {
          const missCount = def.missing.get(valueScopes) ?? 0;
          def.missing.set(valueScopes, missCount + 1);
        } else {
          for (const scope of valueScopes) {
            const missCount = def.missing.get(scope) ?? 0;
            def.missing.set(scope, missCount + 1);
          }
        }
      }
      if (!dataDomain.has(def)) {
        initDataDomain();
      }
      if (valueInDatum && def.validation?.(value, datum, idx) === false) {
        reusableResult.valid = false;
        if ("invalidValue" in def) {
          value = def.invalidValue;
        } else {
          if (this.mode !== "integrated") {
            import_ag_charts_core97.Logger.warnOnce(
              `invalid value of type [${typeof value}] for [${def.scopes} / ${def.id}] ignored:`,
              `[${value}]`
            );
          }
          reusableResult.value = void 0;
          return reusableResult;
        }
      } else {
        reusableResult.valid = true;
      }
      if (def.processor) {
        let processor = processorFns.get(def);
        if (processor == null) {
          processor = def.processor();
          processorFns.set(def, processor);
        }
        value = processor(value, idx);
      }
      dataDomain.get(def)?.extend(value);
      reusableResult.value = value;
      return reusableResult;
    };
    return { dataDomain, processValue, initDataDomain, scopes, allScopesHaveSameDefs };
  }
  buildAccessors(defs) {
    const result = /* @__PURE__ */ new Map();
    if (this.suppressFieldDotNotation) {
      return result;
    }
    for (const def of defs) {
      const isPath = def.property.includes(".") || def.property.includes("[");
      if (!isPath)
        continue;
      const components = getPathComponents(def.property);
      if (components == null) {
        import_ag_charts_core97.Logger.warnOnce("Invalid property path [%s]", def.property);
        continue;
      }
      const accessor = createPathAccessor(components);
      result.set(def.property, accessor);
    }
    return result;
  }
};
function logProcessedData(processedData) {
  const logValues = (name, data) => {
    if (data.length > 0) {
      import_ag_charts_core97.Logger.log(`DataModel.processData() - ${name}`);
      import_ag_charts_core97.Logger.table(data);
    }
  };
  import_ag_charts_core97.Logger.log("DataModel.processData() - processedData", processedData);
  logValues("Key Domains", processedData.domain.keys);
  logValues("Group Domains", processedData.domain.groups ?? []);
  logValues("Value Domains", processedData.domain.values);
  logValues("Aggregate Domains", processedData.domain.aggValues ?? []);
}

// packages/ag-charts-community/src/chart/data/dataController.ts
var _DataController = class _DataController {
  constructor(mode, suppressFieldDotNotation) {
    this.mode = mode;
    this.suppressFieldDotNotation = suppressFieldDotNotation;
    this.debug = Debug.create(true, "data-model");
    this.requested = [];
    this.status = "setup";
  }
  async request(id, data, opts) {
    if (this.status !== "setup") {
      throw new Error(`AG Charts - data request after data setup phase.`);
    }
    return new Promise((resolve, reject) => {
      this.requested.push({ id, opts, data, resolve, reject });
    });
  }
  execute(cachedData) {
    if (this.status !== "setup") {
      throw new Error(`AG Charts - data request after data setup phase.`);
    }
    this.status = "executed";
    this.debug("DataController.execute() - requested", this.requested);
    const valid = this.validateRequests(this.requested);
    this.debug("DataController.execute() - validated", valid);
    const merged = this.mergeRequested(valid);
    this.debug("DataController.execute() - merged", merged);
    if (this.debug.check()) {
      (0, import_ag_charts_core98.getWindow)().processedData = [];
    }
    const nextCachedData = [];
    for (const { data, ids, opts, resolves, rejects } of merged) {
      const reusableCache = cachedData?.find((cacheItem) => canReuseCachedData(cacheItem, data, ids, opts));
      let dataModel;
      let processedData;
      if (reusableCache == null) {
        try {
          dataModel = new DataModel(opts, this.mode, this.suppressFieldDotNotation);
          const sources = new Map(valid.map((v) => [v.id, v.data]));
          processedData = dataModel.processData(sources);
        } catch (error) {
          rejects.forEach((cb) => cb(error));
          continue;
        }
      } else {
        ({ dataModel, processedData } = reusableCache);
      }
      nextCachedData.push({ opts, data, ids, dataModel, processedData });
      if (this.debug.check()) {
        (0, import_ag_charts_core98.getWindow)("processedData").push(processedData);
      }
      if (processedData?.partialValidDataCount === 0) {
        resolves.forEach(
          (resolve) => resolve({
            dataModel,
            processedData
          })
        );
      } else if (processedData) {
        this.splitResult(dataModel, processedData, ids, resolves);
      } else {
        rejects.forEach((cb) => cb(new Error(`AG Charts - no processed data generated`)));
      }
    }
    return nextCachedData;
  }
  validateRequests(requested) {
    const valid = [];
    for (const [index, request] of requested.entries()) {
      if (index > 0 && request.data.length !== requested[0].data.length && request.opts.groupByData === false && request.opts.groupByKeys === false) {
        request.reject(
          new Error("all series[].data arrays must be of the same length and have matching keys.")
        );
      } else {
        valid.push(request);
      }
    }
    return valid;
  }
  mergeRequested(requested) {
    const grouped = [];
    for (const request of requested) {
      const match = grouped.find(_DataController.groupMatch(request));
      if (match) {
        match.push(request);
      } else {
        grouped.push([request]);
      }
    }
    return grouped.map(_DataController.mergeRequests);
  }
  splitResult(dataModel, processedData, scopes, resolves) {
    for (let i = 0; i < scopes.length; i++) {
      const resolve = resolves[i];
      resolve({
        dataModel,
        processedData
      });
    }
  }
  static groupMatch({ data, opts }) {
    function keys(props2) {
      return props2.filter((p) => p.type === "key").map((p) => p.property).join(";");
    }
    const { groupByData, groupByKeys = false, groupByFn, props } = opts;
    const propsKeys = keys(props);
    return ([group]) => (groupByData === false || group.data === data) && (group.opts.groupByKeys ?? false) === groupByKeys && group.opts.groupByFn === groupByFn && keys(group.opts.props) === propsKeys;
  }
  static mergeRequests(requests) {
    const crossScopeMergableTypes = /* @__PURE__ */ new Set(["key", "group-value-processor"]);
    return requests.reduce(
      (result, { id, data, resolve, reject, opts: { props, ...opts } }) => {
        result.ids.push(id);
        result.rejects.push(reject);
        result.resolves.push(resolve);
        result.data ?? (result.data = data);
        result.opts ?? (result.opts = { ...opts, props: [] });
        for (const prop of props) {
          const clone2 = { ...prop, scopes: [id], data };
          _DataController.createIdsMap(id, clone2);
          const match = result.opts.props.find(
            (existing) => existing.type === clone2.type && (crossScopeMergableTypes.has(existing.type) || existing.data === clone2.data) && _DataController.deepEqual(existing, clone2)
          );
          if (!match) {
            result.opts.props.push(clone2);
            continue;
          }
          match.scopes ?? (match.scopes = []);
          match.scopes.push(...clone2.scopes ?? []);
          if ((match.type === "key" || match.type === "value") && clone2.idsMap?.size) {
            _DataController.mergeIdsMap(clone2.idsMap, match.idsMap);
          }
        }
        return result;
      },
      { ids: [], rejects: [], resolves: [], data: null, opts: null }
    );
  }
  static mergeIdsMap(fromMap, toMap) {
    for (const [scope, ids] of fromMap) {
      const toMapValue = toMap.get(scope);
      if (toMapValue == null) {
        toMap.set(scope, new Set(ids));
      } else {
        for (const id of ids) {
          toMapValue.add(id);
        }
      }
    }
  }
  static createIdsMap(scope, prop) {
    if (prop.id == null)
      return;
    prop.idsMap ?? (prop.idsMap = /* @__PURE__ */ new Map());
    if (prop.idsMap.has(scope)) {
      prop.idsMap.get(scope).add(prop.id);
    } else {
      prop.idsMap.set(scope, /* @__PURE__ */ new Set([prop.id]));
    }
  }
  static deepEqual(a, b) {
    if (a === b) {
      return true;
    }
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor) {
        return false;
      }
      let i, length;
      if (Array.isArray(a)) {
        length = a.length;
        if (length !== b.length) {
          return false;
        }
        for (i = length - 1; i >= 0; i--) {
          if (!_DataController.deepEqual(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
      const keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) {
        return false;
      }
      for (i = length - 1; i >= 0; i--) {
        const key = keys[i];
        if (!_DataController.skipKeys.has(key) && (!Object.hasOwn(b, key) || !_DataController.deepEqual(a[key], b[key]))) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
};
// optimized version of deep equality for `mergeRequests` which can potentially loop over 1M times
_DataController.skipKeys = /* @__PURE__ */ new Set(["id", "idsMap", "type", "scopes", "data"]);
var DataController = _DataController;

// packages/ag-charts-community/src/chart/factory/axisRegistry.ts
var AxisRegistry = class {
  constructor() {
    this.axesMap = /* @__PURE__ */ new Map();
    this.themeTemplates = /* @__PURE__ */ new Map();
  }
  register(axisType, module2) {
    this.axesMap.set(axisType, module2.moduleFactory);
    if (module2.themeTemplate) {
      this.setThemeTemplate(axisType, module2.themeTemplate);
    }
  }
  create(axisType, moduleContext) {
    const axisFactory = this.axesMap.get(axisType);
    if (axisFactory) {
      return axisFactory(moduleContext);
    }
    throw new Error(`AG Charts - unknown axis type: ${axisType}`);
  }
  has(axisType) {
    return this.axesMap.has(axisType);
  }
  keys() {
    return this.axesMap.keys();
  }
  setThemeTemplate(axisType, themeTemplate) {
    this.themeTemplates.set(axisType, themeTemplate);
    return this;
  }
  getThemeTemplate(axisType) {
    return this.themeTemplates.get(axisType);
  }
};
var axisRegistry = new AxisRegistry();

// packages/ag-charts-community/src/chart/factory/expectedEnterpriseModules.ts
var EXPECTED_ENTERPRISE_MODULES = [
  {
    type: "root",
    optionsKey: "animation",
    chartTypes: ["cartesian", "polar", "hierarchy", "topology", "flow-proportion", "standalone", "gauge"]
  },
  { type: "root", optionsKey: "annotations", chartTypes: ["cartesian"] },
  {
    type: "root",
    optionsKey: "background",
    chartTypes: ["cartesian", "polar", "hierarchy", "topology", "flow-proportion", "standalone", "gauge"],
    optionsInnerKey: "image"
  },
  {
    type: "root",
    optionsKey: "foreground",
    chartTypes: ["cartesian", "polar", "hierarchy", "topology", "flow-proportion", "standalone", "gauge"],
    optionsInnerKey: "image"
  },
  {
    type: "root",
    optionsKey: "chartToolbar",
    chartTypes: ["cartesian"]
  },
  {
    type: "root",
    optionsKey: "contextMenu",
    chartTypes: ["cartesian", "polar", "hierarchy", "topology", "flow-proportion", "standalone", "gauge"]
  },
  { type: "root", optionsKey: "statusBar", chartTypes: ["cartesian"], identifier: "status-bar" },
  {
    type: "root",
    optionsKey: "dataSource",
    chartTypes: ["cartesian", "polar", "hierarchy", "topology", "flow-proportion", "standalone", "gauge"]
  },
  { type: "root", optionsKey: "sync", chartTypes: ["cartesian"] },
  { type: "root", optionsKey: "zoom", chartTypes: ["cartesian", "topology"] },
  { type: "root", optionsKey: "ranges", chartTypes: ["cartesian"] },
  {
    type: "legend",
    optionsKey: "gradientLegend",
    chartTypes: ["cartesian", "polar", "hierarchy", "topology", "flow-proportion", "standalone", "gauge"],
    identifier: "gradient"
  },
  { type: "root", optionsKey: "navigator", chartTypes: ["cartesian"] },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "angle-category" },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "angle-number" },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "radius-category" },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "radius-number" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "bar", community: true },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "line", community: true },
  { type: "axis", optionsKey: "axes[]", chartTypes: ["cartesian"], identifier: "ordinal-time" },
  { type: "axis-option", optionsKey: "crosshair", chartTypes: ["cartesian"] },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "box-plot" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "candlestick" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "cone-funnel" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "funnel" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "ohlc" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "heatmap" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "range-area" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "range-bar" },
  { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "waterfall" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "nightingale" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radar-area" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radar-line" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radial-bar" },
  { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radial-column" },
  { type: "series", optionsKey: "series[]", chartTypes: ["hierarchy"], identifier: "sunburst" },
  { type: "series", optionsKey: "series[]", chartTypes: ["hierarchy"], identifier: "treemap" },
  { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-shape" },
  { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-line" },
  { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-marker" },
  { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-shape-background" },
  { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-line-background" },
  { type: "series", optionsKey: "series[]", chartTypes: ["flow-proportion"], identifier: "chord" },
  { type: "series", optionsKey: "series[]", chartTypes: ["flow-proportion"], identifier: "sankey" },
  { type: "series", optionsKey: "series[]", chartTypes: ["standalone"], identifier: "pyramid" },
  { type: "series", optionsKey: "series[]", chartTypes: ["gauge"], identifier: "linear-gauge" },
  { type: "series", optionsKey: "series[]", chartTypes: ["gauge"], identifier: "radial-gauge" },
  { type: "series-option", optionsKey: "errorBar", chartTypes: ["cartesian"], identifier: "error-bars" },
  { type: "context", contextKey: "sharedToolbar", chartTypes: ["cartesian"] }
];
function getEnterpriseSeriesChartTypes(type) {
  return EXPECTED_ENTERPRISE_MODULES.find((s) => s.type === "series" && s.identifier === type)?.chartTypes;
}
function isEnterpriseCartesian(seriesType) {
  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === "cartesian");
  return type === "cartesian";
}
function isEnterprisePolar(seriesType) {
  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === "polar");
  return type === "polar";
}
function isEnterpriseHierarchy(seriesType) {
  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === "hierarchy");
  return type === "hierarchy";
}
function isEnterpriseTopology(seriesType) {
  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === "topology");
  return type === "topology";
}
function isEnterpriseFlowProportion(seriesType) {
  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === "flow-proportion");
  return type === "flow-proportion";
}
function isEnterpriseStandalone(seriesType) {
  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === "standalone");
  return type === "standalone";
}
function isEnterpriseGauge(seriesType) {
  const type = getEnterpriseSeriesChartTypes(seriesType)?.find((v) => v === "gauge");
  return type === "gauge";
}

// packages/ag-charts-community/src/chart/factory/legendRegistry.ts
var LegendRegistry = class {
  constructor() {
    this.legendMap = /* @__PURE__ */ new Map();
    this.themeTemplates = /* @__PURE__ */ new Map();
  }
  register(legendType, { optionsKey, moduleFactory, themeTemplate }) {
    this.legendMap.set(legendType, { optionsKey, moduleFactory });
    this.themeTemplates.set(optionsKey, themeTemplate);
  }
  create(legendType, moduleContext) {
    const legendFactory = this.legendMap.get(legendType)?.moduleFactory;
    if (legendFactory) {
      return legendFactory(moduleContext);
    }
    throw new Error(`AG Charts - unknown legend type: ${legendType}`);
  }
  getThemeTemplates() {
    return Object.fromEntries(this.themeTemplates);
  }
  getKeys() {
    return Array.from(this.legendMap.entries()).reduce(
      (result, [legendType, record]) => {
        result[legendType] = record.optionsKey;
        return result;
      },
      {}
    );
  }
};
var legendRegistry = new LegendRegistry();

// packages/ag-charts-community/src/chart/factory/chartTypes.ts
var ChartTypes = class extends Map {
  get(seriesType) {
    return super.get(seriesType) ?? "unknown";
  }
  isCartesian(seriesType) {
    return this.get(seriesType) === "cartesian";
  }
  isPolar(seriesType) {
    return this.get(seriesType) === "polar";
  }
  isHierarchy(seriesType) {
    return this.get(seriesType) === "hierarchy";
  }
  isTopology(seriesType) {
    return this.get(seriesType) === "topology";
  }
  isFlowProportion(seriesType) {
    return this.get(seriesType) === "flow-proportion";
  }
  isStandalone(seriesType) {
    return this.get(seriesType) === "standalone";
  }
  isGauge(seriesType) {
    return this.get(seriesType) === "gauge";
  }
  get seriesTypes() {
    return Array.from(this.keys());
  }
  get cartesianTypes() {
    return this.seriesTypes.filter((t) => this.isCartesian(t));
  }
  get polarTypes() {
    return this.seriesTypes.filter((t) => this.isPolar(t));
  }
  get hierarchyTypes() {
    return this.seriesTypes.filter((t) => this.isHierarchy(t));
  }
  get topologyTypes() {
    return this.seriesTypes.filter((t) => this.isTopology(t));
  }
  get flowProportionTypes() {
    return this.seriesTypes.filter((t) => this.isFlowProportion(t));
  }
  get standaloneTypes() {
    return this.seriesTypes.filter((t) => this.isStandalone(t));
  }
  get gaugeTypes() {
    return this.seriesTypes.filter((t) => this.isGauge(t));
  }
};
var ChartDefaults = class extends Map {
  set(chartType, defaults) {
    return super.set(chartType, mergeDefaults(defaults, this.get(chartType)));
  }
};
var chartTypes3 = new ChartTypes();
var publicChartTypes = new ChartTypes();
var chartDefaults = new ChartDefaults();

// packages/ag-charts-community/src/chart/factory/seriesRegistry.ts
var SeriesRegistry = class {
  constructor() {
    this.seriesMap = /* @__PURE__ */ new Map();
    this.themeTemplates = /* @__PURE__ */ new Map();
  }
  register(seriesType, {
    chartTypes: [chartType],
    moduleFactory,
    tooltipDefaults,
    defaultAxes,
    themeTemplate,
    solo,
    stackable,
    groupable,
    stackedByDefault,
    hidden
  }) {
    this.setThemeTemplate(seriesType, themeTemplate);
    this.seriesMap.set(seriesType, {
      moduleFactory,
      tooltipDefaults,
      defaultAxes,
      solo,
      stackable,
      groupable,
      stackedByDefault
    });
    chartTypes3.set(seriesType, chartType);
    if (!hidden) {
      publicChartTypes.set(seriesType, chartType);
    }
  }
  create(seriesType, moduleContext) {
    const seriesFactory = this.seriesMap.get(seriesType)?.moduleFactory;
    if (seriesFactory) {
      return seriesFactory(moduleContext);
    }
    throw new Error(`AG Charts - unknown series type: ${seriesType}`);
  }
  cloneDefaultAxes(seriesType) {
    const defaultAxes = this.seriesMap.get(seriesType)?.defaultAxes;
    if (defaultAxes == null)
      return null;
    return { axes: deepClone(defaultAxes) };
  }
  setThemeTemplate(seriesType, themeTemplate) {
    const currentTemplate = this.themeTemplates.get(seriesType);
    this.themeTemplates.set(seriesType, mergeDefaults(themeTemplate, currentTemplate));
  }
  getThemeTemplate(seriesType) {
    return this.themeTemplates.get(seriesType);
  }
  getTooltipDefauls(seriesType) {
    return this.seriesMap.get(seriesType)?.tooltipDefaults;
  }
  isSolo(seriesType) {
    return this.seriesMap.get(seriesType)?.solo ?? false;
  }
  isGroupable(seriesType) {
    return this.seriesMap.get(seriesType)?.groupable ?? false;
  }
  isStackable(seriesType) {
    return this.seriesMap.get(seriesType)?.stackable ?? false;
  }
  isStackedByDefault(seriesType) {
    return this.seriesMap.get(seriesType)?.stackedByDefault ?? false;
  }
};
var seriesRegistry = new SeriesRegistry();

// packages/ag-charts-community/src/chart/interaction/syncManager.ts
var _SyncManager = class _SyncManager extends BaseManager {
  constructor(chart) {
    super();
    this.chart = chart;
  }
  subscribe(groupId = _SyncManager.DEFAULT_GROUP) {
    let syncGroup = this.get(groupId);
    if (!syncGroup) {
      syncGroup = { members: /* @__PURE__ */ new Set() };
      _SyncManager.chartsGroups.set(groupId, syncGroup);
    }
    syncGroup.members.add(this.chart);
    return this;
  }
  unsubscribe(groupId = _SyncManager.DEFAULT_GROUP) {
    const groupState = this.get(groupId);
    groupState?.members.delete(this.chart);
    delete groupState?.domains?.x?.sources?.[this.chart.id];
    delete groupState?.domains?.y?.sources?.[this.chart.id];
    return this;
  }
  getChart() {
    return this.chart;
  }
  getGroupState(groupId = _SyncManager.DEFAULT_GROUP) {
    return this.get(groupId);
  }
  getGroupMembers(groupId = _SyncManager.DEFAULT_GROUP) {
    const syncGroup = this.get(groupId);
    return syncGroup ? Array.from(syncGroup.members) : [];
  }
  getGroupSiblings(groupId = _SyncManager.DEFAULT_GROUP) {
    return this.getGroupMembers(groupId).filter((chart) => chart !== this.chart);
  }
  getGroupSyncMode(groupId = _SyncManager.DEFAULT_GROUP) {
    if (this.getGroupMembers(groupId).some((c) => c.series.length > 1)) {
      return "multi-series";
    }
    return "single-series";
  }
  get(groupId) {
    return _SyncManager.chartsGroups.get(groupId);
  }
};
_SyncManager.chartsGroups = /* @__PURE__ */ new Map();
_SyncManager.DEFAULT_GROUP = Symbol("sync-group-default");
var SyncManager = _SyncManager;

// packages/ag-charts-community/src/chart/keyboard.ts
var Keyboard = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = false;
  }
};
__decorateClass([
  Property
], Keyboard.prototype, "enabled", 2);
__decorateClass([
  Property
], Keyboard.prototype, "tabIndex", 2);

// packages/ag-charts-community/src/chart/mapping/prepareAxis.ts
var CartesianAxisPositions = ["top", "right", "bottom", "left"];
function isAxisPosition(position) {
  return typeof position === "string" && CartesianAxisPositions.includes(position);
}
function guessInvalidPositions(axes) {
  const invalidAxes = [];
  const usedPositions = [];
  const guesses = [...CartesianAxisPositions];
  for (const axis of axes) {
    if (axis instanceof CartesianAxis) {
      if (isAxisPosition(axis.position)) {
        usedPositions.push(axis.position);
      } else {
        invalidAxes.push(axis);
      }
    }
  }
  for (const axis of invalidAxes) {
    let nextGuess;
    do {
      nextGuess = guesses.pop();
    } while (nextGuess && usedPositions.includes(nextGuess));
    if (nextGuess == null)
      break;
    axis.position = nextGuess;
  }
}

// packages/ag-charts-community/src/chart/mapping/prepareSeries.ts
var MATCHING_KEYS = ["direction", "xKey", "yKey", "sizeKey", "angleKey", "radiusKey", "normalizedTo"];
function matchSeriesOptions(series, optSeries, oldOptsSeries) {
  const generateKey = (type, i, opts) => {
    const result = [type];
    for (const key of MATCHING_KEYS) {
      if (key in i && i[key] != null)
        result.push(`${key}=${i[key]}`);
    }
    if (opts?.seriesGrouping) {
      result.push(`seriesGrouping.groupId=${opts?.seriesGrouping.groupId}`);
    }
    return result.join(";");
  };
  const seriesMap = /* @__PURE__ */ new Map();
  let idx = 0;
  for (const s of series) {
    const key = generateKey(s.type, s.properties, oldOptsSeries?.[idx]);
    if (!seriesMap.has(key)) {
      seriesMap.set(key, []);
    }
    seriesMap.get(key)?.push([s, idx++]);
  }
  const optsMap = /* @__PURE__ */ new Map();
  idx = 0;
  for (const o of optSeries) {
    const key = generateKey(o.type, o, o);
    if (!optsMap.has(key)) {
      optsMap.set(key, []);
    }
    optsMap.get(key)?.push([o, idx++]);
  }
  const overlap = [...seriesMap.keys()].some((k) => optsMap.has(k));
  if (!overlap) {
    return { status: "no-overlap", oldKeys: seriesMap.keys(), newKeys: optsMap.keys() };
  }
  const changes = [];
  for (const [key, optsTuples] of optsMap.entries()) {
    for (const [opts, targetIdx] of optsTuples) {
      const seriesArray = seriesMap.get(key);
      if (seriesArray == null || seriesArray.length < 1) {
        changes.push({ opts, targetIdx, idx: targetIdx, status: "add" });
        seriesMap.delete(key);
        continue;
      }
      const [outputSeries, currentIdx] = seriesArray.shift();
      const previousOpts = oldOptsSeries?.[currentIdx] ?? {};
      const diff2 = jsonDiff(previousOpts, opts ?? {});
      const { groupIndex, stackIndex } = diff2?.seriesGrouping ?? {};
      if (groupIndex != null || stackIndex != null) {
        changes.push({
          opts,
          series: outputSeries,
          diff: diff2,
          targetIdx,
          idx: currentIdx,
          status: "series-grouping"
        });
      } else if (diff2) {
        changes.push({
          opts,
          series: outputSeries,
          diff: diff2,
          targetIdx,
          idx: currentIdx,
          status: "update"
        });
      } else {
        changes.push({ opts, series: outputSeries, targetIdx, idx: currentIdx, status: "no-op" });
      }
      if (seriesArray.length === 0) {
        seriesMap.delete(key);
      }
    }
  }
  for (const seriesArray of seriesMap.values()) {
    for (const [outputSeries, currentIdx] of seriesArray) {
      changes.push({ series: outputSeries, idx: currentIdx, targetIdx: -1, status: "remove" });
    }
  }
  return { status: "overlap", changes };
}

// packages/ag-charts-community/src/chart/mapping/types.ts
function optionsType(input) {
  const { series } = input;
  return series?.[0]?.type ?? "line";
}
function isAgCartesianChartOptions(input) {
  const specifiedType = optionsType(input);
  return chartTypes3.isCartesian(specifiedType) || isEnterpriseCartesian(specifiedType);
}
function isAgPolarChartOptions(input) {
  const specifiedType = optionsType(input);
  return chartTypes3.isPolar(specifiedType) || isEnterprisePolar(specifiedType);
}
function isAgHierarchyChartOptions(input) {
  const specifiedType = optionsType(input);
  return chartTypes3.isHierarchy(specifiedType) || isEnterpriseHierarchy(specifiedType);
}
function isAgTopologyChartOptions(input) {
  const specifiedType = optionsType(input);
  return chartTypes3.isTopology(specifiedType) || isEnterpriseTopology(specifiedType);
}
function isAgFlowProportionChartOptions(input) {
  const specifiedType = optionsType(input);
  return chartTypes3.isFlowProportion(specifiedType) || isEnterpriseFlowProportion(specifiedType);
}
function isAgStandaloneChartOptions(input) {
  const specifiedType = optionsType(input);
  return chartTypes3.isStandalone(specifiedType) || isEnterpriseStandalone(specifiedType);
}
function isAgGaugeChartOptions(input) {
  const specifiedType = optionsType(input);
  return chartTypes3.isGauge(specifiedType) || isEnterpriseGauge(specifiedType);
}

// packages/ag-charts-community/src/chart/modulesManager.ts
var ModulesManager = class extends ModuleMap {
  applyOptions(options) {
    for (const m of this.moduleMap.values()) {
      if (m.module.optionsKey in options && isProperties(m.moduleInstance)) {
        m.moduleInstance.set(options[m.module.optionsKey]);
      }
    }
  }
  *legends() {
    for (const { module: module2, moduleInstance } of this.moduleMap.values()) {
      if (module2.type !== "legend")
        continue;
      yield {
        legendType: module2.identifier,
        legend: moduleInstance
      };
    }
  }
};

// packages/ag-charts-community/src/chart/overlay/overlay.ts
var import_ag_charts_core99 = require("ag-charts-core");
var DEFAULT_OVERLAY_CLASS = "ag-charts-overlay";
var DEFAULT_OVERLAY_DARK_CLASS = "ag-charts-dark-overlay";
var Overlay = class extends BaseProperties {
  constructor(className, defaultMessageId) {
    super();
    this.className = className;
    this.defaultMessageId = defaultMessageId;
    this.enabled = true;
  }
  getText(localeManager) {
    return localeManager.t(this.text ?? this.defaultMessageId);
  }
  getElement(animationManager, localeManager, rect) {
    this.content?.remove();
    this.focusBox = rect;
    if (this.renderer) {
      const htmlContent = this.renderer();
      if (htmlContent instanceof HTMLElement) {
        this.content = htmlContent;
      } else {
        const tempDiv = (0, import_ag_charts_core99.createElement)("div");
        tempDiv.innerHTML = htmlContent;
        const { firstElementChild } = tempDiv;
        if (firstElementChild instanceof HTMLElement && tempDiv.childElementCount === 1) {
          this.content = firstElementChild;
        } else {
          this.content = tempDiv;
        }
      }
    } else {
      const content = (0, import_ag_charts_core99.createElement)("div", {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        boxSizing: "border-box",
        height: "100%",
        margin: "8px",
        fontFamily: "var(--ag-charts-font-family)",
        fontSize: "var(--ag-charts-font-size)",
        fontWeight: "var(--ag-charts-font-weight)"
      });
      content.innerText = this.getText(localeManager);
      this.content = content;
      animationManager?.animate({
        from: 0,
        to: 1,
        id: "overlay",
        phase: "add",
        groupId: "opacity",
        onUpdate(value) {
          content.style.opacity = String(value);
        },
        onStop() {
          content.style.opacity = "1";
        }
      });
    }
    return this.content;
  }
  removeElement(cleanup = () => this.content?.remove(), animationManager) {
    if (!this.content)
      return;
    if (animationManager) {
      const { content } = this;
      animationManager.animate({
        from: 1,
        to: 0,
        phase: "remove",
        id: "overlay",
        groupId: "opacity",
        onUpdate(value) {
          content.style.opacity = String(value);
        },
        onStop() {
          cleanup?.();
        }
      });
    } else {
      cleanup?.();
    }
    this.content = void 0;
    this.focusBox = void 0;
  }
};
__decorateClass([
  Property
], Overlay.prototype, "enabled", 2);
__decorateClass([
  Property
], Overlay.prototype, "text", 2);
__decorateClass([
  Property
], Overlay.prototype, "renderer", 2);

// packages/ag-charts-community/src/chart/overlay/chartOverlays.ts
var ChartOverlays = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.darkTheme = false;
    this.loading = new Overlay("ag-charts-loading-overlay", "overlayLoadingData");
    this.noData = new Overlay("ag-charts-no-data-overlay", "overlayNoData");
    this.noVisibleSeries = new Overlay("ag-charts-no-visible-series", "overlayNoVisibleSeries");
    this.unsupportedBrowser = new Overlay("ag-charts-unsupported-browser", "overlayUnsupportedBrowser");
  }
  getFocusInfo(localeManager) {
    for (const overlay of [this.loading, this.noData, this.noVisibleSeries, this.unsupportedBrowser]) {
      if (overlay.focusBox !== void 0) {
        return { text: overlay.getText(localeManager), rect: overlay.focusBox };
      }
    }
    return void 0;
  }
  destroy() {
    this.loading.removeElement();
    this.noData.removeElement();
    this.noVisibleSeries.removeElement();
    this.unsupportedBrowser.removeElement();
  }
};
__decorateClass([
  Property
], ChartOverlays.prototype, "darkTheme", 2);
__decorateClass([
  Property
], ChartOverlays.prototype, "loading", 2);
__decorateClass([
  Property
], ChartOverlays.prototype, "noData", 2);
__decorateClass([
  Property
], ChartOverlays.prototype, "noVisibleSeries", 2);
__decorateClass([
  Property
], ChartOverlays.prototype, "unsupportedBrowser", 2);

// packages/ag-charts-community/src/chart/overlay/loadingSpinner.ts
var import_ag_charts_core100 = require("ag-charts-core");
function getLoadingSpinner(text, defaultDuration) {
  const { animationDuration } = PHASE_METADATA["add"];
  const duration = animationDuration * defaultDuration;
  const container = (0, import_ag_charts_core100.createElement)("div", `${DEFAULT_OVERLAY_CLASS}--loading`, {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "column",
    height: "100%",
    boxSizing: "border-box",
    font: "13px Verdana, sans-serif",
    // FONT_SIZE.MEDIUM
    userSelect: "none",
    animation: `ag-charts-loading ${duration}ms linear 50ms both`
  });
  const matrix = (0, import_ag_charts_core100.createElement)("span", {
    width: "45px",
    height: "40px",
    backgroundImage: [
      "linear-gradient(#0000 calc(1 * 100% / 6), #ccc 0 calc(3 * 100% / 6), #0000 0), ",
      "linear-gradient(#0000 calc(2 * 100% / 6), #ccc 0 calc(4 * 100% / 6), #0000 0), ",
      "linear-gradient(#0000 calc(3 * 100% / 6), #ccc 0 calc(5 * 100% / 6), #0000 0)"
    ].join(""),
    backgroundSize: "10px 400%",
    backgroundRepeat: "no-repeat",
    animation: "ag-charts-loading-matrix 1s infinite linear"
  });
  const label = (0, import_ag_charts_core100.createElement)("p", { marginTop: "1em" });
  label.innerText = text;
  const background = (0, import_ag_charts_core100.createElement)("div", `${DEFAULT_OVERLAY_CLASS}__loading-background`, {
    position: "absolute",
    inset: "0",
    opacity: "0.5",
    zIndex: "-1"
  });
  const animationStyles = (0, import_ag_charts_core100.createElement)("style");
  animationStyles.innerText = [
    "@keyframes ag-charts-loading { from { opacity: 0 } to { opacity: 1 } }",
    "@keyframes ag-charts-loading-matrix {",
    "0% { background-position: 0% 0%, 50% 0%, 100% 0%; }",
    "100% { background-position: 0% 100%, 50% 100%, 100% 100%; }",
    "}"
  ].join(" ");
  container.replaceChildren(animationStyles, matrix, label, background);
  return container;
}

// packages/ag-charts-community/src/chart/series/series.ts
var import_ag_charts_core101 = require("ag-charts-core");

// packages/ag-charts-community/src/chart/series/shapeUtil.ts
function getShapeFill(fill, defaultGradient, defaultPattern, defaultImage) {
  if (isGradientFill(fill)) {
    return {
      type: "gradient",
      gradient: fill.gradient ?? defaultGradient.gradient,
      colorStops: fill.colorStops ?? defaultGradient.colorStops,
      bounds: fill.bounds ?? defaultGradient.bounds,
      rotation: fill.rotation ?? defaultGradient.rotation,
      reverse: fill.reverse ?? defaultGradient.reverse
    };
  }
  if (isPatternFill(fill)) {
    const pattern = fill.pattern ?? defaultPattern.pattern;
    let strokeWidth = fill.strokeWidth;
    if (pattern === "backward-slanted-lines" || pattern === "forward-slanted-lines" || pattern === "horizontal-lines" || pattern === "vertical-lines") {
      strokeWidth ?? (strokeWidth = defaultPattern.strokeWidth);
    } else {
      strokeWidth ?? (strokeWidth = 0);
    }
    const width2 = fill.width ?? fill.height ?? defaultPattern.width;
    const height2 = fill.height ?? fill.width ?? defaultPattern.height;
    return {
      type: "pattern",
      pattern,
      width: width2,
      height: height2,
      path: fill.path,
      padding: fill.padding ?? defaultPattern.padding,
      fill: fill.fill ?? defaultPattern.fill,
      fillOpacity: fill.fillOpacity ?? defaultPattern.fillOpacity,
      backgroundFill: fill.backgroundFill ?? defaultPattern.backgroundFill,
      backgroundFillOpacity: fill.backgroundFillOpacity ?? defaultPattern.backgroundFillOpacity,
      stroke: fill.stroke ?? defaultPattern.stroke,
      strokeOpacity: fill.strokeOpacity ?? defaultPattern.strokeOpacity,
      strokeWidth,
      rotation: fill.rotation ?? defaultPattern.rotation,
      scale: fill.scale ?? defaultPattern.scale
    };
  }
  if (isImageFill(fill)) {
    return {
      type: "image",
      url: fill.url,
      width: fill.width,
      height: fill.height,
      backgroundFill: fill.backgroundFill ?? defaultImage.backgroundFill,
      backgroundFillOpacity: fill.backgroundFillOpacity ?? defaultImage.backgroundFillOpacity,
      rotation: fill.rotation ?? defaultImage.rotation,
      repeat: fill.repeat ?? defaultImage.repeat,
      fit: fill.fit ?? defaultImage.fit
    };
  }
  return fill;
}
function getShapeStyle(style, defaultGradient, defaultPattern, defaultImage) {
  if (!isGradientFill(style?.fill) && !isPatternFill(style?.fill) && !isImageFill(style?.fill))
    return style;
  return {
    ...style,
    fill: getShapeFill(style.fill, defaultGradient, defaultPattern, defaultImage)
  };
}
function applyShapeFillBBox(shape, fill, fillBBox, fillParams) {
  if (fillBBox == null || !isGradientFill(fill) || fill.bounds == null || fill.bounds === "item") {
    shape.fillBBox = void 0;
  } else {
    shape.fillBBox = fillBBox[fill.bounds];
  }
  shape.fillParams = fillParams;
}
function applyShapeStyle(shape, style, overrides, fillBBox, fillParams) {
  const fill = overrides?.fill ?? style.fill;
  shape.fill = fill;
  applyShapeFillBBox(shape, overrides?.fill ?? style.fill, fillBBox, fillParams);
  shape.fillOpacity = overrides?.fillOpacity ?? style.fillOpacity ?? 1;
  shape.stroke = overrides?.stroke ?? style.stroke;
  shape.strokeOpacity = overrides?.strokeOpacity ?? style.strokeOpacity ?? 1;
  shape.strokeWidth = overrides?.strokeWidth ?? style.strokeWidth ?? 0;
  shape.lineDash = overrides?.lineDash ?? style.lineDash;
  shape.lineDashOffset = overrides?.lineDashOffset ?? style.lineDashOffset ?? 0;
}

// packages/ag-charts-community/src/chart/series/series.ts
var CROSS_FILTER_MARKER_FILL_OPACITY_FACTOR = 0.25;
var CROSS_FILTER_MARKER_STROKE_OPACITY_FACTOR = 0.125;
var SeriesNodeEvent = class {
  constructor(type, event, nodeDatum, series) {
    this.type = type;
    this.event = event;
    this.defaultPrevented = false;
    this.datum = nodeDatum.datum;
    this.seriesId = series.id;
  }
  preventDefault() {
    this.defaultPrevented = true;
  }
};
var SeriesGroupingChangedEvent = class {
  constructor(series, seriesGrouping, oldGrouping) {
    this.series = series;
    this.seriesGrouping = seriesGrouping;
    this.oldGrouping = oldGrouping;
    this.type = "groupingChanged";
  }
};
var Series = class extends Observable {
  constructor(seriesOpts) {
    super();
    this.destroyFns = [];
    this.usesPlacedLabels = false;
    this.seriesGrouping = void 0;
    this.NodeEvent = SeriesNodeEvent;
    this.internalId = (0, import_ag_charts_core101.createId)(this);
    // The group node that contains the series rendering in its default (non-highlighted) state.
    this.contentGroup = new TranslatableGroup({
      name: `${this.internalId}-content`,
      zIndex: 1 /* ANY_CONTENT */
    });
    // The group node that contains all highlighted series items. This is a performance optimisation
    // for large-scale data-sets, where the only thing that routinely varies is the currently
    // highlighted node.
    this.highlightGroup = new TranslatableGroup({
      name: `${this.internalId}-highlight`,
      zIndex: 1 /* ANY_CONTENT */
    });
    // Error bars etc.
    this.annotationGroup = new TranslatableGroup({
      name: `${this.internalId}-annotation`
    });
    // Lazily initialised labelGroup for label presentation.
    this.labelGroup = new TranslatableGroup({
      name: `${this.internalId}-series-labels`
    });
    this.axes = {};
    this.directions = ["x" /* X */, "y" /* Y */];
    // Flag to determine if we should recalculate node data.
    this.nodeDataRefresh = true;
    this.moduleMap = new ModuleMap();
    this.datumCallbackCache = /* @__PURE__ */ new Map();
    this.connectsToYAxis = false;
    this._declarationOrder = -1;
    this.seriesListeners = new Listeners();
    this._pickNodeCache = new LRUCache();
    const {
      moduleCtx,
      pickModes,
      directionKeys = {},
      directionNames = {},
      canHaveAxes = false,
      usesPlacedLabels = false
    } = seriesOpts;
    this.ctx = moduleCtx;
    this.directionKeys = directionKeys;
    this.directionNames = directionNames;
    this.canHaveAxes = canHaveAxes;
    this.usesPlacedLabels = usesPlacedLabels;
    this.highlightGroup = new TranslatableGroup({
      name: `${this.internalId}-highlight`
    });
    this.highlightNode = this.highlightGroup.appendChild(new Group({ name: "highlightNode", zIndex: 0 }));
    this.highlightLabel = this.highlightGroup.appendChild(new Group({ name: "highlightLabel", zIndex: 10 }));
    this.pickModes = pickModes;
  }
  get pickModeAxis() {
    return "main";
  }
  get id() {
    return this.properties?.id ?? this.internalId;
  }
  get type() {
    return this.constructor.type ?? "";
  }
  get focusable() {
    return true;
  }
  get data() {
    return this._data ?? this._chartData;
  }
  set visible(newVisibility) {
    this.properties.visible = newVisibility;
    this.ctx.legendManager.toggleItem(newVisibility, this.id);
    this.ctx.legendManager.update();
    this.visibleMaybeChanged();
  }
  get visible() {
    return this.ctx.legendManager.getSeriesEnabled(this.id) ?? this.properties.visible;
  }
  get hasData() {
    return this.data != null && this.data.length > 0;
  }
  get tooltipEnabled() {
    return this.properties.tooltip?.enabled;
  }
  onDataChange() {
    this.nodeDataRefresh = true;
    this._pickNodeCache.clear();
  }
  setOptionsData(input) {
    this._data = input;
    this.onDataChange();
  }
  setChartData(input) {
    this._chartData = input;
    if (this.data === input) {
      this.onDataChange();
    }
  }
  onSeriesGroupingChange(prev, next) {
    const { internalId, type, visible } = this;
    if (prev) {
      this.ctx.seriesStateManager.deregisterSeries(this);
    }
    if (next) {
      this.ctx.seriesStateManager.registerSeries({ internalId, type, visible, seriesGrouping: next });
    }
    this.fireEvent(new SeriesGroupingChangedEvent(this, next, prev));
  }
  getBandScalePadding() {
    return { inner: 1, outer: 0 };
  }
  attachSeries(seriesContentNode, seriesNode, annotationNode) {
    seriesContentNode.appendChild(this.contentGroup);
    seriesNode.appendChild(this.highlightGroup);
    seriesNode.appendChild(this.labelGroup);
    annotationNode?.appendChild(this.annotationGroup);
  }
  detachSeries(seriesContentNode, seriesNode, annotationNode) {
    seriesContentNode?.removeChild(this.contentGroup);
    seriesNode.removeChild(this.highlightGroup);
    seriesNode.removeChild(this.labelGroup);
    annotationNode?.removeChild(this.annotationGroup);
  }
  setSeriesIndex(index) {
    if (index === this._declarationOrder)
      return false;
    this._declarationOrder = index;
    this.contentGroup.zIndex = [1 /* ANY_CONTENT */, index, 0 /* FOREGROUND */];
    this.highlightGroup.zIndex = [1 /* ANY_CONTENT */, index, 1 /* HIGHLIGHT */];
    this.labelGroup.zIndex = [1 /* ANY_CONTENT */, index, 2 /* LABEL */];
    this.annotationGroup.zIndex = index;
    return true;
  }
  renderToOffscreenCanvas() {
    return false;
  }
  addEventListener(type, listener) {
    return super.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    return super.removeEventListener(type, listener);
  }
  hasEventListener(type) {
    return super.hasEventListener(type);
  }
  addListener(type, listener) {
    return this.seriesListeners.addListener(type, listener);
  }
  dispatch(type, event) {
    this.seriesListeners.dispatch(type, event);
  }
  addChartEventListeners() {
    return;
  }
  updatedDomains() {
  }
  destroy() {
    this.destroyFns.forEach((f) => f());
    this.destroyFns = [];
    this.resetDatumCallbackCache();
    this.ctx.seriesStateManager.deregisterSeries(this);
  }
  getDirectionValues(direction, properties) {
    const resolvedDirection = this.resolveKeyDirection(direction);
    const keys = properties?.[resolvedDirection];
    const values = [];
    if (!keys) {
      return values;
    }
    const addValues = (...items) => {
      for (const value of items) {
        if (Array.isArray(value)) {
          addValues(...value);
        } else if (typeof value === "object") {
          addValues(...Object.values(value));
        } else {
          values.push(value);
        }
      }
    };
    addValues(...keys.map((key) => this.properties[key]));
    return values;
  }
  getKeys(direction) {
    return this.getDirectionValues(direction, this.directionKeys);
  }
  getKeyProperties(direction) {
    return this.directionKeys[this.resolveKeyDirection(direction)] ?? [];
  }
  getNames(direction) {
    return this.getDirectionValues(direction, this.directionNames);
  }
  resolveKeyDirection(direction) {
    return direction;
  }
  // The union of the series domain ('community') and series-option domains ('enterprise').
  getDomain(direction) {
    const seriesDomain = this.getSeriesDomain(direction);
    const moduleDomains = this.moduleMap.mapModules((module2) => module2.getDomain(direction)).flat();
    return moduleDomains.length !== 0 ? seriesDomain.concat(moduleDomains) : seriesDomain;
  }
  getRange(direction, visibleRange) {
    return this.getSeriesRange(direction, visibleRange);
  }
  getVisibleItems(_xVisibleRange, _yVisibleRange, _minVisibleItems) {
    return Infinity;
  }
  // Indicate that something external changed and we should recalculate nodeData.
  markNodeDataDirty() {
    this.nodeDataRefresh = true;
    this._pickNodeCache.clear();
    this.visibleMaybeChanged();
  }
  visibleMaybeChanged() {
    this.ctx.seriesStateManager.updateSeries(this);
  }
  getOpacity() {
    const defaultOpacity = 1;
    const { dimOpacity = 1, enabled = true } = this.properties.highlightStyle.series;
    if (!enabled || dimOpacity === defaultOpacity) {
      return defaultOpacity;
    }
    switch (this.isItemIdHighlighted()) {
      case 0 /* None */:
      case 1 /* This */:
        return defaultOpacity;
      case 2 /* Other */:
      default:
        return dimOpacity;
    }
  }
  getStrokeWidth(defaultStrokeWidth) {
    const { strokeWidth, enabled = true } = this.properties.highlightStyle.series;
    if (!enabled || strokeWidth === void 0) {
      return defaultStrokeWidth;
    }
    switch (this.isItemIdHighlighted()) {
      case 1 /* This */:
        return strokeWidth;
      case 0 /* None */:
      case 2 /* Other */:
        return defaultStrokeWidth;
    }
  }
  isItemIdHighlighted() {
    const series = this.ctx.highlightManager?.getActiveHighlight()?.series;
    if (series == null) {
      return 0 /* None */;
    }
    if (series !== this) {
      return 2 /* Other */;
    }
    return 1 /* This */;
  }
  getModuleTooltipParams() {
    return this.moduleMap.mapModules((module2) => module2.getTooltipParams()).reduce((total, current) => Object.assign(total, current), {});
  }
  pickNodes(point, intent, exactMatchOnly = false) {
    const { pickModes, pickModeAxis, visible, contentGroup } = this;
    if (!visible || !contentGroup.visible)
      return;
    if (intent === "highlight" && !this.properties.highlight.enabled)
      return;
    if (intent === "highlight-tooltip" && !this.properties.highlight.enabled)
      return;
    let maxDistance = Infinity;
    if (intent === "tooltip" || intent === "highlight-tooltip") {
      const { tooltip } = this.properties;
      maxDistance = typeof tooltip.range === "number" ? tooltip.range : Infinity;
      exactMatchOnly || (exactMatchOnly = tooltip.range === "exact");
    } else if (intent === "event" || intent === "context-menu") {
      const { nodeClickRange } = this.properties;
      maxDistance = typeof nodeClickRange === "number" ? nodeClickRange : Infinity;
      exactMatchOnly || (exactMatchOnly = nodeClickRange === "exact");
    }
    const selectedPickModes = pickModes.filter(
      (m) => !exactMatchOnly || m === 0 /* EXACT_SHAPE_MATCH */
    );
    const { x, y } = point;
    const key = JSON.stringify({ x, y, maxDistance, selectedPickModes });
    if (this._pickNodeCache.has(key)) {
      return this._pickNodeCache.get(key);
    }
    for (const pickMode of selectedPickModes) {
      let result;
      switch (pickMode) {
        case 0 /* EXACT_SHAPE_MATCH */: {
          const exact = this.pickNodesExactShape(point);
          result = exact.length === 0 ? void 0 : { datums: exact, distance: 0 };
          break;
        }
        case 1 /* NEAREST_NODE */: {
          const closest = this.pickNodeClosestDatum(point);
          const exact = closest?.distance === 0 ? this.pickNodesExactShape(point) : void 0;
          if (exact != null && exact.length !== 0) {
            result = { datums: exact, distance: 0 };
          } else if (closest) {
            result = { datums: [closest.datum], distance: closest.distance };
          } else {
            result = void 0;
          }
          break;
        }
        case 2 /* AXIS_ALIGNED */: {
          const closest = pickModeAxis != null ? this.pickNodeMainAxisFirst(point, pickModeAxis === "main-category") : void 0;
          result = closest != null ? { datums: [closest.datum], distance: closest.distance } : void 0;
          break;
        }
      }
      if (result && result.distance <= maxDistance) {
        return this._pickNodeCache.set(key, { pickMode, datums: result.datums, distance: result.distance });
      }
    }
    return this._pickNodeCache.set(key, void 0);
  }
  pickNodesExactShape(point) {
    const datums = [];
    for (const node of this.contentGroup.pickNodes(point.x, point.y)) {
      const datum = node.closestDatum();
      if (datum != null && datum.missing !== true) {
        datums.push(datum);
      }
    }
    return datums;
  }
  pickNodeClosestDatum(_point) {
    throw new Error("AG Charts - Series.pickNodeClosestDatum() not implemented");
  }
  pickNodeNearestDistantObject(point, items) {
    const match = nearestSquared(point.x, point.y, items);
    const datum = match.nearest?.closestDatum();
    if (datum != null && datum.missing !== true) {
      return { datum, distance: Math.sqrt(match.distanceSquared) };
    }
  }
  pickNodeMainAxisFirst(_point, _requireCategoryAxis) {
    throw new Error("AG Charts - Series.pickNodeMainAxisFirst() not implemented");
  }
  getLabelData() {
    return [];
  }
  updatePlacedLabelData(_labels) {
    return;
  }
  fireNodeClickEvent(event, datum) {
    const clickEvent = new this.NodeEvent("seriesNodeClick", event, datum, this);
    this.fireEvent(clickEvent);
    return !clickEvent.defaultPrevented;
  }
  fireNodeDoubleClickEvent(event, datum) {
    const clickEvent = new this.NodeEvent("seriesNodeDoubleClick", event, datum, this);
    this.fireEvent(clickEvent);
    return !clickEvent.defaultPrevented;
  }
  createNodeContextMenuActionEvent(event, datum) {
    return new this.NodeEvent("nodeContextMenuAction", event, datum, this);
  }
  onLegendInitialState(legendType, initialState) {
    const { visible = true, itemId, legendItemName } = initialState ?? {};
    this.toggleSeriesItem(visible, legendType, itemId, legendItemName);
  }
  onLegendItemClick(event) {
    const { enabled, itemId, series, legendType } = event;
    const legendItemName = "legendItemName" in this.properties ? this.properties.legendItemName : void 0;
    const legendItemKey = "legendItemKey" in this.properties ? this.properties.legendItemKey : void 0;
    const matchedLegendItemName = legendItemName != void 0 && legendItemName === event.legendItemName;
    if (series.id === this.id || matchedLegendItemName || legendItemKey != void 0) {
      this.toggleSeriesItem(enabled, legendType, itemId, legendItemName, event);
    }
  }
  onLegendItemDoubleClick(event) {
    const { enabled, itemId, series, numVisibleItems, legendType } = event;
    const legendItemName = "legendItemName" in this.properties ? this.properties.legendItemName : void 0;
    const legendItemKey = "legendItemKey" in this.properties ? this.properties.legendItemKey : void 0;
    const matchedLegendItemName = legendItemName != void 0 && legendItemName === event.legendItemName;
    if (series.id === this.id || matchedLegendItemName || legendItemKey != void 0) {
      this.toggleSeriesItem(true, legendType, itemId, legendItemName, event);
    } else if (enabled && numVisibleItems === 1) {
      this.toggleSeriesItem(true, legendType, void 0, legendItemName);
    } else {
      this.toggleSeriesItem(false, legendType, void 0, legendItemName);
    }
  }
  toggleSeriesItem(enabled, legendType, itemId, legendItemName, legendEvent) {
    const seriesId = this.id;
    if (enabled || legendType !== "category") {
      this.visible = enabled;
    }
    this.nodeDataRefresh = true;
    this._pickNodeCache.clear();
    const event = {
      type: "seriesVisibilityChange",
      seriesId,
      itemId,
      legendItemName: legendEvent?.legendItemName ?? legendItemName,
      visible: enabled
    };
    this.fireEvent(event);
    this.ctx.legendManager.toggleItem(enabled, seriesId, itemId, legendItemName);
  }
  isEnabled() {
    return this.visible;
  }
  getModuleMap() {
    return this.moduleMap;
  }
  createModuleContext() {
    return { ...this.ctx, series: this };
  }
  getLabelText(label, params, defaultFormatter = formatValue) {
    if (label.formatter) {
      return this.cachedCallWithContext(label.formatter, { seriesId: this.id, ...params }) ?? this.callWithContext(defaultFormatter, params.value);
    }
    return this.callWithContext(defaultFormatter, params.value);
  }
  getMarkerStyle(marker, datum, params, highlighted = false, size = marker.size ?? 0, defaultStyle) {
    const { itemStyler, fillGradientDefaults, fillPatternDefaults, fillImageDefaults } = marker;
    const defaultSize = { size };
    let markerStyle = getShapeStyle(
      mergeDefaults(defaultSize, defaultStyle, marker.getStyle()),
      fillGradientDefaults,
      fillPatternDefaults,
      fillImageDefaults
    );
    if (itemStyler && params) {
      const style = this.cachedCallWithContext(itemStyler, {
        seriesId: this.id,
        ...markerStyle,
        ...params,
        highlighted,
        datum
      });
      markerStyle = getShapeStyle(
        mergeDefaults(style, markerStyle),
        fillGradientDefaults,
        fillPatternDefaults,
        fillImageDefaults
      );
    }
    return markerStyle;
  }
  updateMarkerStyle(marker, markerNode, datum, point, params, highlighted, defaultStyle, fillBBox, { applyTranslation = true, selected = true } = {}) {
    const activeStyle = this.getMarkerStyle(marker, datum, params, highlighted, point?.size, defaultStyle);
    const { shape, size } = activeStyle;
    const visible = this.visible && size > 0 && point && !isNaN(point.x) && !isNaN(point.y);
    applyShapeStyle(markerNode, activeStyle, void 0, fillBBox);
    if (applyTranslation) {
      markerNode.setProperties({
        visible,
        shape,
        size,
        x: point?.x,
        y: point?.y,
        scalingCenterX: point?.x,
        scalingCenterY: point?.y
      });
    } else {
      markerNode.setProperties({ visible, shape, size });
    }
    if (!selected) {
      markerNode.fillOpacity *= CROSS_FILTER_MARKER_FILL_OPACITY_FACTOR;
      markerNode.strokeOpacity *= CROSS_FILTER_MARKER_STROKE_OPACITY_FACTOR;
    }
    if (typeof marker.shape === "function" && !markerNode.dirtyPath) {
      markerNode.path.clear(true);
      markerNode.updatePath();
      markerNode.checkPathDirty();
      const bb = markerNode.getBBox();
      if (point !== void 0 && bb.isFinite()) {
        const center2 = bb.computeCenter();
        const [dx, dy] = ["x", "y"].map(
          (key) => (activeStyle.strokeWidth ?? 0) + Math.abs(center2[key] - point[key])
        );
        point.focusSize = Math.max(bb.width + dx, bb.height + dy);
      }
    }
  }
  get nodeDataDependencies() {
    return this._nodeDataDependencies ?? { seriesRectWidth: NaN, seriesRectHeight: NaN };
  }
  checkResize(newSeriesRect) {
    const { width: seriesRectWidth, height: seriesRectHeight } = newSeriesRect ?? { width: NaN, height: NaN };
    const newNodeDataDependencies = newSeriesRect ? { seriesRectWidth, seriesRectHeight } : void 0;
    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;
    if (resize) {
      this._nodeDataDependencies = newNodeDataDependencies;
      this.markNodeDataDirty();
    }
    return resize;
  }
  pickFocus(_opts) {
    return void 0;
  }
  resetDatumCallbackCache() {
    this.datumCallbackCache.clear();
  }
  cachedDatumCallback(id, fn) {
    const { datumCallbackCache } = this;
    const existing = datumCallbackCache.get(id);
    if (existing != null)
      return existing;
    try {
      const value = fn();
      datumCallbackCache.set(id, value);
      return value;
    } catch (error) {
      import_ag_charts_core101.Logger.error(String(error));
    }
  }
  cachedCallWithContext(fn, ...params) {
    return this.ctx.callbackCache.call(this.properties, this.ctx.chartService, fn, ...params);
  }
  callWithContext(fn, ...params) {
    return callWithContext(this.properties, this.ctx.chartService, fn, params);
  }
  formatTooltipWithContext(tooltip, content, params) {
    return tooltip.formatTooltip(this.properties, this.ctx.chartService, content, params);
  }
};
__decorateClass([
  ActionOnSet({
    changeValue: function(newVal, oldVal) {
      this.onSeriesGroupingChange(oldVal, newVal);
    }
  })
], Series.prototype, "seriesGrouping", 2);

// packages/ag-charts-community/src/chart/series/seriesAreaManager.ts
var import_ag_charts_core109 = require("ag-charts-core");

// packages/ag-charts-community/src/dom/focusIndicator.ts
var import_ag_charts_core103 = require("ag-charts-core");

// packages/ag-charts-community/src/scene/shape/path.ts
var import_ag_charts_core102 = require("ag-charts-core");
var Path = class extends Shape {
  constructor() {
    super(...arguments);
    /**
     * Declare a path to retain for later rendering and hit testing
     * using custom Path2D class. Think of it as a TypeScript version
     * of the native Path2D (with some differences) that works in all browsers.
     */
    this.path = new ExtendedPath2D();
    this._clipX = NaN;
    this._clipY = NaN;
    this.clip = false;
    /**
     * The path only has to be updated when certain attributes change.
     * For example, if transform attributes (such as `translationX`)
     * are changed, we don't have to update the path. The `dirtyPath` flag
     * is how we keep track if the path has to be updated or not.
     */
    this._dirtyPath = true;
    this.lastPixelRatio = NaN;
  }
  set clipX(value) {
    this._clipX = value;
    this.dirtyPath = true;
  }
  set clipY(value) {
    this._clipY = value;
    this.dirtyPath = true;
  }
  set dirtyPath(value) {
    if (this._dirtyPath !== value) {
      this._dirtyPath = value;
      if (value) {
        this.markDirty("path");
      }
    }
  }
  get dirtyPath() {
    return this._dirtyPath;
  }
  checkPathDirty() {
    if (this._dirtyPath) {
      return;
    }
    this.dirtyPath = this.path.isDirty() || (this.fillShadow?.isDirty() ?? false) || (this._clipPath?.isDirty() ?? false);
  }
  onChangeDetection(property) {
    if (!this._dirtyPath) {
      this._dirtyPath = true;
      super.onChangeDetection(property);
    }
  }
  computeBBox() {
    this.updatePathIfDirty();
    return this.path.computeBBox();
  }
  isPointInPath(x, y) {
    this.updatePathIfDirty();
    return this.path.closedPath && this.path.isPointInPath(x, y);
  }
  distanceSquared(x, y) {
    return this.distanceSquaredTransformedPoint(x, y);
  }
  svgPathData(transform) {
    this.updatePathIfDirty();
    return this.path.toSVG(transform);
  }
  distanceSquaredTransformedPoint(x, y) {
    this.updatePathIfDirty();
    if (this.path.closedPath && this.path.isPointInPath(x, y)) {
      return 0;
    }
    return this.path.distanceSquared(x, y);
  }
  isDirtyPath() {
    return false;
  }
  updatePath() {
  }
  updatePathIfDirty() {
    if (this.dirtyPath || this.isDirtyPath()) {
      this.updatePath();
      this.dirtyPath = false;
    }
  }
  preRender(renderCtx) {
    if (renderCtx.devicePixelRatio !== this.lastPixelRatio) {
      this.dirtyPath = true;
    }
    this.lastPixelRatio = renderCtx.devicePixelRatio;
    this.updatePathIfDirty();
    return super.preRender(renderCtx, this.path.commands.length);
  }
  render(renderCtx) {
    const { ctx } = renderCtx;
    if (this.clip && !isNaN(this._clipX) && !isNaN(this._clipY)) {
      ctx.save();
      const margin = this.strokeWidth / 2;
      this._clipPath ?? (this._clipPath = new ExtendedPath2D());
      this._clipPath.clear();
      this._clipPath.rect(-margin, -margin, this._clipX + margin, this._clipY + margin + margin);
      ctx.clip(this._clipPath?.getPath2D());
      if (this._clipX > 0 && this._clipY > 0) {
        this.drawPath(ctx);
      }
      ctx.restore();
    } else {
      this._clipPath = void 0;
      this.drawPath(ctx);
    }
    this.fillShadow?.markClean();
    super.render(renderCtx);
  }
  drawPath(ctx) {
    this.fillStroke(ctx, this.path.getPath2D());
  }
  toSVG() {
    if (!this.visible)
      return;
    const element2 = (0, import_ag_charts_core102.createSvgElement)("path");
    element2.setAttribute("d", this.svgPathData());
    const defs = this.applySvgFillAttributes(element2, []);
    this.applySvgStrokeAttributes(element2);
    return {
      elements: [element2],
      defs
    };
  }
};
Path.className = "Path";
__decorateClass([
  SceneChangeDetection()
], Path.prototype, "clip", 2);
__decorateClass([
  SceneChangeDetection()
], Path.prototype, "clipX", 1);
__decorateClass([
  SceneChangeDetection()
], Path.prototype, "clipY", 1);

// packages/ag-charts-community/src/dom/focusIndicator.ts
var FocusIndicator = class {
  constructor(swapChain) {
    this.swapChain = swapChain;
    this.hasBeenActivated = false;
    this.div = (0, import_ag_charts_core103.createElement)("div");
    this.svg = (0, import_ag_charts_core103.createSvgElement)("svg");
    this.outerPath = (0, import_ag_charts_core103.createSvgElement)("path");
    this.innerPath = (0, import_ag_charts_core103.createSvgElement)("path");
    this.svg.append(this.outerPath);
    this.svg.append(this.innerPath);
    this.outerPath.classList.add("ag-charts-focus-svg-outer-path");
    this.innerPath.classList.add("ag-charts-focus-svg-inner-path");
    this.element = (0, import_ag_charts_core103.createElement)("div", "ag-charts-focus-indicator");
    this.element.ariaHidden = "true";
    this.element.append(this.svg);
    this.swapChain.addListener("swap", (parent) => this.onSwap(parent));
  }
  clear() {
  }
  update(focus, rect, clip) {
    if (rect == null)
      return;
    if (focus instanceof Path) {
      const transform = (localX, localY) => {
        let { x, y } = Transformable.toCanvasPoint(focus, localX, localY);
        x -= rect.x ?? 0;
        y -= rect.y ?? 0;
        return { x, y };
      };
      const d = focus.svgPathData(transform);
      this.outerPath.setAttribute("d", d);
      this.innerPath.setAttribute("d", d);
      this.show(this.svg);
    } else {
      let bbox;
      if (clip) {
        const x0 = Math.max(focus.x - rect.x, 0);
        const y0 = Math.max(focus.y - rect.y, 0);
        const x1 = Math.min(focus.x + focus.width - rect.x, rect.width);
        const y1 = Math.min(focus.y + focus.height - rect.y, rect.height);
        bbox = new BBox(x0, y0, x1 - x0, y1 - y0);
      } else {
        bbox = new BBox(focus.x - rect.x, focus.y - rect.y, focus.width, focus.height);
      }
      setElementBBox(this.div, bbox);
      this.show(this.div);
    }
  }
  onSwap(newParent) {
    if (newParent === this.element.parentElement)
      return;
    this.element.remove();
    newParent.appendChild(this.element);
    this.overrideFocusVisible(this.focusVisible);
  }
  show(child) {
    this.hasBeenActivated = true;
    this.element.innerHTML = "";
    this.element.append(child);
  }
  overrideFocusVisible(focusVisible) {
    this.focusVisible = focusVisible;
    const opacity = { true: "1", false: "0", undefined: "" };
    const parent = this.element.parentElement;
    parent?.style.setProperty("opacity", opacity[`${focusVisible}`]);
  }
  // Get the `:focus-visible` CSS state.
  isFocusVisible(force = false) {
    if (!force && !this.hasBeenActivated)
      return false;
    const parent = this.element.parentElement;
    return parent != null && (0, import_ag_charts_core103.getWindow)().getComputedStyle(parent).opacity === "1";
  }
};

// packages/ag-charts-community/src/dom/focusSwapChain.ts
var import_ag_charts_core104 = require("ag-charts-core");
var FocusSwapChain = class {
  constructor(label1, label2, announcerRole) {
    this.label1 = label1;
    this.label2 = label2;
    this.hasFocus = false;
    this.skipDispatch = false;
    this.listeners = {
      blur: [],
      focus: [],
      swap: []
    };
    this.onBlur = (e) => {
      (0, import_ag_charts_core104.setElementStyle)(e.target, "pointer-events", void 0);
      return !this.skipDispatch && this.dispatch("blur", e);
    };
    this.onFocus = (e) => {
      (0, import_ag_charts_core104.setElementStyle)(e.target, "pointer-events", "auto");
      return !this.skipDispatch && this.dispatch("focus", e);
    };
    (0, import_ag_charts_core104.setAttribute)(this.label1, "id", (0, import_ag_charts_core104.createElementId)());
    (0, import_ag_charts_core104.setAttribute)(this.label2, "id", (0, import_ag_charts_core104.createElementId)());
    (0, import_ag_charts_core104.setElementStyle)(this.label1, "display", "none");
    (0, import_ag_charts_core104.setElementStyle)(this.label2, "display", "none");
    this.activeAnnouncer = this.createAnnouncer(announcerRole);
    this.inactiveAnnouncer = this.createAnnouncer(announcerRole);
    (0, import_ag_charts_core104.setAttribute)(this.activeAnnouncer, "tabindex", 0);
    this.label2.insertAdjacentElement("afterend", this.activeAnnouncer);
    this.label2.insertAdjacentElement("afterend", this.inactiveAnnouncer);
    this.swap("");
  }
  createAnnouncer(role) {
    const announcer = (0, import_ag_charts_core104.createElement)("div");
    announcer.role = role;
    announcer.className = "ag-charts-swapchain";
    announcer.addEventListener("blur", this.onBlur);
    announcer.addEventListener("focus", this.onFocus);
    return announcer;
  }
  destroy() {
    for (const announcer of [this.activeAnnouncer, this.inactiveAnnouncer]) {
      announcer.removeEventListener("blur", this.onBlur);
      announcer.removeEventListener("focus", this.onFocus);
      announcer.remove();
    }
  }
  focus(opts) {
    this.focusOptions = opts;
    this.activeAnnouncer.focus(opts);
    this.focusOptions = void 0;
  }
  update(newLabel) {
    this.skipDispatch = true;
    this.swap(newLabel);
    if (this.hasFocus) {
      this.activeAnnouncer.focus(this.focusOptions);
    }
    this.skipDispatch = false;
  }
  addListener(type, handler) {
    this.listeners[type].push(handler);
    if (type === "swap") {
      const swapHandler = handler;
      swapHandler(this.activeAnnouncer);
    }
  }
  dispatch(type, param) {
    if (type === "focus")
      this.hasFocus = true;
    else if (type === "blur")
      this.hasFocus = false;
    this.listeners[type].forEach((fn) => fn(param));
  }
  swap(newLabel) {
    const userTabIndex = this.activeAnnouncer.tabIndex;
    this.label2.textContent = newLabel;
    [this.inactiveAnnouncer, this.activeAnnouncer] = [this.activeAnnouncer, this.inactiveAnnouncer];
    [this.label1, this.label2] = [this.label2, this.label1];
    (0, import_ag_charts_core104.setAttributes)(this.inactiveAnnouncer, {
      "aria-labelledby": this.label1.id,
      "aria-hidden": true,
      tabindex: void 0
    });
    (0, import_ag_charts_core104.setAttributes)(this.activeAnnouncer, {
      "aria-labelledby": this.label1.id,
      "aria-hidden": false,
      tabindex: userTabIndex
    });
    this.dispatch("swap", this.activeAnnouncer);
  }
};

// packages/ag-charts-community/src/chart/interaction/keyBindings.ts
var import_ag_charts_core105 = require("ag-charts-core");
var KEY_BINDINGS = {
  arrowdown: { bindings: [{ code: "ArrowDown" }] },
  arrowleft: { bindings: [{ code: "ArrowLeft" }] },
  arrowright: { bindings: [{ code: "ArrowRight" }] },
  arrowup: { bindings: [{ code: "ArrowUp" }] },
  delete: { bindings: [{ key: "Backspace" }, { key: "Delete" }], activatesFocusIndicator: false },
  redo: {
    bindings: [
      { key: "y", ctrlOrMeta: true },
      { key: "z", ctrlOrMeta: true, shift: true }
    ],
    activatesFocusIndicator: false
  },
  undo: { bindings: [{ key: "z", ctrlOrMeta: true }], activatesFocusIndicator: false },
  submit: { bindings: [{ key: "Enter" }, { code: "Enter" }, { code: "Space" }] },
  zoomin: { bindings: [{ key: "+" }, { code: "ZoomIn" }, { code: "Add" }], activatesFocusIndicator: false },
  zoomout: { bindings: [{ key: "-" }, { code: "ZoomOut" }, { code: "Substract" }], activatesFocusIndicator: false }
};
function matchesKeyBinding(e, bindings) {
  for (const kb of bindings) {
    if ("code" in kb) {
      if (kb.code === e.code)
        return true;
    } else {
      const matches = kb.key === e.key && (kb.shift === void 0 || kb.shift === e.shiftKey) && (kb.ctrlOrMeta === void 0 || kb.ctrlOrMeta === e.ctrlKey || kb.ctrlOrMeta === e.metaKey);
      if (matches)
        return true;
    }
  }
  return false;
}
function mapKeyboardEventToAction(event) {
  for (const [actionName, { activatesFocusIndicator = true, bindings }] of (0, import_ag_charts_core105.entries)(KEY_BINDINGS)) {
    if (matchesKeyBinding(event, bindings)) {
      return { name: actionName, activatesFocusIndicator };
    }
  }
  return void 0;
}

// packages/ag-charts-community/src/chart/keyboardUtil.ts
function computeCenter(series, hoverRect, pick) {
  const refPoint = getDatumRefPoint(series, pick.datum, pick.movedBounds);
  if (refPoint != null)
    return { x: refPoint.canvasX, y: refPoint.canvasY };
  const bboxOrPath = pick.bounds;
  if (bboxOrPath == null)
    return;
  if (bboxOrPath instanceof BBox) {
    const { x: centerX, y: centerY } = bboxOrPath.computeCenter();
    return {
      x: hoverRect.x + centerX,
      y: hoverRect.y + centerY
    };
  }
  return Transformable.toCanvas(bboxOrPath).computeCenter();
}
function getPickedFocusBBox({ bounds }) {
  if (bounds instanceof BBox)
    return bounds;
  if (bounds != null)
    return Transformable.toCanvas(bounds);
  return BBox.NaN;
}
function makeKeyboardPointerEvent(series, hoverRect, pick) {
  const { x: canvasX, y: canvasY } = computeCenter(series, hoverRect, pick) ?? {};
  if (canvasX !== void 0 && canvasY !== void 0) {
    return { type: "keyboard", canvasX, canvasY };
  }
  return void 0;
}

// packages/ag-charts-community/src/chart/tooltip/tooltip.ts
var import_ag_charts_core108 = require("ag-charts-core");

// packages/ag-charts-community/src/util/deprecation.ts
var import_ag_charts_core106 = require("ag-charts-core");
function createDeprecationWarning() {
  return (key, message) => {
    const msg = [`Property [${key}] is deprecated.`, message].filter(Boolean).join(" ");
    import_ag_charts_core106.Logger.warnOnce(msg);
  };
}
function Deprecated(message, opts) {
  const warnDeprecated = createDeprecationWarning();
  const def = opts?.default;
  return addTransformToInstanceProperty((_, key, value) => {
    if (value !== def) {
      warnDeprecated(key.toString(), message);
    }
    return value;
  });
}

// packages/ag-charts-community/src/util/placement.ts
function calculatePlacement(naturalWidth, naturalHeight, container, bounds) {
  let { top, right, bottom, left, width: width2, height: height2 } = bounds;
  if (left != null) {
    if (width2 != null) {
      right = container.width - left + width2;
    } else if (right != null) {
      width2 = container.width - left - right;
    }
  } else if (right != null && width2 != null) {
    left = container.width - right - width2;
  }
  if (top != null) {
    if (height2 != null) {
      bottom = container.height - top - height2;
    } else if (bottom != null) {
      height2 = container.height - bottom - top;
    }
  } else if (bottom != null && height2 != null) {
    top = container.height - bottom - height2;
  }
  if (width2 == null) {
    if (height2 == null) {
      width2 = naturalWidth;
      height2 = naturalHeight;
    } else {
      width2 = Math.ceil(naturalWidth * height2 / naturalHeight);
    }
  } else if (height2 == null) {
    height2 = Math.ceil(naturalHeight * width2 / naturalWidth);
  }
  if (left == null) {
    if (right == null) {
      left = Math.floor((container.width - width2) / 2);
    } else {
      left = container.width - right - width2;
    }
  }
  if (top == null) {
    if (bottom == null) {
      top = Math.floor((container.height - height2) / 2);
    } else {
      top = container.height - height2 - bottom;
    }
  }
  return { x: left, y: top, width: width2, height: height2 };
}

// packages/ag-charts-community/src/chart/tooltip/springAnimation.ts
var M = 0.1;
var K = 200;
var C = 12;
var DELTA = 0.5;
var SpringAnimation = class extends Listeners {
  constructor() {
    super(...arguments);
    this.x1 = NaN;
    this.y1 = NaN;
    this.x = NaN;
    this.y = NaN;
    this.vx = 0;
    this.vy = 0;
    this.t0 = NaN;
    this.animationFrameHandle = void 0;
  }
  reset() {
    this.x = NaN;
    this.y = NaN;
    if (this.animationFrameHandle != null) {
      cancelAnimationFrame(this.animationFrameHandle);
      this.animationFrameHandle = void 0;
    }
  }
  update(x, y) {
    if (Number.isNaN(this.x) || Number.isNaN(this.y)) {
      this.x = x;
      this.y = y;
      this.vx = 0;
      this.vy = 0;
      this.emitUpdate();
      if (this.animationFrameHandle != null) {
        cancelAnimationFrame(this.animationFrameHandle);
        this.animationFrameHandle = void 0;
      }
      return;
    }
    this.x1 = x;
    this.y1 = y;
    this.t0 = Date.now();
    if (this.animationFrameHandle == null) {
      this.animationFrameHandle = requestAnimationFrame(this.onFrame.bind(this));
    }
  }
  onFrame() {
    this.animationFrameHandle = void 0;
    const { x1, y1, t0 } = this;
    const t1 = Date.now();
    const dt = t1 - t0;
    this.t0 = t1;
    const stepT = 1e-3;
    const iterations = Math.ceil(dt / (stepT * 1e3)) | 0;
    let { x, y, vx, vy } = this;
    for (let i = 0; i < iterations; i += 1) {
      const dx = x - x1;
      const dy = y - y1;
      const ax = -(K * dx + C * vx) / M;
      const ay = -(K * dy + C * vy) / M;
      vx += ax * stepT;
      vy += ay * stepT;
      x += vx * stepT;
      y += vy * stepT;
    }
    if (Math.hypot(x - x1, y - y1) < DELTA) {
      this.x = this.x1;
      this.y = this.y1;
      this.vx = 0;
      this.vy = 0;
    } else {
      this.x = x;
      this.y = y;
      this.vx = vx;
      this.vy = vy;
      this.animationFrameHandle = requestAnimationFrame(this.onFrame.bind(this));
    }
    this.emitUpdate();
  }
  emitUpdate() {
    this.dispatch("update", { type: "update", x: this.x, y: this.y });
  }
};

// packages/ag-charts-community/src/util/sanitize.ts
var import_ag_charts_core107 = require("ag-charts-core");
var element = null;
function sanitizeHtml(text) {
  if (text === "") {
    return "";
  }
  element ?? (element = (0, import_ag_charts_core107.createElement)("div"));
  element.textContent = String(text);
  return element.innerHTML.replace(/\n/g, "<br>");
}

// packages/ag-charts-community/src/chart/marker/shapes.ts
function drawMarkerUnitPolygon(params, moves) {
  const { path, size } = params;
  const { x: x0, y: y0 } = params;
  path.clear();
  let didMove = false;
  for (const [dx, dy] of moves) {
    const x = x0 + (dx - 0.5) * size;
    const y = y0 + (dy - 0.5) * size;
    if (didMove) {
      path.lineTo(x, y);
    } else {
      path.moveTo(x, y);
    }
    didMove = true;
  }
  path.closePath();
}
var MARKER_SHAPES = {
  circle({ path, x, y, size }) {
    const r = size / 2;
    path.arc(x, y, r, 0, Math.PI * 2);
    path.closePath();
  },
  cross(params) {
    drawMarkerUnitPolygon(params, [
      [0.25, 0],
      [0.5, 0.25],
      [0.75, 0],
      [1, 0.25],
      [0.75, 0.5],
      [1, 0.75],
      [0.75, 1],
      [0.5, 0.75],
      [0.25, 1],
      [0, 0.75],
      [0.25, 0.5],
      [0, 0.25]
    ]);
  },
  diamond(params) {
    drawMarkerUnitPolygon(params, [
      [0.5, 0],
      [1, 0.5],
      [0.5, 1],
      [0, 0.5]
    ]);
  },
  heart({ path, x, y, size }) {
    const r = size / 4;
    y = y + r / 2;
    path.arc(x - r, y - r, r, toRadians(130), toRadians(330));
    path.arc(x + r, y - r, r, toRadians(220), toRadians(50));
    path.lineTo(x, y + r);
    path.closePath();
  },
  pin({ path, x, y, size: s }) {
    const cx = 0.5;
    const cy = 0.5;
    path.moveTo(x + (0.15625 - cx) * s, y + (0.34375 - cy) * s);
    path.cubicCurveTo(
      x + (0.15625 - cx) * s,
      y + (0.151491 - cy) * s,
      x + (0.307741 - cx) * s,
      y + (0 - cy) * s,
      x + (0.5 - cx) * s,
      y + (0 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.692259 - cx) * s,
      y + (0 - cy) * s,
      x + (0.84375 - cx) * s,
      y + (0.151491 - cy) * s,
      x + (0.84375 - cx) * s,
      y + (0.34375 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.84375 - cx) * s,
      y + (0.493824 - cy) * s,
      x + (0.784625 - cx) * s,
      y + (0.600181 - cy) * s,
      x + (0.716461 - cx) * s,
      y + (0.695393 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.699009 - cx) * s,
      y + (0.719769 - cy) * s,
      x + (0.681271 - cx) * s,
      y + (0.743104 - cy) * s,
      x + (0.663785 - cx) * s,
      y + (0.766105 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.611893 - cx) * s,
      y + (0.834367 - cy) * s,
      x + (0.562228 - cx) * s,
      y + (0.899699 - cy) * s,
      x + (0.528896 - cx) * s,
      y + (0.980648 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.524075 - cx) * s,
      y + (0.992358 - cy) * s,
      x + (0.512663 - cx) * s,
      y + (1 - cy) * s,
      x + (0.5 - cx) * s,
      y + (1 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.487337 - cx) * s,
      y + (1 - cy) * s,
      x + (0.475925 - cx) * s,
      y + (0.992358 - cy) * s,
      x + (0.471104 - cx) * s,
      y + (0.980648 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.487337 - cx) * s,
      y + (1 - cy) * s,
      x + (0.475925 - cx) * s,
      y + (0.992358 - cy) * s,
      x + (0.471104 - cx) * s,
      y + (0.980648 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.437772 - cx) * s,
      y + (0.899699 - cy) * s,
      x + (0.388107 - cx) * s,
      y + (0.834367 - cy) * s,
      x + (0.336215 - cx) * s,
      y + (0.766105 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.318729 - cx) * s,
      y + (0.743104 - cy) * s,
      x + (0.300991 - cx) * s,
      y + (0.719769 - cy) * s,
      x + (0.283539 - cx) * s,
      y + (0.695393 - cy) * s
    );
    path.cubicCurveTo(
      x + (0.215375 - cx) * s,
      y + (0.600181 - cy) * s,
      x + (0.15625 - cx) * s,
      y + (0.493824 - cy) * s,
      x + (0.15625 - cx) * s,
      y + (0.34375 - cy) * s
    );
    path.closePath();
  },
  plus(params) {
    drawMarkerUnitPolygon(params, [
      [1 / 3, 0],
      [2 / 3, 0],
      [2 / 3, 1 / 3],
      [1, 1 / 3],
      [1, 2 / 3],
      [2 / 3, 2 / 3],
      [2 / 3, 1],
      [1 / 3, 1],
      [1 / 3, 2 / 3],
      [0, 2 / 3],
      [0, 1 / 3],
      [1 / 3, 1 / 3]
    ]);
  },
  square({ path, x, y, size, pixelRatio }) {
    const hs = size / 2;
    path.moveTo(align(pixelRatio, x - hs), align(pixelRatio, y - hs));
    path.lineTo(align(pixelRatio, x + hs), align(pixelRatio, y - hs));
    path.lineTo(align(pixelRatio, x + hs), align(pixelRatio, y + hs));
    path.lineTo(align(pixelRatio, x - hs), align(pixelRatio, y + hs));
    path.closePath();
  },
  star({ path, x, y, size }) {
    const spikes = 5;
    const outerRadius = size / 2;
    const innerRadius = outerRadius / 2;
    const rotation = Math.PI / 2;
    for (let i = 0; i < spikes * 2; i++) {
      const radius = i % 2 === 0 ? outerRadius : innerRadius;
      const angle = i * Math.PI / spikes - rotation;
      const xCoordinate = x + Math.cos(angle) * radius;
      const yCoordinate = y + Math.sin(angle) * radius;
      path.lineTo(xCoordinate, yCoordinate);
    }
    path.closePath();
  },
  triangle(params) {
    drawMarkerUnitPolygon(params, [
      [0.5, 0],
      [1, 0.87],
      [0, 0.87]
    ]);
  }
};

// packages/ag-charts-community/src/chart/marker/marker.ts
var InternalMarker = class extends Path {
  constructor() {
    super(...arguments);
    this.shape = "square";
    this.x = 0;
    this.y = 0;
    this.size = 12;
  }
  updatePath() {
    const { path, shape, x, y, size } = this;
    const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;
    const anchor = Marker.anchor(shape);
    const drawParams = {
      path,
      x: x - (anchor.x - 0.5) * size,
      y: y - (anchor.y - 0.5) * size,
      size,
      pixelRatio
    };
    path.clear();
    if (typeof shape === "string") {
      MARKER_SHAPES[shape](drawParams);
    } else if (typeof shape === "function") {
      shape(drawParams);
    }
  }
  computeBBox() {
    const { x, y, size } = this;
    const anchor = Marker.anchor(this.shape);
    return new BBox(x - size * anchor.x, y - size * anchor.y, size, size);
  }
  executeFill(ctx, path) {
    if (!path)
      return;
    return super.executeFill(ctx, path);
  }
  executeStroke(ctx, path) {
    if (!path)
      return;
    return super.executeStroke(ctx, path);
  }
};
__decorateClass([
  SceneObjectChangeDetection({ equals: TRIPLE_EQ })
], InternalMarker.prototype, "shape", 2);
__decorateClass([
  SceneChangeDetection()
], InternalMarker.prototype, "x", 2);
__decorateClass([
  SceneChangeDetection()
], InternalMarker.prototype, "y", 2);
__decorateClass([
  SceneChangeDetection({ convertor: Math.abs })
], InternalMarker.prototype, "size", 2);
var Marker = class extends Rotatable(Scalable(Translatable(InternalMarker))) {
  static anchor(shape) {
    if (shape === "pin") {
      return { x: 0.5, y: 1 };
    } else if (typeof shape === "function" && "anchor" in shape) {
      return shape.anchor;
    }
    return { x: 0.5, y: 0.5 };
  }
  constructor(options) {
    super(options);
    if (options?.shape != null) {
      this.shape = options.shape;
    }
  }
};

// packages/ag-charts-community/src/chart/legend/legendSymbol.ts
function legendSymbolSvg(symbol, size, lineSize = size * (5 / 3)) {
  const group = new Group();
  const markerStrokeWidth = Math.min(symbol.marker.strokeWidth ?? 1, 2);
  const lineStrokeWidth = Math.min(symbol.line?.strokeWidth ?? 0, 2);
  const width2 = Math.max(symbol.marker.enabled === false ? 0 : size, symbol.line == null ? 0 : lineSize);
  const height2 = Math.max(symbol.marker.enabled === false ? 0 : size, lineStrokeWidth);
  if (symbol.line != null) {
    const { stroke: stroke2, strokeOpacity, lineDash } = symbol.line;
    const line = new Line();
    line.x1 = 0;
    line.y1 = height2 / 2;
    line.x2 = width2;
    line.y2 = height2 / 2;
    line.stroke = stroke2;
    line.strokeOpacity = strokeOpacity;
    line.strokeWidth = lineStrokeWidth;
    line.lineDash = lineDash;
    group.append(line);
  }
  if (symbol.marker.enabled !== false) {
    const { shape, fill, fillOpacity, stroke: stroke2, strokeOpacity, lineDash, lineDashOffset } = symbol.marker;
    const marker = new Marker();
    marker.shape = shape ?? "square";
    marker.size = size;
    marker.fill = fill;
    marker.fillOpacity = fillOpacity ?? 1;
    marker.stroke = stroke2;
    marker.strokeOpacity = strokeOpacity ?? 1;
    marker.strokeWidth = markerStrokeWidth;
    marker.lineDash = lineDash;
    marker.lineDashOffset = lineDashOffset ?? 0;
    const anchor = Marker.anchor(shape);
    const x = width2 / 2 + (anchor.x - 0.5) * size;
    const y = height2 / 2 + (anchor.y - 0.5) * size;
    const scale2 = size / (size + markerStrokeWidth);
    marker.x = x;
    marker.y = y;
    marker.scalingCenterX = x;
    marker.scalingCenterY = y;
    marker.scalingX = scale2;
    marker.scalingY = scale2;
    group.append(marker);
  }
  return Group.toSVG(group, width2, height2);
}

// packages/ag-charts-community/src/chart/tooltip/tooltipContent.ts
var DEFAULT_TOOLTIP_CLASS = "ag-charts-tooltip";
var DEFAULT_TOOLTIP_DARK_CLASS = "ag-charts-tooltip--dark";
function aggregateTooltipContent(content) {
  const out = [];
  const groupedContents = /* @__PURE__ */ new Map();
  for (const item of content) {
    if (item.type === "structured") {
      const { heading } = item;
      const insertionTarget = heading != null ? groupedContents.get(heading) : void 0;
      const groupedItem = { type: "structured", heading, items: [item] };
      if (insertionTarget == null) {
        groupedContents.set(heading, groupedItem);
        out.push(groupedItem);
      } else {
        insertionTarget.items.push(item);
      }
    } else {
      out.push(item);
    }
  }
  return out;
}
function tooltipContentAriaLabel(ungroupedContent) {
  const content = aggregateTooltipContent(ungroupedContent);
  const ariaLabel = [];
  content.forEach((c) => {
    if (c.type === "raw")
      return "";
    if (c.heading != null)
      ariaLabel.push(c.heading);
    c.items.forEach((i) => {
      if (i.title != null)
        ariaLabel.push(i.title);
      i.data?.forEach((datum) => {
        ariaLabel.push(datum.label ?? datum.fallbackLabel, datum.value);
      });
    });
  });
  return ariaLabel.join("; ");
}
function dataHtml(label, value, inline) {
  let rowHtml = "";
  if (label == null) {
    rowHtml += `<span class="${DEFAULT_TOOLTIP_CLASS}-label">${sanitizeHtml(value)}</span>`;
  } else {
    rowHtml += `<span class="${DEFAULT_TOOLTIP_CLASS}-label">${sanitizeHtml(label)}</span>`;
    rowHtml += " ";
    rowHtml += `<span class="${DEFAULT_TOOLTIP_CLASS}-value">${sanitizeHtml(value)}</span>`;
  }
  const rowClassNames = [`${DEFAULT_TOOLTIP_CLASS}-row`];
  if (inline)
    rowClassNames.push(`${DEFAULT_TOOLTIP_CLASS}-row--inline`);
  rowHtml = `<div class="${rowClassNames.join(" ")}">${rowHtml}</div>`;
  return rowHtml;
}
function tooltipRowContentHtml(content) {
  let html = "";
  if (content.data?.length && content.data.every((datum) => datum.value == null || datum.value === "")) {
    return html;
  }
  const dataInline = content.title == null && content.data?.length === 1;
  const symbol = content.symbol == null ? void 0 : legendSymbolSvg(content.symbol, 12);
  if (symbol != null && (content.title != null || content.data?.length)) {
    html += `<span class="${DEFAULT_TOOLTIP_CLASS}-symbol">${symbol}</span>`;
  }
  if (content.title != null) {
    html += `<span class="${DEFAULT_TOOLTIP_CLASS}-title">${sanitizeHtml(content.title)}</span>`;
    html += " ";
  }
  content.data?.forEach((datum) => {
    html += dataHtml(datum.label ?? datum.fallbackLabel, datum.value, dataInline);
    html += " ";
  });
  return html;
}
function tooltipPaginationContentHtml(localeManager, pagination) {
  if (localeManager == null || pagination.length === 1)
    return;
  const text = localeManager?.t("tooltipPaginationStatus", {
    index: pagination.index + 1,
    count: pagination.length
  });
  return `<div class="${DEFAULT_TOOLTIP_CLASS}-footer">${text}</div>`;
}
function tooltipContentHtml(localeManager, content, mode, pagination) {
  const singleItem = content.items.length === 1 ? content.items[0] : void 0;
  let compact;
  let compactTitle;
  let compactFallbackLabel;
  switch (mode) {
    case "compact":
      compact = true;
      compactTitle = singleItem?.title;
      break;
    case "single":
      compact = singleItem != null && (content.heading == null || singleItem.title == null) && singleItem.data?.length === 1 && singleItem.data[0].label == null && singleItem.data[0].value != null;
      compactFallbackLabel = content.heading ?? singleItem?.title;
      break;
    case "shared":
      compact = false;
  }
  let html = "";
  if (compact && singleItem != null) {
    if (compactTitle != null) {
      html += dataHtml(void 0, compactTitle, false);
    }
    singleItem.data?.forEach((datum) => {
      html += dataHtml(datum.label ?? compactFallbackLabel, datum.value, false);
      html += " ";
    });
  } else {
    if (content.heading != null) {
      html += `<span class="${DEFAULT_TOOLTIP_CLASS}-heading">${sanitizeHtml(content.heading)}</span>`;
      html += " ";
    }
    content.items.forEach((item) => {
      html += tooltipRowContentHtml(item);
    });
  }
  if (html.length === 0)
    return;
  const paginationContent = mode !== "compact" && pagination != null ? tooltipPaginationContentHtml(localeManager, pagination) : void 0;
  if (paginationContent + null) {
    html += paginationContent;
  }
  html = `<div class="${DEFAULT_TOOLTIP_CLASS}-content">${html.trimEnd()}</div>`;
  return html;
}
function tooltipPaginationHtml(localeManager, pagination) {
  const paginationContent = pagination == null ? void 0 : tooltipPaginationContentHtml(localeManager, pagination);
  if (paginationContent == null)
    return "";
  return `<div class="${DEFAULT_TOOLTIP_CLASS}-content">${paginationContent}</div>`;
}
function tooltipHtml(localeManager, content, mode, pagination) {
  const aggregatedContent = aggregateTooltipContent(content);
  if (aggregatedContent.length === 0)
    return;
  if (aggregatedContent.length === 1 && aggregatedContent[0].type === "structured") {
    return tooltipContentHtml(localeManager, aggregatedContent[0], mode, pagination);
  } else {
    const htmlRows = aggregatedContent.map((c) => {
      return c.type === "structured" ? tooltipContentHtml(localeManager, c, mode) : c.rawHtmlString;
    });
    if (pagination != null) {
      htmlRows.push(tooltipPaginationHtml(localeManager, pagination) ?? "");
    }
    return htmlRows.join("");
  }
}

// packages/ag-charts-community/src/chart/tooltip/tooltip.ts
var horizontalAlignments = {
  left: -1,
  "top-left": -1,
  "bottom-left": -1,
  top: 0,
  center: 0,
  bottom: 0,
  right: 1,
  "top-right": 1,
  "bottom-right": 1
};
var verticalAlignments = {
  "top-left": -1,
  top: -1,
  "top-right": -1,
  left: 0,
  center: 0,
  right: 0,
  "bottom-left": 1,
  bottom: 1,
  "bottom-right": 1
};
var arrowPositions = {
  left: 3 /* Right */,
  "top-left": void 0,
  "bottom-left": void 0,
  top: 2 /* Bottom */,
  center: void 0,
  bottom: 1 /* Top */,
  right: 0 /* Left */,
  "top-right": void 0,
  "bottom-right": void 0
};
var directionChecks = {
  top: 2 /* Vertical */,
  bottom: 2 /* Vertical */,
  left: 1 /* Horizontal */,
  right: 1 /* Horizontal */,
  "top-right": 3 /* Both */,
  "top-left": 3 /* Both */,
  "bottom-right": 3 /* Both */,
  "bottom-left": 3 /* Both */,
  center: 0 /* None */
};
var TooltipPosition = class extends BaseProperties {
  constructor() {
    super(...arguments);
    /** The horizontal offset in pixels for the position of the tooltip. */
    this.xOffset = 0;
    /** The vertical offset in pixels for the position of the tooltip. */
    this.yOffset = 0;
  }
  get defaultAnchorTo() {
    const { type, _seriesOverrideType } = this;
    const defaultType = type ?? _seriesOverrideType ?? "pointer";
    if (defaultType === "node" || defaultType === "pointer") {
      return defaultType;
    } else {
      return "chart";
    }
  }
  get defaultPlacement() {
    const { type, _seriesOverrideType } = this;
    const defaultType = type ?? _seriesOverrideType ?? "pointer";
    if (defaultType === "node" || defaultType === "pointer") {
      return "top";
    }
    return defaultType;
  }
};
__decorateClass([
  Property,
  Deprecated("Use `anchorTo` and/or `placement` options instead.")
], TooltipPosition.prototype, "type", 2);
__decorateClass([
  Property
], TooltipPosition.prototype, "_seriesOverrideType", 2);
__decorateClass([
  Property
], TooltipPosition.prototype, "xOffset", 2);
__decorateClass([
  Property
], TooltipPosition.prototype, "yOffset", 2);
__decorateClass([
  Property
], TooltipPosition.prototype, "anchorTo", 2);
__decorateClass([
  Property
], TooltipPosition.prototype, "placement", 2);
var Tooltip = class extends BaseProperties {
  constructor() {
    super();
    this.enabled = true;
    this.mode = "single";
    this.delay = 0;
    this.range = void 0;
    this.wrapping = "hyphenate";
    this.position = new TooltipPosition();
    this.pagination = false;
    this.darkTheme = false;
    this.bounds = "extended";
    this.destroyFns = [];
    this.springAnimation = new SpringAnimation();
    this.enableInteraction = false;
    this.wrapTypes = ["always", "hyphenate", "on-space", "never"];
    this.sizeMonitor = new SizeMonitor();
    // Reading the element size is expensive, so cache the result
    this._elementSize = void 0;
    this._showTimeout = void 0;
    this.arrowPosition = void 0;
    this._visible = false;
    this.positionParams = void 0;
    this.localeManager = void 0;
    this.destroyFns.push(this.springAnimation.addListener("update", this.updateTooltipPosition.bind(this)));
  }
  get interactive() {
    return this.enableInteraction;
  }
  setup(localeManager, domManager) {
    if ("togglePopover" in (0, import_ag_charts_core108.getWindow)().HTMLElement.prototype) {
      this.element = domManager.addChild("tooltip-container", DEFAULT_TOOLTIP_CLASS);
      this.element.setAttribute("popover", "manual");
      this.element.className = DEFAULT_TOOLTIP_CLASS;
      this.element.style.positionAnchor = domManager.anchorName;
      this.sizeMonitor.observe(this.element, (size) => {
        this._elementSize = size;
        this.updateTooltipPosition();
      });
    }
    this.localeManager = localeManager;
    return () => {
      domManager.removeChild("tooltip-container", DEFAULT_TOOLTIP_CLASS);
      this.destroyFns.forEach((f) => f());
      if (this.element) {
        this.sizeMonitor.unobserve(this.element);
      }
    };
  }
  isVisible() {
    return this._visible;
  }
  contains(node) {
    return this.element?.contains(node) ?? false;
  }
  updateTooltipPosition() {
    const { element: element2, _elementSize: elementSize, positionParams } = this;
    if (element2 == null || elementSize == null || positionParams == null)
      return;
    const { canvasRect, relativeRect, meta } = positionParams;
    const { x: canvasX, y: canvasY } = this.springAnimation;
    let placements2 = meta.position?.placement ?? this.position.placement ?? meta.position?.defaultPlacement ?? this.position.defaultPlacement;
    if (!Array.isArray(placements2)) {
      placements2 = [placements2];
    }
    const anchorTo = meta.position?.anchorTo ?? this.position.anchorTo ?? meta.position?.defaultAnchorTo ?? this.position.defaultAnchorTo;
    const xOffset = meta.position?.xOffset ?? 0;
    const yOffset = meta.position?.yOffset ?? 0;
    const minX = relativeRect.x;
    const minY = relativeRect.y;
    const maxX = relativeRect.width - elementSize.width - 1 + minX;
    const maxY = relativeRect.height - elementSize.height + minY;
    let i = 0;
    let placement;
    let position;
    let constrained = false;
    do {
      placement = placements2[i];
      i += 1;
      const tooltipBounds = this.getTooltipBounds({
        elementSize,
        placement,
        anchorTo,
        canvasX,
        canvasY,
        yOffset,
        xOffset,
        canvasRect
      });
      position = calculatePlacement(elementSize.width, elementSize.height, relativeRect, tooltipBounds);
      constrained = false;
      if (directionChecks[placement] & 1 /* Horizontal */) {
        constrained || (constrained = position.x < minX || position.x > maxX);
      }
      if (directionChecks[placement] & 2 /* Vertical */) {
        constrained || (constrained = position.y < minY || position.y > maxY);
      }
    } while (i < placements2.length && constrained);
    const left = (0, import_ag_charts_core108.clamp)(minX, position.x, maxX);
    const top = (0, import_ag_charts_core108.clamp)(minY, position.y, maxY);
    constrained || (constrained = left !== position.x || top !== position.y);
    const defaultShowArrow = anchorTo !== "chart" && !constrained && !xOffset && !yOffset;
    const showArrow = meta.showArrow ?? this.showArrow ?? defaultShowArrow;
    this.arrowPosition = showArrow ? arrowPositions[placement] : void 0;
    this.updateClassModifiers();
    element2.style.translate = `${left}px ${top}px`;
  }
  /**
   * Shows tooltip at the given event's coordinates.
   * If the `html` parameter is missing, moves the existing tooltip to the new position.
   */
  show(boundingRect, canvasRect, meta, content, pagination, instantly = false) {
    const { element: element2 } = this;
    if (element2 != null && content != null && content.length !== 0) {
      const html = tooltipHtml(this.localeManager, content, this.mode, this.pagination ? pagination : void 0);
      if (html == null) {
        this.toggle(false);
        return;
      }
      element2.innerHTML = html;
    } else if (element2 == null || element2.innerHTML === "") {
      this.toggle(false);
      return;
    }
    const relativeRect = {
      x: boundingRect.x - canvasRect.x,
      y: boundingRect.y - canvasRect.y,
      width: boundingRect.width,
      height: boundingRect.height
    };
    this.positionParams = {
      canvasRect,
      relativeRect,
      meta
    };
    const anchorTo = meta.position?.anchorTo ?? this.position.anchorTo ?? meta.position?.defaultAnchorTo ?? this.position.defaultAnchorTo;
    switch (anchorTo) {
      case "node":
        this.springAnimation.update(meta.nodeCanvasX ?? meta.canvasX, meta.nodeCanvasY ?? meta.canvasY);
        break;
      case "pointer":
        this.springAnimation.update(meta.canvasX, meta.canvasY);
        break;
      case "chart":
        this.springAnimation.reset();
    }
    if (meta.enableInteraction) {
      this.enableInteraction = true;
      element2.style.pointerEvents = "auto";
      element2.removeAttribute("aria-hidden");
      element2.tabIndex = -1;
    } else {
      this.enableInteraction = false;
      element2.style.pointerEvents = "none";
      element2.setAttribute("aria-hidden", "true");
      element2.removeAttribute("tabindex");
    }
    element2.style.setProperty("--top", `${canvasRect.top}px`);
    element2.style.setProperty("--left", `${canvasRect.left}px`);
    this.updateClassModifiers();
    this.toggle(true, instantly);
  }
  hide() {
    this.toggle(false);
  }
  toggle(visible, instantly = false) {
    const { delay } = this;
    if (visible && delay > 0 && !instantly) {
      this._showTimeout ?? (this._showTimeout = setTimeout(() => {
        this._showTimeout = void 0;
        this.toggleCallback(true);
      }, delay));
    } else {
      clearTimeout(this._showTimeout);
      this._showTimeout = void 0;
      this.toggleCallback(visible);
    }
  }
  toggleCallback(visible) {
    if (!this.element?.isConnected)
      return;
    if (this._visible === visible)
      return;
    this._visible = visible;
    this.element.togglePopover(visible);
    if (visible) {
      this.updateTooltipPosition();
    } else {
      this.springAnimation.reset();
    }
  }
  updateClassModifiers() {
    if (!this.element?.isConnected)
      return;
    const { classList } = this.element;
    const toggleClass = (name, include) => classList.toggle(`${DEFAULT_TOOLTIP_CLASS}--${name}`, include);
    toggleClass("no-interaction", !this.enableInteraction);
    toggleClass("arrow-top", this.arrowPosition === 1 /* Top */);
    toggleClass("arrow-right", this.arrowPosition === 3 /* Right */);
    toggleClass("arrow-bottom", this.arrowPosition === 2 /* Bottom */);
    toggleClass("arrow-left", this.arrowPosition === 0 /* Left */);
    toggleClass("compact", this.mode === "compact");
    classList.toggle(DEFAULT_TOOLTIP_DARK_CLASS, this.darkTheme);
    for (const wrapType of this.wrapTypes) {
      classList.toggle(`${DEFAULT_TOOLTIP_CLASS}--wrap-${wrapType}`, wrapType === this.wrapping);
    }
  }
  getTooltipBounds(opts) {
    const { elementSize, anchorTo, placement, canvasX, canvasY, yOffset, xOffset, canvasRect } = opts;
    const { width: tooltipWidth, height: tooltipHeight } = elementSize;
    const bounds = { width: tooltipWidth, height: tooltipHeight };
    if (anchorTo === "node" || anchorTo === "pointer") {
      const horizontalAlignment = horizontalAlignments[placement];
      const verticalAlignment = verticalAlignments[placement];
      bounds.top = canvasY + yOffset + tooltipHeight * (verticalAlignment - 1) / 2 + 8 * verticalAlignment;
      bounds.left = canvasX + xOffset + tooltipWidth * (horizontalAlignment - 1) / 2 + 8 * horizontalAlignment;
      return bounds;
    }
    switch (placement) {
      case "top": {
        bounds.top = yOffset;
        bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;
        return bounds;
      }
      case "right": {
        bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;
        bounds.left = canvasRect.width - tooltipWidth / 2 + xOffset;
        return bounds;
      }
      case "left": {
        bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;
        bounds.left = xOffset;
        return bounds;
      }
      case "bottom": {
        bounds.top = canvasRect.height - tooltipHeight + yOffset;
        bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;
        return bounds;
      }
      case "top-left": {
        bounds.top = yOffset;
        bounds.left = xOffset;
        return bounds;
      }
      case "top-right": {
        bounds.top = yOffset;
        bounds.left = canvasRect.width - tooltipWidth + xOffset;
        return bounds;
      }
      case "bottom-right": {
        bounds.top = canvasRect.height - tooltipHeight + yOffset;
        bounds.left = canvasRect.width - tooltipWidth + xOffset;
        return bounds;
      }
      case "bottom-left": {
        bounds.top = canvasRect.height - tooltipHeight + yOffset;
        bounds.left = xOffset;
        return bounds;
      }
    }
    return bounds;
  }
};
__decorateClass([
  Property
], Tooltip.prototype, "enabled", 2);
__decorateClass([
  Property
], Tooltip.prototype, "mode", 2);
__decorateClass([
  Property
], Tooltip.prototype, "showArrow", 2);
__decorateClass([
  Property
], Tooltip.prototype, "delay", 2);
__decorateClass([
  Property
], Tooltip.prototype, "range", 2);
__decorateClass([
  Property
], Tooltip.prototype, "wrapping", 2);
__decorateClass([
  Property
], Tooltip.prototype, "position", 2);
__decorateClass([
  Property
], Tooltip.prototype, "pagination", 2);
__decorateClass([
  Property
], Tooltip.prototype, "darkTheme", 2);
__decorateClass([
  Property
], Tooltip.prototype, "bounds", 2);

// packages/ag-charts-community/src/chart/series/seriesAreaManager.ts
function pickedNodesEqual(a, b) {
  return a.series === b.series && objectsEqual(a.datumIndex, b.datumIndex);
}
var PickedNodeState = class {
  constructor() {
    this.candidates = [];
  }
  get current() {
    return this.active;
  }
  reset() {
    this.candidates.length = 0;
    this.active = void 0;
  }
  update(nextCandidates, previousActive) {
    this.candidates = nextCandidates;
    let nextIndex = previousActive != null ? nextCandidates.findIndex((c) => pickedNodesEqual(c, previousActive)) : -1;
    if (nextIndex === -1)
      nextIndex = 0;
    this.active = nextCandidates[nextIndex];
    return { current: this.active, index: nextIndex, length: nextCandidates.length };
  }
  next() {
    const { candidates, active } = this;
    const hoverIndex = active == null ? -1 : candidates.findIndex((c) => pickedNodesEqual(c, active));
    if (hoverIndex === -1)
      return void 0;
    let nextIndex = hoverIndex + 1;
    if (nextIndex >= candidates.length) {
      nextIndex = 0;
    }
    this.active = candidates[nextIndex];
    return { current: this.active, index: nextIndex, length: this.candidates.length };
  }
};
var SeriesAreaManager = class extends BaseManager {
  constructor(chart) {
    super();
    this.chart = chart;
    this.id = (0, import_ag_charts_core109.createId)(this);
    this.series = [];
    this.highlight = {
      /** Last received event that still needs to be applied. */
      pendingHoverEvent: void 0,
      /** Last applied event. */
      appliedHoverEvent: void 0,
      /** Last applied event, which has been temporarily stashed during the main chart update cycle. */
      stashedHoverEvent: void 0
    };
    this.tooltip = {
      lastHover: void 0
    };
    /**
     * A11y Requirements for Tooltip/Highlight (see AG-13051 for details):
     *
     *   -   When the series-area is blurred, always the mouse to update the tooltip/highlight.
     *
     *   -   When the series-area receives a `focus` event, use `:focus-visible` to guess the input device.
     *       (this is decided by the browser).
     *
     *   -   For keyboard users, `focus` and `keydown` events always updates & shows the tooltip/highlight on
     *       the currently (or newly) focused datum.
     *
     *   -   For keyboard users, `mousemove` events update the tooltip/highlight iff `pickNode` finds a match
     *       for the mouse event offsets.
     */
    this.hoverDevice = "pointer";
    /**
     * This is the "second last" input event. It can be useful for keydown
     * events that for which don't to set the isFocusVisible state
     * (e.g. Backspace/Delete key on FC annotations, see AG-13041).
     *
     * Use with caution! The focus indicator must ALWAYS be visible for
     * keyboard-only users.
     */
    this.previousInputDevice = "keyboard";
    this.focus = {
      sortedSeries: [],
      series: void 0,
      seriesIndex: 0,
      datumIndex: 0,
      datum: void 0
    };
    this.hoverScheduler = debouncedAnimationFrame(() => {
      if (!this.tooltip.lastHover && !this.highlight.pendingHoverEvent)
        return;
      if (this.chart.getUpdateType() <= 5 /* SERIES_UPDATE */) {
        this.hoverScheduler.schedule();
        return;
      }
      if (this.highlight.pendingHoverEvent) {
        this.handleHoverHighlight(false);
      }
      if (this.tooltip.lastHover) {
        this.handleHoverTooltip(this.tooltip.lastHover, false);
      }
    });
    this.tooltipCandidates = new PickedNodeState();
    const label1 = chart.ctx.domManager.addChild("series-area", "series-area-aria-label1");
    const label2 = chart.ctx.domManager.addChild("series-area", "series-area-aria-label2");
    this.swapChain = new FocusSwapChain(label1, label2, "img");
    this.swapChain.addListener("blur", (event) => this.onBlur(event));
    this.swapChain.addListener("focus", () => this.onFocus());
    if (chart.ctx.domManager.mode === "normal") {
      this.focusIndicator = new FocusIndicator(this.swapChain);
      this.focusIndicator.overrideFocusVisible(chart.mode === "integrated" ? false : void 0);
    }
    const { seriesDragInterpreter, seriesWidget, containerWidget } = chart.ctx.widgets;
    seriesWidget.setTabIndex(-1);
    this.destroyFns.push(
      () => chart.ctx.domManager.removeChild("series-area", "series-area-aria-label1"),
      () => chart.ctx.domManager.removeChild("series-area", "series-area-aria-label2"),
      seriesWidget.addListener("focus", () => this.swapChain.focus()),
      seriesWidget.addListener("mousemove", (event) => this.onHover(event)),
      seriesWidget.addListener("wheel", (event) => this.onWheel(event)),
      seriesWidget.addListener("mouseleave", (event) => this.onLeave(event)),
      seriesWidget.addListener("keydown", (event) => this.onKeyDown(event)),
      seriesWidget.addListener("contextmenu", (event, current) => this.onContextMenu(event, current)),
      seriesDragInterpreter.addListener("drag-move", (event) => this.onDragMove(event)),
      seriesDragInterpreter.addListener("click", (event) => this.onClick(event, seriesWidget)),
      seriesDragInterpreter.addListener("dblclick", (event) => this.onClick(event, seriesWidget)),
      containerWidget.addListener("contextmenu", (event, current) => this.onContextMenu(event, current)),
      containerWidget.addListener("click", (event, current) => this.onClick(event, current)),
      containerWidget.addListener("dblclick", (event, current) => this.onClick(event, current)),
      chart.ctx.animationManager.addListener("animation-start", () => this.clearAll()),
      chart.ctx.domManager.addListener("resize", () => this.clearAll()),
      chart.ctx.highlightManager.addListener("highlight-change", (event) => this.changeHighlightDatum(event)),
      chart.ctx.layoutManager.addListener("layout:complete", (event) => this.layoutComplete(event)),
      chart.ctx.updateService.addListener("pre-scene-render", () => this.preSceneRender()),
      chart.ctx.updateService.addListener("update-complete", () => this.updateComplete()),
      chart.ctx.zoomManager.addListener("zoom-change", () => this.clearAll()),
      chart.ctx.zoomManager.addListener("zoom-pan-start", () => this.clearAll())
    );
  }
  get bbox() {
    return (this.seriesRect ?? BBox.zero).clone();
  }
  isState(allowedStates) {
    return this.chart.ctx.interactionManager.isState(allowedStates);
  }
  isIgnoredTouch(event) {
    if (event.device !== "touch" || event.type === "click")
      return false;
    if (this.chart.ctx.chartService.touch.dragAction === "hover")
      return false;
    if (this.chart.ctx.chartService.touch.dragAction === "drag") {
      if (this.isState(9 /* AnnotationsMoveable */)) {
        return false;
      }
    }
    return true;
  }
  dataChanged() {
    var _a;
    (_a = this.highlight).stashedHoverEvent ?? (_a.stashedHoverEvent = this.highlight.appliedHoverEvent);
    this.chart.ctx.tooltipManager.removeTooltip(this.id);
    this.focusIndicator?.clear();
    this.clearHighlight();
  }
  preSceneRender() {
    if (this.highlight.stashedHoverEvent != null) {
      this.highlight.pendingHoverEvent = this.highlight.stashedHoverEvent;
      this.highlight.stashedHoverEvent = void 0;
      this.handleHoverHighlight(true);
    }
    if (this.tooltip.lastHover != null) {
      this.handleHoverTooltip(this.tooltip.lastHover, true);
    }
  }
  updateComplete() {
    if (this.isState(34 /* Focusable */) && this.focusIndicator?.isFocusVisible()) {
      this.handleSeriesFocus(0, 0, true);
    }
  }
  update(type, opts) {
    this.chart.ctx.updateService.update(type, opts);
  }
  seriesChanged(series) {
    this.focus.sortedSeries = [...series].sort((a, b) => {
      let fpA = a.properties.focusPriority ?? Infinity;
      let fpB = b.properties.focusPriority ?? Infinity;
      if (fpA === fpB) {
        [fpA, fpB] = [a._declarationOrder, b._declarationOrder];
      }
      if (fpA < fpB) {
        return -1;
      } else if (fpA > fpB) {
        return 1;
      }
      return 0;
    });
    this.series = series;
  }
  layoutComplete(event) {
    this.seriesRect = event.series.rect;
    this.hoverRect = event.series.paddedRect;
    this.chart.ctx.widgets.seriesWidget.setBounds(event.series.paddedRect);
    if (this.chart.ctx.domManager.mode === "normal") {
      this.chart.ctx.widgets.chartWidget.setBounds(event.chart);
    }
  }
  onContextMenu(event, current) {
    const { sourceEvent } = event;
    if (sourceEvent.currentTarget != current.getElement())
      return;
    if (sourceEvent.target == this.chart.ctx.widgets.containerWidget.getElement()) {
      if (this.isState(36 /* ContextMenuable */)) {
        const { currentX: canvasX2, currentY: canvasY2 } = event;
        this.chart.ctx.contextMenuRegistry.dispatchContext(
          "always",
          { widgetEvent: event, canvasX: canvasX2, canvasY: canvasY2 },
          void 0
        );
      }
      return;
    }
    let pickedNode;
    let position;
    if (this.focusIndicator?.isFocusVisible()) {
      pickedNode = this.chart.ctx.highlightManager.getActiveHighlight();
      if (pickedNode && this.seriesRect && pickedNode.midPoint) {
        position = Transformable.toCanvasPoint(
          pickedNode.series.contentGroup,
          pickedNode.midPoint.x,
          pickedNode.midPoint.y
        );
      }
    } else if (this.isState(36 /* ContextMenuable */)) {
      const pick = this.pickNodes({ x: event.currentX, y: event.currentY }, "context-menu");
      if (pick) {
        this.chart.ctx.highlightManager.updateHighlight(this.id);
        pickedNode = pick.matches[0].datum;
      }
    }
    const pickedSeries = pickedNode?.series;
    this.clearAll();
    const canvasX = event.currentX + current.cssLeft();
    const canvasY = event.currentY + current.cssTop();
    if (pickedSeries && pickedNode) {
      this.chart.ctx.contextMenuRegistry.dispatchContext(
        "series-node",
        { widgetEvent: event, canvasX, canvasY },
        { pickedSeries, pickedNode },
        position
      );
    } else {
      this.chart.ctx.contextMenuRegistry.dispatchContext(
        "series-area",
        { widgetEvent: event, canvasX, canvasY },
        void 0,
        position
      );
    }
  }
  onLeave(event) {
    if (!this.isState(41 /* Clickable */))
      return;
    const relatedTarget = event.sourceEvent.relatedTarget;
    if (relatedTarget?.className === "ag-charts-text-input__textarea") {
      return;
    }
    if (this.chart.ctx.tooltipManager.isEnteringInteractiveTooltip(event.sourceEvent)) {
      return;
    }
    this.chart.ctx.domManager.updateCursor(this.id);
    if (this.hoverDevice !== "keyboard")
      this.clearAll();
  }
  onWheel(_event) {
    if (!this.isState(41 /* Clickable */))
      return;
    this.focusIndicator?.overrideFocusVisible(false);
    this.previousInputDevice = "pointer";
  }
  onDragMove(event) {
    if (!this.isState(41 /* Clickable */))
      return;
    this.focusIndicator?.overrideFocusVisible(false);
    this.onHoverLikeEvent(event);
  }
  onHover(event) {
    if (!this.isState(41 /* Clickable */))
      return;
    this.onHoverLikeEvent(event);
  }
  onHoverLikeEvent(event) {
    if (this.isIgnoredTouch(event))
      return;
    if (event.device === "touch" || excludesType(event, "drag-move")) {
      this.tooltip.lastHover = event;
    }
    if (event.device === "touch" && this.chart.ctx.chartService.touch.dragAction === "hover") {
      event.sourceEvent.preventDefault();
    }
    this.hoverDevice = "pointer";
    this.previousInputDevice = "pointer";
    this.highlight.pendingHoverEvent = event;
    this.hoverScheduler.schedule();
    if (this.isState(32 /* Default */)) {
      const { currentX: x, currentY: y } = event;
      const matches = this.pickNodes({ x, y }, "event")?.matches;
      const found = matches?.[0];
      if (found?.series.hasEventListener("seriesNodeClick") || found?.series.hasEventListener("seriesNodeDoubleClick") || matches != null && matches.length > 1 && this.chart.tooltip.pagination) {
        this.chart.ctx.domManager.updateCursor(this.id, "pointer");
      } else {
        this.chart.ctx.domManager.updateCursor(this.id);
      }
    }
  }
  onClick(event, current) {
    if (current === this.chart.ctx.widgets.seriesWidget && this.chart.ctx.animationManager.isActive()) {
      this.chart.ctx.animationManager.skipCurrentBatch();
    }
    if (event.device === "touch" && current === this.chart.ctx.widgets.seriesWidget) {
      this.swapChain.focus({ preventScroll: true });
    }
    if (!this.isState(41 /* Clickable */))
      return;
    if (current === this.chart.ctx.widgets.seriesWidget) {
      if (!current.getElement().contains(event.sourceEvent.target)) {
        return;
      }
    } else if (event.sourceEvent.target != current.getElement()) {
      return;
    }
    this.focusIndicator?.overrideFocusVisible(false);
    this.onHoverLikeEvent(event);
    if (!this.isState(32 /* Default */))
      return;
    if (current == this.chart.ctx.widgets.seriesWidget && this.checkSeriesNodeClick(event)) {
      this.update(5 /* SERIES_UPDATE */);
      event.sourceEvent.preventDefault();
      return;
    }
    const newEvent = { type: event.type === "click" ? "click" : "doubleClick", event: event.sourceEvent };
    this.chart.fireEvent(newEvent);
  }
  onFocus() {
    if (!this.isState(34 /* Focusable */))
      return;
    this.hoverDevice = this.focusIndicator?.isFocusVisible(true) ? "keyboard" : "pointer";
    this.handleFocus(0, 0);
  }
  onBlur(event) {
    if (!this.isState(34 /* Focusable */))
      return;
    this.hoverDevice = "pointer";
    if (!this.chart.ctx.tooltipManager.isEnteringInteractiveTooltip(event)) {
      this.clearAll();
    }
    this.focusIndicator?.overrideFocusVisible(void 0);
  }
  onKeyDown(widgetEvent) {
    if (!this.isState(43 /* Keyable */))
      return;
    const action = mapKeyboardEventToAction(widgetEvent.sourceEvent);
    if (action?.activatesFocusIndicator === false) {
      this.focusIndicator?.overrideFocusVisible(this.previousInputDevice === "keyboard");
    }
    switch (action?.name) {
      case "redo":
        return this.chart.ctx.chartEventManager.seriesEvent("series-redo");
      case "undo":
        return this.chart.ctx.chartEventManager.seriesEvent("series-undo");
      case "zoomin":
        return this.chart.ctx.chartEventManager.seriesKeyNavZoom(1, widgetEvent);
      case "zoomout":
        return this.chart.ctx.chartEventManager.seriesKeyNavZoom(-1, widgetEvent);
      case "arrowup":
        return this.onArrow(-1, 0, widgetEvent);
      case "arrowdown":
        return this.onArrow(1, 0, widgetEvent);
      case "arrowleft":
        return this.onArrow(0, -1, widgetEvent);
      case "arrowright":
        return this.onArrow(0, 1, widgetEvent);
      case "submit":
        return this.onSubmit(widgetEvent);
    }
  }
  onArrow(seriesIndexDelta, datumIndexDelta, event) {
    if (!this.isState(34 /* Focusable */))
      return;
    this.hoverDevice = "keyboard";
    this.previousInputDevice = "keyboard";
    this.focusIndicator?.overrideFocusVisible(true);
    this.focus.seriesIndex += seriesIndexDelta;
    this.focus.datumIndex += datumIndexDelta;
    this.handleFocus(seriesIndexDelta, datumIndexDelta);
    event.sourceEvent.preventDefault();
    this.chart.ctx.chartEventManager.seriesEvent("series-focus-change");
  }
  onSubmit(event) {
    if (!this.isState(34 /* Focusable */))
      return;
    const { series, datum } = this.focus;
    const sourceEvent = event.sourceEvent;
    if (series !== void 0 && datum !== void 0) {
      series.fireNodeClickEvent(sourceEvent, datum);
    } else {
      this.chart.fireEvent({
        type: "click",
        event: sourceEvent
      });
    }
    sourceEvent.preventDefault();
  }
  checkSeriesNodeClick(event) {
    var _a;
    const result = this.pickNodes({ x: event.currentX, y: event.currentY }, "event");
    if (result == null || result.matches.length === 0)
      return;
    const paginationUpdate = this.chart.tooltip.pagination ? this.tooltipCandidates.update(result.matches, this.tooltipCandidates.current)?.current : void 0;
    const { series, datum } = paginationUpdate ?? result.matches[0];
    const distance = paginationUpdate == null ? result.distance : 0;
    if (event.type === "click") {
      const defaultBehavior = series.fireNodeClickEvent(event.sourceEvent, datum);
      const nextTooltipCandidate = defaultBehavior && this.chart.tooltip.pagination ? this.tooltipCandidates.next() : void 0;
      if (nextTooltipCandidate != null) {
        event.sourceEvent.preventDefault();
        const { currentX, currentY } = event;
        const canvasX = currentX + (this.hoverRect?.x ?? 0);
        const canvasY = currentY + (this.hoverRect?.y ?? 0);
        (_a = this.highlight).pendingHoverEvent ?? (_a.pendingHoverEvent = this.highlight.appliedHoverEvent);
        this.handleHoverHighlight(false);
        this.showTooltip(nextTooltipCandidate.current, canvasX, canvasY, {
          index: nextTooltipCandidate.index,
          length: nextTooltipCandidate.length
        });
      }
      return true;
    }
    if (event.type === "dblclick") {
      event.preventZoomDblClick = distance === 0;
      series.fireNodeDoubleClickEvent(event.sourceEvent, datum);
      return true;
    }
    return false;
  }
  handleFocus(seriesIndexDelta, datumIndexDelta) {
    const overlayFocus = this.chart.overlays.getFocusInfo(this.chart.ctx.localeManager);
    if (overlayFocus == null) {
      this.handleSeriesFocus(seriesIndexDelta, datumIndexDelta);
    } else {
      this.focusIndicator?.update(overlayFocus.rect, this.seriesRect, false);
    }
  }
  handleSeriesFocus(otherIndexDelta, datumIndexDelta, refresh = false) {
    if (this.chart.chartType === "hierarchy" || this.chart.chartType === "gauge") {
      this.handleSoloSeriesFocus(otherIndexDelta, datumIndexDelta, refresh);
      return;
    }
    const { focus } = this;
    const visibleSeries = focus.sortedSeries.filter((s) => s.visible && s.focusable);
    if (visibleSeries.length === 0)
      return;
    const oldDatumIndex = focus.datumIndex - datumIndexDelta;
    const oldOtherIndex = focus.seriesIndex - otherIndexDelta;
    focus.seriesIndex = (0, import_ag_charts_core109.clamp)(0, focus.seriesIndex, visibleSeries.length - 1);
    focus.series = visibleSeries[focus.seriesIndex];
    const datumIndex = this.focus.datumIndex;
    const otherIndex = this.focus.seriesIndex;
    this.updatePickedFocus(
      datumIndex,
      datumIndexDelta,
      oldDatumIndex,
      otherIndex,
      otherIndexDelta,
      oldOtherIndex,
      refresh
    );
  }
  handleSoloSeriesFocus(otherIndexDelta, datumIndexDelta, refresh) {
    this.focus.series = this.focus.sortedSeries[0];
    const datumIndex = this.focus.datumIndex;
    const otherIndex = this.focus.seriesIndex;
    const oldDatumIndex = this.focus.datumIndex - datumIndexDelta;
    const oldOtherIndex = this.focus.seriesIndex - otherIndexDelta;
    this.updatePickedFocus(
      datumIndex,
      datumIndexDelta,
      oldDatumIndex,
      otherIndex,
      otherIndexDelta,
      oldOtherIndex,
      refresh
    );
  }
  updatePickedFocus(datumIndex, datumIndexDelta, oldDatumIndex, otherIndex, otherIndexDelta, oldOtherIndex, refresh) {
    const { focus, hoverRect, seriesRect } = this;
    if (focus.series === void 0 || hoverRect === void 0)
      return;
    const pick = focus?.series?.pickFocus({ datumIndex, datumIndexDelta, otherIndex, otherIndexDelta, seriesRect });
    if (!pick)
      return;
    const { datum } = pick;
    if (pick.otherIndex !== void 0) {
      focus.seriesIndex = pick.otherIndex;
    }
    focus.datumIndex = pick.datumIndex;
    focus.datum = datum;
    if (this.focusIndicator?.isFocusVisible()) {
      this.chart.ctx.animationManager.reset();
    }
    if (this.focusIndicator?.isFocusVisible()) {
      const focusBBox = getPickedFocusBBox(pick);
      const { x, y } = focusBBox.computeCenter();
      if (!hoverRect.containsPoint(x, y)) {
        const panSuccess = this.chart.ctx.zoomManager.panToBBox(this.id, hoverRect, focusBBox);
        if (panSuccess) {
          return;
        }
      }
      const { x1, x2, y1, y2 } = Vec4.from(focusBBox);
      const nw = hoverRect.containsPoint(x1, y1);
      const ne = hoverRect.containsPoint(x2, y1);
      const sw = hoverRect.containsPoint(x1, y2);
      const se = hoverRect.containsPoint(x2, y2);
      if (!(nw || ne || sw || se)) {
        const hoverBounds = Vec4.from(hoverRect);
        pick.movedBounds = focusBBox.clone();
        if (x1 < hoverBounds.x1 && x2 < hoverBounds.x1) {
          pick.movedBounds.x = hoverBounds.x1 - 2;
          pick.movedBounds.width = 4;
        } else if (x1 > hoverBounds.x2 && x2 > hoverBounds.x2) {
          pick.movedBounds.x = hoverBounds.x2 - 2;
          pick.movedBounds.width = 4;
        }
        if (y1 < hoverBounds.y1 && y2 < hoverBounds.y1) {
          pick.movedBounds.y = hoverBounds.y1 - 2;
          pick.movedBounds.height = 4;
        } else if (y1 > hoverBounds.y2 && y2 > hoverBounds.y2) {
          pick.movedBounds.y = hoverBounds.y2 - 2;
          pick.movedBounds.height = 4;
        }
      }
    }
    this.focusIndicator?.update(pick.movedBounds ?? pick.bounds, this.seriesRect, pick.clipFocusBox);
    const keyboardEvent = makeKeyboardPointerEvent(focus.series, hoverRect, pick);
    if (keyboardEvent !== void 0 && this.hoverDevice === "keyboard") {
      this.tooltip.lastHover = void 0;
      this.highlight.appliedHoverEvent = void 0;
      this.highlight.pendingHoverEvent = void 0;
      this.highlight.stashedHoverEvent = void 0;
      const tooltipContent = this.chart.getTooltipContent(focus.series, datum.datumIndex, datum);
      const meta = TooltipManager.makeTooltipMeta(keyboardEvent, focus.series, datum, pick.movedBounds);
      this.chart.ctx.highlightManager.updateHighlight(this.id, datum);
      const tooltipEnabled = focus.series.tooltipEnabled ?? this.chart.tooltip.enabled;
      if (tooltipEnabled) {
        this.chart.ctx.tooltipManager.updateTooltip(this.id, meta, tooltipContent);
      } else {
        this.chart.ctx.tooltipManager.removeTooltip(this.id);
      }
      if (!refresh) {
        const shouldAnnouncePick = datumIndexDelta === 0 && otherIndexDelta === 0 || oldDatumIndex !== pick.datumIndex || oldOtherIndex !== (pick.otherIndex ?? focus.seriesIndex);
        if (shouldAnnouncePick) {
          this.swapChain.update(this.getDatumAriaText(datum, tooltipContent));
        }
      }
    }
  }
  getDatumAriaText(datum, tooltipContent) {
    const description = tooltipContent == null ? "" : tooltipContentAriaLabel(tooltipContent);
    return this.chart.ctx.localeManager.t("ariaAnnounceHoverDatum", {
      datum: datum.series.getDatumAriaText?.(datum, description) ?? description
    });
  }
  clearHighlight() {
    this.highlight.pendingHoverEvent = void 0;
    this.highlight.appliedHoverEvent = void 0;
    this.chart.ctx.highlightManager.updateHighlight(this.id);
  }
  clearTooltip() {
    this.chart.ctx.tooltipManager.removeTooltip(this.id);
    this.tooltip.lastHover = void 0;
  }
  clearAll() {
    this.clearHighlight();
    this.clearTooltip();
    this.focusIndicator?.clear();
  }
  handleHoverHighlight(redisplay) {
    this.highlight.appliedHoverEvent = this.highlight.pendingHoverEvent;
    this.highlight.pendingHoverEvent = void 0;
    const event = this.highlight.appliedHoverEvent;
    if (!event || !this.isState(41 /* Clickable */))
      return;
    const { currentX, currentY } = event;
    const canvasX = event.currentX + (this.hoverRect?.x ?? 0);
    const canvasY = event.currentY + (this.hoverRect?.y ?? 0);
    if (redisplay ? this.chart.ctx.animationManager.isActive() : !this.hoverRect?.containsPoint(canvasX, canvasY)) {
      this.clearHighlight();
      return;
    }
    const { range: range3 } = this.chart.highlight;
    const intent = range3 === "tooltip" ? "highlight-tooltip" : "highlight";
    const pick = this.pickNodes({ x: currentX, y: currentY }, intent);
    if (!pick || pick.matches.length === 0) {
      this.chart.ctx.highlightManager.updateHighlight(this.id);
      return;
    }
    const { current: tooltipPick } = this.tooltipCandidates;
    const tooltipMatch = tooltipPick == null ? void 0 : pick.matches.find((m) => pickedNodesEqual(m, tooltipPick));
    const datum = tooltipMatch?.datum ?? pick.matches[0].datum;
    this.chart.ctx.highlightManager.updateHighlight(this.id, datum);
    this.hoverDevice = "pointer";
  }
  handleHoverTooltip(event, redisplay) {
    const { current: previousHover } = this.tooltipCandidates;
    this.tooltipCandidates.reset();
    if (!this.isState(41 /* Clickable */))
      return;
    const { currentX, currentY } = event;
    const canvasX = currentX + (this.hoverRect?.x ?? 0);
    const canvasY = currentY + (this.hoverRect?.y ?? 0);
    const targetElement = event.sourceEvent.target;
    if (redisplay ? this.chart.ctx.animationManager.isActive() : !this.hoverRect?.containsPoint(canvasX, canvasY)) {
      if (this.hoverDevice == "pointer")
        this.clearTooltip();
      return;
    }
    if (targetElement && this.chart.tooltip.interactive && this.chart.ctx.domManager.isManagedChildDOMElement(targetElement, "canvas-overlay", DEFAULT_TOOLTIP_CLASS)) {
      return;
    }
    const pick = this.pickNodes({ x: event.currentX, y: event.currentY }, "tooltip");
    if (!pick || pick.matches.length === 0) {
      if (this.hoverDevice == "pointer")
        this.clearTooltip();
      return;
    }
    this.hoverDevice = "pointer";
    if (pick.distance === 0) {
      const { current, index, length } = this.tooltipCandidates.update(
        pick.matches,
        this.chart.tooltip.pagination ? previousHover : void 0
      );
      this.showTooltip(current, canvasX, canvasY, { index, length });
    } else {
      this.showTooltip(pick.matches[0], canvasX, canvasY);
    }
  }
  showTooltip({ series, datum, datumIndex }, canvasX, canvasY, pagination) {
    const content = this.chart.getTooltipContent(series, datumIndex, datum);
    const tooltipEnabled = series.tooltipEnabled ?? this.chart.tooltip.enabled;
    const shouldUpdateTooltip = tooltipEnabled && content != null;
    if (shouldUpdateTooltip) {
      const meta = TooltipManager.makeTooltipMeta(
        { type: "pointermove", canvasX, canvasY },
        series,
        datum,
        void 0
      );
      this.chart.ctx.tooltipManager.updateTooltip(this.id, meta, content, pagination);
    } else {
      this.chart.ctx.tooltipManager.removeTooltip(this.id);
    }
  }
  changeHighlightDatum(event) {
    const seriesToUpdate = /* @__PURE__ */ new Set();
    const { series: newSeries = void 0, datum: newDatum } = event.currentHighlight ?? {};
    const { series: lastSeries = void 0, datum: lastDatum } = event.previousHighlight ?? {};
    if (lastSeries) {
      seriesToUpdate.add(lastSeries);
    }
    if (newSeries) {
      seriesToUpdate.add(newSeries);
    }
    if (lastSeries?.properties.cursor && lastDatum) {
      this.chart.ctx.domManager.updateCursor(lastSeries.id);
    }
    if (newSeries?.properties.cursor && newSeries?.properties.cursor !== "default" && newDatum) {
      this.chart.ctx.domManager.updateCursor(newSeries.id, newSeries.properties.cursor);
    }
    const updateAll = newSeries == null || lastSeries == null;
    if (updateAll) {
      this.update(5 /* SERIES_UPDATE */);
    } else {
      this.update(5 /* SERIES_UPDATE */, { seriesToUpdate });
    }
  }
  pickNodes(point, intent, exactMatchOnly) {
    const reverseSeries = [...this.series].reverse();
    let result;
    for (const series of reverseSeries) {
      if (!series.visible || !series.contentGroup.visible)
        continue;
      const pick = series.pickNodes(point, intent, exactMatchOnly);
      if (pick == null || pick.datums.length === 0)
        continue;
      const { datums, distance } = pick;
      if (pick.datums.length === 0)
        continue;
      if (distance === 0) {
        if (result?.distance !== 0) {
          result = { matches: [], distance: 0 };
        }
        for (const datum of datums) {
          const { datumIndex } = datum;
          result.matches.push({ series, datum, datumIndex });
        }
      } else if (result == null || result.distance > distance) {
        const [datum] = datums;
        const { datumIndex } = datum;
        result = { matches: [{ series, datum, datumIndex }], distance };
      }
    }
    return result;
  }
};
function excludesType(obj, excluded) {
  return obj.type !== excluded;
}

// packages/ag-charts-community/src/chart/series/seriesLayerManager.ts
var import_ag_charts_core110 = require("ag-charts-core");
var SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION = 30;
var SeriesLayerManager = class {
  constructor(seriesRoot) {
    this.seriesRoot = seriesRoot;
    this.groups = /* @__PURE__ */ new Map();
    this.series = /* @__PURE__ */ new Map();
    this.expectedSeriesCount = 1;
    this.mode = "normal";
  }
  setSeriesCount(count) {
    this.expectedSeriesCount = count;
  }
  requestGroup(seriesConfig) {
    const { internalId, type, contentGroup: seriesContentGroup, seriesGrouping } = seriesConfig;
    const { groupIndex = internalId } = seriesGrouping ?? {};
    const seriesInfo = this.series.get(internalId);
    if (seriesInfo != null) {
      throw new Error(`AG Charts - series already has an allocated layer: ${JSON.stringify(seriesInfo)}`);
    }
    if (this.series.size === 0) {
      this.mode = this.expectedSeriesCount >= SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION ? "aggressive-grouping" : "normal";
    }
    let group = this.groups.get(type);
    if (group == null) {
      group = /* @__PURE__ */ new Map();
      this.groups.set(type, group);
    }
    const lookupIndex = this.lookupIdx(groupIndex);
    let groupInfo = group.get(lookupIndex);
    if (groupInfo == null) {
      groupInfo = {
        type,
        id: lookupIndex,
        seriesIds: [],
        group: this.seriesRoot.appendChild(
          new Group({
            name: `${seriesConfig.contentGroup.name ?? type}-managed-layer`,
            zIndex: seriesConfig.contentGroup.zIndex,
            // Set in updateLayerCompositing
            renderToOffscreenCanvas: false
          })
        )
      };
      group.set(lookupIndex, groupInfo);
    }
    this.series.set(internalId, { layerState: groupInfo, seriesConfig });
    groupInfo.seriesIds.push(internalId);
    groupInfo.group.appendChild(seriesContentGroup);
    return groupInfo.group;
  }
  changeGroup(seriesConfig) {
    const { internalId, seriesGrouping, type, contentGroup, oldGrouping } = seriesConfig;
    const { groupIndex = internalId } = seriesGrouping ?? {};
    if (this.groups.get(type)?.get(groupIndex)?.seriesIds.includes(internalId)) {
      return;
    }
    if (this.series.has(internalId)) {
      this.releaseGroup({
        internalId,
        seriesGrouping: oldGrouping,
        type,
        contentGroup
      });
    }
    this.requestGroup(seriesConfig);
  }
  releaseGroup(seriesConfig) {
    const { internalId, contentGroup, type } = seriesConfig;
    if (!this.series.has(internalId)) {
      throw new Error(`AG Charts - series doesn't have an allocated layer: ${internalId}`);
    }
    const groupInfo = this.series.get(internalId)?.layerState;
    if (groupInfo) {
      groupInfo.seriesIds = groupInfo.seriesIds.filter((v) => v !== internalId);
      groupInfo.group.removeChild(contentGroup);
    }
    if (groupInfo?.seriesIds.length === 0) {
      this.seriesRoot.removeChild(groupInfo.group);
      this.groups.get(groupInfo.type)?.delete(groupInfo.id);
      this.groups.get(type)?.delete(internalId);
    } else if (groupInfo != null && groupInfo.seriesIds.length > 0) {
      groupInfo.group.zIndex = this.getLowestSeriesZIndex(groupInfo.seriesIds);
    }
    this.series.delete(internalId);
  }
  updateLayerCompositing() {
    this.groups.forEach((groups) => {
      groups.forEach((groupInfo) => {
        const { group, seriesIds } = groupInfo;
        let renderToOffscreenCanvas;
        if (seriesIds.length === 0) {
          renderToOffscreenCanvas = false;
        } else if (seriesIds.length > 1) {
          renderToOffscreenCanvas = true;
        } else {
          const series = this.series.get(seriesIds[0]);
          renderToOffscreenCanvas = series?.seriesConfig.renderToOffscreenCanvas() === true;
        }
        group.renderToOffscreenCanvas = renderToOffscreenCanvas;
        group.zIndex = this.getLowestSeriesZIndex(seriesIds);
      });
    });
  }
  lookupIdx(groupIndex) {
    if (this.mode === "normal") {
      return groupIndex;
    }
    if (typeof groupIndex === "string") {
      groupIndex = Number(groupIndex.split("-").at(-1));
      if (!groupIndex) {
        return 0;
      }
    }
    return Math.floor(
      (0, import_ag_charts_core110.clamp)(0, groupIndex / this.expectedSeriesCount, 1) * SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION
    );
  }
  destroy() {
    this.groups.forEach((groups) => {
      groups.forEach((groupInfo) => {
        this.seriesRoot.removeChild(groupInfo.group);
      });
    });
    this.groups.clear();
    this.series.clear();
  }
  getLowestSeriesZIndex(seriesIds) {
    const lowestSeriesZIndex = seriesIds.reduce((currentLowest, seriesId) => {
      const series = this.series.get(seriesId);
      const zIndex = series?.seriesConfig.contentGroup.zIndex;
      if (currentLowest == null || zIndex == null)
        return zIndex;
      return compareZIndex(currentLowest, zIndex) <= 0 ? currentLowest : zIndex;
    }, void 0);
    return lowestSeriesZIndex ?? 1 /* ANY_CONTENT */;
  }
};

// packages/ag-charts-community/src/chart/touch.ts
var Touch = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.dragAction = "drag";
  }
};
__decorateClass([
  Property
], Touch.prototype, "dragAction", 2);

// packages/ag-charts-community/src/chart/update/dataWindowProcessor.ts
var DataWindowProcessor = class {
  constructor(chart, dataService, updateService, zoomManager, animationManager) {
    this.chart = chart;
    this.dataService = dataService;
    this.updateService = updateService;
    this.zoomManager = zoomManager;
    this.animationManager = animationManager;
    this.dirtyZoom = false;
    this.dirtyDataSource = false;
    this.lastAxisZooms = /* @__PURE__ */ new Map();
    this.destroyFns = [];
    this.destroyFns.push(
      this.dataService.addListener("data-source-change", () => this.onDataSourceChange()),
      this.dataService.addListener("data-load", () => this.onDataLoad()),
      this.dataService.addListener("data-error", () => this.onDataError()),
      this.updateService.addListener("update-complete", (e) => this.onUpdateComplete(e)),
      this.zoomManager.addListener("zoom-change", () => this.onZoomChange())
    );
  }
  destroy() {
    this.destroyFns.forEach((cb) => cb());
  }
  onDataLoad() {
    this.animationManager.skip();
    this.updateService.update(1 /* UPDATE_DATA */);
  }
  onDataError() {
    this.updateService.update(4 /* PERFORM_LAYOUT */);
  }
  onDataSourceChange() {
    this.dirtyDataSource = true;
  }
  onUpdateComplete(event) {
    if (!event.apiUpdate && !this.dirtyZoom && !this.dirtyDataSource)
      return;
    this.updateWindow(event);
  }
  onZoomChange() {
    this.dirtyZoom = true;
  }
  updateWindow(event) {
    if (!this.dataService.isLazy())
      return;
    const axis = this.getValidAxis();
    let window2;
    let shouldRefresh = true;
    if (axis) {
      const zoom = this.zoomManager.getAxisZoom(axis.id);
      window2 = this.getAxisWindow(axis, zoom);
      shouldRefresh = this.shouldRefresh(event, axis, zoom);
    }
    this.dirtyZoom = false;
    this.dirtyDataSource = false;
    if (!shouldRefresh)
      return;
    this.dataService.load({ windowStart: window2?.min, windowEnd: window2?.max });
  }
  getValidAxis() {
    return this.chart.axes.find((axis) => axis.type === "time");
  }
  shouldRefresh(event, axis, zoom) {
    if (event.apiUpdate)
      return true;
    if (this.dirtyDataSource)
      return true;
    if (!this.dirtyZoom)
      return false;
    const lastZoom = this.lastAxisZooms.get(axis.id);
    if (lastZoom && zoom.min === lastZoom.min && zoom.max === lastZoom.max) {
      return false;
    }
    this.lastAxisZooms.set(axis.id, zoom);
    return true;
  }
  getAxisWindow(axis, zoom) {
    const { domain } = axis.scale;
    if (!zoom || domain.length === 0 || isNaN(Number(domain[0])))
      return;
    const diff2 = Number(domain[1]) - Number(domain[0]);
    const min = new Date(Number(domain[0]) + diff2 * zoom.min);
    const max = new Date(Number(domain[0]) + diff2 * zoom.max);
    return { min, max };
  }
};

// packages/ag-charts-community/src/chart/update/overlaysProcessor.ts
var import_ag_charts_core112 = require("ag-charts-core");

// packages/ag-charts-community/src/util/browser.ts
var import_ag_charts_core111 = require("ag-charts-core");
var isSafariRegexp = /^((?!chrome|android).)*safari/i;
var safariVersionRegexp = /Version\/(\d+(\.\d+)?)/;
var isChromeRegexp = /Chrome/;
var chromeVersionRegexp = /Chrome\/(\d+)/;
var isEdge = /Edg/;
var isOpera = /OPR/;
function isUnsupportedBrowser() {
  const { userAgent } = (0, import_ag_charts_core111.getWindow)("navigator");
  if (isSafariRegexp.test(userAgent)) {
    const versionExec = safariVersionRegexp.exec(userAgent);
    if (versionExec == null)
      return false;
    const version = parseFloat(versionExec[1]);
    const supported = Math.floor(version) > 16;
    if (!supported) {
      import_ag_charts_core111.Logger.warnOnce(`Unsupported Safari version: ${version}; ${userAgent}`);
    }
    return !supported;
  } else if (isChromeRegexp.test(userAgent) && !isEdge.test(userAgent) && !isOpera.test(userAgent)) {
    const versionExec = chromeVersionRegexp.exec(userAgent);
    if (versionExec == null)
      return false;
    const version = parseInt(versionExec[1], 10);
    const supported = version > 126;
    if (!supported) {
      import_ag_charts_core111.Logger.warnOnce(`Unsupported Chrome version: ${version}; ${userAgent}`);
    }
    return !supported;
  }
  return false;
}

// packages/ag-charts-community/src/chart/update/overlaysProcessor.ts
var visibleIgnoredSeries = /* @__PURE__ */ new Set(["map-shape-background", "map-line-background"]);
var OverlaysProcessor = class {
  constructor(chartLike, overlays, dataService, layoutManager, localeManager, animationManager, domManager) {
    this.chartLike = chartLike;
    this.overlays = overlays;
    this.dataService = dataService;
    this.layoutManager = layoutManager;
    this.localeManager = localeManager;
    this.animationManager = animationManager;
    this.domManager = domManager;
    this.destroyFns = [];
    this.overlayElem = this.domManager.addChild("canvas-overlay", "overlay");
    this.overlayElem.role = "status";
    this.overlayElem.ariaAtomic = "false";
    this.overlayElem.ariaLive = "polite";
    this.overlayElem.classList.toggle(DEFAULT_OVERLAY_CLASS);
    this.destroyFns.push(this.layoutManager.addListener("layout:complete", (e) => this.onLayoutComplete(e)));
  }
  destroy() {
    this.destroyFns.forEach((cb) => cb());
    this.domManager.removeChild("canvas-overlay", "overlay");
  }
  onLayoutComplete({ series: { rect } }) {
    const isLoading = this.dataService.isLoading();
    const hasData = this.chartLike.series.some((s) => s.hasData);
    const anySeriesVisible = this.chartLike.series.some((s) => s.visible && !visibleIgnoredSeries.has(s.type));
    if (this.overlays.darkTheme) {
      this.overlayElem.classList.add(DEFAULT_OVERLAY_DARK_CLASS);
    } else {
      this.overlayElem.classList.remove(DEFAULT_OVERLAY_DARK_CLASS);
    }
    this.overlayElem.style.left = `${rect.x}px`;
    this.overlayElem.style.top = `${rect.y}px`;
    this.overlayElem.style.width = `${rect.width}px`;
    this.overlayElem.style.height = `${rect.height}px`;
    const loadingShown = isLoading;
    const noDataShown = !isLoading && !hasData;
    const noVisibleSeriesShown = hasData && !anySeriesVisible;
    const unsupportedBrowser = this.overlays.unsupportedBrowser.enabled && isUnsupportedBrowser();
    if (loadingShown) {
      this.showOverlay(this.overlays.loading, rect);
    } else {
      this.hideOverlay(this.overlays.loading);
    }
    if (noDataShown) {
      this.showOverlay(this.overlays.noData, rect);
    } else {
      this.hideOverlay(this.overlays.noData);
    }
    if (noVisibleSeriesShown) {
      this.showOverlay(this.overlays.noVisibleSeries, rect);
    } else {
      this.hideOverlay(this.overlays.noVisibleSeries);
    }
    if (unsupportedBrowser) {
      this.showOverlay(this.overlays.unsupportedBrowser, rect);
    } else {
      this.hideOverlay(this.overlays.unsupportedBrowser);
    }
    const shown = loadingShown || noDataShown || noVisibleSeriesShown || unsupportedBrowser;
    (0, import_ag_charts_core112.setAttribute)(this.overlayElem, "aria-hidden", !shown);
  }
  showOverlay(overlay, seriesRect) {
    if (!overlay.enabled)
      return;
    const element2 = overlay.getElement(this.animationManager, this.localeManager, seriesRect);
    this.overlayElem.appendChild(element2);
  }
  hideOverlay(overlay) {
    overlay.removeElement(() => {
      this.overlayElem.innerText = "\xA0";
    }, this.animationManager);
  }
};

// packages/ag-charts-community/src/chart/chart.ts
var debug = Debug.create(true, "opts");
var SeriesArea = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.padding = new Padding(0);
  }
};
__decorateClass([
  Property
], SeriesArea.prototype, "clip", 2);
__decorateClass([
  Property
], SeriesArea.prototype, "padding", 2);
var _Chart = class _Chart extends Observable {
  constructor(options, resources) {
    var _a;
    super();
    this.id = (0, import_ag_charts_core113.createId)(this);
    this.seriesRoot = new TranslatableGroup({
      name: `${this.id}-series-root`,
      zIndex: 5 /* SERIES_LAYER */
    });
    this.annotationRoot = new TranslatableGroup({
      name: `${this.id}-annotation-root`,
      zIndex: 9 /* SERIES_ANNOTATION */
    });
    this.titleGroup = new Group({
      name: "titles",
      zIndex: 13 /* SERIES_LABEL */
    });
    this.debug = Debug.create();
    this.extraDebugStats = {};
    this.data = [];
    this._firstAutoSize = true;
    this._autoSizeNotify = new import_ag_charts_core113.AsyncAwaitQueue();
    this.padding = new Padding(20);
    this.seriesArea = new SeriesArea();
    this.keyboard = new Keyboard();
    this.touch = new Touch();
    this.mode = "standalone";
    this.chartCaptions = new ChartCaptions();
    this.suppressFieldDotNotation = false;
    this.loadGoogleFonts = false;
    this.destroyed = false;
    this._destroyFns = [];
    this.chartAnimationPhase = "initial";
    this.modulesManager = new ModulesManager();
    this.processors = [];
    this.queuedUserOptions = [];
    this.queuedChartOptions = [];
    this.firstApply = true;
    this.syncStatus = "init";
    this.apiUpdate = false;
    this._pendingFactoryUpdatesCount = 0;
    this._performUpdateSkipAnimations = false;
    this._performUpdateNotify = new import_ag_charts_core113.AsyncAwaitQueue();
    this.performUpdateType = 8 /* NONE */;
    this.runningUpdateType = 8 /* NONE */;
    this.updateShortcutCount = 0;
    this.seriesToUpdate = /* @__PURE__ */ new Set();
    this.updateMutex = new Mutex();
    this.updateRequestors = {};
    this.performUpdateTrigger = debouncedCallback(({ count }) => {
      if (this.destroyed)
        return;
      this.updateMutex.acquire(async () => {
        try {
          await this.performUpdate(count);
        } catch (error) {
          import_ag_charts_core113.Logger.error("update error", error);
        }
      }).catch((e) => import_ag_charts_core113.Logger.errorOnce(e));
    });
    this._performUpdateSplits = {};
    this.axes = [];
    this.series = [];
    this._cachedData = void 0;
    this.onSeriesNodeClick = (event) => {
      this.fireEvent(event);
    };
    this.onSeriesNodeDoubleClick = (event) => {
      this.fireEvent(event);
    };
    this.onSeriesVisibilityChange = (event) => {
      this.fireEvent(event);
    };
    this.seriesGroupingChanged = (event) => {
      if (!(event instanceof SeriesGroupingChangedEvent))
        return;
      const { series, seriesGrouping, oldGrouping } = event;
      if (series.contentGroup.isRoot())
        return;
      this.seriesLayerManager.changeGroup({
        internalId: series.internalId,
        type: series.type,
        contentGroup: series.contentGroup,
        renderToOffscreenCanvas: () => series.renderToOffscreenCanvas(),
        seriesGrouping,
        oldGrouping
      });
    };
    this.chartOptions = options;
    const scene = resources?.scene;
    const container = resources?.container ?? options.processedOptions.container ?? void 0;
    const styleContainer = resources?.styleContainer ?? options.specialOverrides.styleContainer;
    if (scene) {
      this._firstAutoSize = false;
      this._lastAutoSize = [scene.width, scene.height, scene.pixelRatio];
    }
    const root = new Group({ name: "root" });
    root.visible = false;
    root.append(this.seriesRoot);
    root.append(this.annotationRoot);
    root.append(this.titleGroup);
    this.titleGroup.append(this.title.node);
    this.titleGroup.append(this.subtitle.node);
    this.titleGroup.append(this.footnote.node);
    this.tooltip = new Tooltip();
    this.seriesLayerManager = new SeriesLayerManager(this.seriesRoot);
    this.mode = options.userOptions.mode ?? this.mode;
    this.styleNonce = options.processedOptions.styleNonce;
    const ctx = this.ctx = new ChartContext(this, {
      chartType: this.getChartType(),
      scene,
      root,
      container,
      styleContainer,
      domMode: options.optionMetadata.domMode,
      syncManager: new SyncManager(this),
      fireEvent: (event) => this.fireEvent(event),
      updateCallback: (type, opts) => this.update(type, opts),
      updateMutex: this.updateMutex
    });
    this._destroyFns.push(
      ctx.domManager.addListener("resize", () => this.parentResize(ctx.domManager.containerSize))
    );
    this.overlays = new ChartOverlays();
    (_a = this.overlays.loading).renderer ?? (_a.renderer = () => getLoadingSpinner(this.overlays.loading.getText(ctx.localeManager), ctx.animationManager.defaultDuration));
    this.processors = [
      new DataWindowProcessor(this, ctx.dataService, ctx.updateService, ctx.zoomManager, ctx.animationManager),
      new OverlaysProcessor(
        this,
        this.overlays,
        ctx.dataService,
        ctx.layoutManager,
        ctx.localeManager,
        ctx.animationManager,
        ctx.domManager
      )
    ];
    this.highlight = new ChartHighlight();
    this.container = container;
    const moduleContext = this.getModuleContext();
    ctx.domManager.setDataBoolean("animating", false);
    this.seriesAreaManager = new SeriesAreaManager(this.initSeriesAreaDependencies());
    this._destroyFns.push(
      ctx.layoutManager.registerElement(0 /* Caption */, (e) => {
        e.layoutBox.shrink(this.padding.toJson());
        this.chartCaptions.positionCaptions(e);
      }),
      ctx.layoutManager.addListener("layout:complete", (e) => this.chartCaptions.positionAbsoluteCaptions(e)),
      ctx.dataService.addListener("data-load", (event) => {
        this.data = event.data;
      }),
      this.title.registerInteraction(moduleContext, "beforebegin"),
      this.subtitle.registerInteraction(moduleContext, "beforebegin"),
      this.footnote.registerInteraction(moduleContext, "afterend"),
      Widget.addWindowEvent("page-left", () => this.destroy()),
      ctx.animationManager.addListener("animation-frame", () => {
        this.update(7 /* SCENE_RENDER */);
      }),
      ctx.animationManager.addListener("animation-start", () => ctx.domManager.setDataBoolean("animating", true)),
      ctx.animationManager.addListener("animation-stop", () => ctx.domManager.setDataBoolean("animating", false)),
      ctx.zoomManager.addListener("zoom-change", () => {
        this.series.forEach((s) => s.animationState?.transition("updateData"));
        const skipAnimations = this.chartAnimationPhase !== "initial";
        this.update(4 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });
      })
    );
    this.parentResize(ctx.domManager.containerSize);
  }
  static getInstance(element2) {
    return _Chart.chartsInstances.get(element2);
  }
  /** NOTE: This is exposed for use by Integrated charts only. */
  get canvasElement() {
    return this.ctx.scene.canvas.element;
  }
  download(fileName, fileFormat) {
    this.ctx.scene.download(fileName, fileFormat);
  }
  getCanvasDataURL(fileFormat) {
    return this.ctx.scene.getDataURL(fileFormat);
  }
  toSVG() {
    return this.ctx.scene.toSVG();
  }
  get seriesAreaBoundingBox() {
    return this.seriesAreaManager.bbox;
  }
  getOptions() {
    return this.queuedUserOptions.at(-1) ?? this.chartOptions.userOptions;
  }
  getChartOptions() {
    return this.queuedChartOptions.at(-1) ?? this.chartOptions;
  }
  overrideFocusVisible(visible) {
    this.seriesAreaManager.focusIndicator?.overrideFocusVisible(visible);
  }
  initSeriesAreaDependencies() {
    const { ctx, tooltip, highlight, overlays, seriesRoot, mode } = this;
    const chartType = this.getChartType();
    const fireEvent = this.fireEvent.bind(this);
    const getUpdateType = () => this.performUpdateType;
    const getTooltipContent = (series, datumIndex, removeThisDatum) => this.getTooltipContent(series, datumIndex, removeThisDatum);
    return {
      fireEvent,
      getUpdateType,
      getTooltipContent,
      chartType,
      ctx,
      tooltip,
      highlight,
      overlays,
      seriesRoot,
      mode
    };
  }
  getModuleContext() {
    return this.ctx;
  }
  getTooltipContent(series, datumIndex, removeMeDatum) {
    const baseTooltipContent = series.properties.tooltip.enabled !== false ? series.getTooltipContent(datumIndex, removeMeDatum) : void 0;
    const tooltipContent = baseTooltipContent == null ? [] : [baseTooltipContent];
    if (this.tooltip.mode !== "shared" || this.series.length === 1) {
      return tooltipContent;
    }
    const categoryValue = series.getCategoryValue(datumIndex);
    if (categoryValue == null)
      return tooltipContent;
    return this.series.flatMap((s) => {
      if (s === series)
        return tooltipContent;
      if (!s.isEnabled() || s.properties.tooltip.enabled === false)
        return [];
      const seriesDatumIndex = s.datumIndexForCategoryValue(categoryValue);
      const seriesTooltipContent = seriesDatumIndex == null ? void 0 : s.getTooltipContent(seriesDatumIndex, void 0);
      return seriesTooltipContent == null ? [] : [seriesTooltipContent];
    });
  }
  getCaptionText() {
    return [this.title, this.subtitle, this.footnote].filter((caption) => caption.enabled && caption.text).map((caption) => caption.text).join(". ");
  }
  getAriaLabel() {
    return this.ctx.localeManager.t("ariaAnnounceChart", { seriesCount: this.series.length });
  }
  resetAnimations() {
    this.chartAnimationPhase = "initial";
    for (const series of this.series) {
      series.resetAnimation(this.chartAnimationPhase);
    }
    for (const axis of this.axes) {
      axis.resetAnimation(this.chartAnimationPhase);
    }
    this.animationRect = void 0;
    this.ctx.animationManager.reset();
  }
  skipAnimations() {
    this.ctx.animationManager.skipCurrentBatch();
    this._performUpdateSkipAnimations = true;
  }
  detachAndClear() {
    this.container = void 0;
    this.ctx.scene.clearCanvas();
  }
  destroy(opts) {
    if (this.destroyed) {
      return;
    }
    const keepTransferableResources = opts?.keepTransferableResources;
    let result;
    this.performUpdateType = 8 /* NONE */;
    this._destroyFns.forEach((fn) => fn());
    this.processors.forEach((p) => p.destroy());
    this.overlays.destroy();
    this.modulesManager.destroy();
    if (keepTransferableResources) {
      this.ctx.scene.strip();
      result = {
        container: this.container,
        scene: this.ctx.scene
      };
    } else {
      this.ctx.scene.destroy();
      this.container = void 0;
    }
    this.destroySeries(this.series);
    this.seriesLayerManager.destroy();
    this.axes.forEach((a) => a.destroy());
    this.axes = [];
    this.animationRect = void 0;
    this.ctx.destroy();
    this.destroyed = true;
    Object.freeze(this);
    return result;
  }
  requestFactoryUpdate(cb) {
    if (this.destroyed)
      return;
    this._pendingFactoryUpdatesCount++;
    this.updateMutex.acquire(async () => {
      if (this.destroyed)
        return;
      try {
        await cb(this);
      } finally {
        if (!this.destroyed) {
          this._pendingFactoryUpdatesCount--;
        }
      }
    }).catch((e) => import_ag_charts_core113.Logger.errorOnce(e));
  }
  clearCallbackCache() {
    this.ctx.callbackCache.invalidateCache();
    for (const series of this.series) {
      series.resetDatumCallbackCache();
    }
  }
  update(type = 0 /* FULL */, opts) {
    if (this.destroyed)
      return;
    const {
      forceNodeDataRefresh = false,
      skipAnimations,
      seriesToUpdate = this.series,
      newAnimationBatch,
      apiUpdate = false
    } = opts ?? {};
    this.apiUpdate = apiUpdate;
    this.ctx.widgets.seriesWidget.setDragTouchEnabled(this.touch.dragAction !== "none");
    if (forceNodeDataRefresh) {
      this.series.forEach((series) => series.markNodeDataDirty());
    }
    for (const series of seriesToUpdate) {
      this.seriesToUpdate.add(series);
    }
    if (skipAnimations) {
      this.ctx.animationManager.skipCurrentBatch();
      this._performUpdateSkipAnimations = true;
    }
    if (newAnimationBatch && this.ctx.animationManager.isActive()) {
      this._performUpdateSkipAnimations = true;
    }
    if (this.debug.check()) {
      let stack = new Error().stack ?? "<unknown>";
      stack = stack.replace(/\([^)]*/g, "");
      this.updateRequestors[stack] = type;
    }
    if (type < this.performUpdateType) {
      this.performUpdateType = type;
      this.ctx.domManager.setDataBoolean("updatePending", true);
      this.performUpdateTrigger.schedule(opts?.backOffMs);
    }
  }
  async performUpdate(count) {
    const { performUpdateType, extraDebugStats, _performUpdateSplits: splits, ctx } = this;
    const seriesToUpdate = [...this.seriesToUpdate];
    this.clearCallbackCache();
    this.performUpdateType = 8 /* NONE */;
    this.seriesToUpdate.clear();
    this.runningUpdateType = performUpdateType;
    if (this.updateShortcutCount === 0 && performUpdateType < 7 /* SCENE_RENDER */) {
      ctx.animationManager.startBatch(this._performUpdateSkipAnimations);
      ctx.animationManager.onBatchStop(() => this.chartAnimationPhase = "ready");
    }
    this.ctx.scene.updateDebugFlags();
    this.debug("Chart.performUpdate() - start", ChartUpdateType[performUpdateType]);
    let previousSplit = performance.now();
    splits.start ?? (splits.start = previousSplit);
    const updateSplits = (splitName) => {
      splits[splitName] ?? (splits[splitName] = 0);
      splits[splitName] += performance.now() - previousSplit;
      previousSplit = performance.now();
    };
    switch (performUpdateType) {
      case 0 /* FULL */:
        if (this.checkUpdateShortcut(0 /* FULL */))
          break;
        this.ctx.updateService.dispatchPreDomUpdate();
        this.updateDOM();
      case 1 /* UPDATE_DATA */:
        if (this.checkUpdateShortcut(1 /* UPDATE_DATA */))
          break;
        await this.updateData();
        updateSplits("\u2B07\uFE0F");
      case 2 /* PROCESS_DATA */:
        if (this.checkUpdateShortcut(2 /* PROCESS_DATA */))
          break;
        await this.processData();
        this.seriesAreaManager.dataChanged();
        updateSplits("\u{1F3ED}");
      case 3 /* PROCESS_DOMAIN */:
        if (this.checkUpdateShortcut(3 /* PROCESS_DOMAIN */))
          break;
        await this.processDomains();
        updateSplits("\u26F0\uFE0F");
      case 4 /* PERFORM_LAYOUT */:
        await this.checkFirstAutoSize();
        if (this.checkUpdateShortcut(4 /* PERFORM_LAYOUT */))
          break;
        await this.processLayout();
        updateSplits("\u2316");
      case 5 /* SERIES_UPDATE */: {
        if (this.checkUpdateShortcut(5 /* SERIES_UPDATE */))
          break;
        await this.updateSeries(seriesToUpdate);
        updateSplits("\u{1F914}");
        this.updateAriaLabels();
        this.seriesLayerManager.updateLayerCompositing();
      }
      case 6 /* PRE_SCENE_RENDER */:
        if (this.checkUpdateShortcut(6 /* PRE_SCENE_RENDER */))
          break;
        ctx.updateService.dispatchPreSceneRender();
        updateSplits("\u2196");
      case 7 /* SCENE_RENDER */:
        if (this.checkUpdateShortcut(7 /* SCENE_RENDER */))
          break;
        ctx.animationManager.endBatch();
        extraDebugStats["updateShortcutCount"] = this.updateShortcutCount;
        ctx.scene.render({ debugSplitTimes: splits, extraDebugStats, seriesRect: this.seriesRect });
        this.extraDebugStats = {};
        for (const key of Object.keys(splits)) {
          delete splits[key];
        }
        this.ctx.domManager.incrementDataCounter("sceneRenders");
        this.ctx.domManager.postRenderUpdate();
      case 8 /* NONE */:
        this.updateShortcutCount = 0;
        this.updateRequestors = {};
        this._performUpdateSkipAnimations = false;
        ctx.animationManager.endBatch();
    }
    if (!this.destroyed) {
      ctx.updateService.dispatchUpdateComplete(this.apiUpdate);
      this.apiUpdate = false;
      this.ctx.domManager.setDataBoolean("updatePending", false);
      this.runningUpdateType = 8 /* NONE */;
      this.syncStatus = "ready";
    }
    this._performUpdateNotify.notify();
    const end2 = performance.now();
    this.debug("Chart.performUpdate() - end", {
      chart: this,
      durationMs: Math.round((end2 - splits["start"]) * 100) / 100,
      count,
      performUpdateType: ChartUpdateType[performUpdateType]
    });
  }
  updateThemeClassName() {
    const themeClassNamePrefix = "ag-charts-theme-";
    const validThemeClassNames = [`${themeClassNamePrefix}default`, `${themeClassNamePrefix}default-dark`];
    let themeClassName = validThemeClassNames[0];
    let isDark = false;
    let { theme } = this.chartOptions.processedOptions;
    while (typeof theme !== "string" && theme != null) {
      theme = theme.baseTheme;
    }
    if (typeof theme === "string") {
      themeClassName = theme.replace("ag-", themeClassNamePrefix);
      isDark = theme.includes("-dark");
    }
    if (!validThemeClassNames.includes(themeClassName)) {
      themeClassName = isDark ? validThemeClassNames[1] : validThemeClassNames[0];
    }
    this.ctx.domManager.setThemeClass(themeClassName);
  }
  updateDOM() {
    this.updateThemeClassName();
    const { enabled, tabIndex } = this.keyboard;
    this.ctx.domManager.setTabGuardIndex(enabled ? tabIndex ?? 0 : -1);
    this.ctx.domManager.setThemeParameters(this.chartOptions.themeParameters);
  }
  updateAriaLabels() {
    this.ctx.domManager.updateCanvasLabel(this.getAriaLabel());
  }
  checkUpdateShortcut(checkUpdateType) {
    const maxShortcuts = 3;
    if (this.destroyed)
      return true;
    if (this.updateShortcutCount > maxShortcuts) {
      import_ag_charts_core113.Logger.warn(
        `exceeded the maximum number of simultaneous updates (${maxShortcuts + 1}), discarding changes and rendering`,
        this.updateRequestors
      );
      return false;
    }
    if (this.performUpdateType <= checkUpdateType) {
      this.updateShortcutCount++;
      return true;
    }
    return false;
  }
  async checkFirstAutoSize() {
    if (this.width != null && this.height != null) {
    } else if (!this._lastAutoSize) {
      const success = await this._autoSizeNotify.await(500);
      if (!success) {
        this.debug("Chart.checkFirstAutoSize() - timeout for first size update.");
      }
    }
  }
  onAxisChange(newValue, oldValue) {
    if (oldValue == null && newValue.length === 0)
      return;
    this.ctx.axisManager.updateAxes(oldValue ?? [], newValue);
  }
  onSeriesChange(newValue, oldValue) {
    const seriesToDestroy = oldValue?.filter((series) => !newValue.includes(series)) ?? [];
    this.destroySeries(seriesToDestroy);
    this.seriesLayerManager?.setSeriesCount(newValue.length);
    for (const series of newValue) {
      if (oldValue?.includes(series))
        continue;
      const seriesContentNode = this.seriesLayerManager.requestGroup(series);
      series.attachSeries(seriesContentNode, this.seriesRoot, this.annotationRoot);
      const chart = this;
      series.chart = {
        get mode() {
          return chart.mode;
        },
        get isMiniChart() {
          return false;
        },
        get seriesRect() {
          return chart.seriesRect;
        }
      };
      series.resetAnimation(this.chartAnimationPhase);
      this.addSeriesListeners(series);
      series.addChartEventListeners();
    }
    this.seriesAreaManager?.seriesChanged(newValue);
  }
  destroySeries(allSeries) {
    allSeries?.forEach((series) => {
      series.removeEventListener("seriesNodeClick", this.onSeriesNodeClick);
      series.removeEventListener("seriesNodeDoubleClick", this.onSeriesNodeDoubleClick);
      series.removeEventListener("groupingChanged", this.seriesGroupingChanged);
      series.destroy();
      this.seriesLayerManager.releaseGroup(series);
      series.detachSeries(void 0, this.seriesRoot, this.annotationRoot);
      series.chart = void 0;
    });
  }
  addSeriesListeners(series) {
    if (this.hasEventListener("seriesNodeClick")) {
      series.addEventListener("seriesNodeClick", this.onSeriesNodeClick);
    }
    if (this.hasEventListener("seriesNodeDoubleClick")) {
      series.addEventListener("seriesNodeDoubleClick", this.onSeriesNodeDoubleClick);
    }
    if (this.hasEventListener("seriesVisibilityChange")) {
      series.addEventListener("seriesVisibilityChange", this.onSeriesVisibilityChange);
    }
    series.addEventListener("groupingChanged", this.seriesGroupingChanged);
  }
  assignSeriesToAxes() {
    for (const axis of this.axes) {
      axis.boundSeries = this.series.filter((s) => s.axes[axis.direction] === axis);
    }
  }
  assignAxesToSeries() {
    const directionToAxesMap = (0, import_ag_charts_core113.groupBy)(this.axes, (axis) => axis.direction);
    for (const series of this.series) {
      for (const direction of series.directions) {
        const directionAxes = directionToAxesMap[direction];
        if (!directionAxes) {
          import_ag_charts_core113.Logger.warnOnce(
            `no available axis for direction [${direction}]; check series and axes configuration.`
          );
          return;
        }
        const seriesKeys = series.getKeys(direction);
        const newAxis = directionAxes.find(
          (axis) => !axis.keys.length || seriesKeys.some((key) => axis.keys.includes(key))
        );
        if (!newAxis) {
          import_ag_charts_core113.Logger.warnOnce(
            `no matching axis for direction [${direction}] and keys [${seriesKeys}]; check series and axes configuration.`
          );
          return;
        }
        series.axes[direction] = newAxis;
      }
    }
  }
  parentResize(size) {
    if (size == null || this.width != null && this.height != null)
      return;
    let { width: width2, height: height2 } = size;
    const { pixelRatio } = size;
    width2 = Math.floor(width2);
    height2 = Math.floor(height2);
    if (width2 === 0 && height2 === 0)
      return;
    const [autoWidth = 0, autoHeight = 0, autoPixelRatio = 1] = this._lastAutoSize ?? [];
    if (autoWidth === width2 && autoHeight === height2 && autoPixelRatio === pixelRatio)
      return;
    this._lastAutoSize = [width2, height2, pixelRatio];
    this.resize("SizeMonitor", {});
  }
  resize(source, opts) {
    const { scene, animationManager } = this.ctx;
    const { inWidth, inHeight, inMinWidth, inMinHeight, inOverrideDevicePixelRatio } = opts;
    this.ctx.domManager.setSizeOptions(
      inMinWidth ?? this.minWidth,
      inMinHeight ?? this.minHeight,
      inWidth ?? this.width,
      inHeight ?? this.height
    );
    const width2 = inWidth ?? this.width ?? this._lastAutoSize?.[0];
    const height2 = inHeight ?? this.height ?? this._lastAutoSize?.[1];
    const pixelRatio = inOverrideDevicePixelRatio ?? this.overrideDevicePixelRatio ?? this._lastAutoSize?.[2];
    this.debug(`Chart.resize() from ${source}`, { width: width2, height: height2, pixelRatio, stack: new Error().stack });
    if (width2 == null || height2 == null || !(0, import_ag_charts_core113.isFiniteNumber)(width2) || !(0, import_ag_charts_core113.isFiniteNumber)(height2))
      return;
    if (scene.resize(width2, height2, pixelRatio)) {
      animationManager.reset();
      let skipAnimations = true;
      if ((this.width == null || this.height == null) && this._firstAutoSize) {
        skipAnimations = false;
        this._firstAutoSize = false;
      }
      this.update(4 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });
      this._autoSizeNotify.notify();
    }
  }
  async updateData() {
    this.series.forEach((s) => s.setChartData(this.data));
    const modulePromises = this.modulesManager.mapModules((m) => m.updateData?.(this.data));
    await Promise.all(modulePromises);
  }
  async processData() {
    if (this.series.some((s) => s.canHaveAxes)) {
      this.assignAxesToSeries();
      this.assignSeriesToAxes();
    }
    const dataController = new DataController(this.mode, this.suppressFieldDotNotation);
    const seriesPromises = this.series.map((s) => s.processData(dataController));
    const modulePromises = this.modulesManager.mapModules((m) => m.processData?.(dataController));
    this._cachedData = dataController.execute(this._cachedData);
    await Promise.all([...seriesPromises, ...modulePromises]);
    this.updateLegends();
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async processDomains() {
    for (const axis of this.axes) {
      axis.processData();
    }
    for (const series of this.series) {
      series.updatedDomains();
    }
  }
  updateLegends(initialStateLegend) {
    for (const { legend, legendType } of this.modulesManager.legends()) {
      if (legendType === "category") {
        this.setCategoryLegendData(initialStateLegend);
      } else {
        this.setLegendData(legendType, legend);
      }
    }
  }
  setCategoryLegendData(initialState) {
    var _a;
    const {
      ctx: { legendManager, stateManager }
    } = this;
    if (initialState) {
      this.series.forEach((s) => {
        const seriesState = initialState.find((init) => init.seriesId === s.id);
        s.onLegendInitialState("category", seriesState);
      });
    }
    const legendData = this.series.flatMap((s) => {
      const seriesLegendData = s.getLegendData("category");
      legendManager.updateData(s.id, seriesLegendData);
      return seriesLegendData;
    });
    if (initialState) {
      stateManager.setStateAndRestore(legendManager, initialState);
      return;
    }
    if (this.mode !== "integrated") {
      const seriesMarkerFills = {};
      const seriesTypeMap = new Map(this.series.map((s) => [s.id, s.type]));
      for (const {
        seriesId,
        symbol: { marker },
        label
      } of legendData.filter((d) => !d.hideInLegend)) {
        if (marker.fill == null)
          continue;
        const seriesType = seriesTypeMap.get(seriesId);
        const markerFill = seriesMarkerFills[seriesType] ?? (seriesMarkerFills[seriesType] = {});
        markerFill[_a = label.text] ?? (markerFill[_a] = marker.fill);
        if (markerFill[label.text] !== marker.fill) {
          import_ag_charts_core113.Logger.warnOnce(
            `legend item '${label.text}' has multiple fill colors, this may cause unexpected behaviour.`
          );
        }
      }
    }
    legendManager.update();
  }
  setLegendData(legendType, legend) {
    legend.data = this.series.filter((s) => s.properties.showInLegend).flatMap((s) => s.getLegendData(legendType));
  }
  async processLayout() {
    const oldRect = this.animationRect;
    const { width: width2, height: height2 } = this.ctx.scene;
    const ctx = this.ctx.layoutManager.createContext(width2, height2);
    await this.performLayout(ctx);
    if (oldRect && !this.animationRect?.equals(oldRect)) {
      this.ctx.animationManager.skipCurrentBatch();
    }
    this.debug("Chart.performUpdate() - seriesRect", this.seriesRect);
  }
  async updateSeries(seriesToUpdate) {
    const { seriesRect } = this;
    await Promise.all(seriesToUpdate.map((series) => series.update({ seriesRect })));
    this.ctx.seriesLabelLayoutManager.updateLabels(
      this.series.filter((s) => s.visible && s.usesPlacedLabels),
      this.padding,
      this.seriesRect
    );
  }
  async waitForUpdate(timeoutMs = 1e4, failOnTimeout = false) {
    const start2 = performance.now();
    while (this._pendingFactoryUpdatesCount > 0 || this.performUpdateType !== 8 /* NONE */ || this.runningUpdateType !== 8 /* NONE */ || this.ctx.scene.waitingForUpdate()) {
      if (this.destroyed)
        break;
      if (this._pendingFactoryUpdatesCount > 0) {
        await this.updateMutex.waitForClearAcquireQueue();
      }
      if (this.performUpdateType !== 8 /* NONE */ || this.runningUpdateType !== 8 /* NONE */) {
        await this._performUpdateNotify.await();
      }
      if (performance.now() - start2 > timeoutMs) {
        const message = `Chart.waitForUpdate() timeout of ${timeoutMs} reached - first chart update taking too long.`;
        if (failOnTimeout) {
          throw new Error(message);
        } else {
          import_ag_charts_core113.Logger.warnOnce(message);
        }
      }
      if (isInputPending()) {
        await (0, import_ag_charts_core113.pause)();
      }
      if (this.ctx.scene.waitingForUpdate()) {
        await (0, import_ag_charts_core113.pause)(50);
      }
    }
  }
  filterMiniChartSeries(series) {
    return series?.filter((s) => s.showInMiniChart !== false);
  }
  applyOptions(newChartOptions) {
    const deltaOptions = this.firstApply ? newChartOptions.processedOptions : newChartOptions.diffOptions(this.chartOptions);
    if (deltaOptions == null || Object.keys(deltaOptions).length === 0)
      return;
    const oldOpts = this.firstApply ? {} : this.chartOptions.processedOptions;
    const newOpts = newChartOptions.processedOptions;
    debug("Chart.applyOptions() - applying delta", deltaOptions);
    const modulesChanged = this.applyModules(newOpts);
    const skip = [
      "type",
      "data",
      "series",
      "listeners",
      "preset",
      "theme",
      "legend.listeners",
      "navigator.miniChart.series",
      "navigator.miniChart.label",
      "locale.localeText",
      "axes",
      "topology",
      "nodes",
      "initialState",
      "styleContainer"
    ];
    if (deltaOptions.listeners) {
      this.registerListeners(this, deltaOptions.listeners);
    }
    jsonApply(this, deltaOptions, { skip });
    let forceNodeDataRefresh = false;
    let seriesStatus = "no-op";
    if (deltaOptions.series != null) {
      seriesStatus = this.applySeries(this, deltaOptions.series, oldOpts?.series);
      forceNodeDataRefresh = true;
    }
    if (seriesStatus === "replaced") {
      this.resetAnimations();
    }
    if (this.applyAxes(this, newOpts, oldOpts, seriesStatus, [])) {
      forceNodeDataRefresh = true;
    }
    if (deltaOptions.data) {
      this.data = deltaOptions.data;
    }
    if (deltaOptions.legend?.listeners && this.modulesManager.isEnabled("legend")) {
      Object.assign(this.legend.listeners, deltaOptions.legend.listeners);
    }
    if (deltaOptions.locale?.localeText) {
      this.modulesManager.getModule("locale").localeText = deltaOptions.locale?.localeText;
    }
    this.chartOptions = newChartOptions;
    const navigatorModule = this.modulesManager.getModule("navigator");
    const zoomModule = this.modulesManager.getModule("zoom");
    if (!navigatorModule?.enabled && !zoomModule?.enabled) {
      this.ctx.zoomManager.updateZoom("chart");
    }
    const miniChart = navigatorModule?.miniChart;
    const miniChartSeries = newOpts.navigator?.miniChart?.series ?? newOpts.series;
    if (miniChart?.enabled === true && miniChartSeries != null) {
      this.applyMiniChartOptions(miniChart, miniChartSeries, newOpts, oldOpts);
    } else if (miniChart?.enabled === false) {
      miniChart.series = [];
      miniChart.axes = [];
    }
    this.ctx.annotationManager.setAnnotationStyles(newChartOptions.annotationThemes);
    forceNodeDataRefresh || (forceNodeDataRefresh = this.shouldForceNodeDataRefresh(deltaOptions, seriesStatus));
    const majorChange = forceNodeDataRefresh || modulesChanged;
    const updateType = majorChange ? 0 /* FULL */ : 4 /* PERFORM_LAYOUT */;
    this.maybeResetAnimations(seriesStatus);
    if (this.shouldClearLegendData(newOpts, oldOpts, seriesStatus)) {
      this.ctx.legendManager.clearData();
    }
    this.applyInitialState(newOpts);
    debug("Chart.applyOptions() - update type", ChartUpdateType[updateType], {
      seriesStatus,
      forceNodeDataRefresh
    });
    this.update(updateType, { apiUpdate: true, forceNodeDataRefresh, newAnimationBatch: true });
    this.firstApply = false;
  }
  applyInitialState(options) {
    const { annotationManager, chartTypeOriginator, historyManager, stateManager, zoomManager } = this.ctx;
    const { initialState } = options;
    if ("annotations" in options && options.annotations?.enabled && initialState?.annotations != null) {
      const annotations = initialState.annotations.map((annotation) => {
        const annotationTheme = annotationManager.getAnnotationTypeStyles(annotation.type);
        return mergeDefaults(annotation, annotationTheme);
      });
      stateManager.setState(annotationManager, annotations);
    }
    if (initialState?.chartType != null) {
      stateManager.setState(chartTypeOriginator, initialState.chartType);
    }
    if ((options.navigator?.enabled || options.zoom?.enabled) && initialState?.zoom != null) {
      stateManager.setState(zoomManager, initialState.zoom);
    }
    if (initialState?.legend != null) {
      this.updateLegends(initialState.legend);
    }
    if (initialState != null) {
      historyManager.clear();
    }
  }
  maybeResetAnimations(seriesStatus) {
    if (this.mode !== "standalone")
      return;
    switch (seriesStatus) {
      case "series-grouping-change":
      case "replaced":
        this.resetAnimations();
        break;
      default:
    }
  }
  shouldForceNodeDataRefresh(deltaOptions, seriesStatus) {
    const seriesDataUpdate = !!deltaOptions.data || seriesStatus === "data-change" || seriesStatus === "replaced";
    const legendKeys = legendRegistry.getKeys();
    const optionsHaveLegend = Object.values(legendKeys).some(
      (legendKey) => deltaOptions[legendKey] != null
    );
    const otherRefreshUpdate = deltaOptions.title != null && deltaOptions.subtitle != null;
    return seriesDataUpdate || optionsHaveLegend || otherRefreshUpdate;
  }
  shouldClearLegendData(options, oldOpts, seriesStatus) {
    const seriesChanged = seriesStatus === "replaced" || seriesStatus === "series-grouping-change" || seriesStatus === "updated" && (options.series?.length !== oldOpts.series?.length || !options.series?.every((s, i) => s.type === oldOpts.series?.[i].type));
    const legendRemoved = oldOpts.legend != null && options.legend == null;
    return seriesChanged || legendRemoved;
  }
  applyMiniChartOptions(miniChart, miniChartSeries, completeOptions, oldOpts) {
    const oldSeries = oldOpts?.navigator?.miniChart?.series ?? oldOpts?.series;
    const miniChartSeriesStatus = this.applySeries(
      miniChart,
      this.filterMiniChartSeries(miniChartSeries),
      this.filterMiniChartSeries(oldSeries)
    );
    this.applyAxes(miniChart, completeOptions, oldOpts, miniChartSeriesStatus, [
      "axes[].tick",
      "axes[].thickness",
      "axes[].title",
      "axes[].crosshair",
      "axes[].gridLine",
      "axes[].label"
    ]);
    const series = miniChart.series;
    for (const s of series) {
      s.properties.id = void 0;
    }
    const axes = miniChart.axes;
    const horizontalAxis = axes.find((axis) => axis.direction === "x" /* X */);
    for (const axis of axes) {
      axis.nice = false;
      axis.gridLine.enabled = false;
      axis.label.enabled = axis === horizontalAxis;
      axis.tick.enabled = false;
      axis.interactionEnabled = false;
    }
    if (horizontalAxis != null) {
      const miniChartOpts = completeOptions.navigator?.miniChart;
      const labelOptions = miniChartOpts?.label;
      const intervalOptions = miniChartOpts?.label?.interval;
      horizontalAxis.line.enabled = false;
      horizontalAxis.label.set(
        without(labelOptions, ["interval", "rotation", "minSpacing", "autoRotate", "autoRotateAngle"])
      );
      horizontalAxis.tick.set(
        without(intervalOptions, ["enabled", "width", "size", "color", "interval", "step"])
      );
      if (horizontalAxis.type === "grouped-category") {
        horizontalAxis.label.enabled = false;
        horizontalAxis.label.rotation = 0;
        const { depthOptions } = horizontalAxis;
        if (depthOptions.length === 0) {
          depthOptions.set([{ label: { enabled: true } }]);
        } else {
          for (let i = 1; i < depthOptions.length; i++) {
            depthOptions[i].label.enabled = false;
          }
        }
      } else if (horizontalAxis.type === "time" || horizontalAxis.type === "unit-time" || horizontalAxis.type === "ordinal-time") {
        horizontalAxis.parentLevel.enabled = false;
      }
      const step = intervalOptions?.step;
      if (step != null) {
        horizontalAxis.interval.step = step;
      }
    }
  }
  applyModules(options) {
    const { type: chartType } = this.constructor;
    let modulesChanged = false;
    for (const module2 of moduleRegistry.byType("root", "legend")) {
      const isConfigured = options[module2.optionsKey] != null;
      const shouldBeEnabled = isConfigured && module2.chartTypes.includes(chartType);
      if (shouldBeEnabled === this.modulesManager.isEnabled(module2))
        continue;
      if (shouldBeEnabled) {
        this.modulesManager.addModule(module2, (m) => m.moduleFactory(this.getModuleContext()));
        if (module2.type === "legend") {
          this.modulesManager.getModule(module2)?.attachLegend(this.ctx.scene);
        }
        this[module2.optionsKey] = this.modulesManager.getModule(module2);
      } else {
        this.modulesManager.removeModule(module2);
        delete this[module2.optionsKey];
      }
      modulesChanged = true;
    }
    return modulesChanged;
  }
  initSeriesDeclarationOrder(series) {
    for (let idx = 0; idx < series.length; idx++) {
      series[idx].setSeriesIndex(idx);
    }
  }
  applySeries(chart, optSeries, oldOptSeries) {
    if (!optSeries) {
      return "no-change";
    }
    const matchResult = matchSeriesOptions(chart.series, optSeries, oldOptSeries);
    if (matchResult.status === "no-overlap") {
      debug(`Chart.applySeries() - creating new series instances, status: ${matchResult.status}`, matchResult);
      const chartSeries = optSeries.map((opts) => this.createSeries(opts));
      this.initSeriesDeclarationOrder(chartSeries);
      chart.series = chartSeries;
      return "replaced";
    }
    debug(`Chart.applySeries() - matchResult`, matchResult);
    const seriesInstances = [];
    let dataChanged = false;
    let groupingChanged = false;
    let isUpdated = false;
    const changes = matchResult.changes.toSorted((a, b) => a.targetIdx - b.targetIdx);
    for (const change of changes) {
      groupingChanged || (groupingChanged = change.status === "series-grouping");
      dataChanged || (dataChanged = change.diff?.data != null);
      isUpdated || (isUpdated = change.status !== "no-op");
      switch (change.status) {
        case "add": {
          const newSeries = this.createSeries(change.opts);
          seriesInstances.push(newSeries);
          debug(`Chart.applySeries() - created new series`, newSeries);
          break;
        }
        case "remove":
          debug(`Chart.applySeries() - removing series at previous idx ${change.idx}`, change.series);
          break;
        case "no-op":
          seriesInstances.push(change.series);
          debug(`Chart.applySeries() - no change to series at previous idx ${change.idx}`, change.series);
          break;
        case "series-grouping":
        case "update":
        default: {
          const { series, diff: diff2, idx } = change;
          debug(`Chart.applySeries() - applying series diff previous idx ${idx}`, diff2, series);
          this.applySeriesValues(series, diff2);
          series.markNodeDataDirty();
          seriesInstances.push(series);
        }
      }
    }
    this.initSeriesDeclarationOrder(seriesInstances);
    debug(`Chart.applySeries() - final series instances`, seriesInstances);
    chart.series = seriesInstances;
    if (groupingChanged) {
      return "series-grouping-change";
    }
    if (dataChanged) {
      return "data-change";
    }
    return isUpdated ? "updated" : "no-op";
  }
  applyAxes(chart, options, oldOpts, seriesStatus, skip = []) {
    if (!("axes" in options) || !options.axes) {
      return false;
    }
    skip = ["axes[].type", ...skip];
    const axes = options.axes.map((axis) => {
      if (axis.type === "time" && axis.unit != null) {
        return { ...axis, type: "unit-time" };
      }
      return axis;
    });
    const forceRecreate = seriesStatus === "replaced";
    const matchingTypes = !forceRecreate && chart.axes.length === axes.length && chart.axes.every((a, i) => a.type === axes[i].type);
    if (matchingTypes && isAgCartesianChartOptions(oldOpts)) {
      chart.axes.forEach((axis, index) => {
        const previousOpts = oldOpts.axes?.[index] ?? {};
        const axisDiff = jsonDiff(previousOpts, axes[index]);
        debug(`Chart.applyAxes() - applying axis diff idx ${index}`, axisDiff);
        const path = `axes[${index}]`;
        jsonApply(axis, axisDiff, { path, skip });
      });
      return true;
    }
    debug(`Chart.applyAxes() - creating new axes instances; seriesStatus: ${seriesStatus}`);
    chart.axes = this.createAxis(axes, skip);
    return true;
  }
  createSeries(seriesOptions) {
    const seriesInstance = seriesRegistry.create(seriesOptions.type, this.getModuleContext());
    this.applySeriesOptionModules(seriesInstance, seriesOptions);
    this.applySeriesValues(seriesInstance, seriesOptions);
    return seriesInstance;
  }
  applySeriesOptionModules(series, options) {
    const moduleContext = series.createModuleContext();
    const moduleMap = series.getModuleMap();
    for (const module2 of moduleRegistry.byType("series-option")) {
      if (module2.optionsKey in options && module2.seriesTypes.includes(series.type)) {
        moduleMap.addModule(module2, (m) => m.moduleFactory(moduleContext));
      }
    }
  }
  applySeriesValues(target, options) {
    const moduleMap = target.getModuleMap();
    const { type: _, data, listeners, seriesGrouping, showInMiniChart: __, ...seriesOptions } = options;
    for (const moduleDef of EXPECTED_ENTERPRISE_MODULES) {
      if (moduleDef.type !== "series-option")
        continue;
      if (moduleDef.optionsKey in seriesOptions) {
        const module2 = moduleMap.getModule(moduleDef.optionsKey);
        if (module2) {
          const moduleOptions = seriesOptions[moduleDef.optionsKey];
          delete seriesOptions[moduleDef.optionsKey];
          module2.properties.set(moduleOptions);
        }
      }
    }
    if (seriesOptions.visible != null) {
      target.visible = seriesOptions.visible;
    }
    target.properties.set(seriesOptions);
    if ("data" in options) {
      target.setOptionsData(data);
    }
    if (listeners) {
      this.registerListeners(target, listeners, {
        nodeClick: "seriesNodeClick",
        nodeDoubleClick: "seriesNodeDoubleClick"
      });
    }
    if ("seriesGrouping" in options) {
      if (seriesGrouping == null) {
        target.seriesGrouping = void 0;
      } else {
        target.seriesGrouping = { ...target.seriesGrouping, ...seriesGrouping };
      }
    }
  }
  createAxis(options, skip) {
    const newAxes = [];
    const moduleContext = this.getModuleContext();
    for (let index = 0; index < options.length; index++) {
      const axisOptions = options[index];
      const axis = axisRegistry.create(axisOptions.type, moduleContext);
      this.applyAxisModules(axis, axisOptions);
      jsonApply(axis, axisOptions, { path: `axes[${index}]`, skip });
      newAxes.push(axis);
    }
    guessInvalidPositions(newAxes);
    return newAxes;
  }
  applyAxisModules(axis, options) {
    const moduleContext = axis.createModuleContext();
    const moduleMap = axis.getModuleMap();
    for (const module2 of moduleRegistry.byType("axis-option")) {
      const shouldBeEnabled = options[module2.optionsKey] != null;
      if (shouldBeEnabled === moduleMap.isEnabled(module2))
        continue;
      if (shouldBeEnabled) {
        moduleMap.addModule(module2, (m) => m.moduleFactory(moduleContext));
        axis[module2.optionsKey] = moduleMap.getModule(module2);
      } else {
        moduleMap.removeModule(module2);
        delete axis[module2.optionsKey];
      }
    }
  }
  registerListeners(source, listeners, mapping) {
    source.clearEventListeners();
    for (const [property, listener] of (0, import_ag_charts_core113.entries)(listeners)) {
      if ((0, import_ag_charts_core113.isFunction)(listener)) {
        const mappedEventName = mapping?.[property];
        if (mappedEventName == null) {
          source.addEventListener(property, listener);
        } else {
          source.addEventListener(mappedEventName, (e) => {
            if (e?.type === mappedEventName) {
              const clone2 = new Proxy(e, {
                get(target, p, receiver) {
                  return p === "type" ? property : Reflect.get(target, p, receiver);
                }
              });
              listener(clone2);
            } else {
              listener(e);
            }
          });
        }
      }
    }
  }
};
_Chart.chartsInstances = /* @__PURE__ */ new WeakMap();
__decorateClass([
  ActionOnSet({
    newValue(value) {
      if (this.destroyed)
        return;
      this.ctx.domManager.setContainer(value);
      _Chart.chartsInstances.set(value, this);
    },
    oldValue(value) {
      _Chart.chartsInstances.delete(value);
    }
  })
], _Chart.prototype, "container", 2);
__decorateClass([
  ActionOnSet({
    newValue(value) {
      this.resize("width option", { inWidth: value });
    }
  })
], _Chart.prototype, "width", 2);
__decorateClass([
  ActionOnSet({
    newValue(value) {
      this.resize("height option", { inHeight: value });
    }
  })
], _Chart.prototype, "height", 2);
__decorateClass([
  ActionOnSet({
    newValue(value) {
      this.resize("minWidth option", { inMinWidth: value });
    }
  })
], _Chart.prototype, "minWidth", 2);
__decorateClass([
  ActionOnSet({
    newValue(value) {
      this.resize("minHeight option", { inMinHeight: value });
    }
  })
], _Chart.prototype, "minHeight", 2);
__decorateClass([
  ActionOnSet({
    newValue(value) {
      this.resize("overrideDevicePixelRatio option", { inOverrideDevicePixelRatio: value });
    }
  })
], _Chart.prototype, "overrideDevicePixelRatio", 2);
__decorateClass([
  Property
], _Chart.prototype, "padding", 2);
__decorateClass([
  Property
], _Chart.prototype, "seriesArea", 2);
__decorateClass([
  Property
], _Chart.prototype, "keyboard", 2);
__decorateClass([
  Property
], _Chart.prototype, "touch", 2);
__decorateClass([
  Property
], _Chart.prototype, "mode", 2);
__decorateClass([
  Property
], _Chart.prototype, "styleNonce", 2);
__decorateClass([
  ProxyProperty("chartCaptions.title")
], _Chart.prototype, "title", 2);
__decorateClass([
  ProxyProperty("chartCaptions.subtitle")
], _Chart.prototype, "subtitle", 2);
__decorateClass([
  ProxyProperty("chartCaptions.footnote")
], _Chart.prototype, "footnote", 2);
__decorateClass([
  Property
], _Chart.prototype, "suppressFieldDotNotation", 2);
__decorateClass([
  Property
], _Chart.prototype, "loadGoogleFonts", 2);
__decorateClass([
  ActionOnSet({
    changeValue(newValue, oldValue) {
      this.onAxisChange(newValue, oldValue);
    }
  })
], _Chart.prototype, "axes", 2);
__decorateClass([
  ActionOnSet({
    changeValue(newValue, oldValue) {
      this.onSeriesChange(newValue, oldValue);
    }
  })
], _Chart.prototype, "series", 2);
var Chart = _Chart;

// packages/ag-charts-community/src/chart/series/cartesian/cartesianSeries.ts
var import_ag_charts_core116 = require("ag-charts-core");

// packages/ag-charts-community/src/scale/logScale.ts
var import_ag_charts_core114 = require("ag-charts-core");
var logFunctions = {
  2: (_base, x) => Math.log2(x),
  [Math.E]: (_base, x) => Math.log(x),
  10: (_base, x) => Math.log10(x)
};
var DEFAULT_LOG = (base, x) => Math.log(x) / Math.log(base);
function log(base, domain, x) {
  const start2 = Math.min(...domain);
  const fn = logFunctions[base] ?? DEFAULT_LOG;
  return start2 >= 0 ? fn(base, x) : -fn(base, -x);
}
var powFunctions = {
  [Math.E]: (_base, x) => Math.exp(x),
  10: (_base, x) => x >= 0 ? 10 ** x : 1 / 10 ** -x
};
var DEFAULT_POW = (base, x) => base ** x;
function pow(base, domain, x) {
  const start2 = Math.min(...domain);
  const fn = powFunctions[base] ?? DEFAULT_POW;
  return start2 >= 0 ? fn(base, x) : -fn(base, -x);
}
var LogScale = class _LogScale extends ContinuousScale {
  constructor(d = [1, 10], r = [0, 1]) {
    super(d, r);
    this.type = "log";
    // Handling <1 and crossing 0 cases is tricky, easiest solution is to default to clamping.
    this.defaultClamp = true;
    this.base = 10;
    this.log = (x) => log(this.base, this.domain, x);
    this.pow = (x) => pow(this.base, this.domain, x);
  }
  static is(value) {
    return value instanceof _LogScale;
  }
  toDomain(d) {
    return d;
  }
  transform(x) {
    const [min, max] = findMinMax(this.domain);
    if (min >= 0 !== max >= 0)
      return NaN;
    return min >= 0 ? Math.log(x) : -Math.log(-x);
  }
  transformInvert(x) {
    const [min, max] = findMinMax(this.domain);
    if (min >= 0 !== max >= 0)
      return NaN;
    return min >= 0 ? Math.exp(x) : -Math.exp(-x);
  }
  niceDomain(_ticks, domain = this.domain) {
    if (domain.length < 2)
      return [];
    const { base } = this;
    const [d0, d1] = domain;
    const roundStart = d0 > d1 ? Math.ceil : Math.floor;
    const roundStop = d0 > d1 ? Math.floor : Math.ceil;
    const n0 = pow(base, domain, roundStart(log(base, domain, d0)));
    const n1 = pow(base, domain, roundStop(log(base, domain, d1)));
    return [n0, n1];
  }
  ticks({ interval, tickCount = ContinuousScale.defaultTickCount }, domain = this.domain, visibleRange) {
    if (!domain || domain.length < 2 || tickCount < 1) {
      return;
    }
    const base = this.base;
    const [d0, d1] = domain;
    const start2 = Math.min(d0, d1);
    const stop = Math.max(d0, d1);
    let p0 = this.log(start2);
    let p1 = this.log(stop);
    if (interval) {
      const inBounds = (tick) => tick >= start2 && tick <= stop;
      const step = Math.min(Math.abs(interval), Math.abs(p1 - p0));
      const { ticks: rangeTicks, count } = range(p0, p1, step, visibleRange);
      const ticks2 = rangeTicks.map(this.pow).filter(inBounds);
      if (!isDenseInterval(ticks2.length, this.getPixelRange())) {
        return { ticks: ticks2, count };
      }
    }
    if (!(0, import_ag_charts_core114.isInteger)(base) || p1 - p0 >= tickCount) {
      const step = Math.min(p1 - p0, tickCount);
      const { ticks: ticks2, count } = createTicks(p0, p1, step, void 0, void 0, visibleRange);
      return {
        ticks: ticks2.map(this.pow),
        count
      };
    }
    const ticks = [];
    const isPositive = start2 > 0;
    p0 = Math.floor(p0) - 1;
    p1 = Math.round(p1) + 1;
    const availableSpacing = findRangeExtent(this.range) / tickCount;
    let lastTickPosition = Infinity;
    for (let p = p0; p <= p1; p++) {
      const nextMagnitudeTickPosition = this.convert(this.pow(p + 1));
      for (let k = 1; k < base; k++) {
        const q = isPositive ? k : base - k + 1;
        const t = this.pow(p) * q;
        const tickPosition = this.convert(t);
        const prevSpacing = Math.abs(lastTickPosition - tickPosition);
        const nextSpacing = Math.abs(tickPosition - nextMagnitudeTickPosition);
        const fits = prevSpacing >= availableSpacing && nextSpacing >= availableSpacing;
        if (t >= start2 && t <= stop && (k === 1 || fits || ticks.length === 0)) {
          ticks.push(t);
          lastTickPosition = tickPosition;
        }
      }
    }
    return filterVisibleTicks(ticks, isPositive, visibleRange);
  }
  tickFormatter({ specifier }) {
    return specifier != null ? (0, import_ag_charts_core114.createNumberFormatter)(specifier) : String;
  }
  datumFormatter(params) {
    return this.tickFormatter(params);
  }
};

// packages/ag-charts-community/src/scene/util/quadtree.ts
var QuadtreeNearest = class {
  constructor(capacity, maxdepth, boundary) {
    this.root = new QuadtreeNodeNearest(capacity, maxdepth, boundary);
  }
  clear(boundary) {
    this.root.clear(boundary);
  }
  addValue(hitTester, value) {
    const elem = {
      hitTester,
      value,
      distanceSquared: (x, y) => {
        return hitTester.distanceSquared(x, y);
      }
    };
    this.root.addElem(elem);
  }
  find(x, y) {
    const arg = { best: { nearest: void 0, distanceSquared: Infinity } };
    this.root.find(x, y, arg);
    return arg.best;
  }
};
var QuadtreeSubdivisions = class {
  constructor(nw, ne, sw, se) {
    this.nw = nw;
    this.ne = ne;
    this.sw = sw;
    this.se = se;
  }
  addElem(elem) {
    this.nw.addElem(elem);
    this.ne.addElem(elem);
    this.sw.addElem(elem);
    this.se.addElem(elem);
  }
  find(x, y, arg) {
    this.nw.find(x, y, arg);
    this.ne.find(x, y, arg);
    this.sw.find(x, y, arg);
    this.se.find(x, y, arg);
  }
};
var QuadtreeNode = class {
  constructor(capacity, maxdepth, boundary) {
    this.capacity = capacity;
    this.maxdepth = maxdepth;
    this.boundary = boundary ?? BBox.NaN;
    this.elems = [];
    this.subdivisions = void 0;
  }
  clear(boundary) {
    this.elems.length = 0;
    this.boundary = boundary;
    this.subdivisions = void 0;
  }
  addElem(e) {
    if (this.addCondition(e)) {
      if (this.subdivisions === void 0) {
        if (this.maxdepth === 0 || this.elems.length < this.capacity) {
          this.elems.push(e);
        } else {
          this.subdivide(e);
        }
      } else {
        this.subdivisions.addElem(e);
      }
    }
  }
  find(x, y, arg) {
    if (this.findCondition(x, y, arg)) {
      if (this.subdivisions === void 0) {
        this.findAction(x, y, arg);
      } else {
        this.subdivisions.find(x, y, arg);
      }
    }
  }
  subdivide(newElem) {
    this.subdivisions = this.makeSubdivisions();
    for (const e of this.elems) {
      this.subdivisions.addElem(e);
    }
    this.subdivisions.addElem(newElem);
    this.elems.length = 0;
  }
  makeSubdivisions() {
    const { x, y, width: width2, height: height2 } = this.boundary;
    const { capacity } = this;
    const depth = this.maxdepth - 1;
    const halfWidth = width2 / 2;
    const halfHeight = height2 / 2;
    const nwBoundary = new BBox(x, y, halfWidth, halfHeight);
    const neBoundary = new BBox(x + halfWidth, y, halfWidth, halfHeight);
    const swBoundary = new BBox(x, y + halfHeight, halfWidth, halfHeight);
    const seBoundary = new BBox(x + halfWidth, y + halfHeight, halfWidth, halfHeight);
    return new QuadtreeSubdivisions(
      this.child(capacity, depth, nwBoundary),
      this.child(capacity, depth, neBoundary),
      this.child(capacity, depth, swBoundary),
      this.child(capacity, depth, seBoundary)
    );
  }
};
var QuadtreeNodeNearest = class _QuadtreeNodeNearest extends QuadtreeNode {
  addCondition(e) {
    const { x, y } = e.hitTester.midPoint;
    return this.boundary.containsPoint(x, y);
  }
  findCondition(x, y, arg) {
    const { best } = arg;
    return best.distanceSquared !== 0 && this.boundary.distanceSquared(x, y) < best.distanceSquared;
  }
  findAction(x, y, arg) {
    const other = nearestSquared(x, y, this.elems, arg.best.distanceSquared);
    if (other.nearest !== void 0 && other.distanceSquared < arg.best.distanceSquared) {
      arg.best = other;
    }
  }
  child(capacity, depth, boundary) {
    return new _QuadtreeNodeNearest(capacity, depth, boundary);
  }
};

// packages/ag-charts-community/src/scale/linearScale.ts
var LinearScale = class _LinearScale extends ContinuousScale {
  constructor() {
    super([0, 1], [0, 1]);
    this.type = "number";
  }
  static is(value) {
    return value instanceof _LinearScale;
  }
  static getTickStep(start2, stop, ticks) {
    const { interval, tickCount = ContinuousScale.defaultTickCount, minTickCount, maxTickCount } = ticks;
    return interval ?? tickStep(start2, stop, tickCount, minTickCount, maxTickCount);
  }
  toDomain(d) {
    return d;
  }
  ticks({ interval, tickCount = ContinuousScale.defaultTickCount, minTickCount, maxTickCount }, domain = this.domain, visibleRange) {
    if (!domain || domain.length < 2 || tickCount < 1 || !domain.every(isFinite)) {
      return { ticks: [], count: 0 };
    }
    const [d0, d1] = domain;
    if (interval) {
      const step = Math.abs(interval);
      if (!isDenseInterval((d1 - d0) / step, this.getPixelRange())) {
        return range(d0, d1, step, visibleRange);
      }
    }
    return createTicks(d0, d1, tickCount, minTickCount, maxTickCount, visibleRange);
  }
  niceDomain(ticks, domain = this.domain) {
    if (domain.length < 2)
      return [];
    const { tickCount = ContinuousScale.defaultTickCount } = ticks;
    let [start2, stop] = domain;
    if (tickCount === 1) {
      [start2, stop] = niceTicksDomain(start2, stop);
    } else if (tickCount > 1) {
      const roundStart = start2 > stop ? Math.ceil : Math.floor;
      const roundStop = start2 > stop ? Math.floor : Math.ceil;
      const maxAttempts = 4;
      for (let i = 0; i < maxAttempts; i++) {
        const prev0 = start2;
        const prev1 = stop;
        const step = _LinearScale.getTickStep(start2, stop, ticks);
        const [d0, d1] = domain;
        start2 = roundStart(d0 / step) * step;
        stop = roundStop(d1 / step) * step;
        if (start2 === prev0 && stop === prev1)
          break;
      }
    }
    return [start2, stop];
  }
  tickFormatter({ ticks: specifiedTicks, fractionDigits, specifier }) {
    return specifier != null ? tickFormat(specifiedTicks, specifier) : (x) => formatValue(x, fractionDigits);
  }
  datumFormatter({ ticks: specifiedTicks, fractionDigits, specifier }) {
    return specifier != null ? tickFormat(specifiedTicks, specifier) : (x) => formatValue(x, fractionDigits + 1);
  }
};

// packages/ag-charts-community/src/util/extent.ts
function extent(values) {
  if (values.length === 0) {
    return null;
  }
  let min = Infinity;
  let max = -Infinity;
  for (const n of values) {
    const v = n instanceof Date ? n.getTime() : n;
    if (typeof v !== "number")
      continue;
    if (v < min) {
      min = v;
    }
    if (v > max) {
      max = v;
    }
  }
  const result = [min, max];
  return result.every(isFinite) ? result : null;
}
function normalisedExtentWithMetadata(d, min, max) {
  let clipped = false;
  if (d.length > 2) {
    d = extent(d) ?? [NaN, NaN];
  }
  if (min != null) {
    clipped || (clipped = min > d[0]);
    d = [min, d[1]];
  }
  if (max != null) {
    clipped || (clipped = max < d[1]);
    d = [d[0], max];
  }
  if (d[0] > d[1]) {
    d = [];
  }
  return { extent: d, clipped };
}

// packages/ag-charts-community/src/chart/axis/numberAxis.ts
var NumberAxis = class extends CartesianAxis {
  constructor(moduleCtx, scale2 = new LinearScale()) {
    super(moduleCtx, scale2);
  }
  normaliseDataDomain(d) {
    const { min, max } = this;
    const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);
    return { domain: extent2, clipped };
  }
};
NumberAxis.className = "NumberAxis";
NumberAxis.type = "number";
__decorateClass([
  Property
], NumberAxis.prototype, "min", 2);
__decorateClass([
  Property
], NumberAxis.prototype, "max", 2);

// packages/ag-charts-community/src/chart/axis/timeAxis.ts
var TimeAxisParentLevel = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = false;
    this.label = new AxisLabel();
    this.tick = new AxisTick();
  }
};
__decorateClass([
  Property
], TimeAxisParentLevel.prototype, "enabled", 2);
__decorateClass([
  Property
], TimeAxisParentLevel.prototype, "label", 2);
__decorateClass([
  Property
], TimeAxisParentLevel.prototype, "tick", 2);
var TimeAxis = class extends CartesianAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new TimeScale());
    this.parentLevel = new TimeAxisParentLevel();
    this.min = void 0;
    this.max = void 0;
    this.groupPaddingInner = 0.1;
  }
  get primaryLabel() {
    return this.parentLevel.enabled ? this.parentLevel.label : void 0;
  }
  get primaryTick() {
    return this.parentLevel.enabled ? this.parentLevel.tick : void 0;
  }
  normaliseDataDomain(d) {
    return normaliseTimeDataDomain(d, this.min, this.max);
  }
};
TimeAxis.className = "TimeAxis";
TimeAxis.type = "time";
__decorateClass([
  Property
], TimeAxis.prototype, "parentLevel", 2);
__decorateClass([
  Property
], TimeAxis.prototype, "min", 2);
__decorateClass([
  Property
], TimeAxis.prototype, "max", 2);
__decorateClass([
  Property
], TimeAxis.prototype, "groupPaddingInner", 2);
__decorateClass([
  Property
], TimeAxis.prototype, "paddingInner", 2);
__decorateClass([
  Property
], TimeAxis.prototype, "paddingOuter", 2);
function normaliseTimeDataDomain(d, min, max) {
  let clipped = false;
  if (typeof min === "number") {
    min = new Date(min);
  }
  if (typeof max === "number") {
    max = new Date(max);
  }
  if (d.length > 2) {
    d = extent(d)?.map((x) => new Date(x)) ?? [];
  }
  if (min instanceof Date) {
    clipped || (clipped = min > d[0]);
    d = [min, d[1]];
  }
  if (max instanceof Date) {
    clipped || (clipped = max < d[1]);
    d = [d[0], max];
  }
  if (d[0] > d[1]) {
    d = [];
  }
  return { domain: d, clipped };
}

// packages/ag-charts-community/src/chart/series/dataModelSeries.ts
var import_ag_charts_core115 = require("ag-charts-core");
var DataModelSeries = class extends Series {
  constructor({ clipFocusBox, categoryKey, ...seriesOpts }) {
    super(seriesOpts);
    this.categoryKey = categoryKey;
    this.clipFocusBox = clipFocusBox ?? true;
  }
  getScaleInformation({
    xScale,
    yScale
  }) {
    const isContinuousX = ContinuousScale.is(xScale);
    const isContinuousY = ContinuousScale.is(yScale);
    return { isContinuousX, isContinuousY, xScaleType: xScale?.type, yScaleType: yScale?.type };
  }
  getModulePropertyDefinitions() {
    const xScale = this.axes["x" /* X */]?.scale;
    const yScale = this.axes["y" /* Y */]?.scale;
    return this.moduleMap.mapModules((mod) => mod.getPropertyDefinitions(this.getScaleInformation({ xScale, yScale }))).flat();
  }
  // Request data, but with message dispatching to series-options (modules).
  async requestDataModel(dataController, data, opts) {
    opts.props.push(...this.getModulePropertyDefinitions());
    const { dataModel, processedData } = await dataController.request(this.id, data ?? [], opts);
    this.dataModel = dataModel;
    this.processedData = processedData;
    this.dispatch("data-processed", { dataModel, processedData });
    return { dataModel, processedData };
  }
  isProcessedDataAnimatable() {
    const validationResults = this.processedData?.reduced?.animationValidation;
    if (!validationResults) {
      return true;
    }
    const { orderedKeys, uniqueKeys } = validationResults;
    return orderedKeys && uniqueKeys;
  }
  checkProcessedDataAnimatable() {
    if (!this.isProcessedDataAnimatable()) {
      this.ctx.animationManager.skipCurrentBatch();
    }
  }
  pickFocus(opts) {
    const nodeData = this.getNodeData();
    if (nodeData === void 0 || nodeData.length === 0) {
      return;
    }
    const datumIndex = this.computeFocusDatumIndex(opts, nodeData);
    if (datumIndex === void 0) {
      return;
    }
    const { clipFocusBox } = this;
    const datum = nodeData[datumIndex];
    const derivedOpts = { ...opts, datumIndex };
    const bounds = this.computeFocusBounds(derivedOpts);
    if (bounds !== void 0) {
      return { bounds, clipFocusBox, datum, datumIndex };
    }
  }
  isDatumEnabled(nodeData, datumIndex) {
    const { missing = false, enabled = true, focusable = true } = nodeData[datumIndex];
    return !missing && enabled && focusable;
  }
  computeFocusDatumIndex(opts, nodeData) {
    const searchBackward = (datumIndex2, delta3) => {
      while (datumIndex2 >= 0 && !this.isDatumEnabled(nodeData, datumIndex2)) {
        datumIndex2 += delta3;
      }
      return datumIndex2 === -1 ? void 0 : datumIndex2;
    };
    const searchForward = (datumIndex2, delta3) => {
      while (datumIndex2 < nodeData.length && !this.isDatumEnabled(nodeData, datumIndex2)) {
        datumIndex2 += delta3;
      }
      return datumIndex2 === nodeData.length ? void 0 : datumIndex2;
    };
    let datumIndex;
    const clampedIndex = (0, import_ag_charts_core115.clamp)(0, opts.datumIndex, nodeData.length - 1);
    if (opts.datumIndexDelta < 0) {
      datumIndex = searchBackward(clampedIndex, opts.datumIndexDelta);
    } else if (opts.datumIndexDelta > 0) {
      datumIndex = searchForward(clampedIndex, opts.datumIndexDelta);
    } else {
      datumIndex = searchForward(clampedIndex, 1) ?? searchBackward(clampedIndex, -1);
    }
    if (datumIndex === void 0) {
      if (opts.datumIndexDelta === 0) {
        return;
      } else {
        return opts.datumIndex - opts.datumIndexDelta;
      }
    } else {
      return datumIndex;
    }
  }
  // Workaround - it would be nice if this difference didn't exist
  keysOrValues(xKey) {
    const key = this.dataModel.resolveProcessedDataIndexById(this, xKey);
    return this.processedData?.keys[key]?.get(this.id) ?? this.processedData?.columns[key] ?? [];
  }
  getCategoryKey() {
    return this.categoryKey;
  }
  getCategoryValue(datumIndex) {
    const { processedData, dataModel } = this;
    const categoryKey = this.getCategoryKey();
    if (!processedData || !dataModel || !categoryKey)
      return;
    const invalid = processedData.invalidData?.get(this.id)?.[datumIndex] ?? false;
    return invalid ? void 0 : this.keysOrValues(categoryKey)[datumIndex];
  }
  datumIndexForCategoryValue(categoryValue) {
    const { processedData, dataModel } = this;
    const categoryKey = this.getCategoryKey();
    if (!processedData || !dataModel || !categoryKey)
      return;
    categoryValue = categoryValue.valueOf();
    const invalidValues = processedData.invalidData?.get(this.id);
    const xValues = this.keysOrValues(categoryKey);
    for (let datumIndex = 0; datumIndex < xValues.length; datumIndex += 1) {
      if (invalidValues?.[datumIndex] === true)
        continue;
      const xValue = xValues[datumIndex]?.valueOf();
      if (objectsEqual(categoryValue, xValue))
        return datumIndex;
    }
  }
};

// packages/ag-charts-community/src/chart/series/seriesProperties.ts
var SeriesItemHighlightStyle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.fill = "rgba(255,255,255, 0.33)";
    this.stroke = `rgba(0, 0, 0, 0.4)`;
    this.strokeWidth = 2;
  }
};
__decorateClass([
  Property
], SeriesItemHighlightStyle.prototype, "fill", 2);
__decorateClass([
  Property
], SeriesItemHighlightStyle.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], SeriesItemHighlightStyle.prototype, "stroke", 2);
__decorateClass([
  Property
], SeriesItemHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], SeriesItemHighlightStyle.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], SeriesItemHighlightStyle.prototype, "lineDash", 2);
__decorateClass([
  Property
], SeriesItemHighlightStyle.prototype, "lineDashOffset", 2);
var SeriesHighlightStyle = class extends BaseProperties {
};
__decorateClass([
  Property
], SeriesHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], SeriesHighlightStyle.prototype, "dimOpacity", 2);
__decorateClass([
  Property
], SeriesHighlightStyle.prototype, "enabled", 2);
var TextHighlightStyle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.color = "black";
  }
};
__decorateClass([
  Property
], TextHighlightStyle.prototype, "color", 2);
var HighlightProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
  }
};
__decorateClass([
  Property
], HighlightProperties.prototype, "enabled", 2);
var FillGradientDefaults = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.type = "gradient";
    this.colorStops = [];
    this.bounds = "item";
    this.gradient = "linear";
    this.rotation = 0;
    this.reverse = false;
  }
};
__decorateClass([
  Property
], FillGradientDefaults.prototype, "type", 2);
__decorateClass([
  Property
], FillGradientDefaults.prototype, "colorStops", 2);
__decorateClass([
  Property
], FillGradientDefaults.prototype, "bounds", 2);
__decorateClass([
  Property
], FillGradientDefaults.prototype, "gradient", 2);
__decorateClass([
  Property
], FillGradientDefaults.prototype, "rotation", 2);
__decorateClass([
  Property
], FillGradientDefaults.prototype, "reverse", 2);
var FillPatternDefaults = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.type = "pattern";
    this.colorStops = [];
    this.bounds = "item";
    this.gradient = "linear";
    this.rotation = 0;
    this.scale = 1;
    this.reverse = false;
    this.pattern = "forward-slanted-lines";
    this.width = 26;
    this.height = 26;
    this.padding = 6;
    this.fill = "black";
    this.fillOpacity = 1;
    this.backgroundFill = "white";
    this.backgroundFillOpacity = 1;
    this.stroke = "black";
    this.strokeOpacity = 1;
    this.strokeWidth = 0;
  }
};
__decorateClass([
  Property
], FillPatternDefaults.prototype, "type", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "colorStops", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "bounds", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "gradient", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "rotation", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "scale", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "reverse", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "path", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "pattern", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "width", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "height", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "padding", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "fill", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "backgroundFill", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "backgroundFillOpacity", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "stroke", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], FillPatternDefaults.prototype, "strokeWidth", 2);
var FillImageDefaults = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.type = "image";
    this.url = "";
    this.rotation = 0;
    this.scale = 1;
    this.backgroundFill = "black";
    this.backgroundFillOpacity = 1;
    this.repeat = "no-repeat";
    this.fit = "contain";
  }
};
__decorateClass([
  Property
], FillImageDefaults.prototype, "type", 2);
__decorateClass([
  Property
], FillImageDefaults.prototype, "url", 2);
__decorateClass([
  Property
], FillImageDefaults.prototype, "rotation", 2);
__decorateClass([
  Property
], FillImageDefaults.prototype, "scale", 2);
__decorateClass([
  Property
], FillImageDefaults.prototype, "backgroundFill", 2);
__decorateClass([
  Property
], FillImageDefaults.prototype, "backgroundFillOpacity", 2);
__decorateClass([
  Property
], FillImageDefaults.prototype, "repeat", 2);
__decorateClass([
  Property
], FillImageDefaults.prototype, "fit", 2);
var HighlightStyle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.item = new SeriesItemHighlightStyle();
    this.series = new SeriesHighlightStyle();
    this.text = new TextHighlightStyle();
  }
};
__decorateClass([
  Property
], HighlightStyle.prototype, "item", 2);
__decorateClass([
  Property
], HighlightStyle.prototype, "series", 2);
__decorateClass([
  Property
], HighlightStyle.prototype, "text", 2);
var SeriesProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.visible = true;
    this.focusPriority = Infinity;
    this.showInLegend = true;
    this.cursor = "default";
    this.nodeClickRange = "exact";
    this.highlight = new HighlightProperties();
    this.highlightStyle = new HighlightStyle();
  }
  handleUnknownProperties(unknownKeys, properties) {
    if ("context" in properties) {
      this.context = properties.context;
      unknownKeys.delete("context");
    }
  }
};
__decorateClass([
  Property
], SeriesProperties.prototype, "id", 2);
__decorateClass([
  Property
], SeriesProperties.prototype, "visible", 2);
__decorateClass([
  Property
], SeriesProperties.prototype, "focusPriority", 2);
__decorateClass([
  Property
], SeriesProperties.prototype, "showInLegend", 2);
__decorateClass([
  Property
], SeriesProperties.prototype, "cursor", 2);
__decorateClass([
  Property
], SeriesProperties.prototype, "nodeClickRange", 2);
__decorateClass([
  Property
], SeriesProperties.prototype, "highlight", 2);
__decorateClass([
  Property
], SeriesProperties.prototype, "highlightStyle", 2);

// packages/ag-charts-community/src/chart/series/cartesian/cartesianSeries.ts
var DEFAULT_CARTESIAN_DIRECTION_KEYS = {
  ["x" /* X */]: ["xKey"],
  ["y" /* Y */]: ["yKey"]
};
var DEFAULT_CARTESIAN_DIRECTION_NAMES = {
  ["x" /* X */]: ["xName"],
  ["y" /* Y */]: ["yName"]
};
var CartesianSeriesNodeEvent = class extends SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.xKey = series.properties.xKey;
    this.yKey = series.properties.yKey;
  }
};
var CartesianSeriesProperties = class extends SeriesProperties {
  constructor() {
    super(...arguments);
    this.pickOutsideVisibleMinorAxis = false;
  }
};
__decorateClass([
  Property
], CartesianSeriesProperties.prototype, "legendItemName", 2);
__decorateClass([
  Property
], CartesianSeriesProperties.prototype, "pickOutsideVisibleMinorAxis", 2);
var RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD = 100;
var CartesianSeries = class extends DataModelSeries {
  constructor({
    pathsPerSeries = ["path"],
    hasMarkers = false,
    hasHighlightedLabels = false,
    pathsZIndexSubOrderOffset = [],
    datumSelectionGarbageCollection = true,
    markerSelectionGarbageCollection = true,
    animationAlwaysUpdateSelections = false,
    animationResetFns,
    directionKeys,
    directionNames,
    ...otherOpts
  }) {
    super({
      directionKeys,
      directionNames,
      canHaveAxes: true,
      ...otherOpts
    });
    this.NodeEvent = CartesianSeriesNodeEvent;
    this.dataNodeGroup = this.contentGroup.appendChild(
      new Group({ name: `${this.id}-series-dataNodes`, zIndex: 0 })
    );
    this.markerGroup = this.contentGroup.appendChild(
      new Group({ name: `${this.id}-series-markers`, zIndex: 1 })
    );
    this.labelGroup = this.contentGroup.appendChild(
      new TranslatableGroup({ name: `${this.id}-series-labels` })
    );
    this.labelSelection = Selection.select(this.labelGroup, Text);
    this.highlightSelection = Selection.select(
      this.highlightNode,
      () => this.opts.hasMarkers ? new Marker() : this.nodeFactory()
    );
    this.highlightLabelSelection = Selection.select(this.highlightLabel, Text);
    this.annotationSelections = /* @__PURE__ */ new Set();
    this.debug = Debug.create();
    if (!directionKeys || !directionNames)
      throw new Error(`Unable to initialise series type ${this.type}`);
    this.opts = {
      pathsPerSeries,
      hasMarkers,
      hasHighlightedLabels,
      pathsZIndexSubOrderOffset,
      directionKeys,
      directionNames,
      animationResetFns,
      animationAlwaysUpdateSelections,
      datumSelectionGarbageCollection,
      markerSelectionGarbageCollection
    };
    this.paths = pathsPerSeries.map((path) => {
      return new Path({ name: `${this.id}-${path}` });
    });
    this.datumSelection = Selection.select(
      this.dataNodeGroup,
      () => this.nodeFactory(),
      datumSelectionGarbageCollection
    );
    this.markerSelection = Selection.select(this.markerGroup, Marker, markerSelectionGarbageCollection);
    this.animationState = new StateMachine(
      "empty",
      {
        empty: {
          update: {
            target: "ready",
            action: (data) => this.animateEmptyUpdateReady(data)
          },
          reset: "empty",
          skip: "ready",
          disable: "disabled"
        },
        ready: {
          updateData: "waiting",
          clear: "clearing",
          highlight: (data) => this.animateReadyHighlight(data),
          highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),
          resize: (data) => this.animateReadyResize(data),
          reset: "empty",
          skip: "ready",
          disable: "disabled"
        },
        waiting: {
          update: {
            target: "ready",
            action: (data) => {
              if (this.ctx.animationManager.isSkipped()) {
                this.resetAllAnimation(data);
              } else {
                this.animateWaitingUpdateReady(data);
              }
            }
          },
          reset: "empty",
          skip: "ready",
          disable: "disabled"
        },
        disabled: {
          update: (data) => this.resetAllAnimation(data),
          reset: "empty"
        },
        clearing: {
          update: {
            target: "empty",
            action: (data) => this.animateClearingUpdateEmpty(data)
          },
          reset: "empty",
          skip: "ready"
        }
      },
      () => this.checkProcessedDataAnimatable()
    );
  }
  get contextNodeData() {
    return this._contextNodeData;
  }
  getNodeData() {
    return this.contextNodeData?.nodeData;
  }
  attachSeries(seriesContentNode, seriesNode, annotationNode) {
    super.attachSeries(seriesContentNode, seriesNode, annotationNode);
    this.attachPaths(this.paths, seriesNode, annotationNode);
  }
  detachSeries(seriesContentNode, seriesNode, annotationNode) {
    super.detachSeries(seriesContentNode, seriesNode, annotationNode);
    this.detachPaths(this.paths, seriesNode, annotationNode);
  }
  updatedDomains() {
    this.animationState.transition("updateData");
  }
  attachPaths(paths, _seriesNode, _annotationNode) {
    for (const path of paths) {
      this.contentGroup.appendChild(path);
    }
  }
  detachPaths(paths, _seriesNode, _annotationNode) {
    for (const path of paths) {
      this.contentGroup.removeChild(path);
    }
  }
  renderToOffscreenCanvas() {
    const nodeData = this.getNodeData();
    return nodeData != null && nodeData.length > RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD;
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    } else if (phase === "ready") {
      this.animationState.transition("skip");
    } else if (phase === "disabled") {
      this.animationState.transition("disable");
    }
  }
  addChartEventListeners() {
    this.destroyFns.push(
      this.ctx.chartEventManager.addListener("legend-item-click", (event) => this.onLegendItemClick(event)),
      this.ctx.chartEventManager.addListener(
        "legend-item-double-click",
        (event) => this.onLegendItemDoubleClick(event)
      )
    );
  }
  destroy() {
    super.destroy();
    this._contextNodeData = void 0;
  }
  update({ seriesRect }) {
    const { visible, _contextNodeData: previousContextData } = this;
    const series = this.ctx.highlightManager?.getActiveHighlight()?.series;
    const seriesHighlighted = series === this;
    const resize = this.checkResize(seriesRect);
    const highlightItems = this.updateHighlightSelection(seriesHighlighted);
    this.updateSelections(visible);
    this.updateNodes(highlightItems, seriesHighlighted, visible);
    const animationData = this.getAnimationData(seriesRect, previousContextData);
    if (!animationData)
      return;
    if (resize) {
      this.animationState.transition("resize", animationData);
    }
    this.animationState.transition("update", animationData);
  }
  updateSelections(anySeriesItemEnabled) {
    var _a;
    const animationSkipUpdate = !this.opts.animationAlwaysUpdateSelections && this.ctx.animationManager.isSkipped();
    if (!anySeriesItemEnabled && animationSkipUpdate) {
      return;
    }
    if (!this.nodeDataRefresh && !this.isPathOrSelectionDirty()) {
      return;
    }
    if (this.nodeDataRefresh) {
      this.nodeDataRefresh = false;
      this.debug(`CartesianSeries.updateSelections() - calling createNodeData() for`, this.id);
      this.markQuadtreeDirty();
      this._contextNodeData = this.createNodeData();
      const animationValid = this.isProcessedDataAnimatable();
      if (this._contextNodeData) {
        (_a = this._contextNodeData).animationValid ?? (_a.animationValid = animationValid);
      }
      const { dataModel, processedData } = this;
      if (dataModel !== void 0 && processedData !== void 0) {
        this.dispatch("data-update", { dataModel, processedData });
      }
    }
    this.updateSeriesSelections();
  }
  updateSeriesSelections(seriesHighlighted) {
    const { datumSelection, labelSelection, markerSelection, paths } = this;
    const contextData = this._contextNodeData;
    if (!contextData)
      return;
    const { nodeData, labelData, itemId } = contextData;
    this.updatePaths({ seriesHighlighted, itemId, contextData, paths });
    this.datumSelection = this.updateDatumSelection({ nodeData, datumSelection });
    this.labelSelection = this.updateLabelSelection({ labelData, labelSelection }) ?? labelSelection;
    if (this.opts.hasMarkers) {
      this.markerSelection = this.updateMarkerSelection({ nodeData, markerSelection });
    }
  }
  getShapeFillBBox() {
    const { axes } = this;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    const [axisX1, axisX2] = findMinMax(xAxis?.range ?? [0, 1]);
    const [axisY1, axisY2] = findMinMax(yAxis?.range ?? [0, 1]);
    const xSeriesDomain = this.getSeriesDomain("x" /* X */);
    const xSeriesRange = [xAxis?.scale.convert(xSeriesDomain.at(0)), xAxis?.scale.convert(xSeriesDomain.at(-1))];
    const ySeriesDomain = this.getSeriesDomain("y" /* Y */);
    const ySeriesRange = [yAxis?.scale.convert(ySeriesDomain.at(0)), yAxis?.scale.convert(ySeriesDomain.at(-1))];
    const [seriesX1, seriesX2] = findMinMax(xSeriesRange);
    const [seriesY1, seriesY2] = findMinMax(ySeriesRange);
    return {
      axis: new BBox(axisX1, axisY1, axisX2 - axisX1, axisY2 - axisY1),
      series: new BBox(seriesX1, seriesY1, seriesX2 - seriesX1, seriesY2 - seriesY1)
    };
  }
  updateNodes(highlightedItems, seriesHighlighted, anySeriesItemEnabled) {
    const {
      highlightSelection,
      highlightLabelSelection,
      opts: { hasMarkers, hasHighlightedLabels }
    } = this;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const visible = this.visible && this._contextNodeData != null && anySeriesItemEnabled;
    this.contentGroup.visible = animationEnabled || visible;
    this.highlightGroup.visible = (animationEnabled || visible) && seriesHighlighted;
    const opacity = this.getOpacity();
    if (hasMarkers) {
      this.updateMarkerNodes({
        markerSelection: highlightSelection,
        isHighlight: true
      });
      this.animationState.transition("highlightMarkers", highlightSelection);
    } else {
      this.updateDatumNodes({
        datumSelection: highlightSelection,
        isHighlight: true
      });
      this.animationState.transition("highlight", highlightSelection);
    }
    if (hasHighlightedLabels) {
      this.updateLabelNodes({ labelSelection: highlightLabelSelection });
    }
    const { dataNodeGroup, markerGroup, datumSelection, labelSelection, markerSelection, paths, labelGroup } = this;
    const { itemId } = this.contextNodeData ?? {};
    dataNodeGroup.opacity = opacity;
    dataNodeGroup.visible = animationEnabled || visible;
    labelGroup.visible = visible;
    if (hasMarkers) {
      markerGroup.opacity = opacity;
      markerGroup.visible = visible;
    }
    if (labelGroup) {
      labelGroup.opacity = opacity;
    }
    this.updatePathNodes({
      seriesHighlighted,
      itemId,
      paths,
      opacity,
      visible,
      animationEnabled
    });
    if (!dataNodeGroup.visible) {
      return;
    }
    this.updateDatumNodes({ datumSelection, highlightedItems, isHighlight: false });
    if (!this.usesPlacedLabels) {
      this.updateLabelNodes({ labelSelection });
    }
    if (hasMarkers) {
      this.updateMarkerNodes({ markerSelection, isHighlight: false });
    }
  }
  getHighlightLabelData(labelData, highlightedItem) {
    const labelItems = labelData.filter(
      (ld) => ld.datum === highlightedItem.datum && ld.itemId === highlightedItem.itemId
    );
    return labelItems.length === 0 ? void 0 : labelItems;
  }
  getHighlightData(_nodeData, highlightedItem) {
    return highlightedItem ? [highlightedItem] : void 0;
  }
  updateHighlightSelection(seriesHighlighted) {
    const { highlightSelection, highlightLabelSelection, _contextNodeData: contextNodeData } = this;
    if (!contextNodeData)
      return;
    const highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();
    const item = seriesHighlighted && highlightedDatum?.datum ? highlightedDatum : void 0;
    let labelItems;
    let highlightItems;
    if (item != null) {
      const labelsEnabled = this.isLabelEnabled();
      const { labelData, nodeData } = contextNodeData;
      highlightItems = this.getHighlightData(nodeData, item);
      labelItems = labelsEnabled ? this.getHighlightLabelData(labelData, item) : void 0;
    }
    this.highlightSelection = this.updateHighlightSelectionItem({
      items: highlightItems,
      highlightSelection
    });
    this.highlightLabelSelection = this.updateHighlightSelectionLabel({
      items: labelItems,
      highlightLabelSelection
    });
    return highlightItems;
  }
  markQuadtreeDirty() {
    this.quadtree = void 0;
  }
  *datumNodesIter() {
    for (const { node } of this.datumSelection) {
      if (node.datum.missing === true)
        continue;
      yield node;
    }
  }
  getQuadTree() {
    if (this.quadtree === void 0) {
      const { width: width2, height: height2 } = this.ctx.scene.canvas;
      const canvasRect = new BBox(0, 0, width2, height2);
      this.quadtree = new QuadtreeNearest(100, 10, canvasRect);
      this.initQuadTree(this.quadtree);
    }
    return this.quadtree;
  }
  initQuadTree(_quadtree) {
  }
  pickNodesExactShape(point) {
    const result = super.pickNodesExactShape(point);
    if (result.length !== 0) {
      return result;
    }
    const { x, y } = point;
    const {
      opts: { hasMarkers }
    } = this;
    const { dataNodeGroup, markerGroup } = this;
    let matches = dataNodeGroup.pickNodes(x, y).filter((match) => match.datum.missing !== true);
    if (matches.length === 0 && hasMarkers) {
      matches = markerGroup?.pickNodes(x, y).filter((match) => match.datum.missing !== true);
    }
    if (matches.length !== 0) {
      const datums = matches.map((match) => match.datum);
      return datums;
    }
    for (const mod of this.moduleMap.modules()) {
      const { datum } = mod.pickNodeExact(point) ?? {};
      if (datum == null)
        continue;
      if (datum?.missing === true)
        continue;
      return [datum];
    }
    return [];
  }
  pickNodeClosestDatum(point) {
    const { x, y } = point;
    const { axes, _contextNodeData: contextNodeData } = this;
    if (!contextNodeData)
      return;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    const hitPoint = { x, y };
    let minDistance = Infinity;
    let closestDatum;
    for (const datum of contextNodeData.nodeData) {
      const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;
      if (isNaN(datumX) || isNaN(datumY)) {
        continue;
      }
      const isInRange = xAxis?.inRange(datumX) && yAxis?.inRange(datumY);
      if (!isInRange) {
        continue;
      }
      const distance = Math.max((hitPoint.x - datumX) ** 2 + (hitPoint.y - datumY) ** 2, 0);
      if (distance < minDistance) {
        minDistance = distance;
        closestDatum = datum;
      }
    }
    for (const mod of this.moduleMap.modules()) {
      const modPick = mod.pickNodeNearest(point);
      if (modPick !== void 0 && modPick.distanceSquared < minDistance) {
        minDistance = modPick.distanceSquared;
        closestDatum = modPick.datum;
        break;
      }
    }
    if (closestDatum) {
      const distance = Math.max(Math.sqrt(minDistance) - (closestDatum.point?.size ?? 0) / 2, 0);
      return { datum: closestDatum, distance };
    }
  }
  pickNodeMainAxisFirst(point, requireCategoryAxis) {
    const { x, y } = point;
    const { axes, _contextNodeData: contextNodeData } = this;
    const { pickOutsideVisibleMinorAxis } = this.properties;
    if (!contextNodeData)
      return;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    const directions2 = [xAxis, yAxis].filter(CategoryAxis.is).map((a) => a.direction);
    if (requireCategoryAxis && directions2.length === 0)
      return;
    const [majorDirection = "x" /* X */] = directions2;
    const hitPointCoords = [x, y];
    if (majorDirection !== "x" /* X */)
      hitPointCoords.reverse();
    const minDistance = [Infinity, Infinity];
    let closestDatum;
    for (const datum of contextNodeData.nodeData) {
      const { x: datumX = NaN, y: datumY = NaN } = datum.point ?? datum.midPoint ?? {};
      if (isNaN(datumX) || isNaN(datumY) || datum.missing === true)
        continue;
      const visible = [xAxis?.inRange(datumX), yAxis?.inRange(datumY)];
      if (majorDirection !== "x" /* X */) {
        visible.reverse();
      }
      if (!visible[0] || !pickOutsideVisibleMinorAxis && !visible[1])
        continue;
      const datumPoint = [datumX, datumY];
      if (majorDirection !== "x" /* X */) {
        datumPoint.reverse();
      }
      let newMinDistance = true;
      for (let i = 0; i < datumPoint.length; i++) {
        const dist = Math.abs(datumPoint[i] - hitPointCoords[i]);
        if (dist > minDistance[i]) {
          newMinDistance = false;
          break;
        } else if (dist < minDistance[i]) {
          minDistance[i] = dist;
          minDistance.fill(Infinity, i + 1, minDistance.length);
        }
      }
      if (newMinDistance) {
        closestDatum = datum;
      }
    }
    if (closestDatum) {
      let closestDistanceSquared = Math.max(
        minDistance[0] ** 2 + minDistance[1] ** 2 - (closestDatum.point?.size ?? 0),
        0
      );
      for (const mod of this.moduleMap.modules()) {
        const modPick = mod.pickNodeMainAxisFirst(point);
        if (modPick !== void 0 && modPick.distanceSquared < closestDistanceSquared) {
          closestDatum = modPick.datum;
          closestDistanceSquared = modPick.distanceSquared;
          break;
        }
      }
      return { datum: closestDatum, distance: Math.sqrt(closestDistanceSquared) };
    }
  }
  isPathOrSelectionDirty() {
    return false;
  }
  shouldFlipXY() {
    return false;
  }
  visibleRange(axisKey, visibleRange, indices) {
    const xValues = this.keysOrValues(axisKey);
    const pixelSize = 0;
    return visibleRangeIndices(indices?.length ?? xValues.length, visibleRange, (topIndex) => {
      const datumIndex = indices?.[topIndex] ?? topIndex;
      return this.xCoordinateRange(xValues[datumIndex], pixelSize, datumIndex);
    });
  }
  domainForVisibleRange(_direction, axisKeys, crossAxisKey, visibleRange, sorted, indices) {
    const { processedData, dataModel } = this;
    const [r0, r1] = visibleRange;
    const crossAxisValues = this.keysOrValues(crossAxisKey);
    if (sorted) {
      const crossAxisRange = this.visibleRange(crossAxisKey, visibleRange, indices);
      return dataModel.getDomainBetweenRange(this, axisKeys, crossAxisRange, processedData);
    }
    const allAxisValues = axisKeys.map((axisKey) => this.keysOrValues(axisKey));
    let axisMin = Infinity;
    let axisMax = -Infinity;
    crossAxisValues.forEach((crossAxisValue, i) => {
      const [x0, x1] = this.xCoordinateRange(crossAxisValue, 0, i);
      if (x1 < r0 || x0 > r1)
        return;
      for (let j = 0; j < axisKeys.length; j++) {
        const axisValue = allAxisValues[j][i];
        axisMin = Math.min(axisMin, axisValue);
        axisMax = Math.max(axisMax, axisValue);
      }
    });
    if (axisMin > axisMax)
      return [NaN, NaN];
    return [axisMin, axisMax];
  }
  domainForClippedRange(direction, axisKeys, crossAxisKey, sorted) {
    const { processedData, dataModel, axes } = this;
    const crossDirection = direction === "x" /* X */ ? "y" /* Y */ : "x" /* X */;
    const crossAxisRange = axisExtent(axes[crossDirection]);
    if (!crossAxisRange) {
      return axisKeys.flatMap((axisKey) => dataModel.getDomain(this, axisKey, "value", processedData));
    }
    const crossAxisValues = this.keysOrValues(crossAxisKey);
    if (sorted) {
      const crossRange = clippedRangeIndices(
        crossAxisValues.length,
        crossAxisRange,
        (index) => crossAxisValues[index]
      );
      return dataModel.getDomainBetweenRange(this, axisKeys, crossRange, processedData);
    }
    const allAxisValues = axisKeys.map((axisKey) => this.keysOrValues(axisKey));
    const range0 = crossAxisRange[0].valueOf();
    const range1 = crossAxisRange[1].valueOf();
    const axisValues = [];
    crossAxisValues.forEach((crossAxisValue, i) => {
      const c = crossAxisValue.valueOf();
      if (c < range0 || c > range1)
        return;
      const values = allAxisValues.map((v) => v[i]);
      if (c >= range0) {
        axisValues.push(...values);
      }
      if (c <= range1) {
        axisValues.push(...values);
      }
    });
    return axisValues;
  }
  countVisibleItems(crossAxisKey, axisKeys, xVisibleRange, yVisibleRange, minVisibleItems) {
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData)
      return Infinity;
    const crossValues = this.keysOrValues(crossAxisKey);
    const allAxisValues = axisKeys.map((axisKey) => dataModel.resolveColumnById(this, axisKey, processedData));
    const crossAxis = this.axes["x" /* X */];
    const axis = this.axes["y" /* Y */];
    const shouldFlipXY = this.shouldFlipXY();
    const crossRange = crossAxis.range;
    const range3 = axis.range;
    const convert = (d, r, v) => {
      return d[0] + (v - r[0]) / (r[1] - r[0]) * (d[1] - d[0]);
    };
    const crossMin = convert(crossRange, crossAxis.visibleRange, xVisibleRange[0]);
    const crossMax = convert(crossRange, crossAxis.visibleRange, xVisibleRange[1]);
    const axisMin = convert(range3, axis.visibleRange, shouldFlipXY ? yVisibleRange[0] : yVisibleRange[1]);
    const axisMax = convert(range3, axis.visibleRange, shouldFlipXY ? yVisibleRange[1] : yVisibleRange[0]);
    const startIndex = Math.round(
      (xVisibleRange[0] + (xVisibleRange[1] - xVisibleRange[0]) / 2) * crossValues.length
    );
    const pixelSize = 0;
    return countExpandingSearch(0, crossValues.length - 1, startIndex, minVisibleItems, (index) => {
      let [x0, x1] = this.xCoordinateRange(crossValues[index], pixelSize, index);
      let [y0, y1] = this.yCoordinateRange(
        allAxisValues.map((axisValues) => axisValues[index]),
        pixelSize,
        index
      );
      if (!(0, import_ag_charts_core116.isFiniteNumber)(x0) || !(0, import_ag_charts_core116.isFiniteNumber)(x1) || !(0, import_ag_charts_core116.isFiniteNumber)(y0) || !(0, import_ag_charts_core116.isFiniteNumber)(y1)) {
        return false;
      }
      if (shouldFlipXY)
        [x0, x1, y0, y1] = [y0, y1, x0, x1];
      return x0 >= crossMin && x1 <= crossMax && y0 >= axisMin && y1 <= axisMax;
    });
  }
  updateHighlightSelectionItem(opts) {
    const {
      opts: { hasMarkers }
    } = this;
    const { items, highlightSelection } = opts;
    const nodeData = items ?? [];
    if (hasMarkers) {
      const markerSelection = highlightSelection;
      return this.updateMarkerSelection({ nodeData, markerSelection });
    } else {
      return this.updateDatumSelection({
        nodeData,
        datumSelection: highlightSelection
      });
    }
  }
  updateHighlightSelectionLabel(opts) {
    return this.updateLabelSelection({
      labelData: opts.items ?? [],
      labelSelection: opts.highlightLabelSelection
    });
  }
  updateDatumSelection(opts) {
    return opts.datumSelection;
  }
  updateDatumNodes(_opts) {
  }
  updateMarkerSelection(opts) {
    return opts.markerSelection;
  }
  updateMarkerNodes(_opts) {
  }
  updatePaths(opts) {
    opts.paths.forEach((p) => p.visible = false);
  }
  updatePathNodes(opts) {
    const { paths, opacity, visible } = opts;
    for (const path of paths) {
      path.opacity = opacity;
      path.visible = visible;
    }
  }
  resetPathAnimation(data) {
    const { path } = this.opts?.animationResetFns ?? {};
    if (path) {
      data.paths.forEach((paths) => {
        resetMotion([paths], path);
      });
    }
  }
  resetDatumAnimation(data) {
    const { datum } = this.opts?.animationResetFns ?? {};
    if (datum) {
      resetMotion([data.datumSelection], datum);
    }
  }
  resetLabelAnimation(data) {
    const { label } = this.opts?.animationResetFns ?? {};
    if (label) {
      resetMotion([data.labelSelection], label);
    }
  }
  resetMarkerAnimation(data) {
    const { marker } = this.opts?.animationResetFns ?? {};
    if (marker && this.opts.hasMarkers) {
      resetMotion([data.markerSelection], marker);
    }
  }
  resetAllAnimation(data) {
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    this.resetPathAnimation(data);
    this.resetDatumAnimation(data);
    this.resetLabelAnimation(data);
    this.resetMarkerAnimation(data);
    if (data.contextData?.animationValid === false) {
      this.ctx.animationManager.skipCurrentBatch();
    }
  }
  animateEmptyUpdateReady(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation(data);
  }
  animateWaitingUpdateReady(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation(data);
  }
  animateReadyHighlight(data) {
    const { datum } = this.opts?.animationResetFns ?? {};
    if (datum) {
      resetMotion([data], datum);
    }
  }
  animateReadyHighlightMarkers(data) {
    const { marker } = this.opts?.animationResetFns ?? {};
    if (marker) {
      resetMotion([data], marker);
    }
  }
  animateReadyResize(data) {
    this.resetAllAnimation(data);
  }
  animateClearingUpdateEmpty(data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation(data);
  }
  getAnimationData(seriesRect, previousContextData) {
    const { _contextNodeData: contextData } = this;
    if (!contextData)
      return;
    const animationData = {
      datumSelection: this.datumSelection,
      markerSelection: this.markerSelection,
      labelSelection: this.labelSelection,
      annotationSelections: [...this.annotationSelections],
      contextData,
      previousContextData,
      paths: this.paths,
      seriesRect
    };
    return animationData;
  }
  updateLabelSelection(opts) {
    return opts.labelSelection;
  }
  getScaling(scale2) {
    if (scale2 instanceof LogScale) {
      const { range: range3, domain } = scale2;
      return {
        type: "log",
        convert: (d) => scale2.convert(d),
        domain: [domain[0], domain[1]],
        range: [range3[0], range3[1]]
      };
    } else if (scale2 instanceof ContinuousScale) {
      const { range: range3, domain } = scale2;
      return {
        type: "continuous",
        domain: [domain[0], domain[1]],
        range: [range3[0], range3[1]]
      };
    } else if (scale2 instanceof BandScale) {
      const { domain } = scale2;
      return {
        type: "category",
        domain,
        inset: scale2.inset,
        step: scale2.step
      };
    }
  }
  calculateScaling() {
    const result = {};
    for (const direction of Object.values(ChartAxisDirection)) {
      const axis = this.axes[direction];
      if (!axis)
        continue;
      const scalingResult = this.getScaling(axis.scale);
      if (scalingResult != null) {
        result[direction] = scalingResult;
      }
    }
    return result;
  }
};
function axisExtent(axis) {
  let min;
  let max;
  if (axis instanceof NumberAxis || axis instanceof TimeAxis) {
    ({ min, max } = axis);
  }
  if (min == null && max == null)
    return;
  min ?? (min = -Infinity);
  max ?? (max = Infinity);
  return [min, max];
}
function clippedRangeIndices(length, range3, xValue) {
  const range0 = range3[0].valueOf();
  const range1 = range3[1].valueOf();
  const xMinIndex = (0, import_ag_charts_core116.findMinIndex)(0, length - 1, (index) => {
    const x = xValue(index)?.valueOf();
    return !Number.isFinite(x) || x >= range0;
  });
  let xMaxIndex = (0, import_ag_charts_core116.findMaxIndex)(0, length - 1, (index) => {
    const x = xValue(index)?.valueOf();
    return !Number.isFinite(x) || x <= range1;
  });
  if (xMinIndex == null || xMaxIndex == null)
    return [0, 0];
  xMaxIndex = Math.min(xMaxIndex + 1, length);
  return [xMinIndex, xMaxIndex];
}

// packages/ag-charts-community/src/chart/cartesianChart.ts
var directions = ["top", "right", "bottom", "left"];
var _CartesianChart = class _CartesianChart extends Chart {
  constructor(options, resources) {
    super(options, resources);
    // TODO should come from theme
    /** Integrated Charts feature state - not used in Standalone Charts. */
    this.paired = true;
    this.lastUpdateClipRect = void 0;
    this.lastLayoutWidth = NaN;
    this.lastLayoutHeight = NaN;
  }
  onAxisChange(newValue, oldValue) {
    super.onAxisChange(newValue, oldValue);
    this.syncAxisChanges(newValue, oldValue);
    if (this.ctx != null) {
      this.ctx.zoomManager.updateAxes(newValue);
    }
  }
  destroySeries(series) {
    super.destroySeries(series);
    this.lastLayoutWidth = NaN;
    this.lastLayoutHeight = NaN;
  }
  getChartType() {
    return "cartesian";
  }
  setRootClipRects(clipRect) {
    const { seriesRoot, annotationRoot } = this;
    seriesRoot.setClipRect(clipRect);
    annotationRoot.setClipRect(clipRect);
  }
  async processData() {
    await super.processData();
    if (this.syncStatus === "init") {
      this.syncStatus = "domains-calculated";
    }
    this.ctx.updateService.dispatchProcessData({ series: { shouldFlipXY: this.shouldFlipXY() } });
  }
  async processDomains() {
    await super.processDomains();
    for (const axis of this.axes) {
      const syncedDomain = await this.getSyncedDomain(axis);
      if (syncedDomain != null) {
        axis.setDomains(syncedDomain);
      }
    }
  }
  performLayout(ctx) {
    const { seriesRoot, annotationRoot } = this;
    const { clipSeries, seriesRect, visible } = this.updateAxes(ctx.layoutBox);
    this.seriesRoot.visible = visible;
    this.seriesRect = seriesRect;
    this.animationRect = ctx.layoutBox;
    const { x, y } = seriesRect;
    if (ctx.width !== this.lastLayoutWidth || ctx.height !== this.lastLayoutHeight) {
      for (const group of [seriesRoot, annotationRoot]) {
        group.translationX = Math.floor(x);
        group.translationY = Math.floor(y);
      }
    } else {
      const { translationX, translationY } = seriesRoot;
      staticFromToMotion(
        this.id,
        "seriesRect",
        this.ctx.animationManager,
        [seriesRoot, annotationRoot],
        { translationX, translationY },
        { translationX: Math.floor(x), translationY: Math.floor(y) },
        { phase: "update" }
      );
    }
    this.lastLayoutWidth = ctx.width;
    this.lastLayoutHeight = ctx.height;
    const seriesPaddedRect = seriesRect.clone().grow(this.seriesArea.padding);
    const clipRect = this.seriesArea.clip || clipSeries ? seriesPaddedRect : void 0;
    const { lastUpdateClipRect } = this;
    this.lastUpdateClipRect = clipRect;
    if (this.ctx.animationManager.isActive() && lastUpdateClipRect != null) {
      this.ctx.animationManager.animate({
        id: this.id,
        groupId: "clip-rect",
        phase: "update",
        from: lastUpdateClipRect,
        to: seriesPaddedRect,
        onUpdate: (interpolatedClipRect) => this.setRootClipRects(interpolatedClipRect),
        onComplete: () => this.setRootClipRects(clipRect)
      });
    } else {
      this.setRootClipRects(clipRect);
    }
    this.ctx.layoutManager.emitLayoutComplete(ctx, {
      axes: this.axes.map((axis) => axis.getLayoutState()),
      series: {
        visible,
        rect: seriesRect,
        paddedRect: seriesPaddedRect
      },
      clipSeries
    });
  }
  updateAxes(layoutBox) {
    const { clipSeries, seriesRect, overflows } = this.resolveAxesLayout(layoutBox);
    for (const axis of this.axes) {
      axis.update();
      axis.setCrossLinesVisible(!overflows);
      this.clipAxis(axis, seriesRect, layoutBox);
    }
    return { clipSeries, seriesRect, visible: !overflows };
  }
  // Iteratively try to resolve axis widths - since X axis width affects Y axis range,
  // and vice-versa, we need to iteratively try and find a fit for the axes and their
  // ticks/labels.
  resolveAxesLayout(layoutBox) {
    let newState;
    let prevState;
    let iterations = 0;
    const maxIterations = 10;
    do {
      prevState = newState ?? this.getDefaultState();
      newState = this.updateAxesPass(new Map(prevState.axisAreaWidths), layoutBox.clone());
      if (iterations++ > maxIterations) {
        import_ag_charts_core117.Logger.warn("Max iterations reached. Unable to stabilize axes layout.");
        break;
      }
    } while (!this.isLayoutStable(newState, prevState));
    this.lastAreaWidths = newState.axisAreaWidths;
    return newState;
  }
  updateAxesPass(axisAreaWidths, axisAreaBound) {
    const axisWidths = /* @__PURE__ */ new Map();
    const primaryTickCounts = {};
    let overflows = false;
    let clipSeries = false;
    for (const dir of directions) {
      const padding = this.seriesArea.padding[dir];
      const axis = this.axes.findLast((a) => a.position === dir);
      if (axis) {
        axis.seriesAreaPadding = padding;
      } else {
        axisAreaBound.shrink(padding, dir);
      }
    }
    const totalWidth = (axisAreaWidths.get("left") ?? 0) + (axisAreaWidths.get("right") ?? 0);
    const totalHeight = (axisAreaWidths.get("top") ?? 0) + (axisAreaWidths.get("bottom") ?? 0);
    const crossLinePadding = this.buildCrossLinePadding(axisAreaWidths);
    const crossLineHPadding = crossLinePadding.left + crossLinePadding.right;
    const crossLineVPadding = crossLinePadding.top + crossLinePadding.bottom;
    if (axisAreaBound.width <= totalWidth + crossLineHPadding || axisAreaBound.height <= totalHeight + crossLineVPadding) {
      overflows = true;
    } else {
      axisAreaBound.shrink(crossLinePadding);
    }
    const seriesRect = axisAreaBound.clone().shrink(Object.fromEntries(axisAreaWidths));
    for (const axis of this.axes) {
      const { position = "left", direction } = axis;
      this.sizeAxis(axis, seriesRect, position);
      const isVertical = direction === "y" /* Y */;
      const { primaryTickCount, bbox } = axis.calculateLayout(
        axis.nice ? primaryTickCounts[direction] : void 0,
        this.padding
      );
      primaryTickCounts[direction] ?? (primaryTickCounts[direction] = primaryTickCount);
      clipSeries || (clipSeries = axis.dataDomain.clipped || axis.visibleRange[0] > 0 || axis.visibleRange[1] < 1);
      axisWidths.set(axis.id, Math.ceil(axis.thickness ?? (isVertical ? bbox?.width : bbox?.height) ?? 0));
    }
    const axisGroups = (0, import_ag_charts_core117.groupBy)(this.axes, (axis) => axis.position ?? "left");
    const { width: width2, height: height2, pixelRatio } = this.ctx.scene;
    const newAxisAreaWidths = /* @__PURE__ */ new Map();
    const axisOffsets = /* @__PURE__ */ new Map();
    for (const [position, axes] of (0, import_ag_charts_core117.entries)(axisGroups)) {
      const isVertical = position === "left" || position === "right";
      let currentOffset = isVertical ? height2 % pixelRatio : width2 % pixelRatio;
      let totalAxisWidth = 0;
      for (const axis of axes ?? []) {
        axisOffsets.set(axis.id, currentOffset);
        const axisThickness = axisWidths.get(axis.id) ?? 0;
        totalAxisWidth = Math.max(totalAxisWidth, currentOffset + axisThickness);
        if (axis.layoutConstraints.stacked) {
          currentOffset += axisThickness + _CartesianChart.AxesPadding;
        }
      }
      newAxisAreaWidths.set(position, Math.ceil(totalAxisWidth));
    }
    for (const [position, axes] of (0, import_ag_charts_core117.entries)(axisGroups)) {
      this.positionAxes({
        axes: axes ?? [],
        position,
        axisWidths,
        axisOffsets,
        axisAreaWidths: newAxisAreaWidths,
        axisBound: axisAreaBound,
        seriesRect
      });
    }
    return { clipSeries, seriesRect, axisAreaWidths: newAxisAreaWidths, overflows };
  }
  buildCrossLinePadding(axisAreaSize) {
    const crossLinePadding = { top: 0, right: 0, bottom: 0, left: 0 };
    this.axes.forEach((axis) => {
      const { position, label } = axis;
      axis.crossLines?.forEach((crossLine) => {
        var _a;
        if (crossLine instanceof CartesianCrossLine) {
          crossLine.position = position ?? "top";
          (_a = crossLine.label).parallel ?? (_a.parallel = label.parallel);
        }
        crossLine.calculatePadding?.(crossLinePadding);
      });
    });
    for (const [side, padding = 0] of (0, import_ag_charts_core117.entries)(crossLinePadding)) {
      crossLinePadding[side] = Math.max(padding - (axisAreaSize.get(side) ?? 0), 0);
    }
    return crossLinePadding;
  }
  clampToOutsideSeriesRect(seriesRect, value, dimension, direction) {
    const bound = dimension === "x" ? seriesRect.x : seriesRect.y;
    const size = dimension === "x" ? seriesRect.width : seriesRect.height;
    return direction === 1 ? Math.min(value, bound + size) : Math.max(value, bound);
  }
  async getSyncedDomain(axis) {
    const syncModule = this.modulesManager.getModule("sync");
    if (!syncModule?.enabled)
      return;
    return await syncModule.getSyncedDomain(axis);
  }
  syncAxisChanges(newValue, oldValue) {
    const syncModule = this.modulesManager.getModule("sync");
    if (!syncModule?.enabled)
      return;
    const removed = new Set(oldValue ?? []);
    for (const axis of newValue) {
      removed.delete(axis);
    }
    for (const removedAxis of removed) {
      syncModule.removeAxis(removedAxis);
    }
  }
  sizeAxis(axis, seriesRect, position) {
    const isCategory = axis instanceof CategoryAxis;
    const isLeftRight = position === "left" || position === "right";
    const { width: width2, height: height2 } = seriesRect;
    const maxEnd = isLeftRight ? height2 : width2;
    let start2 = 0;
    let end2 = maxEnd;
    let { min, max } = this.ctx.zoomManager.getAxisZoom(axis.id);
    const { width: axisWidth, unit, align: align2 } = axis.layoutConstraints;
    if (unit === "px") {
      end2 = start2 + axisWidth;
    } else {
      end2 = end2 * axisWidth / 100;
    }
    if (align2 === "end") {
      start2 = maxEnd - (end2 - start2);
      end2 = maxEnd;
    }
    if (isLeftRight) {
      if (isCategory) {
        [min, max] = [1 - max, 1 - min];
      } else {
        [start2, end2] = [end2, start2];
      }
    }
    axis.range = [start2, end2];
    axis.visibleRange = [min, max];
    axis.gridLength = isLeftRight ? width2 : height2;
  }
  positionAxes(opts) {
    const { axes, axisBound, axisWidths, axisOffsets, axisAreaWidths, seriesRect, position } = opts;
    const axisAreaWidth = axisAreaWidths.get(position) ?? 0;
    let mainDimension = "x";
    let minorDimension = "y";
    let direction = 1;
    if (position === "top" || position === "bottom") {
      mainDimension = "y";
      minorDimension = "x";
    }
    let axisBoundMainOffset = axisBound[mainDimension];
    if (position === "right" || position === "bottom") {
      direction = -1;
      axisBoundMainOffset += mainDimension === "x" ? axisBound.width : axisBound.height;
    }
    for (const axis of axes) {
      const minorOffset = axisAreaWidths.get(minorDimension === "x" ? "left" : "top") ?? 0;
      const axisThickness = axisWidths.get(axis.id) ?? 0;
      const axisOffset = axisOffsets.get(axis.id) ?? 0;
      axis.gridPadding = axisAreaWidth - axisOffset - axisThickness;
      axis.translation[minorDimension] = axisBound[minorDimension] + minorOffset;
      axis.translation[mainDimension] = this.clampToOutsideSeriesRect(
        seriesRect,
        axisBoundMainOffset + direction * (axisOffset + axisThickness),
        mainDimension,
        direction
      );
    }
  }
  shouldFlipXY() {
    return this.series.every((series) => series instanceof CartesianSeries && series.shouldFlipXY());
  }
  getDefaultState() {
    const axisAreaWidths = /* @__PURE__ */ new Map();
    if (this.lastAreaWidths) {
      for (const { position = "left" } of this.axes) {
        const areaWidth = this.lastAreaWidths.get(position);
        if (areaWidth != null) {
          axisAreaWidths.set(position, areaWidth);
        }
      }
    }
    return { axisAreaWidths, clipSeries: false, overflows: false };
  }
  isLayoutStable(newState, prevState) {
    if (prevState.overflows !== newState.overflows || prevState.clipSeries !== newState.clipSeries) {
      return false;
    }
    for (const key of newState.axisAreaWidths.keys()) {
      if (!prevState.axisAreaWidths.has(key)) {
        return false;
      }
    }
    for (const [p, w] of prevState.axisAreaWidths.entries()) {
      const otherW = newState.axisAreaWidths.get(p);
      if ((w != null || otherW != null) && w !== otherW) {
        return false;
      }
    }
    return true;
  }
  clipAxis(axis, seriesRect, layoutBBox) {
    const gridLinePadding = Math.ceil(axis.gridLine?.width ?? 0);
    const axisLinePadding = Math.ceil(axis.line?.width ?? 0);
    let { width: width2, height: height2 } = seriesRect;
    width2 += axis.direction === "x" /* X */ ? gridLinePadding : axisLinePadding;
    height2 += axis.direction === "y" /* Y */ ? gridLinePadding : axisLinePadding;
    axis.clipGrid(seriesRect.x, seriesRect.y, width2, height2);
    switch (axis.position) {
      case "left":
      case "right":
        axis.clipTickLines(
          layoutBBox.x,
          seriesRect.y - gridLinePadding,
          layoutBBox.width + gridLinePadding,
          seriesRect.height + gridLinePadding * 2
        );
        break;
      case "top":
      case "bottom":
        axis.clipTickLines(
          seriesRect.x - gridLinePadding,
          layoutBBox.y,
          seriesRect.width + gridLinePadding * 2,
          layoutBBox.height + gridLinePadding
        );
        break;
    }
  }
};
_CartesianChart.className = "CartesianChart";
_CartesianChart.type = "cartesian";
_CartesianChart.AxesPadding = 15;
var CartesianChart = _CartesianChart;

// packages/ag-charts-community/src/chart/chartOptionsDefs.ts
var import_ag_charts_core118 = require("ag-charts-core");
var commonChartOptions = {
  mode: (0, import_ag_charts_core118.undocumented)((0, import_ag_charts_core118.union)("integrated", "standalone")),
  container: import_ag_charts_core118.htmlElement,
  theme: import_ag_charts_core118.defined,
  series: import_ag_charts_core118.array,
  annotations: import_ag_charts_core118.defined,
  navigator: import_ag_charts_core118.defined,
  initialState: {
    chartType: import_ag_charts_core118.string,
    annotations: import_ag_charts_core118.defined,
    legend: (0, import_ag_charts_core118.arrayOfDefs)(
      {
        visible: import_ag_charts_core118.boolean,
        seriesId: import_ag_charts_core118.string,
        itemId: import_ag_charts_core118.string,
        legendItemName: import_ag_charts_core118.string
      },
      "legend state array"
    ),
    zoom: import_ag_charts_core118.defined
  }
};
var cartesianChartOptionsDefs = {
  ...commonChartOptionsDefs,
  ...commonChartOptions,
  axes: import_ag_charts_core118.defined,
  data: import_ag_charts_core118.array
};
var polarChartOptionsDefs = {
  ...commonChartOptionsDefs,
  ...commonChartOptions,
  axes: import_ag_charts_core118.defined,
  data: import_ag_charts_core118.array
};
var topologyChartOptionsDefs = {
  ...commonChartOptionsDefs,
  ...commonChartOptions,
  data: import_ag_charts_core118.array,
  topology: import_ag_charts_core118.geoJson
};
var standaloneChartOptionsDefs = {
  ...commonChartOptionsDefs,
  ...commonChartOptions,
  data: import_ag_charts_core118.array
};
var hierarchyChartOptionsDefs = {
  ...commonChartOptionsDefs,
  ...commonChartOptions,
  data: import_ag_charts_core118.array
};
var flowProportionChartOptionsDefs = {
  ...commonChartOptionsDefs,
  ...commonChartOptions,
  data: import_ag_charts_core118.array,
  nodes: import_ag_charts_core118.array
};
var gaugeChartOptionsDefs = {
  ...commonChartOptionsDefs,
  ...commonChartOptions,
  data: import_ag_charts_core118.array
};

// packages/ag-charts-community/src/chart/cartesianChartModule.ts
var histogramAxisTypes = /* @__PURE__ */ new Set(["number", "log", "time"]);
var validHistogramAxis = (axis) => (0, import_ag_charts_core119.isObject)(axis) && !histogramAxisTypes.has(axis.type);
var CartesianChartModule = {
  type: "chart",
  name: "cartesian",
  options: cartesianChartOptionsDefs,
  detect: isAgCartesianChartOptions,
  create(options, resources) {
    return new CartesianChart(options, resources);
  },
  validate(options, optionsDefs4, path) {
    const additionalErrors = [];
    if (options?.series?.[0]?.type === "histogram") {
      if (options?.axes?.some(validHistogramAxis)) {
        additionalErrors.push(
          new import_ag_charts_core119.ValidationError(
            "invalid",
            "only continuous axis types when histogram series is used",
            options.axes,
            path,
            "axes"
          )
        );
        options = without(options, ["axes"]);
      }
    }
    const result = (0, import_ag_charts_core119.validate)(options, optionsDefs4, path);
    result.invalid.push(...additionalErrors);
    return result;
  }
};

// packages/ag-charts-community/src/chart/enterpriseChartModules.ts
var import_ag_charts_core120 = require("ag-charts-core");
var placeholderCreate = () => {
  throw new Error("Enterprise module placeholder cannot be initialised");
};
var FlowProportionChartModule = {
  type: "chart",
  name: "flow-proportion",
  placeholder: true,
  options: {},
  detect: isAgFlowProportionChartOptions,
  create: placeholderCreate
};
var GaugeChartModule = {
  type: "chart",
  name: "gauge",
  placeholder: true,
  options: {},
  detect: isAgGaugeChartOptions,
  create: placeholderCreate
};
var HierarchyChartModule = {
  type: "chart",
  name: "hierarchy",
  placeholder: true,
  options: {},
  detect: isAgHierarchyChartOptions,
  create: placeholderCreate
};
var StandaloneChartModule = {
  type: "chart",
  name: "standalone",
  placeholder: true,
  options: {},
  detect: isAgStandaloneChartOptions,
  create: placeholderCreate
};
var TopologyChartModule = {
  type: "chart",
  name: "topology",
  placeholder: true,
  options: {},
  detect: isAgTopologyChartOptions,
  create: placeholderCreate
};

// packages/ag-charts-community/src/chart/polarChartModule.ts
var import_ag_charts_core122 = require("ag-charts-core");

// packages/ag-charts-community/src/chart/polarChart.ts
var import_ag_charts_core121 = require("ag-charts-core");

// packages/ag-charts-community/src/chart/axis/polarAxis.ts
var PolarAxis = class extends Axis {
  constructor() {
    super(...arguments);
    this.shape = "polygon";
    this.innerRadiusRatio = 0;
    this.defaultTickMinSpacing = 20;
  }
  layoutCrossLines() {
    const sideFlag = this.label.getSideFlag();
    const anySeriesActive = this.isAnySeriesActive();
    const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();
    this.crossLines.forEach((crossLine) => {
      crossLine.sideFlag = -sideFlag;
      crossLine.direction = rotation === -Math.PI / 2 ? "angle" /* Angle */ : "radius" /* Radius */;
      crossLine.parallelFlipRotation = parallelFlipRotation;
      crossLine.regularFlipRotation = regularFlipRotation;
      crossLine.calculateLayout?.(anySeriesActive, this.reverse);
    });
  }
  updatePosition() {
    super.updatePosition();
    const translationX = Math.floor(this.translation.x);
    const translationY = Math.floor(this.translation.y);
    this.tickLineGroup.translationX = translationX;
    this.tickLineGroup.translationY = translationY;
    this.tickLabelGroup.translationX = translationX;
    this.tickLabelGroup.translationY = translationY;
    this.crossLineRangeGroup.translationX = translationX;
    this.crossLineRangeGroup.translationY = translationY;
    this.crossLineLineGroup.translationX = translationX;
    this.crossLineLineGroup.translationY = translationY;
    this.crossLineLabelGroup.translationX = translationX;
    this.crossLineLabelGroup.translationY = translationY;
    this.tickLabelGroupSelection.each(resetAxisLabelSelectionFn());
  }
  computeLabelsBBox(_options, _seriesRect) {
    return null;
  }
  computeRange() {
  }
  getAxisLinePoints() {
    return void 0;
  }
};
__decorateClass([
  Property
], PolarAxis.prototype, "shape", 2);
__decorateClass([
  Property
], PolarAxis.prototype, "innerRadiusRatio", 2);

// packages/ag-charts-community/src/chart/series/polar/polarSeries.ts
var PolarSeries = class extends DataModelSeries {
  constructor({
    categoryKey,
    useLabelLayer = false,
    pickModes = [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],
    canHaveAxes = false,
    animationResetFns,
    ...opts
  }) {
    super({
      ...opts,
      categoryKey,
      useLabelLayer,
      pickModes,
      directionKeys: {
        ["angle" /* Angle */]: ["angleKey"],
        ["radius" /* Radius */]: ["radiusKey"]
      },
      directionNames: {
        ["angle" /* Angle */]: ["angleName"],
        ["radius" /* Radius */]: ["radiusName"]
      },
      canHaveAxes
    });
    this.directions = ["angle" /* Angle */, "radius" /* Radius */];
    this.itemGroup = this.contentGroup.appendChild(new Group());
    this.nodeData = [];
    this.itemSelection = Selection.select(
      this.itemGroup,
      () => this.nodeFactory(),
      false
    );
    this.labelSelection = Selection.select(
      this.labelGroup,
      () => this.labelFactory(),
      false
    );
    this.highlightSelection = Selection.select(
      this.highlightGroup,
      () => this.nodeFactory()
    );
    this.highlightLabelSelection = Selection.select(
      this.highlightLabel,
      () => this.labelFactory()
    );
    /**
     * The center of the polar series (for example, the center of a pie).
     * If the polar chart has multiple series, all of them will have their
     * center set to the same value as a result of the polar chart layout.
     * The center coordinates are not supposed to be set by the user.
     */
    this.centerX = 0;
    this.centerY = 0;
    /**
     * The maximum radius the series can use.
     * This value is set automatically as a result of the polar chart layout
     * and is not supposed to be set by the user.
     */
    this.radius = 0;
    this.animationResetFns = animationResetFns;
    this.animationState = new StateMachine(
      "empty",
      {
        empty: {
          update: {
            target: "ready",
            action: (data) => this.animateEmptyUpdateReady(data)
          },
          reset: "empty",
          skip: "ready"
        },
        ready: {
          updateData: "waiting",
          clear: "clearing",
          highlight: (data) => this.animateReadyHighlight(data),
          highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),
          resize: (data) => this.animateReadyResize(data),
          reset: "empty",
          skip: "ready"
        },
        waiting: {
          update: {
            target: "ready",
            action: (data) => this.animateWaitingUpdateReady(data)
          },
          reset: "empty",
          skip: "ready"
        },
        clearing: {
          update: {
            target: "empty",
            action: (data) => this.animateClearingUpdateEmpty(data)
          },
          reset: "empty",
          skip: "ready"
        }
      },
      () => this.checkProcessedDataAnimatable()
    );
  }
  getItemNodes() {
    return [...this.itemGroup.children()];
  }
  getNodeData() {
    return this.nodeData;
  }
  setSeriesIndex(index) {
    if (!super.setSeriesIndex(index))
      return false;
    this.contentGroup.zIndex = [index, 1 /* FOREGROUND */];
    this.highlightGroup.zIndex = [index, 2 /* HIGHLIGHT */];
    this.labelGroup.zIndex = [index, 3 /* LABEL */];
    return true;
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    } else if (phase === "ready") {
      this.animationState.transition("skip");
    }
  }
  labelFactory() {
    const text = new Text();
    text.pointerEvents = 1 /* None */;
    return text;
  }
  addChartEventListeners() {
    this.destroyFns.push(
      this.ctx.chartEventManager?.addListener("legend-item-click", (event) => this.onLegendItemClick(event)),
      this.ctx.chartEventManager?.addListener(
        "legend-item-double-click",
        (event) => this.onLegendItemDoubleClick(event)
      )
    );
  }
  getInnerRadius() {
    return 0;
  }
  computeLabelsBBox(_options, _seriesRect) {
    return null;
  }
  getShapeFillBBox() {
    const outerRadius = this.radius;
    return {
      series: new BBox(-outerRadius, -outerRadius, outerRadius * 2, outerRadius * 2),
      axis: new BBox(-outerRadius, -outerRadius, outerRadius * 2, outerRadius * 2)
    };
  }
  resetAllAnimation() {
    const { item, label } = this.animationResetFns ?? {};
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    if (item) {
      resetMotion([this.itemSelection, this.highlightSelection], item);
    }
    if (label) {
      resetMotion([this.labelSelection, this.highlightLabelSelection], label);
    }
    this.itemSelection.cleanup();
    this.labelSelection.cleanup();
    this.highlightSelection.cleanup();
    this.highlightLabelSelection.cleanup();
  }
  animateEmptyUpdateReady(_data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation();
  }
  animateWaitingUpdateReady(_data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation();
  }
  animateReadyHighlight(_data) {
    const { item, label } = this.animationResetFns ?? {};
    if (item) {
      resetMotion([this.highlightSelection], item);
    }
    if (label) {
      resetMotion([this.highlightLabelSelection], label);
    }
  }
  animateReadyHighlightMarkers(_data) {
  }
  animateReadyResize(_data) {
    this.resetAllAnimation();
  }
  animateClearingUpdateEmpty(_data) {
    this.ctx.animationManager.skipCurrentBatch();
    this.resetAllAnimation();
  }
  computeFocusBounds(opts) {
    const datum = this.getNodeData()?.[opts.datumIndex];
    if (datum !== void 0) {
      return this.itemSelection.select((node) => node instanceof Path && node.datum === datum)[0];
    }
    return void 0;
  }
  getSeriesRange(_direction, _visibleRange) {
    return [NaN, NaN];
  }
};

// packages/ag-charts-community/src/chart/polarChart.ts
var PolarChart = class extends Chart {
  constructor(options, resources) {
    super(options, resources);
    this.padding = new Padding(40);
    this.ctx.axisManager.axisGroup.zIndex = 6 /* AXIS_FOREGROUND */;
  }
  getChartType() {
    return "polar";
  }
  async performLayout(ctx) {
    const { layoutBox } = ctx;
    layoutBox.shrink(this.seriesArea.padding.toJson());
    const seriesRect = layoutBox.clone();
    this.seriesRect = seriesRect;
    this.animationRect = seriesRect;
    this.seriesRoot.translationX = seriesRect.x;
    this.seriesRoot.translationY = seriesRect.y;
    await this.computeCircle(seriesRect);
    this.axes.forEach((axis) => axis.update());
    this.ctx.layoutManager.emitLayoutComplete(ctx, {
      series: { visible: true, rect: seriesRect, paddedRect: seriesRect }
    });
  }
  updateAxes(seriesBox, cx, cy, radius) {
    const angleAxis = this.axes.find((axis) => axis.direction === "angle" /* Angle */);
    const radiusAxis = this.axes.find((axis) => axis.direction === "radius" /* Radius */);
    if (!(angleAxis instanceof PolarAxis) || !(radiusAxis instanceof PolarAxis))
      return;
    const angleScale = angleAxis.scale;
    const innerRadiusRatio = radiusAxis.innerRadiusRatio;
    angleAxis.innerRadiusRatio = innerRadiusRatio;
    angleAxis.computeRange();
    angleAxis.gridLength = radius;
    radiusAxis.gridAngles = angleScale.ticks({
      nice: angleAxis.nice,
      interval: void 0,
      tickCount: void 0,
      minTickCount: 0,
      maxTickCount: Infinity
    })?.ticks?.map((value) => angleScale.convert(value));
    radiusAxis.gridRange = angleAxis.range;
    radiusAxis.range = [radius, radius * innerRadiusRatio];
    [angleAxis, radiusAxis].forEach((axis) => {
      axis.translation.x = seriesBox.x + cx;
      axis.translation.y = seriesBox.y + cy;
      axis.calculateLayout();
    });
  }
  async computeCircle(seriesBox) {
    const polarSeries = this.series.filter(isPolarSeries);
    const polarAxes = this.axes.filter(isPolarAxis);
    const setSeriesCircle = (cx, cy, r) => {
      this.updateAxes(seriesBox, cx, cy, r);
      polarSeries.forEach((series) => {
        series.centerX = cx;
        series.centerY = cy;
        series.radius = r;
      });
      const pieSeries = polarSeries.filter((s) => s.type === "donut" || s.type === "pie");
      if (pieSeries.length > 1) {
        const innerRadii = pieSeries.map((series) => {
          const innerRadius = series.getInnerRadius();
          return { series, innerRadius };
        }).sort((a, b) => a.innerRadius - b.innerRadius);
        innerRadii.at(-1).series.surroundingRadius = void 0;
        for (let i = 0; i < innerRadii.length - 1; i++) {
          innerRadii[i].series.surroundingRadius = innerRadii[i + 1].innerRadius;
        }
      }
    };
    const centerX = seriesBox.width / 2;
    const centerY = seriesBox.height / 2;
    const initialRadius = Math.max(0, Math.min(seriesBox.width, seriesBox.height) / 2);
    let radius = initialRadius;
    setSeriesCircle(centerX, centerY, radius);
    const shake = async ({ hideWhenNecessary = false } = {}) => {
      const labelBoxes = [];
      for (const series of (0, import_ag_charts_core121.iterate)(polarAxes, polarSeries)) {
        const box = await series.computeLabelsBBox({ hideWhenNecessary }, seriesBox);
        if (box) {
          labelBoxes.push(box);
        }
      }
      if (labelBoxes.length === 0) {
        setSeriesCircle(centerX, centerY, initialRadius);
        return;
      }
      const labelBox = BBox.merge(labelBoxes);
      const refined = this.refineCircle(labelBox, radius, seriesBox);
      setSeriesCircle(refined.centerX, refined.centerY, refined.radius);
      radius = refined.radius;
    };
    await shake();
    await shake();
    await shake();
    await shake({ hideWhenNecessary: true });
    await shake({ hideWhenNecessary: true });
    for (const series of (0, import_ag_charts_core121.iterate)(polarAxes, polarSeries)) {
      await series.computeLabelsBBox({ hideWhenNecessary: true }, seriesBox);
    }
    return { radius, centerX, centerY };
  }
  refineCircle(labelsBox, radius, seriesBox) {
    const minCircleRatio = 0.5;
    const circleLeft = -radius;
    const circleTop = -radius;
    const circleRight = radius;
    const circleBottom = radius;
    let padLeft = Math.max(0, circleLeft - labelsBox.x);
    let padTop = Math.max(0, circleTop - labelsBox.y);
    let padRight = Math.max(0, labelsBox.x + labelsBox.width - circleRight);
    let padBottom = Math.max(0, labelsBox.y + labelsBox.height - circleBottom);
    padLeft = padRight = Math.max(padLeft, padRight);
    padTop = padBottom = Math.max(padTop, padBottom);
    const availCircleWidth = seriesBox.width - padLeft - padRight;
    const availCircleHeight = seriesBox.height - padTop - padBottom;
    let newRadius = Math.min(availCircleWidth, availCircleHeight) / 2;
    const minHorizontalRadius = minCircleRatio * seriesBox.width / 2;
    const minVerticalRadius = minCircleRatio * seriesBox.height / 2;
    const minRadius = Math.min(minHorizontalRadius, minVerticalRadius);
    if (newRadius < minRadius) {
      newRadius = minRadius;
      const horizontalPadding = padLeft + padRight;
      const verticalPadding = padTop + padBottom;
      if (2 * newRadius + verticalPadding > seriesBox.height) {
        const padHeight = seriesBox.height - 2 * newRadius;
        if (Math.min(padTop, padBottom) * 2 > padHeight) {
          padTop = padHeight / 2;
          padBottom = padHeight / 2;
        } else if (padTop > padBottom) {
          padTop = padHeight - padBottom;
        } else {
          padBottom = padHeight - padTop;
        }
      }
      if (2 * newRadius + horizontalPadding > seriesBox.width) {
        const padWidth = seriesBox.width - 2 * newRadius;
        if (Math.min(padLeft, padRight) * 2 > padWidth) {
          padLeft = padWidth / 2;
          padRight = padWidth / 2;
        } else if (padLeft > padRight) {
          padLeft = padWidth - padRight;
        } else {
          padRight = padWidth - padLeft;
        }
      }
    }
    const newWidth = padLeft + 2 * newRadius + padRight;
    const newHeight = padTop + 2 * newRadius + padBottom;
    return {
      centerX: (seriesBox.width - newWidth) / 2 + padLeft + newRadius,
      centerY: (seriesBox.height - newHeight) / 2 + padTop + newRadius,
      radius: newRadius
    };
  }
};
PolarChart.className = "PolarChart";
PolarChart.type = "polar";
function isPolarSeries(series) {
  return series instanceof PolarSeries;
}
function isPolarAxis(axis) {
  return axis instanceof PolarAxis;
}

// packages/ag-charts-community/src/chart/polarChartModule.ts
var PolarChartModule = {
  type: "chart",
  name: "polar",
  options: polarChartOptionsDefs,
  detect: isAgPolarChartOptions,
  create(options, resources) {
    return new PolarChart(options, resources);
  },
  validate(options, optionsDefs4, path) {
    const additionalErrors = [];
    const baseType = options?.series?.[0]?.type;
    if (baseType === "pie" || baseType === "donut") {
      if (options?.axes) {
        additionalErrors.push(new import_ag_charts_core122.UnknownError([], options.axes, path, "axes"));
        options = without(options, ["axes"]);
      }
    }
    const result = (0, import_ag_charts_core122.validate)(options, optionsDefs4, path);
    result.invalid.push(...additionalErrors);
    return result;
  }
};

// packages/ag-charts-community/src/chart/series/cartesian/areaSeries.ts
var import_ag_charts_core128 = require("ag-charts-core");

// packages/ag-charts-community/src/motion/pathMotion.ts
function pathMotion(groupId, subId, animationManager, paths, fns) {
  const { addPhaseFn, updatePhaseFn, removePhaseFn } = fns;
  const animate = (phase, path, updateFn) => {
    animationManager.animate({
      id: `${groupId}_${subId}_${path.id}_${phase}`,
      groupId,
      from: 0,
      to: 1,
      ease: easeOut,
      collapsable: false,
      onUpdate(ratio8, preInit) {
        if (preInit && phase !== "removed")
          return;
        path.path.clear(true);
        updateFn(ratio8, path);
        path.checkPathDirty();
      },
      onStop() {
        if (phase !== "added")
          return;
        path.path.clear(true);
        updateFn(1, path);
        path.checkPathDirty();
      },
      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase]
    });
  };
  for (const path of paths) {
    if (!animationManager.isSkipped()) {
      animate("removed", path, removePhaseFn);
      animate("updated", path, updatePhaseFn);
    }
    animate("added", path, addPhaseFn);
  }
}

// packages/ag-charts-community/src/chart/axis/logAxis.ts
var import_ag_charts_core123 = require("ag-charts-core");
var LogAxis = class extends NumberAxis {
  normaliseDataDomain(d) {
    const { min, max } = this;
    const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);
    if (extent2[0] < 0 && extent2[1] > 0 || d[0] < 0 && d[1] > 0) {
      import_ag_charts_core123.Logger.warn(
        `The log axis domain crosses zero, the chart data cannot be rendered. See log axis documentation for more information.`
      );
      return { domain: [], clipped };
    } else if (extent2[0] === 0 || extent2[1] === 0 || d[0] === 0 || d[1] === 0) {
      import_ag_charts_core123.Logger.warn(
        `The log axis domain contains a value of 0, the chart data cannot be rendered. See log axis documentation for more information.`
      );
      return { domain: [], clipped };
    }
    return { domain: extent2, clipped };
  }
  set base(value) {
    this.scale.base = value;
  }
  get base() {
    return this.scale.base;
  }
  constructor(moduleCtx) {
    super(moduleCtx, new LogScale());
  }
  defaultDatumFormatter(datum, _fractionDigits) {
    return String(datum);
  }
  defaultLabelFormatter(datum, _fractionDigits) {
    return String(datum);
  }
};
LogAxis.className = "LogAxis";
LogAxis.type = "log";

// packages/ag-charts-community/src/chart/data/processors.ts
var import_ag_charts_core125 = require("ag-charts-core");

// packages/ag-charts-community/src/chart/data/aggregateFunctions.ts
var import_ag_charts_core124 = require("ag-charts-core");
function sumValues(values, accumulator = [0, 0]) {
  for (const value of values) {
    if (typeof value !== "number") {
      continue;
    }
    if (value < 0) {
      accumulator[0] += value;
    }
    if (value > 0) {
      accumulator[1] += value;
    }
  }
  return accumulator;
}
function groupSum(id, matchGroupId) {
  return {
    id,
    type: "aggregate",
    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,
    aggregateFunction: (values) => sumValues(values),
    groupAggregateFunction: (next, acc = [0, 0]) => {
      acc[0] += next?.[0] ?? 0;
      acc[1] += next?.[1] ?? 0;
      return acc;
    }
  };
}
function range2(id, matchGroupId) {
  const result = {
    id,
    matchGroupIds: [matchGroupId],
    type: "aggregate",
    aggregateFunction: (values) => ContinuousDomain.extendDomain(values)
  };
  return result;
}
function groupCount(id) {
  return {
    id,
    type: "aggregate",
    aggregateFunction: () => [0, 1],
    groupAggregateFunction: (next, acc = [0, 0]) => {
      acc[0] += next?.[0] ?? 0;
      acc[1] += next?.[1] ?? 0;
      return acc;
    }
  };
}
function groupAverage(id, matchGroupId) {
  const def = {
    id,
    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,
    type: "aggregate",
    aggregateFunction: (values) => sumValues(values),
    groupAggregateFunction: (next, acc = [0, 0, -1]) => {
      acc[0] += next?.[0] ?? 0;
      acc[1] += next?.[1] ?? 0;
      acc[2]++;
      return acc;
    },
    finalFunction: (acc = [0, 0, 0]) => {
      const result = acc[0] + acc[1];
      if (result >= 0) {
        return [0, result / acc[2]];
      }
      return [result / acc[2], 0];
    }
  };
  return def;
}
function area(id, aggFn, matchGroupId) {
  const result = {
    id,
    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,
    type: "aggregate",
    aggregateFunction: (values, keyRange = []) => {
      const keyWidth = keyRange[1] - keyRange[0];
      return aggFn.aggregateFunction(values).map((v) => v / keyWidth);
    }
  };
  if (aggFn.groupAggregateFunction) {
    result.groupAggregateFunction = aggFn.groupAggregateFunction;
  }
  return result;
}
function accumulatedValue(onlyPositive) {
  return () => {
    let value = 0;
    return (datum) => {
      if (!(0, import_ag_charts_core124.isFiniteNumber)(datum)) {
        return datum;
      }
      value += onlyPositive ? Math.max(0, datum) : datum;
      return value;
    };
  };
}

// packages/ag-charts-community/src/chart/data/processors.ts
function basicContinuousCheckDatumValidation(value) {
  return value != null && isContinuous(value);
}
function basicDiscreteCheckDatumValidation(value) {
  return value != null;
}
function getValidationFn(scaleType) {
  switch (scaleType) {
    case "number":
    case "log":
    case "ordinal-time":
    case "unit-time":
    case "time":
    case "color":
      return basicContinuousCheckDatumValidation;
    default:
      return basicDiscreteCheckDatumValidation;
  }
}
function getValueType(scaleType) {
  switch (scaleType) {
    case "number":
    case "log":
    case "time":
    case "color":
      return "range";
    default:
      return "category";
  }
}
function keyProperty(propName, scaleType, opts = {}) {
  const result = {
    property: propName,
    type: "key",
    valueType: getValueType(scaleType),
    validation: getValidationFn(scaleType),
    ...opts
  };
  return result;
}
function valueProperty(propName, scaleType, opts = {}) {
  const result = {
    property: propName,
    type: "value",
    valueType: getValueType(scaleType),
    validation: getValidationFn(scaleType),
    ...opts
  };
  return result;
}
function rowCountProperty(propName, opts = {}) {
  const result = {
    property: propName,
    type: "value",
    valueType: "range",
    missingValue: 1,
    processor: () => () => 1,
    ...opts
  };
  return result;
}
var noopProcessor = function(v) {
  return v;
};
function processorChain(...chain) {
  const filteredChain = chain.filter((fn) => fn != null);
  if (filteredChain.length === 0) {
    return () => noopProcessor;
  }
  if (filteredChain.length === 1) {
    return filteredChain[0];
  }
  return () => {
    const processorInstances = filteredChain.map((fn) => fn());
    return (value, index) => {
      return processorInstances.reduce((r, p) => p(r, index), value);
    };
  };
}
function rangedValueProperty(propName, opts = {}) {
  const { min = -Infinity, max = Infinity, processor, ...defOpts } = opts;
  return {
    type: "value",
    property: propName,
    valueType: "range",
    validation: basicContinuousCheckDatumValidation,
    processor: processorChain(processor, () => (datum) => (0, import_ag_charts_core125.isFiniteNumber)(datum) ? (0, import_ag_charts_core125.clamp)(min, datum, max) : datum),
    ...defOpts
  };
}
function accumulativeValueProperty(propName, scaleType, opts = {}) {
  const { onlyPositive, processor, ...defOpts } = opts;
  const result = {
    ...valueProperty(propName, scaleType, defOpts),
    processor: processorChain(processor, accumulatedValue(onlyPositive))
  };
  return result;
}
function groupAccumulativeValueProperty(propName, mode, sum, opts, scaleType) {
  return [
    valueProperty(propName, scaleType, opts),
    accumulateGroup(opts.groupId, mode, sum, opts.separateNegative),
    ...opts.rangeId != null ? [range2(opts.rangeId, opts.groupId)] : []
  ];
}
function groupStackValueProperty(propName, scaleType, opts) {
  return [valueProperty(propName, scaleType, opts), accumulateStack(opts.groupId)];
}
var SMALLEST_KEY_INTERVAL = {
  type: "reducer",
  property: "smallestKeyInterval",
  initialValue: Infinity,
  reducer: () => {
    let prevX = NaN;
    return (smallestSoFar = Infinity, keys) => {
      const nextX = typeof keys[0] === "number" ? keys[0] : Number(keys[0]);
      const interval = Math.abs(nextX - prevX);
      prevX = nextX;
      if (!isNaN(interval) && interval > 0 && interval < smallestSoFar) {
        return interval;
      }
      return smallestSoFar;
    };
  }
};
var LARGEST_KEY_INTERVAL = {
  type: "reducer",
  property: "largestKeyInterval",
  initialValue: -Infinity,
  reducer: () => {
    let prevX = NaN;
    return (largestSoFar = -Infinity, keys) => {
      const nextX = typeof keys[0] === "number" ? keys[0] : Number(keys[0]);
      const interval = Math.abs(nextX - prevX);
      prevX = nextX;
      if (!isNaN(interval) && interval > 0 && interval > largestSoFar) {
        return interval;
      }
      return largestSoFar;
    };
  }
};
var SORT_DOMAIN_GROUPS = {
  type: "processor",
  property: "sortedGroupDomain",
  calculate: ({ domain: { groups } }) => groups?.slice().sort((a, b) => {
    for (let i = 0; i < a.length; i++) {
      const result = a[i] - b[i];
      if (result !== 0) {
        return result;
      }
    }
    return 0;
  })
};
function normaliseFnBuilder({ normaliseTo }) {
  const normalise2 = (val, extent2) => {
    if (extent2 === 0)
      return null;
    const result = (val ?? 0) * normaliseTo / extent2;
    if (result >= 0) {
      return Math.min(normaliseTo, result);
    }
    return Math.max(-normaliseTo, result);
  };
  return () => () => (columns, valueIndexes, dataGroup) => {
    const extent2 = normaliseFindExtent(columns, valueIndexes, dataGroup);
    for (const valueIdx of valueIndexes) {
      for (const datumIndex of dataGroup.datumIndices[valueIdx] ?? []) {
        const column = columns[valueIdx];
        const value = column[datumIndex];
        if (value == null) {
          column[datumIndex] = void 0;
          continue;
        }
        column[datumIndex] = // eslint-disable-next-line sonarjs/no-nested-functions
        typeof value === "number" ? normalise2(value, extent2) : value.map((v) => normalise2(v, extent2));
      }
    }
  };
}
function normaliseFindExtent(columns, valueIndexes, dataGroup) {
  const valuesExtent = [0, 0];
  for (const valueIdx of valueIndexes) {
    const column = columns[valueIdx];
    for (const datumIndex of dataGroup.datumIndices[valueIdx] ?? []) {
      const value = column[datumIndex];
      if (value == null)
        continue;
      const valueExtent = typeof value === "number" ? value : Math.max(...value.map((v) => v ?? 0));
      const valIdx = valueExtent < 0 ? 0 : 1;
      if (valIdx === 0) {
        valuesExtent[valIdx] = Math.min(valuesExtent[valIdx], valueExtent);
      } else {
        valuesExtent[valIdx] = Math.max(valuesExtent[valIdx], valueExtent);
      }
    }
  }
  return Math.max(Math.abs(valuesExtent[0]), valuesExtent[1]);
}
function normaliseGroupTo(matchGroupIds, normaliseTo) {
  return {
    type: "group-value-processor",
    matchGroupIds,
    adjust: memo({ normaliseTo }, normaliseFnBuilder)
  };
}
function normalisePropertyFnBuilder({
  normaliseTo,
  zeroDomain,
  rangeMin,
  rangeMax
}) {
  const normaliseSpan = normaliseTo[1] - normaliseTo[0];
  const normalise2 = (val, start2, span) => {
    const result = normaliseTo[0] + (val - start2) / span * normaliseSpan;
    if (span === 0) {
      return zeroDomain;
    } else if (result >= normaliseTo[1]) {
      return normaliseTo[1];
    } else if (result < normaliseTo[0]) {
      return normaliseTo[0];
    }
    return result;
  };
  return () => (pData, pIdx) => {
    let [start2, end2] = pData.domain.values[pIdx];
    if (rangeMin != null)
      start2 = rangeMin;
    if (rangeMax != null)
      end2 = rangeMax;
    const span = end2 - start2;
    pData.domain.values[pIdx] = [normaliseTo[0], normaliseTo[1]];
    const column = pData.columns[pIdx];
    for (let datumIndex = 0; datumIndex < column.length; datumIndex += 1) {
      column[datumIndex] = normalise2(column[datumIndex], start2, span);
    }
  };
}
function normalisePropertyTo(property, normaliseTo, zeroDomain, rangeMin, rangeMax) {
  return {
    type: "property-value-processor",
    property,
    adjust: memo({ normaliseTo, rangeMin, rangeMax, zeroDomain }, normalisePropertyFnBuilder)
  };
}
var ANIMATION_VALIDATION_UNIQUE_KEYS = 1;
var ANIMATION_VALIDATION_ORDERED_KEYS = 2;
function animationValidationProcessKey(count, def, keyValues, column) {
  let validation = ANIMATION_VALIDATION_UNIQUE_KEYS | ANIMATION_VALIDATION_ORDERED_KEYS;
  if (def.valueType === "category") {
    if (keyValues.length < count)
      validation &= ~ANIMATION_VALIDATION_UNIQUE_KEYS;
    return validation;
  }
  let lastValue = column[0]?.valueOf();
  for (let d = 1; validation !== 0 && d < column.length; d++) {
    const keyValue = column[d]?.valueOf();
    if (!Number.isFinite(keyValue) || lastValue > keyValue)
      validation &= ~ANIMATION_VALIDATION_ORDERED_KEYS;
    if (Number.isFinite(keyValue) && lastValue === keyValue)
      validation &= ~ANIMATION_VALIDATION_UNIQUE_KEYS;
    lastValue = keyValue;
  }
  return validation;
}
function animationValidation(valueKeyIds) {
  return {
    type: "processor",
    property: "animationValidation",
    calculate(result) {
      const { keys: keysDefs, values: valuesDef } = result.defs;
      const {
        input: { count },
        domain: { keys: domainKeys, values: domainValues },
        keys,
        columns
      } = result;
      let validation = ANIMATION_VALIDATION_UNIQUE_KEYS | ANIMATION_VALIDATION_ORDERED_KEYS;
      if (count !== 0) {
        for (let i = 0; validation !== 0 && i < keysDefs.length; i++) {
          for (const scope of keysDefs[i].scopes) {
            validation &= animationValidationProcessKey(
              count,
              keysDefs[i],
              domainKeys[i],
              keys[i].get(scope)
            );
          }
        }
        for (let i = 0; validation !== 0 && i < valuesDef.length; i++) {
          const value = valuesDef[i];
          if (!valueKeyIds?.includes(value.id))
            continue;
          validation &= animationValidationProcessKey(count, value, domainValues[i], columns[i]);
        }
      }
      return {
        uniqueKeys: (validation & ANIMATION_VALIDATION_UNIQUE_KEYS) !== 0,
        orderedKeys: (validation & ANIMATION_VALIDATION_ORDERED_KEYS) !== 0
      };
    }
  };
}
function buildGroupAccFn({ mode, separateNegative }) {
  return () => () => (columns, valueIndexes, dataGroup) => {
    const acc = [0, 0];
    for (const valueIdx of valueIndexes) {
      for (const datumIndex of dataGroup.datumIndices[valueIdx] ?? []) {
        const column = columns[valueIdx];
        const currentVal = column[datumIndex];
        const accIndex = (0, import_ag_charts_core125.isNegative)(currentVal) && separateNegative ? 0 : 1;
        if (!(0, import_ag_charts_core125.isFiniteNumber)(currentVal))
          continue;
        if (mode === "normal")
          acc[accIndex] += currentVal;
        column[datumIndex] = acc[accIndex];
        if (mode === "trailing")
          acc[accIndex] += currentVal;
      }
    }
  };
}
function buildGroupWindowAccFn({ mode, sum }) {
  return () => {
    const lastValues = [];
    let firstRow = true;
    return () => {
      return (columns, valueIndexes, dataGroup) => {
        let acc = 0;
        for (const valueIdx of valueIndexes) {
          const column = columns[valueIdx];
          for (const datumIndex of dataGroup.datumIndices[valueIdx] ?? []) {
            const currentVal = column[datumIndex];
            const lastValue = firstRow && sum === "current" ? 0 : lastValues[valueIdx];
            lastValues[valueIdx] = currentVal;
            const sumValue = sum === "current" ? currentVal : lastValue;
            if (!(0, import_ag_charts_core125.isFiniteNumber)(currentVal) || !(0, import_ag_charts_core125.isFiniteNumber)(lastValue)) {
              column[datumIndex] = acc;
              continue;
            }
            if (mode === "normal") {
              acc += sumValue;
            }
            column[datumIndex] = acc;
            if (mode === "trailing") {
              acc += sumValue;
            }
          }
        }
        firstRow = false;
      };
    };
  };
}
function accumulateGroup(matchGroupId, mode, sum, separateNegative = false) {
  let adjust;
  if (mode.startsWith("window")) {
    const modeParam = mode.endsWith("-trailing") ? "trailing" : "normal";
    adjust = memo({ mode: modeParam, sum }, buildGroupWindowAccFn);
  } else {
    adjust = memo({ mode, separateNegative }, buildGroupAccFn);
  }
  return {
    type: "group-value-processor",
    matchGroupIds: [matchGroupId],
    adjust
  };
}
function groupStackAccFn() {
  return () => (columns, valueIndexes, dataGroup) => {
    const acc = new Float64Array(valueIndexes.length);
    let stackCount = 0;
    for (const valueIdx of valueIndexes) {
      const column = columns[valueIdx];
      for (const datumIndex of dataGroup.datumIndices[valueIdx] ?? []) {
        const currentValue = column[datumIndex];
        acc[stackCount] = Number.isFinite(currentValue) ? currentValue : NaN;
        stackCount += 1;
        column[datumIndex] = acc.subarray(0, stackCount);
      }
    }
  };
}
function accumulateStack(matchGroupId) {
  return {
    type: "group-value-processor",
    matchGroupIds: [matchGroupId],
    adjust: groupStackAccFn
  };
}
function valueIdentifier(value) {
  return value.id ?? value.property;
}
function valueIndices(id, previousData, processedData) {
  const properties = /* @__PURE__ */ new Map();
  const previousValues = previousData.defs.values;
  for (let previousIndex = 0; previousIndex < previousValues.length; previousIndex += 1) {
    const previousValue = previousValues[previousIndex];
    if (previousValue.scopes?.includes(id) === false)
      continue;
    const valueId = valueIdentifier(previousValue);
    if (properties.has(valueId))
      return;
    properties.set(valueId, previousIndex);
  }
  const indices = [];
  const nextValues = processedData.defs.values;
  for (let nextIndex = 0; nextIndex < nextValues.length; nextIndex += 1) {
    const nextValue = nextValues[nextIndex];
    if (nextValue.scopes?.includes(id) === false)
      continue;
    const valueId = valueIdentifier(nextValue);
    const previousIndex = properties.get(valueId);
    if (previousIndex == null)
      return;
    properties.delete(valueId);
    indices.push({ previousIndex, nextIndex });
  }
  if (properties.size !== 0)
    return;
  return indices;
}
function columnsEqual(previousColumns, nextColumns, indices, previousDatumIndex, nextDatumIndex) {
  for (const { previousIndex, nextIndex } of indices) {
    const previousColumn = previousColumns[previousIndex];
    const nextColumn = nextColumns[nextIndex];
    const previousValue = previousColumn[previousDatumIndex];
    const nextValue = nextColumn[nextDatumIndex];
    if (previousValue !== nextValue) {
      return false;
    }
  }
  return true;
}
function diff(id, previousData, updateMovedData = true) {
  return {
    type: "processor",
    property: "diff",
    calculate(processedData, previousValue) {
      const moved = /* @__PURE__ */ new Map();
      const added = /* @__PURE__ */ new Map();
      const updated = /* @__PURE__ */ new Map();
      const removed = /* @__PURE__ */ new Map();
      const previousKeys = previousData.keys;
      const keys = processedData.keys;
      const previousColumns = previousData.columns;
      const columns = processedData.columns;
      const indices = valueIndices(id, previousData, processedData);
      if (indices == null)
        return previousValue;
      const length = Math.max(previousData.input.count, processedData.input.count);
      for (let i = 0; i < length; i++) {
        const hasPreviousDatum = i < previousData.input.count;
        const hasDatum = i < processedData.input.count;
        const prevKeys = hasPreviousDatum ? datumKeys(previousKeys, id, i) : void 0;
        const prevId = prevKeys != null ? createDatumId(prevKeys) : "";
        const dKeys = hasDatum ? datumKeys(keys, id, i) : void 0;
        const datumId = dKeys != null ? createDatumId(dKeys) : "";
        if (hasDatum && hasPreviousDatum && prevId === datumId) {
          if (!columnsEqual(previousColumns, columns, indices, i, i)) {
            updated.set(datumId, i);
          }
          continue;
        }
        const removedIndex = removed.get(datumId);
        if (removedIndex != null) {
          if (updateMovedData || !columnsEqual(previousColumns, columns, indices, removedIndex, i)) {
            updated.set(datumId, i);
            moved.set(datumId, i);
          }
          removed.delete(datumId);
        } else if (hasDatum) {
          added.set(datumId, i);
        }
        const addedIndex = added.get(prevId);
        if (addedIndex != null) {
          if (updateMovedData || !columnsEqual(previousColumns, columns, indices, addedIndex, i)) {
            updated.set(prevId, i);
            moved.set(prevId, i);
          }
          added.delete(prevId);
        } else if (hasPreviousDatum) {
          updated.delete(prevId);
          removed.set(prevId, i);
        }
      }
      const changed = added.size > 0 || updated.size > 0 || removed.size > 0;
      const value = {
        changed,
        added: new Set(added.keys()),
        updated: new Set(updated.keys()),
        removed: new Set(removed.keys()),
        moved: new Set(moved.keys())
      };
      return {
        ...previousValue,
        [id]: value
      };
    }
  };
}
function createDatumId(keys, ...extraKeys) {
  let result;
  if ((0, import_ag_charts_core125.isArray)(keys)) {
    result = keys.map((key) => transformIntegratedCategoryValue(key)).join("___");
  } else {
    result = transformIntegratedCategoryValue(keys);
  }
  const primitiveType = typeof result === "string" || typeof result === "number" || typeof result === "boolean" || result instanceof Date;
  if (primitiveType && extraKeys.length > 0) {
    result += `___${extraKeys.join("___")}`;
  }
  return result;
}

// packages/ag-charts-community/src/chart/series/seriesLabelUtil.ts
function seriesLabelFadeInAnimation({ id }, subId, animationManager, ...labelSelections) {
  for (const labelSelection of labelSelections) {
    labelSelection.cleanup();
  }
  staticFromToMotion(
    id,
    subId,
    animationManager,
    labelSelections,
    { opacity: 0 },
    { opacity: 1 },
    { phase: "trailing" }
  );
}
function seriesLabelFadeOutAnimation({ id }, subId, animationManager, ...labelSelections) {
  staticFromToMotion(
    id,
    subId,
    animationManager,
    labelSelections,
    { opacity: 1 },
    { opacity: 0 },
    { phase: "remove" }
  );
}
function resetLabelFn(_node) {
  return { opacity: 1 };
}

// packages/ag-charts-community/src/scene/util/changeDetectableProperties.ts
var ChangeDetectableProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this._dirty = true;
  }
  markDirty() {
    this._dirty = true;
  }
  markClean(_opts) {
    this._dirty = false;
  }
  isDirty() {
    return this._dirty;
  }
  onChangeDetection(_property) {
    this.markDirty();
  }
};

// packages/ag-charts-community/src/scene/dropShadow.ts
var DropShadow = class extends ChangeDetectableProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.color = "rgba(0, 0, 0, 0.5)";
    this.xOffset = 0;
    this.yOffset = 0;
    this.blur = 5;
  }
};
__decorateClass([
  Property,
  SceneChangeDetection()
], DropShadow.prototype, "enabled", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], DropShadow.prototype, "color", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], DropShadow.prototype, "xOffset", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], DropShadow.prototype, "yOffset", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], DropShadow.prototype, "blur", 2);

// packages/ag-charts-community/src/chart/series/seriesMarker.ts
var SeriesMarker = class extends ChangeDetectableProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.shape = "circle";
    this.size = 6;
    this.fillGradientDefaults = new FillGradientDefaults();
    this.fillPatternDefaults = new FillPatternDefaults();
    this.fillImageDefaults = new FillImageDefaults();
    this.fillOpacity = 1;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
  }
  getStyle() {
    const { size, shape, fill, fillOpacity, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this;
    return {
      size,
      shape,
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset
    };
  }
  getDiameter() {
    return this.size + this.strokeWidth;
  }
};
__decorateClass([
  Property,
  SceneChangeDetection()
], SeriesMarker.prototype, "enabled", 2);
__decorateClass([
  Property,
  SceneObjectChangeDetection({ equals: TRIPLE_EQ })
], SeriesMarker.prototype, "shape", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], SeriesMarker.prototype, "size", 2);
__decorateClass([
  Property,
  SceneObjectChangeDetection({ equals: objectsEqual })
], SeriesMarker.prototype, "fill", 2);
__decorateClass([
  Property
], SeriesMarker.prototype, "fillGradientDefaults", 2);
__decorateClass([
  Property
], SeriesMarker.prototype, "fillPatternDefaults", 2);
__decorateClass([
  Property
], SeriesMarker.prototype, "fillImageDefaults", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], SeriesMarker.prototype, "fillOpacity", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], SeriesMarker.prototype, "stroke", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], SeriesMarker.prototype, "strokeWidth", 2);
__decorateClass([
  Property,
  SceneChangeDetection()
], SeriesMarker.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], SeriesMarker.prototype, "lineDash", 2);
__decorateClass([
  Property
], SeriesMarker.prototype, "lineDashOffset", 2);
__decorateClass([
  Property,
  SceneObjectChangeDetection({ equals: TRIPLE_EQ })
], SeriesMarker.prototype, "itemStyler", 2);

// packages/ag-charts-community/src/chart/series/seriesTooltip.ts
var SeriesTooltipInteraction = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = false;
  }
};
__decorateClass([
  Property
], SeriesTooltipInteraction.prototype, "enabled", 2);
var SeriesTooltip = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.interaction = new SeriesTooltipInteraction();
    this.position = new TooltipPosition();
    this.range = void 0;
    this.class = void 0;
  }
  formatTooltip(caller1, caller2, content, params) {
    const overrides = this.renderer == null ? void 0 : callWithContext(caller1, caller2, this.renderer, [params]);
    if (typeof overrides === "string")
      return { type: "raw", rawHtmlString: overrides };
    if (overrides != null)
      return { type: "structured", ...content, ...overrides };
    return { type: "structured", ...content };
  }
};
__decorateClass([
  Property
], SeriesTooltip.prototype, "enabled", 2);
__decorateClass([
  Property
], SeriesTooltip.prototype, "showArrow", 2);
__decorateClass([
  Property
], SeriesTooltip.prototype, "renderer", 2);
__decorateClass([
  Property
], SeriesTooltip.prototype, "interaction", 2);
__decorateClass([
  Property
], SeriesTooltip.prototype, "position", 2);
__decorateClass([
  Property
], SeriesTooltip.prototype, "range", 2);
__decorateClass([
  Property
], SeriesTooltip.prototype, "class", 2);

// packages/ag-charts-community/src/chart/series/cartesian/interpolationProperties.ts
var InterpolationProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.type = "linear";
    this.tension = 1;
    this.position = "end";
  }
};
__decorateClass([
  Property
], InterpolationProperties.prototype, "type", 2);
__decorateClass([
  Property
], InterpolationProperties.prototype, "tension", 2);
__decorateClass([
  Property
], InterpolationProperties.prototype, "position", 2);

// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesProperties.ts
var AreaSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.xName = void 0;
    this.fill = "#c16068";
    this.fillGradientDefaults = new FillGradientDefaults();
    this.fillPatternDefaults = new FillPatternDefaults();
    this.fillImageDefaults = new FillImageDefaults();
    this.fillOpacity = 1;
    this.stroke = "#874349";
    this.strokeWidth = 2;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.interpolation = new InterpolationProperties();
    this.shadow = new DropShadow();
    this.marker = new SeriesMarker();
    this.label = new Label();
    this.tooltip = new SeriesTooltip();
    this.connectMissingData = false;
  }
};
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "yFilterKey", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "normalizedTo", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "fill", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "interpolation", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "marker", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "label", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Property
], AreaSeriesProperties.prototype, "connectMissingData", 2);

// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolation.ts
function spanRange(span) {
  switch (span.type) {
    case "linear":
    case "step":
      return [
        { x: span.x0, y: span.y0 },
        { x: span.x1, y: span.y1 }
      ];
    case "cubic":
      return [
        { x: span.cp0x, y: span.cp0y },
        { x: span.cp3x, y: span.cp3y }
      ];
  }
}
function spanRangeNormalized(span) {
  const range3 = spanRange(span);
  if (range3[0].x > range3[1].x) {
    range3.reverse();
  }
  return range3;
}
function collapseSpanToPoint(span, point) {
  const { x, y } = point;
  switch (span.type) {
    case "linear":
      return {
        type: "linear",
        moveTo: span.moveTo,
        x0: x,
        y0: y,
        x1: x,
        y1: y
      };
    case "step":
      return {
        type: "step",
        moveTo: span.moveTo,
        x0: x,
        y0: y,
        x1: x,
        y1: y,
        stepX: x
      };
    case "cubic":
      return {
        type: "cubic",
        moveTo: span.moveTo,
        cp0x: x,
        cp0y: y,
        cp1x: x,
        cp1y: y,
        cp2x: x,
        cp2y: y,
        cp3x: x,
        cp3y: y
      };
  }
}
function rescaleSpan(span, nextStart, nextEnd) {
  const [prevStart, prevEnd] = spanRange(span);
  const widthScale = prevEnd.x !== prevStart.x ? (nextEnd.x - nextStart.x) / (prevEnd.x - prevStart.x) : 0;
  const heightScale = prevEnd.y !== prevStart.y ? (nextEnd.y - nextStart.y) / (prevEnd.y - prevStart.y) : 0;
  switch (span.type) {
    case "linear":
      return {
        type: "linear",
        moveTo: span.moveTo,
        x0: nextStart.x,
        y0: nextStart.y,
        x1: nextEnd.x,
        y1: nextEnd.y
      };
    case "cubic":
      return {
        type: "cubic",
        moveTo: span.moveTo,
        cp0x: nextStart.x,
        cp0y: nextStart.y,
        cp1x: nextEnd.x - (span.cp2x - prevStart.x) * widthScale,
        cp1y: nextEnd.y - (span.cp2y - prevStart.y) * heightScale,
        cp2x: nextEnd.x - (span.cp1x - prevStart.x) * widthScale,
        cp2y: nextEnd.y - (span.cp1y - prevStart.y) * heightScale,
        cp3x: nextEnd.x,
        cp3y: nextEnd.y
      };
    case "step":
      return {
        type: "step",
        moveTo: span.moveTo,
        x0: nextStart.x,
        y0: nextStart.y,
        x1: nextEnd.x,
        y1: nextEnd.y,
        stepX: nextEnd.x - (span.stepX - prevStart.x) * widthScale
      };
  }
}
function clipSpanX(span, x0, x1) {
  const { moveTo } = span;
  const [start2, end2] = spanRangeNormalized(span);
  const { x: spanX0, y: spanY0 } = start2;
  const { x: spanX1, y: spanY1 } = end2;
  if (x1 < spanX0) {
    return rescaleSpan(span, start2, start2);
  } else if (x0 > spanX1) {
    return rescaleSpan(span, end2, end2);
  }
  switch (span.type) {
    case "linear": {
      const m = spanY0 === spanY1 ? void 0 : (spanY1 - spanY0) / (spanX1 - spanX0);
      const y0 = m == null ? spanY0 : m * (x0 - spanX0) + spanY0;
      const y1 = m == null ? spanY0 : m * (x1 - spanX0) + spanY0;
      return { type: "linear", moveTo, x0, y0, x1, y1 };
    }
    case "step":
      if (x1 <= span.stepX) {
        const y = span.y0;
        return { type: "step", moveTo, x0, y0: y, x1, y1: y, stepX: x1 };
      } else if (x0 >= span.stepX) {
        const y = span.y1;
        return { type: "step", moveTo, x0, y0: y, x1, y1: y, stepX: x0 };
      } else {
        const { y0, y1, stepX } = span;
        return { type: "step", moveTo, x0, y0, x1, y1, stepX };
      }
    case "cubic": {
      const t0 = solveBezier(span.cp0x, span.cp1x, span.cp2x, span.cp3x, x0);
      let [_unused, bezier] = splitBezier(
        span.cp0x,
        span.cp0y,
        span.cp1x,
        span.cp1y,
        span.cp2x,
        span.cp2y,
        span.cp3x,
        span.cp3y,
        t0
      );
      const t1 = solveBezier(bezier[0].x, bezier[1].x, bezier[2].x, bezier[3].x, x1);
      [bezier, _unused] = splitBezier(
        bezier[0].x,
        bezier[0].y,
        bezier[1].x,
        bezier[1].y,
        bezier[2].x,
        bezier[2].y,
        bezier[3].x,
        bezier[3].y,
        t1
      );
      return {
        type: "cubic",
        moveTo,
        cp0x: bezier[0].x,
        cp0y: bezier[0].y,
        cp1x: bezier[1].x,
        cp1y: bezier[1].y,
        cp2x: bezier[2].x,
        cp2y: bezier[2].y,
        cp3x: bezier[3].x,
        cp3y: bezier[3].y
      };
    }
  }
}
function linearPoints(points) {
  const spans = [];
  let i = 0;
  let x0 = NaN;
  let y0 = NaN;
  for (const { x: x1, y: y1 } of points) {
    if (i > 0) {
      const moveTo = i === 1;
      spans.push({ type: "linear", moveTo, x0, y0, x1, y1 });
    }
    i += 1;
    x0 = x1;
    y0 = y1;
  }
  return spans;
}
var lineSteps = {
  start: 0,
  middle: 0.5,
  end: 1
};
function stepPoints(points, position) {
  const spans = [];
  let i = 0;
  let x0 = NaN;
  let y0 = NaN;
  const p0 = typeof position === "number" ? position : lineSteps[position];
  for (const { x: x1, y: y1 } of points) {
    if (i > 0) {
      const moveTo = i === 1;
      const stepX = x0 + (x1 - x0) * p0;
      spans.push({ type: "step", moveTo, x0, y0, x1, y1, stepX });
    }
    i += 1;
    x0 = x1;
    y0 = y1;
  }
  return spans;
}
var flatnessRatio = 0.05;
function smoothPoints(iPoints, tension) {
  const points = Array.isArray(iPoints) ? iPoints : Array.from(iPoints);
  if (points.length <= 1)
    return [];
  const gradients = points.map((c, i) => {
    const p = i === 0 ? c : points[i - 1];
    const n = i === points.length - 1 ? c : points[i + 1];
    const isTerminalPoint = i === 0 || i === points.length - 1;
    if (Math.sign(p.y - c.y) === Math.sign(n.y - c.y)) {
      return 0;
    }
    if (!isTerminalPoint) {
      const range3 = Math.abs(p.y - n.y);
      const prevRatio = Math.abs(c.y - p.y) / range3;
      const nextRatio = Math.abs(c.y - n.y) / range3;
      if (prevRatio <= flatnessRatio || 1 - prevRatio <= flatnessRatio || nextRatio <= flatnessRatio || 1 - nextRatio <= flatnessRatio) {
        return 0;
      }
    }
    return (n.y - p.y) / (n.x - p.x);
  });
  if (gradients[1] === 0) {
    gradients[0] *= 2;
  }
  if (gradients[gradients.length - 2] === 0) {
    gradients[gradients.length - 1] *= 2;
  }
  const spans = [];
  for (let i = 1; i < points.length; i += 1) {
    const prev = points[i - 1];
    const prevM = gradients[i - 1];
    const cur = points[i];
    const curM = gradients[i];
    const dx = cur.x - prev.x;
    const dy = cur.y - prev.y;
    let dcp1x = dx * tension / 3;
    let dcp1y = dx * prevM * tension / 3;
    let dcp2x = dx * tension / 3;
    let dcp2y = dx * curM * tension / 3;
    if (curM === 0 && Math.abs(dcp1y) > Math.abs(dy)) {
      dcp1x *= Math.abs(dy / dcp1y);
      dcp1y = Math.sign(dcp1y) * Math.abs(dy);
    }
    if (prevM === 0 && Math.abs(dcp2y) > Math.abs(dy)) {
      dcp2x *= Math.abs(dy / dcp2y);
      dcp2y = Math.sign(dcp2y) * Math.abs(dy);
    }
    spans.push({
      type: "cubic",
      moveTo: i === 1,
      cp0x: prev.x,
      cp0y: prev.y,
      cp1x: prev.x + dcp1x,
      cp1y: prev.y + dcp1y,
      cp2x: cur.x - dcp2x,
      cp2y: cur.y - dcp2y,
      cp3x: cur.x,
      cp3y: cur.y
    });
  }
  return spans;
}

// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolationPlotting.ts
function lerp2(a, b, ratio8) {
  return (b - a) * ratio8 + a;
}
function linearSupertype(span, stepX) {
  const { x0, y0, x1, y1 } = span;
  const m = (y1 - y0) / (x1 - x0);
  const stepY = m * (stepX - x0) + y0;
  return {
    leftCp1x: x0,
    leftCp1y: y0,
    leftCp2x: stepX,
    leftCp2y: stepY,
    stepX,
    stepY0: stepY,
    stepY1: stepY,
    rightCp1x: stepX,
    rightCp1y: stepY,
    rightCp2x: x1,
    rightCp2y: y1
  };
}
function bezierSupertype(span, stepX) {
  const { cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y } = span;
  const t = solveBezier(cp0x, cp1x, cp2x, cp3x, stepX);
  const [left, right] = splitBezier(cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y, t);
  const stepY = left[3].y;
  return {
    leftCp1x: left[1].x,
    leftCp1y: left[1].y,
    leftCp2x: left[2].x,
    leftCp2y: left[2].y,
    stepX,
    stepY0: stepY,
    stepY1: stepY,
    rightCp1x: right[1].x,
    rightCp1y: right[1].y,
    rightCp2x: right[2].x,
    rightCp2y: right[2].y
  };
}
function stepSupertype(span) {
  const { x0, y0, x1, y1, stepX } = span;
  return {
    leftCp1x: (x0 + stepX) / 2,
    leftCp1y: y0,
    leftCp2x: (x0 + stepX) / 2,
    leftCp2y: y0,
    stepX,
    stepY0: y0,
    stepY1: y1,
    rightCp1x: (stepX + x1) / 2,
    rightCp1y: y1,
    rightCp2x: (stepX + x1) / 2,
    rightCp2y: y1
  };
}
function spanSupertype(span, stepX) {
  if (span.type === "linear") {
    return linearSupertype(span, stepX);
  } else if (span.type === "cubic") {
    return bezierSupertype(span, stepX);
  } else {
    return stepSupertype(span);
  }
}
function plotStart(path, moveTo, x0, y0, x1, y1, reversed) {
  switch (moveTo) {
    case 0 /* MoveTo */:
      if (reversed) {
        path.moveTo(x1, y1);
      } else {
        path.moveTo(x0, y0);
      }
      break;
    case 1 /* LineTo */:
      if (reversed) {
        path.lineTo(x1, y1);
      } else {
        path.lineTo(x0, y0);
      }
      break;
  }
}
function plotLinear(path, x0, y0, x1, y1, reversed) {
  if (reversed) {
    path.lineTo(x0, y0);
  } else {
    path.lineTo(x1, y1);
  }
}
function plotCubic(path, cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, cp3x, cp3y, reversed) {
  if (reversed) {
    path.cubicCurveTo(cp2x, cp2y, cp1x, cp1y, cp0x, cp0y);
  } else {
    path.cubicCurveTo(cp1x, cp1y, cp2x, cp2y, cp3x, cp3y);
  }
}
function plotStep(path, x0, y0, x1, y1, stepX, reversed) {
  if (reversed) {
    path.lineTo(stepX, y1);
    path.lineTo(stepX, y0);
    path.lineTo(x0, y0);
  } else {
    path.lineTo(stepX, y0);
    path.lineTo(stepX, y1);
    path.lineTo(x1, y1);
  }
}
function plotSpan(path, span, moveTo, reversed) {
  const [start2, end2] = spanRange(span);
  plotStart(path, moveTo, start2.x, start2.y, end2.x, end2.y, reversed);
  switch (span.type) {
    case "linear":
      plotLinear(path, span.x0, span.y0, span.x1, span.y1, reversed);
      break;
    case "cubic":
      plotCubic(
        path,
        span.cp0x,
        span.cp0y,
        span.cp1x,
        span.cp1y,
        span.cp2x,
        span.cp2y,
        span.cp3x,
        span.cp3y,
        reversed
      );
      break;
    case "step":
      plotStep(path, span.x0, span.y0, span.x1, span.y1, span.stepX, reversed);
      break;
  }
}
function interpolatedSpanRange(a, b, ratio8) {
  const [aStart, aEnd] = spanRange(a);
  const [bStart, bEnd] = spanRange(b);
  const x0 = lerp2(aStart.x, bStart.x, ratio8);
  const y0 = lerp2(aStart.y, bStart.y, ratio8);
  const x1 = lerp2(aEnd.x, bEnd.x, ratio8);
  const y1 = lerp2(aEnd.y, bEnd.y, ratio8);
  return [
    { x: x0, y: y0 },
    { x: x1, y: y1 }
  ];
}
function plotInterpolatedSpans(path, a, b, ratio8, moveTo, reversed) {
  const [{ x: x0, y: y0 }, { x: x1, y: y1 }] = interpolatedSpanRange(a, b, ratio8);
  plotStart(path, moveTo, x0, y0, x1, y1, reversed);
  if (a.type === "cubic" && b.type === "cubic") {
    const cp1x = lerp2(a.cp1x, b.cp1x, ratio8);
    const cp1y = lerp2(a.cp1y, b.cp1y, ratio8);
    const cp2x = lerp2(a.cp2x, b.cp2x, ratio8);
    const cp2y = lerp2(a.cp2y, b.cp2y, ratio8);
    plotCubic(path, x0, y0, cp1x, cp1y, cp2x, cp2y, x1, y1, reversed);
  } else if (a.type === "step" && b.type === "step") {
    const stepX = lerp2(a.stepX, b.stepX, ratio8);
    plotStep(path, x0, y0, x1, y1, stepX, reversed);
  } else if (a.type === "linear" && b.type === "linear") {
    plotLinear(path, x0, y0, x1, y1, reversed);
  } else {
    let defaultStepX;
    if (a.type === "step") {
      defaultStepX = a.stepX;
    } else if (b.type === "step") {
      defaultStepX = b.stepX;
    } else {
      defaultStepX = (x0 + x1) / 2;
    }
    const as = spanSupertype(a, defaultStepX);
    const bs = spanSupertype(b, defaultStepX);
    const leftCp1x = lerp2(as.leftCp1x, bs.leftCp1x, ratio8);
    const leftCp1y = lerp2(as.leftCp1y, bs.leftCp1y, ratio8);
    const leftCp2x = lerp2(as.leftCp2x, bs.leftCp2x, ratio8);
    const leftCp2y = lerp2(as.leftCp2y, bs.leftCp2y, ratio8);
    const stepX = lerp2(as.stepX, bs.stepX, ratio8);
    const stepY0 = lerp2(as.stepY0, bs.stepY0, ratio8);
    const stepY1 = lerp2(as.stepY1, bs.stepY1, ratio8);
    const rightCp1x = lerp2(as.rightCp1x, bs.rightCp1x, ratio8);
    const rightCp1y = lerp2(as.rightCp1y, bs.rightCp1y, ratio8);
    const rightCp2x = lerp2(as.rightCp2x, bs.rightCp2x, ratio8);
    const rightCp2y = lerp2(as.rightCp2y, bs.rightCp2y, ratio8);
    if (reversed) {
      path.cubicCurveTo(rightCp2x, rightCp2y, rightCp1x, rightCp1y, stepX, stepY1);
      path.lineTo(stepX, stepY0);
      path.cubicCurveTo(leftCp2x, leftCp2y, leftCp1x, leftCp1y, x0, y0);
    } else {
      path.cubicCurveTo(leftCp1x, leftCp1y, leftCp2x, leftCp2y, stepX, stepY0);
      path.lineTo(stepX, stepY1);
      path.cubicCurveTo(rightCp1x, rightCp1y, rightCp2x, rightCp2y, x1, y1);
    }
  }
}

// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolationUtil.ts
function integratedCategoryMatch(a, b) {
  if (a == null || b == null)
    return false;
  if (typeof a !== "object" || typeof b !== "object")
    return false;
  if ("id" in a && "id" in b) {
    return a.id === b.id;
  }
  return a.toString() === b.toString();
}
function scale(val, scaling) {
  if (!scaling)
    return NaN;
  if (val instanceof Date) {
    val = val.getTime();
  }
  if (scaling.type === "continuous" && typeof val === "number") {
    const domainRatio = (val - scaling.domain[0]) / (scaling.domain[1] - scaling.domain[0]);
    return domainRatio * (scaling.range[1] - scaling.range[0]) + scaling.range[0];
  }
  if (scaling.type === "log" && typeof val === "number") {
    return scaling.convert(val);
  }
  if (scaling.type !== "category")
    return NaN;
  let matchingIndex = scaling.domain.findIndex((d) => d === val);
  if (matchingIndex === -1) {
    matchingIndex = scaling.domain.findIndex((d) => integratedCategoryMatch(val, d));
  }
  if (matchingIndex >= 0) {
    return scaling.inset + scaling.step * matchingIndex;
  }
  return NaN;
}
function toAxisValue(value) {
  return transformIntegratedCategoryValue(value).valueOf();
}
function getAxisIndices({ data }, values) {
  return data.map((datum, datumIndex) => ({
    xValue0Index: values.indexOf(toAxisValue(datum.xValue0)),
    xValue1Index: values.indexOf(toAxisValue(datum.xValue1)),
    datumIndex
  }));
}
function validateCategorySorting(newData, oldData) {
  const oldScale = oldData.scales.x;
  const newScale = newData.scales.x;
  if (oldScale?.type !== "category" || newScale?.type !== "category")
    return true;
  let x0 = -Infinity;
  for (const oldValue of oldScale.domain) {
    const x = scale(oldValue, newScale);
    if (!Number.isFinite(x))
      continue;
    if (x < x0) {
      return false;
    } else {
      x0 = x;
    }
  }
  return true;
}
function validateAxisEntriesOrder(axisValues, data) {
  let x0 = -Infinity;
  for (const axisValue of axisValues) {
    const x = scale(axisValue.value, data.scales.x);
    if (!Number.isFinite(x))
      continue;
    if (x < x0) {
      return false;
    } else {
      x0 = x;
    }
  }
  return true;
}
function spanAxisContext(newData, oldData) {
  const allAxisEntries = /* @__PURE__ */ new Map();
  for (const { xValue0, xValue1 } of newData.data) {
    const xValue0Value = toAxisValue(xValue0);
    const xValue1Value = toAxisValue(xValue1);
    allAxisEntries.set(xValue0Value, xValue0).set(xValue1Value, xValue1);
  }
  const newAxisEntries = Array.from(allAxisEntries, ([axisValue, value]) => ({ axisValue, value }));
  newAxisEntries.sort((a, b) => {
    return scale(a.value, newData.scales.x) - scale(b.value, newData.scales.x);
  });
  const exclusivelyOldAxisEntries = [];
  for (const { xValue0, xValue1 } of oldData.data) {
    const xValue0Value = toAxisValue(xValue0);
    const xValue1Value = toAxisValue(xValue1);
    if (!allAxisEntries.has(xValue0Value)) {
      allAxisEntries.set(xValue0Value, xValue0);
      exclusivelyOldAxisEntries.push({ axisValue: xValue0Value, value: xValue0 });
    }
    if (!allAxisEntries.has(xValue1Value)) {
      allAxisEntries.set(xValue1Value, xValue1);
      exclusivelyOldAxisEntries.push({ axisValue: xValue1Value, value: xValue1 });
    }
  }
  exclusivelyOldAxisEntries.sort((a, b) => {
    return scale(a.value, oldData.scales.x) - scale(b.value, oldData.scales.x);
  });
  const axisEntries = newAxisEntries;
  let insertionIndex = 0;
  for (const oldAxisEntries of exclusivelyOldAxisEntries) {
    for (let i = axisEntries.length - 1; i > insertionIndex; i -= 1) {
      const oldValueX = scale(oldAxisEntries.value, oldData.scales.x);
      const newValueX = scale(axisEntries[i].value, oldData.scales.x);
      if (oldValueX > newValueX) {
        insertionIndex = i + 1;
        break;
      }
    }
    axisEntries.splice(insertionIndex, 0, oldAxisEntries);
    insertionIndex += 1;
  }
  if (!validateAxisEntriesOrder(axisEntries, oldData))
    return;
  const axisValues = axisEntries.map((axisEntry) => axisEntry.axisValue);
  const oldDataAxisIndices = getAxisIndices(oldData, axisValues);
  const newDataAxisIndices = getAxisIndices(newData, axisValues);
  return { axisValues, oldDataAxisIndices, newDataAxisIndices };
}
function clipSpan(span, xValue0Index, xIndices) {
  if (xIndices.xValue1Index === xIndices.xValue0Index + 1)
    return span;
  const range3 = spanRange(span);
  const step = (range3[1].x - range3[0].x) / (xIndices.xValue1Index - xIndices.xValue0Index);
  const start2 = range3[0].x + (xValue0Index - xIndices.xValue0Index) * step;
  const end2 = start2 + step;
  return clipSpanX(span, start2, end2);
}
function axisZeroSpan(span, data) {
  const [r0, r1] = spanRange(span);
  const y0 = scale(0, data.scales.y);
  return rescaleSpan(span, { x: r0.x, y: y0 }, { x: r1.x, y: y0 });
}
function collapseSpanToMidpoint(span) {
  const [r0, r1] = spanRange(span);
  return collapseSpanToPoint(span, {
    x: (r0.x + r1.x) / 2,
    y: (r0.y + r1.y) / 2
  });
}
function collapseSpan(span, collapseMode, data, axisIndices, indices, range3) {
  let xValue;
  let yValue;
  if (indices.xValue0Index >= range3.xValue1Index) {
    const datumIndex = axisIndices.findLast((i) => i.xValue1Index <= range3.xValue1Index)?.datumIndex;
    const datum = datumIndex != null ? data.data[datumIndex] : void 0;
    xValue = datum?.xValue1;
    yValue = datum?.yValue1;
  } else if (indices.xValue0Index <= range3.xValue0Index) {
    const datumIndex = axisIndices.find((i) => i.xValue0Index >= range3.xValue0Index)?.datumIndex;
    const datum = datumIndex != null ? data.data[datumIndex] : void 0;
    xValue = datum?.xValue0;
    yValue = datum?.yValue0;
  }
  if (xValue == null || yValue == null) {
    switch (collapseMode) {
      case 0 /* Zero */:
        return axisZeroSpan(span, data);
      case 1 /* Split */:
        return collapseSpanToMidpoint(span);
    }
  }
  const x = scale(xValue, data.scales.x);
  const y = scale(yValue, data.scales.y);
  const point = { x, y };
  return rescaleSpan(span, point, point);
}
function zeroDataSpan(spanDatum, zeroData) {
  if (zeroData == null)
    return;
  const newSpanXValue0 = toAxisValue(spanDatum.xValue0);
  const newSpanXValue1 = toAxisValue(spanDatum.xValue1);
  return zeroData.find(
    (zeroSpanDatum) => toAxisValue(zeroSpanDatum.xValue0) === newSpanXValue0 && toAxisValue(zeroSpanDatum.xValue1) === newSpanXValue1
  )?.span;
}
function addSpan(newData, collapseMode, newAxisIndices, newIndices, oldZeroData, range3, out) {
  const newSpanDatum = newData.data[newIndices.datumIndex];
  const newSpan = newSpanDatum.span;
  const zeroSpan = zeroDataSpan(newSpanDatum, oldZeroData);
  if (zeroSpan != null) {
    out.removed.push({ from: zeroSpan, to: zeroSpan });
    out.moved.push({ from: zeroSpan, to: newSpan });
    out.added.push({ from: newSpan, to: newSpan });
  } else {
    const oldSpan = collapseSpan(newSpan, collapseMode, newData, newAxisIndices, newIndices, range3);
    out.added.push({ from: oldSpan, to: newSpan });
  }
}
function removeSpan(oldData, collapseMode, oldAxisIndices, oldIndices, newZeroData, range3, out) {
  const oldSpanDatum = oldData.data[oldIndices.datumIndex];
  const oldSpan = oldSpanDatum.span;
  const zeroSpan = zeroDataSpan(oldSpanDatum, newZeroData);
  if (zeroSpan != null) {
    out.removed.push({ from: oldSpan, to: oldSpan });
    out.moved.push({ from: oldSpan, to: zeroSpan });
    out.added.push({ from: zeroSpan, to: zeroSpan });
  } else {
    const newSpan = collapseSpan(oldSpan, collapseMode, oldData, oldAxisIndices, oldIndices, range3);
    out.removed.push({ from: oldSpan, to: newSpan });
  }
}
function alignSpanToContainingSpan(span, axisValues, preData, postData, postSpanIndices) {
  const startXValue0 = axisValues[postSpanIndices.xValue0Index];
  const startDatum = preData.data.find((spanDatum) => toAxisValue(spanDatum.xValue0) === startXValue0);
  const endXValue1 = axisValues[postSpanIndices.xValue1Index];
  const endDatum = preData.data.find((spanDatum) => toAxisValue(spanDatum.xValue1) === endXValue1);
  if (startDatum == null || endDatum == null)
    return;
  const [{ x: x0 }, { x: x1 }] = spanRange(span);
  const startX = scale(startDatum.xValue0, preData.scales.x);
  const startY = scale(startDatum.yValue0, preData.scales.y);
  const endX = scale(endDatum.xValue1, preData.scales.x);
  const endY = scale(endDatum.yValue1, preData.scales.y);
  let altSpan = postData.data[postSpanIndices.datumIndex].span;
  altSpan = rescaleSpan(altSpan, { x: startX, y: startY }, { x: endX, y: endY });
  altSpan = clipSpanX(altSpan, x0, x1);
  return altSpan;
}
function appendSpanPhases(newData, oldData, collapseMode, axisValues, xValue0Index, newAxisIndices, oldAxisIndices, range3, out) {
  const xValue1Index = xValue0Index + 1;
  const oldIndices = oldAxisIndices.find((i) => i.xValue0Index <= xValue0Index && i.xValue1Index >= xValue1Index);
  const newIndices = newAxisIndices.find((i) => i.xValue0Index <= xValue0Index && i.xValue1Index >= xValue1Index);
  const oldZeroData = oldData.zeroData;
  const newZeroData = newData.zeroData;
  if (oldIndices == null && newIndices != null) {
    addSpan(newData, collapseMode, newAxisIndices, newIndices, oldZeroData, range3, out);
    return;
  } else if (oldIndices != null && newIndices == null) {
    removeSpan(oldData, collapseMode, oldAxisIndices, oldIndices, newZeroData, range3, out);
    return;
  } else if (oldIndices == null || newIndices == null) {
    return;
  }
  let ordering;
  if (oldIndices.xValue0Index === newIndices.xValue0Index && oldIndices.xValue1Index === newIndices.xValue1Index) {
    ordering = 0;
  } else if (oldIndices.xValue0Index <= newIndices.xValue0Index && oldIndices.xValue1Index >= newIndices.xValue1Index) {
    ordering = -1;
  } else if (oldIndices.xValue0Index >= newIndices.xValue0Index && oldIndices.xValue1Index <= newIndices.xValue1Index) {
    ordering = 1;
  } else {
    ordering = 0;
  }
  const oldSpanDatum = oldData.data[oldIndices.datumIndex];
  const clippedOldSpanOldScale = clipSpan(oldSpanDatum.span, xValue0Index, oldIndices);
  const newSpanDatum = newData.data[newIndices.datumIndex];
  const clippedNewSpanNewScale = clipSpan(newSpanDatum.span, xValue0Index, newIndices);
  if (ordering === 1) {
    const clippedPostRemoveOldSpanOldScale = alignSpanToContainingSpan(
      clippedOldSpanOldScale,
      axisValues,
      oldData,
      newData,
      newIndices
    );
    if (clippedPostRemoveOldSpanOldScale != null) {
      out.removed.push({ from: clippedOldSpanOldScale, to: clippedPostRemoveOldSpanOldScale });
      out.moved.push({ from: clippedPostRemoveOldSpanOldScale, to: clippedNewSpanNewScale });
      out.added.push({ from: clippedNewSpanNewScale, to: clippedNewSpanNewScale });
    } else {
      removeSpan(oldData, collapseMode, oldAxisIndices, oldIndices, newZeroData, range3, out);
    }
  } else if (ordering === -1) {
    const clippedPreAddedNewSpanNewScale = alignSpanToContainingSpan(
      clippedNewSpanNewScale,
      axisValues,
      newData,
      oldData,
      oldIndices
    );
    if (clippedPreAddedNewSpanNewScale != null) {
      out.removed.push({ from: clippedOldSpanOldScale, to: clippedOldSpanOldScale });
      out.moved.push({ from: clippedOldSpanOldScale, to: clippedPreAddedNewSpanNewScale });
      out.added.push({ from: clippedPreAddedNewSpanNewScale, to: clippedNewSpanNewScale });
    } else {
      addSpan(newData, collapseMode, newAxisIndices, newIndices, oldZeroData, range3, out);
    }
  } else {
    out.removed.push({ from: clippedOldSpanOldScale, to: clippedOldSpanOldScale });
    out.moved.push({ from: clippedOldSpanOldScale, to: clippedNewSpanNewScale });
    out.added.push({ from: clippedNewSpanNewScale, to: clippedNewSpanNewScale });
  }
}
function phaseAnimation(axisContext, newData, oldData, collapseMode) {
  const out = {
    removed: [],
    moved: [],
    added: []
  };
  const { axisValues, oldDataAxisIndices, newDataAxisIndices } = axisContext;
  const range3 = {
    xValue0Index: Math.max(
      oldDataAxisIndices.at(0)?.xValue0Index ?? -Infinity,
      newDataAxisIndices.at(0)?.xValue0Index ?? -Infinity
    ),
    xValue1Index: Math.min(
      oldDataAxisIndices.at(-1)?.xValue1Index ?? Infinity,
      newDataAxisIndices.at(-1)?.xValue1Index ?? Infinity
    )
  };
  for (let xValue0Index = 0; xValue0Index < axisValues.length - 1; xValue0Index += 1) {
    appendSpanPhases(
      newData,
      oldData,
      collapseMode,
      axisValues,
      xValue0Index,
      newDataAxisIndices,
      oldDataAxisIndices,
      range3,
      out
    );
  }
  return out;
}
function resetSpan(data, spanDatum, collapseMode) {
  const { span } = spanDatum;
  switch (collapseMode) {
    case 0 /* Zero */:
      return zeroDataSpan(spanDatum, data.zeroData) ?? axisZeroSpan(span, data);
    case 1 /* Split */:
      return collapseSpanToMidpoint(span);
  }
}
function resetAnimation(newData, oldData, collapseMode) {
  const added = [];
  const removed = [];
  for (const oldSpanDatum of oldData.data) {
    const oldSpan = oldSpanDatum.span;
    const collapsedSpan = resetSpan(oldData, oldSpanDatum, collapseMode);
    removed.push({ from: oldSpan, to: collapsedSpan });
  }
  for (const newSpanDatum of newData.data) {
    const newSpan = newSpanDatum.span;
    const collapsedSpan = resetSpan(newData, newSpanDatum, collapseMode);
    added.push({ from: collapsedSpan, to: newSpan });
  }
  return {
    removed,
    moved: [],
    added
  };
}
function pairUpSpans(newData, oldData, collapseMode) {
  if (!validateCategorySorting(newData, oldData))
    return;
  const axisContext = spanAxisContext(newData, oldData);
  return axisContext == null ? resetAnimation(newData, oldData, collapseMode) : phaseAnimation(axisContext, newData, oldData, collapseMode);
}

// packages/ag-charts-community/src/chart/series/cartesian/scaling.ts
var import_ag_charts_core126 = require("ag-charts-core");
function isContinuousScaling(scaling) {
  return scaling.type === "continuous" || scaling.type === "log";
}
function isCategoryScaling(scaling) {
  return scaling.type === "category";
}
function areScalingEqual(a, b) {
  if (a === void 0 || b === void 0) {
    return a !== void 0 || b !== void 0;
  }
  if (isContinuousScaling(a) && isContinuousScaling(b)) {
    return a.type === b.type && (0, import_ag_charts_core126.arraysEqual)(a.domain, b.domain) && (0, import_ag_charts_core126.arraysEqual)(a.range, b.range);
  }
  if (isCategoryScaling(a) && isCategoryScaling(b)) {
    return a.inset === b.inset && a.step === b.step && (0, import_ag_charts_core126.arraysEqual)(a.domain, b.domain);
  }
  return false;
}
function isScaleValid(scale2) {
  if (scale2 == null)
    return false;
  if (scale2.type === "category")
    return scale2.domain.every((v) => v != null);
  return scale2.domain.every((v) => Number.isFinite(v) || v instanceof Date) && scale2.range.every((v) => Number.isFinite(v));
}

// packages/ag-charts-community/src/chart/series/cartesian/lineUtil.ts
function interpolatePoints(points, interpolation) {
  let spans;
  const pointsIter = points.map((point) => point.point);
  switch (interpolation.type) {
    case "linear":
      spans = linearPoints(pointsIter);
      break;
    case "smooth":
      spans = smoothPoints(pointsIter, interpolation.tension);
      break;
    case "step":
      spans = stepPoints(pointsIter, interpolation.position);
      break;
  }
  return spans.map((span, i) => ({
    span,
    xValue0: points[i].xDatum,
    yValue0: points[i].yDatum,
    xValue1: points[i + 1].xDatum,
    yValue1: points[i + 1].yDatum
  }));
}
function pointsEq(a, b, delta3 = 1e-3) {
  return Math.abs(a.x - b.x) < delta3 && Math.abs(a.y - b.y) < delta3;
}
function plotLinePathStroke({ path }, spans) {
  let lastPoint;
  for (const { span } of spans) {
    const [start2, end2] = spanRange(span);
    const join = lastPoint != null && pointsEq(lastPoint, start2) ? 1 /* LineTo */ : 0 /* MoveTo */;
    plotSpan(path, span, join, false);
    lastPoint = end2;
  }
}
function plotInterpolatedLinePathStroke(ratio8, path, spans) {
  let lastPoint;
  for (const span of spans) {
    const [start2, end2] = interpolatedSpanRange(span.from, span.to, ratio8);
    const join = lastPoint != null && pointsEq(lastPoint, start2) ? 1 /* LineTo */ : 0 /* MoveTo */;
    plotInterpolatedSpans(path.path, span.from, span.to, ratio8, join, false);
    lastPoint = end2;
  }
}
function prepareLinePathStrokeAnimationFns(status, spans, visibleToggleMode) {
  const removePhaseFn = (ratio8, path) => plotInterpolatedLinePathStroke(ratio8, path, spans.removed);
  const updatePhaseFn = (ratio8, path) => plotInterpolatedLinePathStroke(ratio8, path, spans.moved);
  const addPhaseFn = (ratio8, path) => plotInterpolatedLinePathStroke(ratio8, path, spans.added);
  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);
  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };
}
function prepareLinePathPropertyAnimation(status, visibleToggleMode) {
  const phase = visibleToggleMode === "none" ? "updated" : status;
  const result = {
    fromFn: (_path) => {
      let mixin;
      if (status === "removed") {
        mixin = { finish: { visible: false } };
      } else if (status === "added") {
        mixin = { start: { visible: true } };
      } else {
        mixin = {};
      }
      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase], ...mixin };
    },
    toFn: (_path) => {
      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase] };
    }
  };
  if (visibleToggleMode === "fade") {
    return {
      fromFn: (path) => {
        const opacity = status === "added" ? 0 : path.opacity;
        return { opacity, ...result.fromFn(path) };
      },
      toFn: (path) => {
        const opacity = status === "removed" ? 0 : 1;
        return { opacity, ...result.toFn(path) };
      }
    };
  }
  return result;
}
function prepareLinePathAnimation(newData, oldData, diff2) {
  const isCategoryBased = newData.scales.x?.type === "category";
  const wasCategoryBased = oldData.scales.x?.type === "category";
  if (isCategoryBased !== wasCategoryBased || !isScaleValid(newData.scales.x) || !isScaleValid(oldData.scales.x)) {
    return;
  }
  if (newData.strokeData == null || oldData.strokeData == null) {
    return;
  }
  let status = "updated";
  if (oldData.visible && !newData.visible) {
    status = "removed";
  } else if (!oldData.visible && newData.visible) {
    status = "added";
  }
  const strokeSpans = pairUpSpans(
    { scales: newData.scales, data: newData.strokeData.spans },
    { scales: oldData.scales, data: oldData.strokeData.spans },
    1 /* Split */
  );
  if (strokeSpans == null)
    return;
  const stroke2 = prepareLinePathStrokeAnimationFns(status, strokeSpans, "fade");
  const hasMotion = (diff2?.changed ?? true) || !areScalingEqual(newData.scales.x, oldData.scales.x) || !areScalingEqual(newData.scales.y, oldData.scales.y) || status !== "updated";
  return { status, stroke: stroke2, hasMotion };
}

// packages/ag-charts-community/src/chart/series/cartesian/areaUtil.ts
function plotAreaPathFill({ path }, { spans, phantomSpans }) {
  for (let i = 0; i < spans.length; i += 1) {
    const { span } = spans[i];
    const phantomSpan = phantomSpans[i].span;
    plotSpan(path, span, 0 /* MoveTo */, false);
    plotSpan(path, phantomSpan, 1 /* LineTo */, true);
    path.closePath();
  }
}
function plotInterpolatedAreaSeriesFillSpans(ratio8, { path }, spans, fillPhantomSpans) {
  for (let i = 0; i < spans.length; i += 1) {
    const span = spans[i];
    const reversedPhantomSpan = fillPhantomSpans[i];
    plotInterpolatedSpans(path, span.from, span.to, ratio8, 0 /* MoveTo */, false);
    plotInterpolatedSpans(path, reversedPhantomSpan.from, reversedPhantomSpan.to, ratio8, 1 /* LineTo */, true);
    path.closePath();
  }
}
function prepareAreaFillAnimationFns(status, spans, fillPhantomSpans, visibleToggleMode) {
  const removePhaseFn = (ratio8, path) => plotInterpolatedAreaSeriesFillSpans(ratio8, path, spans.removed, fillPhantomSpans.removed);
  const updatePhaseFn = (ratio8, path) => plotInterpolatedAreaSeriesFillSpans(ratio8, path, spans.moved, fillPhantomSpans.moved);
  const addPhaseFn = (ratio8, path) => plotInterpolatedAreaSeriesFillSpans(ratio8, path, spans.added, fillPhantomSpans.added);
  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);
  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };
}
function prepareAreaPathAnimation(newData, oldData) {
  const isCategoryBased = newData.scales.x?.type === "category";
  const wasCategoryBased = oldData.scales.x?.type === "category";
  if (isCategoryBased !== wasCategoryBased || !isScaleValid(newData.scales.x) || !isScaleValid(oldData.scales.x)) {
    return;
  }
  let status = "updated";
  if (oldData.visible && !newData.visible) {
    status = "removed";
  } else if (!oldData.visible && newData.visible) {
    status = "added";
  }
  const fillSpans = pairUpSpans(
    { scales: newData.scales, data: newData.fillData.spans },
    { scales: oldData.scales, data: oldData.fillData.spans },
    0 /* Zero */
  );
  if (fillSpans == null)
    return;
  const fillPhantomSpans = pairUpSpans(
    { scales: newData.scales, data: newData.fillData.phantomSpans },
    { scales: oldData.scales, data: oldData.fillData.phantomSpans },
    0 /* Zero */
  );
  if (fillPhantomSpans == null)
    return;
  const strokeSpans = pairUpSpans(
    {
      scales: newData.scales,
      data: newData.strokeData.spans,
      zeroData: newData.fillData.phantomSpans
    },
    {
      scales: oldData.scales,
      data: oldData.strokeData.spans,
      zeroData: oldData.fillData.phantomSpans
    },
    0 /* Zero */
  );
  if (strokeSpans == null)
    return;
  const fadeMode = "none";
  const fill = prepareAreaFillAnimationFns(status, fillSpans, fillPhantomSpans, fadeMode);
  const stroke2 = prepareLinePathStrokeAnimationFns(status, strokeSpans, fadeMode);
  return { status, fill, stroke: stroke2 };
}

// packages/ag-charts-community/src/chart/series/cartesian/markerUtil.ts
var import_ag_charts_core127 = require("ag-charts-core");
function markerFadeInAnimation({ id }, animationManager, status, ...markerSelections) {
  const params = { phase: status ? NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] : "trailing" };
  staticFromToMotion(id, "markers", animationManager, markerSelections, { opacity: 0 }, { opacity: 1 }, params);
  markerSelections.forEach((s) => s.cleanup());
}
function markerScaleInAnimation({ id }, animationManager, ...markerSelections) {
  staticFromToMotion(
    id,
    "markers",
    animationManager,
    markerSelections,
    { scalingX: 0, scalingY: 0 },
    { scalingX: 1, scalingY: 1 },
    { phase: "initial" }
  );
  markerSelections.forEach((s) => s.cleanup());
}
function markerSwipeScaleInAnimation({ id, nodeDataDependencies }, animationManager, ...markerSelections) {
  const seriesWidth = nodeDataDependencies.seriesRectWidth;
  const fromFn = (_, datum) => {
    const x = datum.midPoint?.x ?? seriesWidth;
    let delay = (0, import_ag_charts_core127.clamp)(0, inverseEaseOut(x / seriesWidth), 1);
    if (isNaN(delay)) {
      delay = 0;
    }
    return { scalingX: 0, scalingY: 0, delay, duration: QUICK_TRANSITION, phase: "initial" };
  };
  const toFn = () => {
    return { scalingX: 1, scalingY: 1 };
  };
  fromToMotion(id, "markers", animationManager, markerSelections, { fromFn, toFn });
}
function resetMarkerFn(_node) {
  return { opacity: 1, scalingX: 1, scalingY: 1 };
}
function resetMarkerPositionFn(_node, datum) {
  return {
    x: datum.point?.x ?? NaN,
    y: datum.point?.y ?? NaN,
    scalingCenterX: datum.point?.x ?? NaN,
    scalingCenterY: datum.point?.y ?? NaN
  };
}
function computeMarkerFocusBounds(series, { datumIndex }) {
  const nodeData = series.getNodeData();
  if (nodeData === void 0)
    return void 0;
  const datum = nodeData[datumIndex];
  const { point } = datum ?? {};
  if (datum == null || point == null)
    return void 0;
  const size = 4 + (point.focusSize ?? series.getFormattedMarkerStyle(datum).size);
  const radius = size / 2;
  const x = datum.point.x - radius;
  const y = datum.point.y - radius;
  return Transformable.toCanvas(series.contentGroup, new BBox(x, y, size, size));
}

// packages/ag-charts-community/src/chart/series/cartesian/pathUtil.ts
function pathSwipeInAnimation({ id, visible, nodeDataDependencies }, animationManager, ...paths) {
  const { seriesRectWidth: width2, seriesRectHeight: height2 } = nodeDataDependencies;
  staticFromToMotion(
    id,
    "path_properties",
    animationManager,
    paths,
    { clipX: 0 },
    { clipX: width2 },
    {
      phase: "initial",
      start: { clip: true, clipY: height2, visible },
      finish: { clip: false, visible }
    }
  );
}
function pathFadeInAnimation({ id }, subId, animationManager, phase = "add", ...selection) {
  staticFromToMotion(id, subId, animationManager, selection, { opacity: 0 }, { opacity: 1 }, { phase });
}
function buildResetPathFn(opts) {
  return (_node) => ({
    visible: opts.getVisible(),
    opacity: opts.getOpacity(),
    clipScalingX: 1,
    clip: false
  });
}
function updateClipPath({ nodeDataDependencies }, path) {
  const toFinite = (value) => isFinite(value) ? value : 0;
  path.clipX = toFinite(nodeDataDependencies.seriesRectWidth);
  path.clipY = toFinite(nodeDataDependencies.seriesRectHeight);
}

// packages/ag-charts-community/src/chart/series/cartesian/areaSeries.ts
var CROSS_FILTER_AREA_FILL_OPACITY_FACTOR = 0.125;
var CROSS_FILTER_AREA_STROKE_OPACITY_FACTOR = 0.25;
var AreaSeries = class extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
      categoryKey: "xValue",
      pathsPerSeries: ["fill", "stroke"],
      pathsZIndexSubOrderOffset: [0, 1e3],
      hasMarkers: true,
      markerSelectionGarbageCollection: false,
      pickModes: [2 /* AXIS_ALIGNED */, 0 /* EXACT_SHAPE_MATCH */],
      animationResetFns: {
        path: buildResetPathFn({ getVisible: () => this.visible, getOpacity: () => this.getOpacity() }),
        label: resetLabelFn,
        marker: (node, datum) => ({ ...resetMarkerFn(node), ...resetMarkerPositionFn(node, datum) })
      },
      clipFocusBox: false
    });
    this.properties = new AreaSeriesProperties();
    this.connectsToYAxis = true;
    this.backgroundGroup = new Group({
      name: `${this.id}-background`,
      zIndex: 0 /* BACKGROUND */
    });
    this._isStacked = void 0;
  }
  get pickModeAxis() {
    return "main";
  }
  renderToOffscreenCanvas() {
    return super.renderToOffscreenCanvas() || this.contextNodeData != null && (this.contextNodeData.fillData.spans.length > RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD || this.contextNodeData.strokeData.spans.length > RENDER_TO_OFFSCREEN_CANVAS_THRESHOLD);
  }
  attachSeries(seriesContentNode, seriesNode, annotationNode) {
    super.attachSeries(seriesContentNode, seriesNode, annotationNode);
    seriesContentNode.appendChild(this.backgroundGroup);
  }
  detachSeries(seriesContentNode, seriesNode, annotationNode) {
    super.detachSeries(seriesContentNode, seriesNode, annotationNode);
    seriesContentNode?.removeChild(this.backgroundGroup);
  }
  attachPaths([fill, stroke2]) {
    this.backgroundGroup.appendChild(fill);
    this.contentGroup.appendChild(stroke2);
    stroke2.zIndex = -1;
  }
  detachPaths([fill, stroke2]) {
    this.backgroundGroup.removeChild(fill);
    this.contentGroup.removeChild(stroke2);
  }
  isStacked() {
    const stackCount = this.seriesGrouping?.stackCount ?? 1;
    return stackCount > 1;
  }
  setSeriesIndex(index) {
    const isStacked = this.isStacked();
    if (!super.setSeriesIndex(index) && this._isStacked === isStacked)
      return false;
    this._isStacked = isStacked;
    if (isStacked) {
      this.backgroundGroup.zIndex = [0 /* BACKGROUND */, index];
      this.contentGroup.zIndex = [1 /* ANY_CONTENT */, index, 0 /* FOREGROUND */];
    } else {
      this.backgroundGroup.zIndex = [1 /* ANY_CONTENT */, index, 0 /* FOREGROUND */, 0];
      this.contentGroup.zIndex = [1 /* ANY_CONTENT */, index, 0 /* FOREGROUND */, 1];
    }
    return true;
  }
  async processData(dataController) {
    if (this.data == null)
      return;
    const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 1 } = {} } = this;
    const { xKey, yKey, yFilterKey, connectMissingData, normalizedTo } = this.properties;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const xScale = this.axes["x" /* X */]?.scale;
    const yScale = this.axes["y" /* Y */]?.scale;
    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const idMap = {
      value: `area-stack-${groupIndex}-yValue`,
      values: `area-stack-${groupIndex}-yValues`,
      stack: `area-stack-${groupIndex}-yValue-stack`,
      marker: `area-stack-${groupIndex}-yValues-marker`
    };
    const extraProps = [];
    if ((0, import_ag_charts_core128.isDefined)(normalizedTo)) {
      extraProps.push(normaliseGroupTo(Object.values(idMap), normalizedTo));
    }
    if (animationEnabled) {
      extraProps.push(animationValidation());
    }
    const common = { invalidValue: null };
    if (((0, import_ag_charts_core128.isDefined)(normalizedTo) || connectMissingData) && stackCount > 1) {
      common.invalidValue = 0;
    }
    if (!visible) {
      common.forceValue = 0;
    }
    await this.requestDataModel(dataController, data, {
      props: [
        keyProperty(xKey, xScaleType, { id: "xValue" }),
        valueProperty(yKey, yScaleType, { id: `yValueRaw`, ...common }),
        ...yFilterKey != null ? [valueProperty(yFilterKey, yScaleType, { id: "yFilterRaw" })] : [],
        ...groupStackValueProperty(yKey, yScaleType, { id: `yValueStack`, ...common, groupId: idMap.stack }),
        valueProperty(yKey, yScaleType, { id: `yValue`, ...common, groupId: idMap.value }),
        ...groupAccumulativeValueProperty(
          yKey,
          "window",
          "current",
          { id: `yValueEnd`, ...common, groupId: idMap.values },
          yScaleType
        ),
        ...groupAccumulativeValueProperty(
          yKey,
          "normal",
          "current",
          { id: `yValueCumulative`, ...common, groupId: idMap.marker },
          yScaleType
        ),
        ...extraProps
      ],
      groupByKeys: true,
      groupByData: false
    });
    this.animationState.transition("updateData");
  }
  xCoordinateRange(xValue, pixelSize) {
    const { marker } = this.properties;
    const x = this.axes["x" /* X */].scale.convert(xValue);
    const r = marker.enabled ? 0.5 * marker.size * pixelSize : 0;
    return [x - r, x + r];
  }
  yCoordinateRange(yValues, pixelSize) {
    const { marker } = this.properties;
    const y = this.axes["y" /* Y */].scale.convert(yValues[0]);
    const r = marker.enabled ? 0.5 * marker.size * pixelSize : 0;
    return [y - r, y + r];
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel, axes } = this;
    if (!processedData || !dataModel)
      return [];
    const yAxis = axes["y" /* Y */];
    if (direction === "x" /* X */) {
      const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
      const keys = dataModel.getDomain(this, `xValue`, "key", processedData);
      if (keyDef?.def.type === "key" && keyDef.def.valueType === "category") {
        return keys;
      }
      return fixNumericExtent(extent(keys));
    }
    const yExtent = this.domainForClippedRange("y" /* Y */, ["yValueCumulative"], "xValue", true);
    if (yAxis instanceof LogAxis || yAxis instanceof TimeAxis) {
      return fixNumericExtent(yExtent);
    } else {
      const fixedYExtent = Number.isFinite(yExtent[1] - yExtent[0]) ? [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]] : [];
      return fixNumericExtent(fixedYExtent);
    }
  }
  getSeriesRange(_direction, visibleRange) {
    const [y0, y1] = this.domainForVisibleRange(
      "y" /* Y */,
      ["yValueCumulative"],
      "xValue",
      visibleRange,
      true
    );
    return [Math.min(y0, 0), Math.max(y1, 0)];
  }
  getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {
    return this.countVisibleItems("xValue", ["yValueCumulative"], xVisibleRange, yVisibleRange, minVisibleItems);
  }
  createNodeData() {
    const { axes, data, processedData, dataModel } = this;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!xAxis || !yAxis || !data || !dataModel || processedData?.type !== "grouped")
      return;
    const {
      yKey,
      xKey,
      yFilterKey,
      marker,
      label,
      fill: seriesFill,
      stroke: seriesStroke,
      connectMissingData,
      interpolation
    } = this.properties;
    const { scale: xScale } = xAxis;
    const { scale: yScale } = yAxis;
    const { isContinuousY } = this.getScaleInformation({ xScale, yScale });
    const xOffset = (xScale.bandwidth ?? 0) / 2;
    const xValues = dataModel.resolveKeysById(this, "xValue", processedData);
    const yEndValues = dataModel.resolveColumnById(this, `yValueEnd`, processedData);
    const yRawValues = dataModel.resolveColumnById(this, `yValueRaw`, processedData);
    const yCumulativeValues = dataModel.resolveColumnById(this, `yValueCumulative`, processedData);
    const yFilterValues = yFilterKey != null ? dataModel.resolveColumnById(this, "yFilterRaw", processedData) : void 0;
    const yStackValues = dataModel.resolveColumnById(this, "yValueStack", processedData);
    const createMarkerCoordinate = (xDatum, yEnd, rawYDatum) => {
      let currY;
      if ((0, import_ag_charts_core128.isDefined)(this.properties.normalizedTo) ? isContinuousY && isContinuous(rawYDatum) : !isNaN(rawYDatum)) {
        currY = yEnd;
      }
      return {
        x: xScale.convert(xDatum) + xOffset,
        y: yScale.convert(currY),
        size: marker.size
      };
    };
    const labelData = [];
    const markerData = [];
    const { visibleSameStackCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);
    let crossFiltering = false;
    const { dataSources } = processedData;
    const rawData = dataSources.get(this.id) ?? [];
    for (const { datumIndex } of dataModel.forEachGroupDatum(this, processedData)) {
      const xDatum = xValues[datumIndex];
      if (xDatum == null)
        return;
      const seriesDatum = rawData[datumIndex];
      const yDatum = yRawValues[datumIndex];
      const yValueCumulative = yCumulativeValues[datumIndex];
      const yValueEnd = yEndValues[datumIndex];
      const validPoint = Number.isFinite(yDatum);
      const point = createMarkerCoordinate(xDatum, +yValueCumulative, yDatum);
      const selected = yFilterValues != null ? yFilterValues[datumIndex] === yDatum : void 0;
      if (selected === false) {
        crossFiltering = true;
      }
      if (validPoint && marker) {
        markerData.push({
          series: this,
          itemId: yKey,
          datum: seriesDatum,
          datumIndex,
          midPoint: { x: point.x, y: point.y },
          cumulativeValue: yValueEnd,
          yValue: yDatum,
          xValue: xDatum,
          yKey,
          xKey,
          point,
          fill: marker.fill ?? seriesFill,
          stroke: marker.stroke ?? seriesStroke,
          strokeWidth: marker.strokeWidth ?? this.getStrokeWidth(this.properties.strokeWidth),
          selected
        });
      }
      if (validPoint && label) {
        const labelText = this.getLabelText(label, {
          value: yDatum,
          datum: seriesDatum,
          xKey,
          yKey,
          xName: this.properties.xName,
          yName: this.properties.yName
        });
        labelData.push({
          series: this,
          itemId: yKey,
          datum: seriesDatum,
          datumIndex,
          x: point.x,
          y: point.y,
          labelText
        });
      }
    }
    const spansForPoints = (points) => {
      return points.flatMap((p) => {
        return Array.isArray(p) ? interpolatePoints(p, interpolation) : new Array(p.skip).fill(null);
      });
    };
    const createPoint = (xDatum, yDatum) => ({
      point: {
        x: xScale.convert(xDatum) + xOffset,
        y: yScale.convert(yDatum)
      },
      xDatum,
      yDatum
    });
    const getSeriesSpans = (index) => {
      const points = [];
      for (const {
        datumIndexes: [pIdx, datumIndex, nIndx]
      } of dataModel.forEachGroupDatumTuple(this, processedData)) {
        const xDatum = xValues[datumIndex];
        const yValueStack = yStackValues[datumIndex];
        const yDatum = yValueStack[index];
        const yDatumIsFinite = Number.isFinite(yDatum);
        if (connectMissingData && !yDatumIsFinite)
          continue;
        const lastYValueStack = pIdx != null ? yStackValues[pIdx] : void 0;
        const nextYValueStack = nIndx != null ? yStackValues[nIndx] : void 0;
        let yValueEndBackwards = 0;
        let yValueEndForwards = 0;
        for (let j = 0; j <= index; j += 1) {
          const value = yValueStack[j];
          if (Number.isFinite(value)) {
            const lastWasFinite = lastYValueStack == null || Number.isFinite(lastYValueStack[j]);
            const nextWasFinite = nextYValueStack == null || Number.isFinite(nextYValueStack[j]);
            if (lastWasFinite) {
              yValueEndBackwards += value;
            }
            if (nextWasFinite) {
              yValueEndForwards += value;
            }
          }
        }
        const currentPoints = points[points.length - 1];
        if (!connectMissingData && (yValueEndBackwards !== yValueEndForwards || !yDatumIsFinite)) {
          if (!yDatumIsFinite && Array.isArray(currentPoints) && currentPoints.length === 1) {
            points[points.length - 1] = { skip: 1 };
          } else {
            const pointBackwards = createPoint(xDatum, yValueEndBackwards);
            const pointForwards = createPoint(xDatum, yValueEndForwards);
            if (Array.isArray(currentPoints)) {
              currentPoints.push(pointBackwards);
            } else if (currentPoints != null) {
              currentPoints.skip += 1;
            }
            points.push(yDatumIsFinite ? [pointForwards] : { skip: 0 });
          }
        } else {
          const yValue = connectMissingData ? yDatum : Math.max(yValueEndBackwards, yValueEndForwards);
          const point = createPoint(xDatum, yValue);
          if (Array.isArray(currentPoints)) {
            currentPoints.push(point);
          } else if (currentPoints != null) {
            currentPoints.skip += 1;
            points.push([point]);
          } else {
            points.push([point]);
          }
        }
      }
      return spansForPoints(points);
    };
    const stackIndex = this.seriesGrouping?.stackIndex ?? 0;
    const getAxisSpans = () => {
      const yValueZeroPoints = Array.from(dataModel.forEachGroupDatum(this, processedData), ({ datumIndex }) => {
        const xDatum = xValues[datumIndex];
        const yValueStack = yStackValues[datumIndex];
        const yDatum = yValueStack[stackIndex];
        if (connectMissingData && !Number.isFinite(yDatum))
          return;
        return createPoint(xDatum, 0);
      }).filter((x) => x != null);
      return interpolatePoints(yValueZeroPoints, interpolation);
    };
    const currentSeriesSpans = getSeriesSpans(stackIndex);
    const phantomSpans = currentSeriesSpans.map(() => null);
    for (let j = stackIndex - 1; j >= -1; j -= 1) {
      let spans;
      for (let i = 0; i < phantomSpans.length; i += 1) {
        if (phantomSpans[i] != null)
          continue;
        spans ?? (spans = j !== -1 ? getSeriesSpans(j) : getAxisSpans());
        phantomSpans[i] = spans[i];
      }
    }
    const fillSpans = currentSeriesSpans.map((span, index) => span ?? phantomSpans[index]);
    const strokeSpans = currentSeriesSpans.filter((span) => span != null);
    const context = {
      itemId: yKey,
      fillData: { itemId: yKey, spans: fillSpans, phantomSpans },
      strokeData: { itemId: yKey, spans: strokeSpans },
      labelData,
      nodeData: markerData,
      scales: this.calculateScaling(),
      visible: this.visible,
      stackVisible: visibleSameStackCount > 0,
      crossFiltering
    };
    return context;
  }
  isPathOrSelectionDirty() {
    return this.properties.marker.isDirty();
  }
  updatePathNodes(opts) {
    const { opacity, visible, animationEnabled } = opts;
    const [fill, stroke2] = opts.paths;
    const crossFiltering = this.contextNodeData?.crossFiltering === true;
    const strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);
    stroke2.setProperties({
      fill: void 0,
      lineCap: "round",
      lineJoin: "round",
      pointerEvents: 1 /* None */,
      stroke: this.properties.stroke,
      strokeWidth,
      strokeOpacity: this.properties.strokeOpacity * (crossFiltering ? CROSS_FILTER_AREA_STROKE_OPACITY_FACTOR : 1),
      lineDash: this.properties.lineDash,
      lineDashOffset: this.properties.lineDashOffset,
      opacity,
      visible: visible || animationEnabled
    });
    const seriesFill = getShapeFill(
      this.properties.fill,
      this.properties.fillGradientDefaults,
      this.properties.fillPatternDefaults,
      this.properties.fillImageDefaults
    );
    applyShapeStyle(
      fill,
      {
        fill: seriesFill,
        stroke: void 0,
        fillOpacity: this.properties.fillOpacity * (crossFiltering ? CROSS_FILTER_AREA_FILL_OPACITY_FACTOR : 1)
      },
      void 0,
      this.getShapeFillBBox()
    );
    fill.setProperties({
      lineJoin: "round",
      pointerEvents: 1 /* None */,
      fillShadow: this.properties.shadow,
      opacity,
      visible: visible || animationEnabled
    });
    updateClipPath(this, stroke2);
    updateClipPath(this, fill);
  }
  updatePaths(opts) {
    this.updateAreaPaths(opts.paths, opts.contextData);
  }
  updateAreaPaths(paths, contextData) {
    for (const path of paths) {
      path.visible = contextData.visible;
    }
    if (contextData.visible) {
      this.updateFillPath(paths, contextData);
      this.updateStrokePath(paths, contextData);
    } else {
      for (const path of paths) {
        path.path.clear();
        path.markDirty("AreaSeries");
      }
    }
  }
  updateFillPath(paths, contextData) {
    const [fill] = paths;
    fill.path.clear();
    plotAreaPathFill(fill, contextData.fillData);
    fill.markDirty("AreaSeries");
  }
  updateStrokePath(paths, contextData) {
    const { spans } = contextData.strokeData;
    const [, stroke2] = paths;
    stroke2.path.clear();
    plotLinePathStroke(stroke2, spans);
    stroke2.markDirty("AreaSeries");
  }
  updateMarkerSelection(opts) {
    const { nodeData, markerSelection } = opts;
    const markersEnabled = this.properties.marker.enabled || this.contextNodeData?.crossFiltering === true;
    if (this.properties.marker.isDirty()) {
      markerSelection.clear();
      markerSelection.cleanup();
    }
    return markerSelection.update(markersEnabled ? nodeData : []);
  }
  updateMarkerNodes(opts) {
    const { markerSelection, isHighlight: highlighted } = opts;
    const { xKey, yKey, marker, fill, stroke: stroke2, strokeWidth, fillOpacity, strokeOpacity, highlightStyle } = this.properties;
    const xDomain = this.getSeriesDomain("x" /* X */);
    const yDomain = this.getSeriesDomain("y" /* Y */);
    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle(), {
      fill,
      stroke: stroke2,
      strokeWidth,
      fillOpacity,
      strokeOpacity
    });
    const fillBBox = this.getShapeFillBBox();
    markerSelection.each((node, datum) => {
      this.updateMarkerStyle(
        marker,
        node,
        datum.datum,
        datum.point,
        datumStylerProperties(datum, xKey, yKey, xDomain, yDomain),
        highlighted,
        baseStyle,
        fillBBox,
        { selected: datum.selected }
      );
    });
    if (!highlighted) {
      this.properties.marker.markClean();
    }
  }
  updateLabelSelection(opts) {
    const { labelData, labelSelection } = opts;
    return labelSelection.update(labelData);
  }
  updateLabelNodes(opts) {
    const { labelSelection } = opts;
    const { enabled: labelEnabled, fontStyle, fontWeight, fontSize, fontFamily, color: color7 } = this.properties.label;
    labelSelection.each((text, datum) => {
      const { x, y, labelText } = datum;
      if (labelText && labelEnabled && this.visible) {
        text.fontStyle = fontStyle;
        text.fontWeight = fontWeight;
        text.fontSize = fontSize;
        text.fontFamily = fontFamily;
        text.textAlign = "center";
        text.textBaseline = "bottom";
        text.text = labelText;
        text.x = x;
        text.y = y - 10;
        text.fill = color7;
        text.visible = true;
      } else {
        text.visible = false;
      }
    });
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, axes, properties } = this;
    const { xKey, xName, yKey, yName, tooltip, marker } = properties;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!dataModel || !processedData || !xAxis || !yAxis)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const xValue = dataModel.resolveKeysById(this, `xValue`, processedData)[datumIndex];
    const yValue = dataModel.resolveColumnById(this, `yValueRaw`, processedData)[datumIndex];
    const { xDomain, yDomain } = this.cachedDatumCallback("domain", () => ({
      xDomain: this.getSeriesDomain("x" /* X */),
      yDomain: this.getSeriesDomain("y" /* Y */)
    }));
    if (xValue == null)
      return;
    const style = marker.getStyle();
    const nodeDatum = {
      datum,
      xValue,
      yValue
    };
    const activeStyle = this.getMarkerStyle(
      marker,
      datum,
      datumStylerProperties(nodeDatum, xKey, yKey, xDomain, yDomain),
      false,
      void 0,
      style
    );
    return this.formatTooltipWithContext(
      tooltip,
      {
        heading: xAxis.formatDatum(xValue),
        symbol: this.legendItemSymbol(),
        data: [{ label: yName, fallbackLabel: yKey, value: yAxis.formatDatum(yValue) }]
      },
      {
        seriesId,
        datum,
        title: yName,
        xKey,
        xName,
        yKey,
        yName,
        ...activeStyle,
        ...this.getModuleTooltipParams()
      }
    );
  }
  legendItemSymbol() {
    const {
      fill,
      stroke: stroke2,
      fillOpacity,
      strokeOpacity,
      strokeWidth,
      lineDash,
      marker,
      fillGradientDefaults,
      fillPatternDefaults,
      fillImageDefaults
    } = this.properties;
    const useAreaFill = !marker.enabled || marker.fill === void 0;
    const legendMarkerFill = useAreaFill ? getShapeFill(fill, fillGradientDefaults, fillPatternDefaults, fillImageDefaults) : getShapeFill(
      marker.fill,
      marker.fillGradientDefaults,
      marker.fillPatternDefaults,
      marker.fillImageDefaults
    );
    const markerStyle = this.getMarkerStyle(marker, void 0, void 0, false, void 0, {
      fill: legendMarkerFill,
      fillOpacity: useAreaFill ? fillOpacity : marker.fillOpacity
    });
    return {
      marker: {
        ...markerStyle,
        enabled: marker.enabled || strokeWidth <= 0
      },
      line: {
        stroke: stroke2,
        strokeOpacity,
        strokeWidth,
        lineDash
      }
    };
  }
  getLegendData(legendType) {
    if (legendType !== "category") {
      return [];
    }
    const {
      id: seriesId,
      ctx: { legendManager },
      visible
    } = this;
    const { yKey: itemId, yName, legendItemName, showInLegend } = this.properties;
    return [
      {
        legendType,
        id: seriesId,
        itemId,
        seriesId,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId }),
        label: {
          text: legendItemName ?? yName ?? itemId
        },
        symbol: this.legendItemSymbol(),
        legendItemName,
        hideInLegend: !showInLegend
      }
    ];
  }
  animateEmptyUpdateReady(animationData) {
    const { markerSelection, labelSelection, contextData, paths } = animationData;
    const { animationManager } = this.ctx;
    this.updateAreaPaths(paths, contextData);
    pathSwipeInAnimation(this, animationManager, ...paths);
    resetMotion([markerSelection], resetMarkerPositionFn);
    markerSwipeScaleInAnimation(this, animationManager, markerSelection);
    seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
  }
  animateReadyResize(animationData) {
    const { contextData, paths } = animationData;
    this.updateAreaPaths(paths, contextData);
    super.animateReadyResize(animationData);
  }
  animateWaitingUpdateReady(animationData) {
    const { animationManager } = this.ctx;
    const { markerSelection, labelSelection, contextData, paths, previousContextData } = animationData;
    const [fill, stroke2] = paths;
    if (fill == null && stroke2 == null)
      return;
    this.resetMarkerAnimation(animationData);
    this.resetLabelAnimation(animationData);
    const update = () => {
      this.resetPathAnimation(animationData);
      this.updateAreaPaths(paths, contextData);
    };
    const skip = () => {
      animationManager.skipCurrentBatch();
      update();
    };
    if (contextData == null || previousContextData == null) {
      update();
      markerFadeInAnimation(this, animationManager, "added", markerSelection);
      pathFadeInAnimation(this, "fill_path_properties", animationManager, "add", fill);
      pathFadeInAnimation(this, "stroke_path_properties", animationManager, "add", stroke2);
      seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
      return;
    }
    if (contextData.crossFiltering !== previousContextData.crossFiltering) {
      skip();
      return;
    }
    const fns = prepareAreaPathAnimation(contextData, previousContextData);
    if (fns === void 0) {
      skip();
      return;
    } else if (fns.status === "no-op") {
      return;
    }
    markerFadeInAnimation(this, animationManager, void 0, markerSelection);
    fromToMotion(this.id, "fill_path_properties", animationManager, [fill], fns.fill.pathProperties);
    pathMotion(this.id, "fill_path_update", animationManager, [fill], fns.fill.path);
    fromToMotion(this.id, "stroke_path_properties", animationManager, [stroke2], fns.stroke.pathProperties);
    pathMotion(this.id, "stroke_path_update", animationManager, [stroke2], fns.stroke.path);
    seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
    this.ctx.animationManager.animate({
      id: this.id,
      groupId: "reset_after_animation",
      phase: "trailing",
      from: {},
      to: {},
      onComplete: () => this.updateAreaPaths(paths, contextData)
    });
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  nodeFactory() {
    return new Group();
  }
  getFormattedMarkerStyle(datum) {
    const { xKey, yKey } = datum;
    const xDomain = this.getSeriesDomain("x" /* X */);
    const yDomain = this.getSeriesDomain("y" /* Y */);
    return this.getMarkerStyle(
      this.properties.marker,
      datum.datum,
      datumStylerProperties(datum, xKey, yKey, xDomain, yDomain),
      true
    );
  }
  computeFocusBounds(opts) {
    return computeMarkerFocusBounds(this, opts);
  }
};
AreaSeries.className = "AreaSeries";
AreaSeries.type = "area";

// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesModule.ts
var AreaSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "area",
  moduleFactory: (ctx) => new AreaSeries(ctx),
  stackable: true,
  tooltipDefaults: { range: "nearest" },
  defaultAxes: [
    {
      type: "number" /* NUMBER */,
      position: "left" /* LEFT */
    },
    {
      type: "category" /* CATEGORY */,
      position: "bottom" /* BOTTOM */
    }
  ],
  themeTemplate: {
    series: {
      nodeClickRange: "nearest",
      // @ts-expect-error deprecated type field fallback value
      tooltip: { position: { _seriesOverrideType: "node" } },
      fill: { $palette: "fill" },
      fillGradientDefaults: {
        type: "gradient",
        gradient: "linear",
        bounds: "item",
        colorStops: { $palette: "gradient" },
        rotation: 0,
        reverse: false
      },
      fillPatternDefaults: FILL_PATTERN_DEFAULTS,
      fillImageDefaults: FILL_IMAGE_DEFAULTS,
      stroke: { $palette: "stroke" },
      fillOpacity: 0.8,
      strokeOpacity: 1,
      strokeWidth: 0,
      lineDash: [0],
      lineDashOffset: 0,
      shadow: {
        enabled: false,
        color: DEFAULT_SHADOW_COLOUR,
        xOffset: 3,
        yOffset: 3,
        blur: 5
      },
      interpolation: {
        type: "linear"
      },
      marker: {
        enabled: false,
        shape: "circle",
        size: 7,
        strokeWidth: 0,
        fill: { $palette: "fill" },
        stroke: { $palette: "stroke" },
        // @ts-expect-error undocumented option
        fillGradientDefaults: {
          type: "gradient",
          gradient: "radial",
          bounds: "item",
          colorStops: { $palette: "gradient" },
          rotation: 0,
          reverse: true
        },
        fillPatternDefaults: FILL_PATTERN_DEFAULTS
      },
      label: {
        enabled: false,
        fontSize: { $ref: "fontSize" },
        fontFamily: { $ref: "fontFamily" },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "textColor" }
      }
    }
  }
};
var NewAreaSeriesModule = {
  type: "series",
  name: "area",
  chartType: "cartesian",
  options: areaSeriesOptionsDef,
  create: (ctx) => new AreaSeries(ctx)
};

// packages/ag-charts-community/src/chart/series/cartesian/barSeriesModule.ts
var import_ag_charts_core134 = require("ag-charts-core");

// packages/ag-charts-community/src/chart/series/cartesian/barSeries.ts
var import_ag_charts_core133 = require("ag-charts-core");

// packages/ag-charts-community/src/scene/util/corner.ts
var drawCorner = (path, { x0, y0, x1, y1, cx, cy }, cornerRadius, move) => {
  if (move) {
    path.moveTo(x0, y0);
  }
  if (x0 !== x1 || y0 !== y1) {
    const r0 = Math.atan2(y0 - cy, x0 - cx);
    const r1 = Math.atan2(y1 - cy, x1 - cx);
    path.arc(cx, cy, cornerRadius, r0, r1);
  } else {
    path.lineTo(x0, y0);
  }
};

// packages/ag-charts-community/src/scene/shape/rect.ts
var epsilon = 1e-6;
var cornerEdges = (leadingEdge, trailingEdge, leadingInset, trailingInset, cornerRadius) => {
  let leadingClipped = false;
  let trailingClipped = false;
  let leading0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - leadingInset ** 2, 0));
  let leading1 = 0;
  let trailing0 = 0;
  let trailing1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - trailingInset ** 2, 0));
  if (leading0 > leadingEdge) {
    leadingClipped = true;
    leading0 = leadingEdge;
    leading1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (trailingInset - leadingEdge) ** 2));
  } else if (leading0 < epsilon) {
    leading0 = 0;
  }
  if (trailing1 > trailingEdge) {
    trailingClipped = true;
    trailing0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (leadingInset - trailingEdge) ** 2));
    trailing1 = trailingEdge;
  } else if (trailing1 < epsilon) {
    trailing1 = 0;
  }
  return { leading0, leading1, trailing0, trailing1, leadingClipped, trailingClipped };
};
var clippedRoundRect = (path, x, y, width2, height2, cornerRadii, clipBBox) => {
  let {
    topLeft: topLeftCornerRadius,
    topRight: topRightCornerRadius,
    bottomRight: bottomRightCornerRadius,
    bottomLeft: bottomLeftCornerRadius
  } = cornerRadii;
  const maxVerticalCornerRadius = Math.max(
    topLeftCornerRadius + bottomLeftCornerRadius,
    topRightCornerRadius + bottomRightCornerRadius
  );
  const maxHorizontalCornerRadius = Math.max(
    topLeftCornerRadius + topRightCornerRadius,
    bottomLeftCornerRadius + bottomRightCornerRadius
  );
  if (maxVerticalCornerRadius <= 0 && maxHorizontalCornerRadius <= 0) {
    if (clipBBox == null) {
      path.rect(x, y, width2, height2);
    } else {
      path.rect(clipBBox.x, clipBBox.y, clipBBox.width, clipBBox.height);
    }
    return;
  } else if (clipBBox == null && topLeftCornerRadius === topRightCornerRadius && topLeftCornerRadius === bottomRightCornerRadius && topLeftCornerRadius === bottomLeftCornerRadius) {
    path.roundRect(x, y, width2, height2, topLeftCornerRadius);
    return;
  }
  if (width2 < 0) {
    x += width2;
    width2 = Math.abs(width2);
  }
  if (height2 < 0) {
    y += height2;
    height2 = Math.abs(height2);
  }
  if (width2 <= 0 || height2 <= 0)
    return;
  if (clipBBox == null) {
    clipBBox = new BBox(x, y, width2, height2);
  } else {
    const x0 = Math.max(x, clipBBox.x);
    const x1 = Math.min(x + width2, clipBBox.x + clipBBox.width);
    const y0 = Math.max(y, clipBBox.y);
    const y1 = Math.min(y + height2, clipBBox.y + clipBBox.height);
    clipBBox = new BBox(x0, y0, x1 - x0, y1 - y0);
  }
  const borderScale = Math.max(maxVerticalCornerRadius / height2, maxHorizontalCornerRadius / width2, 1);
  if (borderScale > 1) {
    topLeftCornerRadius /= borderScale;
    topRightCornerRadius /= borderScale;
    bottomRightCornerRadius /= borderScale;
    bottomLeftCornerRadius /= borderScale;
  }
  let drawTopLeftCorner = true;
  let drawTopRightCorner = true;
  let drawBottomRightCorner = true;
  let drawBottomLeftCorner = true;
  let topLeftCorner;
  let topRightCorner;
  let bottomRightCorner;
  let bottomLeftCorner;
  if (drawTopLeftCorner) {
    const nodes = cornerEdges(
      clipBBox.height,
      clipBBox.width,
      Math.max(x + topLeftCornerRadius - clipBBox.x, 0),
      Math.max(y + topLeftCornerRadius - clipBBox.y, 0),
      topLeftCornerRadius
    );
    if (nodes.leadingClipped)
      drawBottomLeftCorner = false;
    if (nodes.trailingClipped)
      drawTopRightCorner = false;
    const x0 = Math.max(clipBBox.x + nodes.leading1, clipBBox.x);
    const y0 = Math.max(clipBBox.y + nodes.leading0, clipBBox.y);
    const x1 = Math.max(clipBBox.x + nodes.trailing1, clipBBox.x);
    const y1 = Math.max(clipBBox.y + nodes.trailing0, clipBBox.y);
    const cx = x + topLeftCornerRadius;
    const cy = y + topLeftCornerRadius;
    topLeftCorner = { x0, y0, x1, y1, cx, cy };
  }
  if (drawTopRightCorner) {
    const nodes = cornerEdges(
      clipBBox.width,
      clipBBox.height,
      Math.max(y + topRightCornerRadius - clipBBox.y, 0),
      Math.max(clipBBox.x + clipBBox.width - (x + width2 - topRightCornerRadius), 0),
      topRightCornerRadius
    );
    if (nodes.leadingClipped)
      drawTopLeftCorner = false;
    if (nodes.trailingClipped)
      drawBottomRightCorner = false;
    const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading0, clipBBox.x + clipBBox.width);
    const y0 = Math.max(clipBBox.y + nodes.leading1, clipBBox.y);
    const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing0, clipBBox.x + clipBBox.width);
    const y1 = Math.max(clipBBox.y + nodes.trailing1, clipBBox.y);
    const cx = x + width2 - topRightCornerRadius;
    const cy = y + topRightCornerRadius;
    topRightCorner = { x0, y0, x1, y1, cx, cy };
  }
  if (drawBottomRightCorner) {
    const nodes = cornerEdges(
      clipBBox.height,
      clipBBox.width,
      Math.max(clipBBox.x + clipBBox.width - (x + width2 - bottomRightCornerRadius), 0),
      Math.max(clipBBox.y + clipBBox.height - (y + height2 - bottomRightCornerRadius), 0),
      bottomRightCornerRadius
    );
    if (nodes.leadingClipped)
      drawTopRightCorner = false;
    if (nodes.trailingClipped)
      drawBottomLeftCorner = false;
    const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading1, clipBBox.x + clipBBox.width);
    const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading0, clipBBox.y + clipBBox.height);
    const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing1, clipBBox.x + clipBBox.width);
    const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing0, clipBBox.y + clipBBox.height);
    const cx = x + width2 - bottomRightCornerRadius;
    const cy = y + height2 - bottomRightCornerRadius;
    bottomRightCorner = { x0, y0, x1, y1, cx, cy };
  }
  if (drawBottomLeftCorner) {
    const nodes = cornerEdges(
      clipBBox.width,
      clipBBox.height,
      Math.max(clipBBox.y + clipBBox.height - (y + height2 - bottomLeftCornerRadius), 0),
      Math.max(x + bottomLeftCornerRadius - clipBBox.x, 0),
      bottomLeftCornerRadius
    );
    if (nodes.leadingClipped)
      drawBottomRightCorner = false;
    if (nodes.trailingClipped)
      drawTopLeftCorner = false;
    const x0 = Math.max(clipBBox.x + nodes.leading0, clipBBox.x);
    const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading1, clipBBox.y + clipBBox.height);
    const x1 = Math.max(clipBBox.x + nodes.trailing0, clipBBox.x);
    const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing1, clipBBox.y + clipBBox.height);
    const cx = x + bottomLeftCornerRadius;
    const cy = y + height2 - bottomLeftCornerRadius;
    bottomLeftCorner = { x0, y0, x1, y1, cx, cy };
  }
  let didMove = false;
  if (drawTopLeftCorner && topLeftCorner != null) {
    drawCorner(path, topLeftCorner, topLeftCornerRadius, !didMove);
    didMove || (didMove = true);
  }
  if (drawTopRightCorner && topRightCorner != null) {
    drawCorner(path, topRightCorner, topRightCornerRadius, !didMove);
    didMove || (didMove = true);
  }
  if (drawBottomRightCorner && bottomRightCorner != null) {
    drawCorner(path, bottomRightCorner, bottomRightCornerRadius, !didMove);
    didMove || (didMove = true);
  }
  if (drawBottomLeftCorner && bottomLeftCorner != null) {
    drawCorner(path, bottomLeftCorner, bottomLeftCornerRadius, !didMove);
  }
  path.closePath();
};
var Rect = class extends Path {
  constructor() {
    super(...arguments);
    this.borderPath = new ExtendedPath2D();
    this.x = 0;
    this.y = 0;
    this.width = 10;
    this.height = 10;
    this.topLeftCornerRadius = 0;
    this.topRightCornerRadius = 0;
    this.bottomRightCornerRadius = 0;
    this.bottomLeftCornerRadius = 0;
    this.clipBBox = void 0;
    this.crisp = false;
    this.lastUpdatePathStrokeWidth = Shape.defaultStyles.strokeWidth;
    this.effectiveStrokeWidth = Shape.defaultStyles.strokeWidth;
    this.hittester = super.isPointInPath.bind(this);
    this.distanceCalculator = super.distanceSquaredTransformedPoint.bind(this);
    /**
     * When the rectangle's width or height is less than a pixel
     * and crisp mode is on, the rectangle will still fit into the pixel,
     * but will be less opaque to make an effect of holding less space.
     */
    this.microPixelEffectOpacity = 1;
  }
  set cornerRadius(cornerRadius) {
    this.topLeftCornerRadius = cornerRadius;
    this.topRightCornerRadius = cornerRadius;
    this.bottomRightCornerRadius = cornerRadius;
    this.bottomLeftCornerRadius = cornerRadius;
  }
  isDirtyPath() {
    return this.lastUpdatePathStrokeWidth !== this.strokeWidth || Boolean(this.path.isDirty() || this.borderPath.isDirty());
  }
  updatePath() {
    const {
      path,
      borderPath,
      crisp,
      topLeftCornerRadius: topLeft,
      topRightCornerRadius: topRight,
      bottomRightCornerRadius: bottomRight,
      bottomLeftCornerRadius: bottomLeft
    } = this;
    let { x, y, width: w, height: h, strokeWidth, clipBBox } = this;
    const pixelRatio = this.layerManager?.canvas.pixelRatio ?? 1;
    const pixelSize = 1 / pixelRatio;
    let microPixelEffectOpacity = 1;
    path.clear(true);
    borderPath.clear(true);
    if (crisp) {
      if (w <= pixelSize) {
        microPixelEffectOpacity *= w / pixelSize;
      }
      if (h <= pixelSize) {
        microPixelEffectOpacity *= h / pixelSize;
      }
      w = this.align(x, w);
      h = this.align(y, h);
      x = this.align(x);
      y = this.align(y);
      clipBBox = clipBBox != null ? new BBox(
        this.align(clipBBox.x),
        this.align(clipBBox.y),
        this.align(clipBBox.x, clipBBox.width),
        this.align(clipBBox.y, clipBBox.height)
      ) : void 0;
    }
    if (strokeWidth) {
      if (w < pixelSize) {
        const lx = x + pixelSize / 2;
        borderPath.moveTo(lx, y);
        borderPath.lineTo(lx, y + h);
        strokeWidth = pixelSize;
        this.borderClipPath = void 0;
      } else if (h < pixelSize) {
        const ly = y + pixelSize / 2;
        borderPath.moveTo(x, ly);
        borderPath.lineTo(x + w, ly);
        strokeWidth = pixelSize;
        this.borderClipPath = void 0;
      } else if (strokeWidth < w && strokeWidth < h) {
        const halfStrokeWidth = strokeWidth / 2;
        x += halfStrokeWidth;
        y += halfStrokeWidth;
        w -= strokeWidth;
        h -= strokeWidth;
        const adjustedClipBBox = clipBBox?.clone().shrink(halfStrokeWidth);
        const cornerRadii = {
          topLeft: topLeft > 0 ? topLeft - strokeWidth : 0,
          topRight: topRight > 0 ? topRight - strokeWidth : 0,
          bottomRight: bottomRight > 0 ? bottomRight - strokeWidth : 0,
          bottomLeft: bottomLeft > 0 ? bottomLeft - strokeWidth : 0
        };
        this.borderClipPath = void 0;
        if (w > 0 && h > 0 && (adjustedClipBBox == null || adjustedClipBBox?.width > 0 && adjustedClipBBox?.height > 0)) {
          clippedRoundRect(path, x, y, w, h, cornerRadii, adjustedClipBBox);
          clippedRoundRect(borderPath, x, y, w, h, cornerRadii, adjustedClipBBox);
        }
      } else {
        this.borderClipPath = this.borderClipPath ?? new ExtendedPath2D();
        this.borderClipPath.clear(true);
        this.borderClipPath.rect(x, y, w, h);
        borderPath.rect(x, y, w, h);
      }
    } else {
      const cornerRadii = { topLeft, topRight, bottomRight, bottomLeft };
      this.borderClipPath = void 0;
      clippedRoundRect(path, x, y, w, h, cornerRadii, clipBBox);
    }
    if ([topLeft, topRight, bottomRight, bottomLeft].every((r) => r === 0)) {
      const bbox = this.getBBox();
      this.hittester = bbox.containsPoint.bind(bbox);
      this.distanceSquared = (hitX, hitY) => this.getBBox().distanceSquared(hitX, hitY);
    } else {
      this.hittester = super.isPointInPath;
      this.distanceCalculator = super.distanceSquaredTransformedPoint;
    }
    this.effectiveStrokeWidth = strokeWidth;
    this.lastUpdatePathStrokeWidth = strokeWidth;
    this.microPixelEffectOpacity = microPixelEffectOpacity;
  }
  computeBBox() {
    const { x, y, width: width2, height: height2, clipBBox } = this;
    return clipBBox?.clone() ?? new BBox(x, y, width2, height2);
  }
  isPointInPath(x, y) {
    return this.hittester(x, y);
  }
  get midPoint() {
    return { x: this.x + this.width / 2, y: this.y + this.height / 2 };
  }
  distanceSquared(x, y) {
    return this.distanceCalculator(x, y);
  }
  applyFillAndAlpha(ctx) {
    super.applyFillAndAlpha(ctx);
    ctx.globalAlpha *= this.microPixelEffectOpacity;
  }
  applyStrokeAndAlpha(ctx) {
    super.applyStrokeAndAlpha(ctx);
    ctx.globalAlpha *= this.microPixelEffectOpacity;
  }
  renderStroke(ctx) {
    const { stroke: stroke2, effectiveStrokeWidth } = this;
    if (stroke2 && effectiveStrokeWidth) {
      const { globalAlpha } = ctx;
      const { lineDash, lineDashOffset, lineCap, lineJoin, borderPath, borderClipPath } = this;
      if (borderClipPath) {
        ctx.clip(borderClipPath.getPath2D());
      }
      this.applyStrokeAndAlpha(ctx);
      ctx.lineWidth = effectiveStrokeWidth;
      if (lineDash) {
        ctx.setLineDash(lineDash);
      }
      if (lineDashOffset) {
        ctx.lineDashOffset = lineDashOffset;
      }
      if (lineCap) {
        ctx.lineCap = lineCap;
      }
      if (lineJoin) {
        ctx.lineJoin = lineJoin;
      }
      ctx.stroke(borderPath.getPath2D());
      ctx.globalAlpha = globalAlpha;
    }
  }
};
Rect.className = "Rect";
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "x", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "y", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "width", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "height", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "topLeftCornerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "topRightCornerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "bottomRightCornerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "bottomLeftCornerRadius", 2);
__decorateClass([
  SceneObjectChangeDetection({ equals: BBoxValues.equals })
], Rect.prototype, "clipBBox", 2);
__decorateClass([
  SceneChangeDetection()
], Rect.prototype, "crisp", 2);

// packages/ag-charts-community/src/chart/series/cartesian/abstractBarSeries.ts
var import_ag_charts_core131 = require("ag-charts-core");

// packages/ag-charts-community/src/chart/axis/groupedCategoryAxis.ts
var import_ag_charts_core129 = require("ag-charts-core");

// packages/ag-charts-community/src/scale/groupedCategoryScale.ts
var GroupedCategoryScale = class _GroupedCategoryScale extends CategoryScale {
  static is(value) {
    return value instanceof _GroupedCategoryScale;
  }
  normalizeDomains(...domains) {
    const { domain } = super.normalizeDomains(...domains);
    return { domain, animatable: false };
  }
  findIndex(value) {
    return super.findIndex(value) ?? this.getMatchIndex(value);
  }
  getMatchIndex(value) {
    const key = JSON.stringify(value);
    const match = this._domain.find((d) => JSON.stringify(d) === key);
    if (match != null) {
      return super.findIndex(match);
    }
  }
};

// packages/ag-charts-community/src/chart/axis/tree.ts
var Dimensions = class {
  constructor() {
    this.top = Infinity;
    this.right = -Infinity;
    this.bottom = -Infinity;
    this.left = Infinity;
  }
  update(x, y) {
    if (x > this.right) {
      this.right = x;
    }
    if (x < this.left) {
      this.left = x;
    }
    if (y > this.bottom) {
      this.bottom = y;
    }
    if (y < this.top) {
      this.top = y;
    }
  }
};
var TreeNode = class _TreeNode {
  constructor(label = "", parent, refId) {
    this.label = label;
    this.parent = parent;
    this.refId = refId;
    this.position = 0;
    this.subtreeLeft = NaN;
    this.subtreeRight = NaN;
    this.children = [];
    this.leafCount = 0;
    this.prelim = 0;
    this.mod = 0;
    this.ancestor = this;
    this.change = 0;
    this.shift = 0;
    this.index = 0;
    // screen is meant to be recomputed from (layout) when the tree is resized (without performing another layout)
    this.screen = 0;
    this.depth = parent ? parent.depth + 1 : 0;
  }
  insertTick(tick, index) {
    let root = this;
    for (let i = 0; i < tick.length; i++) {
      const pathPart = tick[i];
      const isNotLeaf = i !== tick.length - 1;
      const { children } = root;
      const existingNode = children.find((child) => child.label === pathPart);
      if (existingNode && isNotLeaf) {
        root = existingNode;
      } else {
        const node = new _TreeNode(pathPart, root, index);
        node.index = children.length;
        children.push(node);
        if (isNotLeaf) {
          root = node;
        }
      }
    }
  }
  getLeftSibling() {
    return this.index > 0 ? this.parent?.children[this.index - 1] : void 0;
  }
  getLeftmostSibling() {
    return this.index > 0 ? this.parent?.children[0] : void 0;
  }
  // traverse the left contour of a subtree, return the successor of v on this contour
  nextLeft() {
    return this.children[0];
  }
  // traverse the right contour of a subtree, return the successor of v on this contour
  nextRight() {
    return this.children.at(-1);
  }
  getSiblings() {
    return this.parent?.children.filter((_, i) => i !== this.index) ?? [];
  }
};
function ticksToTree(ticks) {
  const maxDepth = ticks.reduce((depth, tick) => depth < tick.length ? tick.length : depth, 0);
  const root = new TreeNode();
  for (let i = 0; i < ticks.length; i++) {
    const tick = ticks[i];
    while (tick.length < maxDepth) {
      tick.push("");
    }
    root.insertTick(tick, i);
  }
  return root;
}
function moveSubtree(wm, wp, shift) {
  const subtrees = wp.index - wm.index;
  const ratio8 = shift / subtrees;
  wp.change -= ratio8;
  wp.shift += shift;
  wm.change += ratio8;
  wp.prelim += shift;
  wp.mod += shift;
}
function ancestor(vim, v, defaultAncestor) {
  return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;
}
function executeShifts({ children }) {
  let shift = 0;
  let change = 0;
  for (let i = children.length - 1; i >= 0; i--) {
    const w = children[i];
    w.prelim += shift;
    w.mod += shift;
    change += w.change;
    shift += w.shift + change;
  }
}
function apportion(v, defaultAncestor) {
  const w = v.getLeftSibling();
  if (w) {
    let vop = v;
    let vip = v;
    let vim = w;
    let vom = vip.getLeftmostSibling();
    let sip = vip.mod;
    let sop = vop.mod;
    let sim = vim.mod;
    let som = vom.mod;
    while (vim.nextRight() && vip.nextLeft()) {
      vim = vim.nextRight();
      vip = vip.nextLeft();
      vom = vom.nextLeft();
      vop = vop.nextRight();
      vop.ancestor = v;
      const shift = vim.prelim + sim - (vip.prelim + sip) + 1;
      if (shift > 0) {
        moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);
        sip += shift;
        sop += shift;
      }
      sim += vim.mod;
      sip += vip.mod;
      som += vom.mod;
      sop += vop.mod;
    }
    if (vim.nextRight() && !vop.nextRight()) {
      vop.mod += sim - sop;
    } else {
      if (vip.nextLeft() && !vom.nextLeft()) {
        vom.mod += sip - som;
      }
      defaultAncestor = v;
    }
  }
  return defaultAncestor;
}
function firstWalk(node) {
  const { children } = node;
  if (children.length) {
    let [defaultAncestor] = children;
    for (const child of children) {
      firstWalk(child);
      defaultAncestor = apportion(child, defaultAncestor);
    }
    executeShifts(node);
    const midpoint = (children[0].prelim + children.at(-1).prelim) / 2;
    const leftSibling = node.getLeftSibling();
    if (leftSibling) {
      node.prelim = leftSibling.prelim + 1;
      node.mod = node.prelim - midpoint;
    } else {
      node.prelim = midpoint;
    }
  } else {
    const leftSibling = node.getLeftSibling();
    node.prelim = leftSibling ? leftSibling.prelim + 1 : 0;
  }
}
function secondWalk(v, m, layout) {
  v.position = v.prelim + m;
  layout.insertNode(v);
  for (const w of v.children) {
    secondWalk(w, m + v.mod, layout);
  }
}
function thirdWalk(v) {
  const { children } = v;
  let leafCount = 0;
  for (const w of children) {
    thirdWalk(w);
    if (w.children.length) {
      leafCount += w.leafCount;
    } else {
      leafCount++;
    }
  }
  v.leafCount = leafCount;
  if (children.length) {
    v.subtreeLeft = children[0].subtreeLeft;
    v.subtreeRight = children[children.length - 1].subtreeRight;
    v.position = (v.subtreeLeft + v.subtreeRight) / 2;
  } else {
    v.subtreeLeft = v.position;
    v.subtreeRight = v.position;
  }
}
function treeLayout(ticks) {
  const layout = new TreeLayout();
  const root = ticksToTree(ticks);
  firstWalk(root);
  secondWalk(root, -root.prelim, layout);
  thirdWalk(root);
  return layout;
}
var TreeLayout = class {
  constructor() {
    this.dimensions = new Dimensions();
    this.nodes = [];
    this.depth = 0;
  }
  insertNode(node) {
    if (this.depth < node.depth) {
      this.depth = node.depth;
    }
    this.dimensions.update(node.position, node.depth);
    this.nodes.push(node);
  }
  scaling(extent2, flip) {
    let scaling = 1;
    if (extent2 > 0) {
      const { left, right } = this.dimensions;
      if (right !== left) {
        scaling = extent2 / (right - left);
      }
    }
    if (flip) {
      scaling *= -1;
    }
    return scaling;
  }
};

// packages/ag-charts-community/src/chart/axis/groupedCategoryAxis.ts
var DepthLabelProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
  }
};
__decorateClass([
  Property
], DepthLabelProperties.prototype, "enabled", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "avoidCollisions", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "color", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "spacing", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "rotation", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "fontStyle", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "fontWeight", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "fontSize", 2);
__decorateClass([
  Property
], DepthLabelProperties.prototype, "fontFamily", 2);
var DepthTickProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
  }
};
__decorateClass([
  Property
], DepthTickProperties.prototype, "enabled", 2);
__decorateClass([
  Property
], DepthTickProperties.prototype, "width", 2);
__decorateClass([
  Property
], DepthTickProperties.prototype, "stroke", 2);
var DepthProperties = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.label = new DepthLabelProperties();
    this.tick = new DepthTickProperties();
  }
};
__decorateClass([
  Property
], DepthProperties.prototype, "label", 2);
__decorateClass([
  Property
], DepthProperties.prototype, "tick", 2);
var GroupedCategoryAxis = class extends CategoryAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new GroupedCategoryScale());
    // Label scale (labels are positioned between ticks, tick count = label count + 1).
    // We don't call is `labelScale` for consistency with other axes.
    this.tickScale = new GroupedCategoryScale();
    this.depthOptions = new PropertiesArray(DepthProperties);
    this.includeInvisibleDomains = true;
    this.tickScale.paddingInner = 1;
    this.tickScale.paddingOuter = 0;
  }
  resizeTickTree() {
    if (!this.tickTreeLayout)
      return;
    const { nodes } = this.tickTreeLayout;
    const { range: range3, step, inset, bandwidth } = this.scale;
    const width2 = Math.abs(range3[1] - range3[0]) - step;
    const scaling = this.tickTreeLayout.scaling(width2, range3[0] > range3[1]);
    const shift = inset + bandwidth / 2;
    let offset4 = 0;
    for (const node of nodes) {
      const screen = node.position * scaling;
      if (offset4 > screen) {
        offset4 = screen;
      }
      node.screen = screen + shift;
    }
    for (const node of nodes) {
      node.screen -= offset4;
    }
  }
  getDepthOptionsMap(maxDepth) {
    const optionsMap = [];
    const { depthOptions, label } = this;
    const defaultNonLeafRotation = this.horizontal ? 0 : -90;
    for (let i = 0; i < maxDepth; i++) {
      optionsMap.push(
        depthOptions[i]?.label.enabled ?? label.enabled ? {
          enabled: true,
          spacing: depthOptions[i]?.label.spacing ?? label.spacing,
          rotation: depthOptions[i]?.label.rotation ?? (i ? defaultNonLeafRotation : label.rotation),
          // Default top-level label roration only applies to label leaves
          avoidCollisions: depthOptions[i]?.label.avoidCollisions ?? label.avoidCollisions
        } : { enabled: false, spacing: 0, rotation: 0, avoidCollisions: false }
      );
    }
    return optionsMap;
  }
  updateCategoryLabels() {
    if (!this.computedLayout)
      return;
    this.tickLabelGroupSelection.update(this.computedLayout.tickLabelLayout).each((node, datum) => node.setProperties(datum));
  }
  updateAxisLine() {
    if (!this.computedLayout)
      return;
    this.lineNode.visible = this.line.enabled;
    this.lineNode.stroke = this.line.stroke;
    this.lineNode.strokeWidth = this.line.width;
  }
  computeLayout() {
    this.updateDirection();
    this.updateScale();
    this.resizeTickTree();
    if (!this.tickTreeLayout?.depth) {
      return { bbox: BBox.zero, spacing: 0, separatorLayout: [], tickLabelLayout: [] };
    }
    const { step } = this.scale;
    const { title, label, range: range3, depthOptions, horizontal } = this;
    const { depth: maxDepth, nodes: treeLabels } = this.tickTreeLayout;
    const keepEvery = Math.ceil(label.fontSize / step);
    const sideFlag = horizontal ? -label.getSideFlag() : label.getSideFlag();
    const tickLabelLayout = [];
    const labelBBoxes = /* @__PURE__ */ new Map();
    const tempText = new TransformableText();
    const optionsMap = this.getDepthOptionsMap(maxDepth);
    const labelSpacing = sideFlag * optionsMap[0].spacing;
    const setLabelProps = (datum, index) => {
      const depth = maxDepth - datum.depth;
      if (!optionsMap[depth]?.enabled || index % keepEvery !== 0 || !(0, import_ag_charts_core129.inRange)(datum.screen, range3)) {
        return false;
      }
      const text = this.formatTick(datum.label, index - 1, this.scale.domain);
      const labelStyles = this.getLabelStyles({ value: text, depth }, depthOptions[depth]?.label);
      tempText.setProperties({
        ...labelStyles,
        text,
        textAlign: "center",
        textBaseline: label.parallel ? "hanging" : "bottom",
        lineHeight: TextUtils.getLineHeight(labelStyles.fontSize),
        x: horizontal ? datum.screen : labelSpacing,
        y: horizontal ? labelSpacing : datum.screen,
        rotation: 0
      });
      return true;
    };
    const depthLabelMaxSize = {};
    treeLabels.forEach((datum, index) => {
      const depth = maxDepth - datum.depth;
      const isVisible = setLabelProps(datum, index);
      if (!isVisible || !tempText.getBBox())
        return;
      labelBBoxes.set(index, tempText.getBBox());
      tempText.rotation = normalizeAngle360FromDegrees(optionsMap[depth]?.rotation);
      const { width: width3, height: height2 } = tempText.getBBox();
      const labelSize = horizontal ? height2 : width3;
      depthLabelMaxSize[depth] ?? (depthLabelMaxSize[depth] = 0);
      if (depthLabelMaxSize[depth] < labelSize) {
        depthLabelMaxSize[depth] = labelSize;
      }
    });
    const idGenerator = createIdsGenerator();
    const separatorData = /* @__PURE__ */ new Map();
    const nestedPadding = (d) => {
      if (d === 0)
        return 0;
      let v = depthLabelMaxSize[0];
      for (let i = 1; i <= d; i++) {
        v += optionsMap[i].spacing;
        if (i !== d) {
          v += depthLabelMaxSize[i];
        }
      }
      return v;
    };
    treeLabels.forEach((datum, index) => {
      if (index === 0)
        return;
      const visible = setLabelProps(datum, index);
      const isLeaf = !datum.children.length;
      const depth = maxDepth - datum.depth;
      if (datum.parent) {
        const separatorX = isLeaf ? datum.position : datum.position - (datum.leafCount - 1) / 2;
        if (!separatorData.has(separatorX)) {
          const tickOptions = this.depthOptions[depth]?.tick;
          let v = depthLabelMaxSize[0];
          for (let i = 0; i <= depth; i++) {
            v += optionsMap[i].spacing;
            if (i !== 0) {
              v += depthLabelMaxSize[i];
            }
          }
          separatorData.set(separatorX, {
            tickSize: v,
            tickStroke: tickOptions?.stroke,
            tickWidth: tickOptions?.enabled !== false ? tickOptions?.width : 0
          });
        }
      }
      if (!visible)
        return;
      const labelRotation = normalizeAngle360FromDegrees(optionsMap[depth].rotation);
      const { width: w, height: h } = labelBBoxes.get(index);
      const depthPadding = nestedPadding(depth);
      tempText.textAlign = "end";
      tempText.textBaseline = "middle";
      tempText.rotation = labelRotation;
      if (horizontal) {
        tempText.x += w / 2;
        tempText.y += (depthPadding + angularPadding(w / 2, h / 2, labelRotation)) * sideFlag;
        tempText.rotationCenterX = datum.screen;
        tempText.rotationCenterY = tempText.y;
      } else {
        tempText.x += depthPadding * sideFlag + angularPadding(
          (optionsMap[depth].spacing * sideFlag + w) / 2,
          label.mirrored ? w : 0,
          labelRotation
        );
        tempText.rotationCenterX = tempText.x - w / 2;
        tempText.rotationCenterY = datum.screen;
      }
      if (optionsMap[depth].avoidCollisions) {
        const { width: width3, height: height2 } = tempText.getBBox();
        const labelSize = horizontal ? width3 : height2;
        const availableRange = isLeaf ? step : datum.leafCount * step;
        if (labelSize > availableRange) {
          labelBBoxes.delete(index);
          return;
        }
      }
      const { text = "" } = tempText;
      tickLabelLayout.push({
        text,
        visible: true,
        range: this.scale.range,
        tickId: idGenerator(text),
        fill: tempText.fill,
        fontFamily: tempText.fontFamily,
        fontSize: tempText.fontSize,
        fontStyle: tempText.fontStyle,
        fontWeight: tempText.fontWeight,
        rotation: tempText.rotation,
        rotationCenterX: tempText.rotationCenterX,
        rotationCenterY: tempText.rotationCenterY,
        textAlign: tempText.textAlign,
        textBaseline: tempText.textBaseline,
        x: tempText.x,
        y: tempText.y
      });
      labelBBoxes.set(index, Transformable.toCanvas(tempText));
    });
    const { enabled, stroke: stroke2, width: width2 } = this.line;
    this.lineNode.datum = horizontal ? { x1: range3[0], x2: range3[1], y1: 0, y2: 0 } : { x1: 0, x2: 0, y1: range3[0], y2: range3[1] };
    this.lineNode.setProperties({ stroke: stroke2, strokeWidth: enabled ? width2 : 0 });
    const separatorLayout = [...separatorData.values()];
    separatorLayout.push(separatorLayout[0]);
    const bboxes = [
      this.lineNodeBBox(),
      BBox.merge(labelBBoxes.values()),
      new BBox(0, 0, separatorLayout[0].tickSize * sideFlag, 0)
    ];
    let spacing = 0;
    if (title.enabled) {
      const withoutTitle = BBox.merge(bboxes);
      spacing = horizontal ? withoutTitle.height : withoutTitle.width;
      bboxes.push(this.titleBBox(this.scale.domain, spacing));
    }
    const mergedBBox = BBox.merge(bboxes);
    return { bbox: mergedBBox, spacing, separatorLayout, tickLabelLayout };
  }
  /**
   * Creates/removes/updates the scene graph nodes that constitute the axis.
   * Supposed to be called _manually_ after changing _any_ of the axis properties.
   * This allows to bulk set axis properties before updating the nodes.
   * The node changes made by this method are rendered on the next animation frame.
   * We could schedule this method call automatically on the next animation frame
   * when any of the axis properties change (the way we do when properties of scene graph's
   * nodes change), but this will mean that we first wait for the next animation
   * frame to make changes to the nodes of the axis, then wait for another animation
   * frame to render those changes. It's nice to have everything update automatically,
   * but this extra level of async indirection will not just introduce an unwanted delay,
   * it will also make it harder to reason about the program.
   */
  update() {
    if (!this.computedLayout)
      return;
    this.moduleCtx.animationManager.skipCurrentBatch();
    const { tickScale, tick, gridLine, gridLength } = this;
    const { separatorLayout, spacing } = this.computedLayout;
    const { position, horizontal, gridPadding } = this;
    const direction = position === "bottom" || position === "right" ? -1 : 1;
    const p1 = gridPadding;
    const p2 = direction * gridLength - gridPadding;
    const ticks = tickScale.ticks({
      nice: false,
      interval: void 0,
      tickCount: void 0,
      minTickCount: 0,
      maxTickCount: Infinity
    }).ticks.map((t, index) => ({
      tickId: createDatumId(t, index),
      offset: Math.round(tickScale.convert(t))
    }));
    this.gridLineGroupSelection.update(
      gridLine.enabled && gridLength ? ticks.map(({ tickId, offset: offset4 }, index) => {
        const [x1, x2, y1, y2] = horizontal ? [offset4, offset4, p1, p2] : [p1, p2, offset4, offset4];
        const { style, width: strokeWidth } = gridLine;
        const { stroke: stroke2, lineDash } = style[index % style.length] ?? {};
        return { tickId, offset: offset4, x1, y1, x2, y2, stroke: stroke2, strokeWidth, lineDash };
      }) : []
    );
    this.tickLineGroupSelection.update(
      tick.enabled ? ticks.map(({ tickId, offset: offset4 }, index) => {
        const {
          tickSize = this.getTickSize(),
          tickStroke: stroke2 = tick.stroke,
          tickWidth: strokeWidth = tick.width
        } = separatorLayout[index] ?? {};
        const h = -direction * tickSize;
        const [x1, x2, y1, y2] = horizontal ? [offset4, offset4, 0, h] : [0, h, offset4, offset4];
        const lineDash = void 0;
        return { tickId, offset: offset4, x1, y1, x2, y2, stroke: stroke2, strokeWidth, lineDash };
      }) : []
    );
    this.updatePosition();
    this.updateCategoryLabels();
    this.updateAxisLine();
    this.updateGridLines();
    this.updateTickLines();
    this.updateTitle(this.scale.domain, spacing);
    this.resetSelectionNodes();
  }
  calculateLayout() {
    const { separatorLayout, tickLabelLayout, spacing, bbox } = this.computeLayout();
    this.computedLayout = { separatorLayout, tickLabelLayout, spacing };
    return { bbox, niceDomain: this.scale.domain };
  }
  /**
   * The length of the grid. The grid is only visible in case of a non-zero value.
   */
  onGridVisibilityChange() {
    this.gridLineGroupSelection.clear();
    this.tickLabelGroupSelection.clear();
  }
  updateScale() {
    super.updateScale();
    this.tickScale.range = this.scale.range;
    this.scale.paddingOuter = this.scale.paddingInner / 2;
  }
  processData() {
    const { direction } = this;
    const flatDomains = this.boundSeries.filter((s) => s.visible).flatMap((series) => series.getDomain(direction));
    this.dataDomain = { domain: extent(flatDomains) ?? this.filterDuplicateArrays(flatDomains), clipped: false };
    if (this.isReversed()) {
      this.dataDomain.domain.reverse();
    }
    const domain = this.dataDomain.domain.map(
      (datum) => (
        // Handle integrated charts data when provided as an object
        (0, import_ag_charts_core129.toArray)((0, import_ag_charts_core129.isObject)(datum) && "value" in datum ? datum.value : datum)
      )
    );
    this.tickTreeLayout = treeLayout(domain);
    const orderedDomain = [];
    for (const node of this.tickTreeLayout.nodes) {
      if (node.leafCount || node.refId == null)
        continue;
      orderedDomain.push(this.dataDomain.domain[node.refId]);
    }
    this.scale.domain = (0, import_ag_charts_core129.sortBasedOnArray)(this.dataDomain.domain, orderedDomain);
    this.tickScale.domain = domain.concat([[""]]);
  }
  filterDuplicateArrays(array4) {
    const seen = /* @__PURE__ */ new Set();
    return array4.filter((item) => {
      const key = (0, import_ag_charts_core129.isArray)(item) ? JSON.stringify(item) : item;
      if (seen.has(key))
        return false;
      seen.add(key);
      return true;
    });
  }
};
GroupedCategoryAxis.className = "GroupedCategoryAxis";
GroupedCategoryAxis.type = "grouped-category";
__decorateClass([
  Property
], GroupedCategoryAxis.prototype, "depthOptions", 2);

// packages/ag-charts-community/src/chart/series/cartesian/quadtreeUtil.ts
var import_ag_charts_core130 = require("ag-charts-core");
function addHitTestersToQuadtree(quadtree, hitTesters) {
  for (const node of hitTesters) {
    const datum = node.datum;
    if (datum === void 0) {
      import_ag_charts_core130.Logger.error("undefined datum");
    } else {
      quadtree.addValue(node, datum);
    }
  }
}
function findQuadtreeMatch(series, point) {
  const { x, y } = point;
  const { nearest, distanceSquared } = series.getQuadTree().find(x, y);
  if (nearest !== void 0) {
    return { datum: nearest.value, distance: Math.sqrt(distanceSquared) };
  }
  return void 0;
}

// packages/ag-charts-community/src/chart/series/cartesian/abstractBarSeries.ts
var AbstractBarSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.direction = "vertical";
  }
};
__decorateClass([
  Property
], AbstractBarSeriesProperties.prototype, "direction", 2);
var AbstractBarSeries = class extends CartesianSeries {
  constructor() {
    super(...arguments);
    /**
     * Used to get the position of bars within each group.
     */
    this.groupScale = new CategoryScale();
    this.smallestDataInterval = void 0;
    this.largestDataInterval = void 0;
  }
  padBandExtent(keys, alignStart) {
    const ratio8 = typeof alignStart === "boolean" ? 1 : 0.5;
    const scalePadding = (0, import_ag_charts_core131.isFiniteNumber)(this.smallestDataInterval) ? this.smallestDataInterval * ratio8 : 0;
    const keysExtent = extent(keys) ?? [NaN, NaN];
    if (typeof alignStart === "boolean") {
      keysExtent[alignStart ? 0 : 1] -= (alignStart ? 1 : -1) * scalePadding;
    } else {
      keysExtent[0] -= scalePadding;
      keysExtent[1] += scalePadding;
    }
    return fixNumericExtent(keysExtent);
  }
  getBandScalePadding() {
    return { inner: 0.3, outer: 0.15 };
  }
  shouldFlipXY() {
    return !this.isVertical();
  }
  isVertical() {
    return this.properties.direction === "vertical";
  }
  getBarDirection() {
    return this.shouldFlipXY() ? "x" /* X */ : "y" /* Y */;
  }
  getCategoryDirection() {
    return this.shouldFlipXY() ? "y" /* Y */ : "x" /* X */;
  }
  getValueAxis() {
    const direction = this.getBarDirection();
    return this.axes[direction];
  }
  getCategoryAxis() {
    const direction = this.getCategoryDirection();
    return this.axes[direction];
  }
  getBandwidth(xAxis, minWidth) {
    return ContinuousScale.is(xAxis.scale) ? xAxis.scale.calcBandwidth(this.smallestDataInterval, minWidth) : xAxis.scale.bandwidth;
  }
  xCoordinateRange(xValue) {
    const xAxis = this.axes[this.getCategoryDirection()];
    const xScale = xAxis.scale;
    const bandWidth = this.getBandwidth(xAxis, 0) ?? 0;
    const barOffset = ContinuousScale.is(xScale) ? bandWidth * -0.5 : 0;
    const x = xScale.convert(xValue) + barOffset;
    return [x, x + bandWidth];
  }
  yCoordinateRange(yValues) {
    const yAxis = this.axes[this.getBarDirection()];
    const yScale = yAxis.scale;
    const ys = yValues.map((yValue) => yScale.convert(yValue));
    if (ys.length === 1) {
      const y0 = yScale.convert(0);
      return [Math.min(ys[0], y0), Math.max(ys[0], y0)];
    }
    return [Math.min(...ys), Math.max(...ys)];
  }
  updateGroupScale(xAxis) {
    const domain = [];
    const { groupScale } = this;
    const xBandWidth = this.getBandwidth(xAxis);
    const { index: groupIndex, visibleGroupCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);
    for (let groupIdx = 0; groupIdx < visibleGroupCount; groupIdx++) {
      domain.push(String(groupIdx));
    }
    groupScale.domain = domain;
    groupScale.range = [0, xBandWidth ?? 0];
    if (xAxis instanceof GroupedCategoryAxis) {
      groupScale.paddingInner = xAxis.groupPaddingInner;
    } else if (xAxis instanceof CategoryAxis) {
      groupScale.paddingInner = xAxis.groupPaddingInner;
      groupScale.round = groupScale.padding !== 0;
    } else {
      groupScale.padding = 0;
    }
    const barWidth = groupScale.bandwidth >= 1 ? (
      // Pixel-rounded value for low-volume bar charts.
      groupScale.bandwidth
    ) : (
      // Handle high-volume bar charts gracefully.
      groupScale.rawBandwidth
    );
    return { barWidth, groupIndex };
  }
  resolveKeyDirection(direction) {
    if (this.getBarDirection() === "x" /* X */) {
      if (direction === "x" /* X */) {
        return "y" /* Y */;
      }
      return "x" /* X */;
    }
    return direction;
  }
  initQuadTree(quadtree) {
    addHitTestersToQuadtree(quadtree, this.datumNodesIter());
  }
  pickNodeClosestDatum(point) {
    return findQuadtreeMatch(this, point);
  }
};

// packages/ag-charts-community/src/chart/series/cartesian/barSeriesProperties.ts
var BarSeriesLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.placement = "inside-center";
    this.padding = 0;
  }
};
__decorateClass([
  Property
], BarSeriesLabel.prototype, "placement", 2);
__decorateClass([
  Property
], BarSeriesLabel.prototype, "padding", 2);
var BarSeriesProperties = class extends AbstractBarSeriesProperties {
  constructor() {
    super(...arguments);
    this.fill = "#c16068";
    this.fillGradientDefaults = new FillGradientDefaults();
    this.fillPatternDefaults = new FillPatternDefaults();
    this.fillImageDefaults = new FillImageDefaults();
    this.fillOpacity = 1;
    this.stroke = "#874349";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.crisp = void 0;
    this.shadow = new DropShadow();
    this.label = new BarSeriesLabel();
    this.tooltip = new SeriesTooltip();
    this.sparklineMode = false;
    this.fastDataProcessing = false;
  }
};
__decorateClass([
  Property
], BarSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "yFilterKey", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "stackGroup", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "normalizedTo", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "fill", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "crisp", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "label", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "sparklineMode", 2);
__decorateClass([
  Property
], BarSeriesProperties.prototype, "fastDataProcessing", 2);

// packages/ag-charts-community/src/chart/series/cartesian/barUtil.ts
var import_ag_charts_core132 = require("ag-charts-core");
function checkCrisp(scale2, visibleRange, smallestDataInterval, largestDataInterval) {
  if (visibleRange != null) {
    const [visibleMin, visibleMax] = visibleRange;
    const isZoomed = visibleMin !== 0 || visibleMax !== 1;
    if (isZoomed)
      return false;
  }
  if (ContinuousScale.is(scale2)) {
    const spacing = scale2.calcBandwidth(largestDataInterval) - scale2.calcBandwidth(smallestDataInterval);
    if (spacing > 0 && spacing < 1)
      return false;
  }
  return true;
}
var isDatumNegative = (datum) => {
  return (0, import_ag_charts_core132.isNegative)(datum.yValue ?? 0);
};
function collapsedStartingBarPosition(isVertical, axes, mode) {
  const { startingX, startingY } = getStartingValues(isVertical, axes);
  const calculate = (datum, prevDatum) => {
    let x = isVertical ? datum.x : startingX;
    let y = isVertical ? startingY : datum.y;
    let width2 = isVertical ? datum.width : 0;
    let height2 = isVertical ? 0 : datum.height;
    const { opacity = 1 } = datum;
    if (prevDatum && (isNaN(x) || isNaN(y))) {
      ({ x, y } = prevDatum);
      width2 = isVertical ? prevDatum.width : 0;
      height2 = isVertical ? 0 : prevDatum.height;
      if (isVertical && !isDatumNegative(prevDatum)) {
        y += prevDatum.height;
      } else if (!isVertical && isDatumNegative(prevDatum)) {
        x += prevDatum.width;
      }
    }
    let clipBBox;
    if (datum.clipBBox == null) {
      clipBBox = void 0;
    } else if (isDatumNegative(datum)) {
      clipBBox = isVertical ? new BBox(x, y - height2, width2, height2) : new BBox(x - width2, y, width2, height2);
    } else {
      clipBBox = new BBox(x, y, width2, height2);
    }
    return { x, y, width: width2, height: height2, clipBBox, opacity };
  };
  return { isVertical, calculate, mode };
}
function prepareBarAnimationFunctions(initPos) {
  const isRemoved = (datum) => datum == null || isNaN(datum.x) || isNaN(datum.y);
  const fromFn = (rect, datum, status) => {
    if (status === "updated" && isRemoved(datum)) {
      status = "removed";
    } else if (status === "updated" && isRemoved(rect.previousDatum)) {
      status = "added";
    }
    let source;
    if (status === "added" && rect.previousDatum == null && initPos.mode === "fade") {
      source = {
        ...resetBarSelectionsFn(rect, datum),
        opacity: 0
      };
    } else if (status === "unknown" || status === "added") {
      source = initPos.calculate(datum, rect.previousDatum);
    } else {
      source = {
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        clipBBox: rect.clipBBox,
        opacity: rect.opacity ?? 1
      };
    }
    const phase = NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];
    return { ...source, phase };
  };
  const toFn = (rect, datum, status) => {
    if (status === "removed" && rect.datum == null && initPos.mode === "fade") {
      return { ...resetBarSelectionsFn(rect, datum), opacity: 0 };
    } else if (status === "removed" || isRemoved(datum)) {
      return initPos.calculate(datum, rect.previousDatum);
    } else {
      return {
        x: datum.x,
        y: datum.y,
        width: datum.width,
        height: datum.height,
        clipBBox: datum.clipBBox,
        opacity: datum.opacity ?? 1
      };
    }
  };
  const applyFn = (rect, datum, status) => {
    rect.setProperties(datum);
    rect.crisp = status === "end" && (rect.datum?.crisp ?? false);
  };
  return { toFn, fromFn, applyFn };
}
function getStartingValues(isVertical, axes) {
  const axis = axes[isVertical ? "y" /* Y */ : "x" /* X */];
  let startingX = Infinity;
  let startingY = 0;
  if (!axis) {
    return { startingX, startingY };
  }
  if (isVertical) {
    startingY = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.max(...axis.range));
  } else {
    startingX = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.min(...axis.range));
  }
  return { startingX, startingY };
}
function resetBarSelectionsFn(rect, { x, y, width: width2, height: height2, clipBBox, opacity = 1 }) {
  return { x, y, width: width2, height: height2, clipBBox, opacity, crisp: rect.datum?.crisp ?? false };
}
function computeBarFocusBounds(series, datum) {
  if (datum === void 0)
    return void 0;
  const { x, y, width: width2, height: height2 } = datum;
  return Transformable.toCanvas(series.contentGroup, new BBox(x, y, width2, height2));
}

// packages/ag-charts-community/src/chart/series/cartesian/diffUtil.ts
function calculateDataDiff(seriesId, datumSelection, getDatumId, contextNodeData, previousContextNodeData, processedData) {
  let dataDiff = processedData?.reduced?.diff?.[seriesId];
  if (dataDiff?.changed) {
    return dataDiff;
  }
  const scalingChanged = hasScalingChanged(contextNodeData, previousContextNodeData);
  if (dataDiff == null && processedData?.reduced?.diff != null) {
    dataDiff = {
      changed: true,
      added: /* @__PURE__ */ new Set(),
      updated: /* @__PURE__ */ new Set(),
      removed: /* @__PURE__ */ new Set(),
      moved: /* @__PURE__ */ new Set()
    };
    if (scalingChanged) {
      dataDiff.updated = new Set(Array.from(datumSelection, ({ datum }) => getDatumId(datum)));
    } else {
      dataDiff.added = new Set(Array.from(datumSelection, ({ datum }) => getDatumId(datum)));
    }
  } else if (scalingChanged) {
    dataDiff = {
      changed: true,
      added: /* @__PURE__ */ new Set(),
      updated: new Set(Array.from(datumSelection, ({ datum }) => getDatumId(datum))),
      removed: /* @__PURE__ */ new Set(),
      moved: /* @__PURE__ */ new Set()
    };
  }
  return dataDiff;
}
function isGroupScaleContext(ctx) {
  return typeof ctx === "object" && ctx !== null && "groupScale" in ctx;
}
function hasScalingChanged(contextNodeData, previousContextNodeData) {
  if (!previousContextNodeData)
    return false;
  const scales = contextNodeData.scales;
  const prevScales = previousContextNodeData.scales;
  if (!areScalingEqual(scales.x, prevScales.x))
    return true;
  if (!areScalingEqual(scales.y, prevScales.y))
    return true;
  if (!isGroupScaleContext(contextNodeData) || !isGroupScaleContext(previousContextNodeData))
    return false;
  const groupScale = contextNodeData.groupScale;
  const prevGroupScale = previousContextNodeData.groupScale;
  return !areScalingEqual(groupScale, prevGroupScale);
}

// packages/ag-charts-community/src/chart/series/cartesian/labelUtil.ts
function updateLabelNode(textNode, label, labelDatum) {
  if (label.enabled && labelDatum) {
    const { x, y, text, textAlign, textBaseline } = labelDatum;
    const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = label;
    textNode.setProperties({
      visible: true,
      x,
      y,
      text,
      fill,
      fontStyle,
      fontWeight,
      fontSize,
      fontFamily,
      textAlign,
      textBaseline
    });
  } else {
    textNode.visible = false;
  }
}
var placements = {
  "inside-start": { inside: true, direction: -1, textAlignment: 1 },
  "inside-end": { inside: true, direction: 1, textAlignment: -1 },
  "outside-start": { inside: false, direction: -1, textAlignment: -1 },
  "outside-end": { inside: false, direction: 1, textAlignment: 1 }
};
function adjustLabelPlacement({
  isUpward,
  isVertical,
  placement,
  padding = 0,
  rect
}) {
  let x = rect.x + rect.width / 2;
  let y = rect.y + rect.height / 2;
  let textAlign = "center";
  let textBaseline = "middle";
  if (placement !== "inside-center") {
    const barDirection = (isUpward ? 1 : -1) * (isVertical ? -1 : 1);
    const { direction, textAlignment } = placements[placement];
    const displacementRatio = (direction + 1) * 0.5;
    if (isVertical) {
      const y0 = isUpward ? rect.y + rect.height : rect.y;
      const height2 = rect.height * barDirection;
      y = y0 + height2 * displacementRatio + padding * textAlignment * barDirection;
      textBaseline = textAlignment === barDirection ? "top" : "bottom";
    } else {
      const x0 = isUpward ? rect.x : rect.x + rect.width;
      const width2 = rect.width * barDirection;
      x = x0 + width2 * displacementRatio + padding * textAlignment * barDirection;
      textAlign = textAlignment === barDirection ? "left" : "right";
    }
  }
  return { x, y, textAlign, textBaseline };
}

// packages/ag-charts-community/src/chart/series/cartesian/barSeries.ts
var X_MIN = 0;
var X_MAX = 1;
var Y_MIN = 2;
var Y_MAX = 3;
var SPAN2 = 4;
var BarSeries = class extends AbstractBarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
      categoryKey: "xValue",
      pickModes: [
        2 /* AXIS_ALIGNED */,
        // Only used in sparklineMode
        1 /* NEAREST_NODE */,
        0 /* EXACT_SHAPE_MATCH */
      ],
      pathsPerSeries: [],
      hasHighlightedLabels: true,
      datumSelectionGarbageCollection: false,
      animationAlwaysUpdateSelections: true,
      animationResetFns: {
        datum: resetBarSelectionsFn,
        label: resetLabelFn
      }
    });
    this.properties = new BarSeriesProperties();
    this.connectsToYAxis = true;
    this.dataAggregationFilters = void 0;
  }
  get pickModeAxis() {
    return this.properties.sparklineMode ? "main" : void 0;
  }
  crossFilteringEnabled() {
    return this.properties.yFilterKey != null && (this.seriesGrouping == null || this.seriesGrouping.stackIndex === 0);
  }
  async processData(dataController) {
    if (!this.data)
      return;
    const { xKey, yKey, yFilterKey, normalizedTo, fastDataProcessing } = this.properties;
    const { seriesGrouping: { groupIndex = this.id } = {}, data } = this;
    const groupCount2 = this.seriesGrouping?.groupCount ?? 0;
    const stackCount = this.seriesGrouping?.stackCount ?? 0;
    const stacked = stackCount >= 1 || normalizedTo != null;
    const grouped = !fastDataProcessing || groupCount2 > 1 || stacked;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const xScale = this.getCategoryAxis()?.scale;
    const yScale = this.getValueAxis()?.scale;
    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const stackGroupName = `bar-stack-${groupIndex}-yValues`;
    const stackGroupTrailingName = `${stackGroupName}-trailing`;
    const visibleProps = this.visible ? {} : { forceValue: 0 };
    const props = [
      keyProperty(xKey, xScaleType, { id: "xValue" }),
      valueProperty(yKey, yScaleType, { id: `yValue-raw`, invalidValue: null, ...visibleProps })
    ];
    if (this.crossFilteringEnabled()) {
      props.push(
        valueProperty(yFilterKey, yScaleType, {
          id: `yFilterValue`,
          invalidValue: null,
          ...visibleProps
        })
      );
    }
    if (stacked) {
      props.push(
        ...groupAccumulativeValueProperty(
          yKey,
          "normal",
          "current",
          {
            id: `yValue-end`,
            rangeId: `yValue-range`,
            invalidValue: null,
            missingValue: 0,
            groupId: stackGroupName,
            separateNegative: true,
            ...visibleProps
          },
          yScaleType
        ),
        ...groupAccumulativeValueProperty(
          yKey,
          "trailing",
          "current",
          {
            id: `yValue-start`,
            invalidValue: null,
            missingValue: 0,
            groupId: stackGroupTrailingName,
            separateNegative: true,
            ...visibleProps
          },
          yScaleType
        )
      );
    }
    if (isContinuousX) {
      props.push(SMALLEST_KEY_INTERVAL, LARGEST_KEY_INTERVAL);
    }
    if ((0, import_ag_charts_core133.isFiniteNumber)(normalizedTo)) {
      props.push(normaliseGroupTo([stackGroupName, stackGroupTrailingName], Math.abs(normalizedTo)));
    }
    if (animationEnabled && this.processedData) {
      props.push(diff(this.id, this.processedData));
    }
    if (animationEnabled || !grouped) {
      props.push(animationValidation());
    }
    const { dataModel, processedData } = await this.requestDataModel(dataController, data, {
      props,
      groupByKeys: grouped,
      groupByData: !grouped
    });
    this.dataAggregationFilters = this.aggregateData(dataModel, processedData);
    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;
    this.largestDataInterval = processedData.reduced?.largestKeyInterval;
    this.animationState.transition("updateData");
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel } = this;
    if (dataModel == null || processedData == null)
      return [];
    if (direction === this.getCategoryDirection()) {
      const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
      const keys = dataModel.getDomain(this, `xValue`, "key", processedData);
      if (keyDef?.def.type === "key" && keyDef.def.valueType === "category") {
        return keys;
      }
      return this.padBandExtent(keys);
    }
    const yKey = this.dataModel?.hasColumnById(this, `yValue-end`) ? "yValue-end" : "yValue-raw";
    let yExtent = this.domainForClippedRange(direction, [yKey], "xValue", true);
    const yFilterExtent = this.crossFilteringEnabled() ? dataModel.getDomain(this, `yFilterValue`, "value", processedData) : void 0;
    if (yFilterExtent != null) {
      yExtent = [Math.min(yExtent[0], yFilterExtent[0]), Math.max(yExtent[1], yFilterExtent[1])];
    }
    if (this.getValueAxis() instanceof LogAxis) {
      return fixNumericExtent(yExtent);
    } else {
      const fixedYExtent = Number.isFinite(yExtent[1] - yExtent[0]) ? [Math.min(0, yExtent[0]), Math.max(0, yExtent[1])] : [];
      return fixNumericExtent(fixedYExtent);
    }
  }
  getSeriesRange(_direction, visibleRange) {
    const yKey = this.dataModel?.hasColumnById(this, `yValue-end`) ? "yValue-end" : "yValue-raw";
    const [y0, y1] = this.domainForVisibleRange("y" /* Y */, [yKey], "xValue", visibleRange, true);
    return [Math.min(y0, 0), Math.max(y1, 0)];
  }
  getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {
    const yKey = this.dataModel?.hasColumnById(this, `yValue-end`) ? "yValue-end" : "yValue-raw";
    return this.countVisibleItems("xValue", [yKey], xVisibleRange, yVisibleRange, minVisibleItems);
  }
  aggregateData(_dataModel, _processedData) {
    return;
  }
  createNodeData() {
    const { dataModel, processedData, groupScale, dataAggregationFilters } = this;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!dataModel || !processedData || !xAxis || !yAxis)
      return;
    const rawData = processedData.dataSources?.get(this.id);
    if (rawData == null)
      return;
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    const { xKey, yKey, xName, yName, legendItemName, label } = this.properties;
    const yReversed = yAxis.isReversed();
    const { barWidth, groupIndex: groupScaleIndex } = this.updateGroupScale(xAxis);
    const groupOffset = groupScale.convert(String(groupScaleIndex));
    const barOffset = ContinuousScale.is(xScale) ? barWidth * -0.5 : 0;
    const xValues = dataModel.resolveKeysById(this, `xValue`, processedData);
    const yRawValues = dataModel.resolveColumnById(this, `yValue-raw`, processedData);
    const yFilterValues = this.crossFilteringEnabled() ? dataModel.resolveColumnById(this, `yFilterValue`, processedData) : void 0;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const xPosition = (index) => xScale.convert(xValues[index]) + groupOffset + barOffset;
    const crisp = this.properties.crisp ?? checkCrisp(xAxis?.scale, xAxis?.visibleRange, this.smallestDataInterval, this.largestDataInterval);
    const bboxBottom = yScale.convert(0);
    const nodeDatum = ({
      datum,
      datumIndex,
      valueIndex,
      xValue,
      yValue,
      cumulativeValue,
      phantom,
      currY,
      prevY,
      x,
      width: width2,
      isPositive,
      yRange,
      labelText,
      opacity,
      crossScale = 1
    }) => {
      const isUpward = isPositive !== yReversed;
      const y = yScale.convert(currY);
      const bottomY = yScale.convert(prevY);
      const bboxHeight = yScale.convert(yRange);
      const barAlongX = this.getBarDirection() === "x" /* X */;
      const xOffset = width2 * 0.5 * (1 - crossScale);
      const rect = {
        x: barAlongX ? Math.min(y, bottomY) : x + xOffset,
        y: barAlongX ? x + xOffset : Math.min(y, bottomY),
        width: barAlongX ? Math.abs(bottomY - y) : width2 * crossScale,
        height: barAlongX ? width2 * crossScale : Math.abs(bottomY - y)
      };
      const clipBBox = new BBox(rect.x, rect.y, rect.width, rect.height);
      const barRect = {
        x: barAlongX ? Math.min(bboxBottom, bboxHeight) : x + xOffset,
        y: barAlongX ? x + xOffset : Math.min(bboxBottom, bboxHeight),
        width: barAlongX ? Math.abs(bboxBottom - bboxHeight) : width2 * crossScale,
        height: barAlongX ? width2 * crossScale : Math.abs(bboxBottom - bboxHeight)
      };
      const lengthRatioMultiplier = this.shouldFlipXY() ? rect.height : rect.width;
      return {
        series: this,
        itemId: phantom ? createDatumId(yKey, phantom) : yKey,
        datum,
        datumIndex,
        valueIndex,
        cumulativeValue,
        phantom,
        xValue,
        yValue,
        yKey,
        xKey,
        capDefaults: {
          lengthRatioMultiplier,
          lengthMax: lengthRatioMultiplier
        },
        x: barRect.x,
        y: barRect.y,
        width: barRect.width,
        height: barRect.height,
        midPoint: { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 },
        opacity,
        topLeftCornerRadius: barAlongX !== isUpward,
        topRightCornerRadius: isUpward,
        bottomRightCornerRadius: barAlongX === isUpward,
        bottomLeftCornerRadius: !isUpward,
        clipBBox,
        crisp,
        label: labelText != null ? {
          text: labelText,
          ...adjustLabelPlacement({
            isUpward,
            isVertical: !barAlongX,
            placement: label.placement,
            padding: label.padding,
            rect
          })
        } : void 0,
        missing: yValue == null,
        focusable: !phantom
      };
    };
    const phantomNodes = [];
    const nodes = [];
    const labels = [];
    const handleDatum = (datumIndex, valueIndex, x, width2, yStart, yEnd, yRange, opacity) => {
      const xValue = xValues[datumIndex];
      if (xValue == null)
        return;
      const yRawValue = yRawValues[datumIndex];
      const yFilterValue = yFilterValues != null ? Number(yFilterValues[datumIndex]) : void 0;
      const isPositive = yRawValue >= 0 && !Object.is(yRawValue, -0);
      if (!Number.isFinite(yEnd))
        return;
      if (yFilterValue != null && !Number.isFinite(yFilterValue))
        return;
      const labelText = yRawValue != null ? this.getLabelText(this.properties.label, {
        datum: rawData[datumIndex],
        value: yFilterValue ?? yRawValue,
        xKey,
        yKey,
        xName,
        yName,
        legendItemName
      }) : void 0;
      const inset = yFilterValue != null && yFilterValue > yRawValue;
      const nodeData = nodeDatum({
        datum: rawData[datumIndex],
        datumIndex,
        valueIndex,
        xValue,
        yValue: yFilterValue ?? yRawValue,
        cumulativeValue: yFilterValue ?? yEnd,
        phantom: false,
        currY: yFilterValue != null ? yStart + yFilterValue : yEnd,
        prevY: yStart,
        x,
        width: width2,
        isPositive,
        yRange: Math.max(yStart + (yFilterValue ?? -Infinity), yRange),
        labelText,
        opacity,
        crossScale: inset ? 0.6 : void 0
      });
      nodes.push(nodeData);
      labels.push(nodeData);
      if (yFilterValue != null) {
        const phantomNodeData = nodeDatum({
          datum: rawData[datumIndex],
          datumIndex,
          valueIndex,
          xValue,
          yValue: yFilterValue,
          cumulativeValue: yFilterValue,
          phantom: true,
          currY: yEnd,
          prevY: yStart,
          x,
          width: width2,
          isPositive,
          yRange,
          labelText: void 0,
          opacity,
          crossScale: void 0
        });
        phantomNodes.push(phantomNodeData);
      }
    };
    const [r0, r1] = xScale.range;
    const range3 = r1 - r0;
    const dataAggregationFilter = dataAggregationFilters?.find((f) => f.maxRange > range3);
    if (processedData.type === "grouped") {
      const width2 = barWidth;
      const stacked = dataModel.hasColumnById(this, `yValue-start`);
      const yStartValues = stacked ? dataModel.resolveColumnById(this, `yValue-start`, processedData) : void 0;
      const yEndValues = stacked ? dataModel.resolveColumnById(this, `yValue-end`, processedData) : void 0;
      const yRangeIndex = stacked ? dataModel.resolveProcessedDataIndexById(this, `yValue-range`) : -1;
      for (const {
        datumIndex,
        valueIndex,
        group: { aggregation }
      } of dataModel.forEachGroupDatum(this, processedData)) {
        const x = xPosition(datumIndex);
        const yRawValue = yRawValues[datumIndex];
        const isPositive = yRawValue >= 0 && !Object.is(yRawValue, -0);
        const yStart = stacked ? Number(yStartValues?.[datumIndex]) : 0;
        const yEnd = stacked ? Number(yEndValues?.[datumIndex]) : yRawValue;
        let yRange = yEnd;
        if (stacked) {
          yRange = aggregation[yRangeIndex][isPositive ? 1 : 0];
        }
        handleDatum(datumIndex, valueIndex, x, width2, yStart, yEnd, yRange, 1);
      }
    } else if (dataAggregationFilter == null) {
      const width2 = barWidth;
      let [start2, end2] = this.visibleRange("xValue", xAxis.range);
      if (processedData.input.count < 1e3) {
        start2 = 0;
        end2 = processedData.input.count;
      }
      for (let datumIndex = start2; datumIndex < end2; datumIndex += 1) {
        const x = xPosition(datumIndex);
        const yEnd = Number(yRawValues[datumIndex]);
        handleDatum(datumIndex, 0, x, width2, 0, yEnd, yEnd, 1);
      }
    } else {
      const { indexData, indices } = dataAggregationFilter;
      const [start2, end2] = this.visibleRange("xValue", xAxis.range, indices);
      for (let i = start2; i < end2; i += 1) {
        const aggIndex = i * SPAN2;
        const xMinIndex = indexData[aggIndex + X_MIN];
        const xMaxIndex = indexData[aggIndex + X_MAX];
        const yMinIndex = indexData[aggIndex + Y_MIN];
        const yMaxIndex = indexData[aggIndex + Y_MAX];
        if (xMinIndex === -1)
          continue;
        const x = xPosition((xMinIndex + xMaxIndex) / 2 | 0);
        const width2 = Math.abs(xPosition(xMaxIndex) - xPosition(xMinIndex)) + barWidth;
        const yEndMax = xValues[yMaxIndex] != null ? Number(yRawValues[yMaxIndex]) : NaN;
        const yEndMin = xValues[yMinIndex] != null ? Number(yRawValues[yMinIndex]) : NaN;
        if (yEndMax > 0) {
          const opacity = yEndMin >= 0 ? yEndMin / yEndMax : 1;
          handleDatum(yMaxIndex, 0, x, width2, 0, yEndMax, yEndMax, opacity);
        }
        if (yEndMin < 0) {
          const opacity = yEndMax <= 0 ? yEndMax / yEndMin : 1;
          handleDatum(yMinIndex, 1, x, width2, 0, yEndMin, yEndMin, opacity);
        }
      }
    }
    return {
      itemId: yKey,
      nodeData: phantomNodes.length > 0 ? [...phantomNodes, ...nodes] : nodes,
      labelData: labels,
      scales: this.calculateScaling(),
      visible: this.visible || animationEnabled,
      groupScale: this.getScaling(this.groupScale)
    };
  }
  nodeFactory() {
    return new Rect();
  }
  getHighlightData(nodeData, highlightedItem) {
    const highlightItem = nodeData.find(
      (nodeDatum) => nodeDatum.datum === highlightedItem.datum && !nodeDatum.phantom
    );
    return highlightItem != null ? [highlightItem] : void 0;
  }
  updateDatumSelection(opts) {
    return opts.datumSelection.update(opts.nodeData, void 0, (datum) => this.getDatumId(datum));
  }
  getItemBaseStyle(highlighted) {
    const { properties } = this;
    const { cornerRadius, fillGradientDefaults, fillPatternDefaults, fillImageDefaults } = properties;
    const highlightStyle = highlighted ? properties.highlightStyle.item : void 0;
    return getShapeStyle(
      {
        fill: highlightStyle?.fill ?? properties.fill,
        fillOpacity: highlightStyle?.fillOpacity ?? properties.fillOpacity,
        stroke: highlightStyle?.stroke ?? properties.stroke,
        strokeWidth: highlightStyle?.strokeWidth ?? this.getStrokeWidth(properties.strokeWidth),
        strokeOpacity: highlightStyle?.strokeOpacity ?? properties.strokeOpacity,
        lineDash: highlightStyle?.lineDash ?? properties.lineDash ?? [],
        lineDashOffset: highlightStyle?.lineDashOffset ?? properties.lineDashOffset,
        cornerRadius
      },
      fillGradientDefaults,
      fillPatternDefaults,
      fillImageDefaults
    );
  }
  getItemStyleOverrides(datumId, datum, xValue, yValue, format, highlighted) {
    const { id: seriesId, properties } = this;
    const { xKey, yKey, itemStyler, fillGradientDefaults, fillPatternDefaults, fillImageDefaults } = properties;
    if (itemStyler == null)
      return;
    const { xDomain, yDomain } = this.cachedDatumCallback("domain", () => ({
      xDomain: this.getSeriesDomain("x" /* X */),
      yDomain: this.getSeriesDomain("y" /* Y */)
    }));
    const overrides = this.cachedDatumCallback(createDatumId(datumId, highlighted ? "highlight" : "node"), () => {
      return this.callWithContext(itemStyler, {
        seriesId,
        ...datumStylerProperties(datum, xKey, yKey, xDomain, yDomain),
        datum,
        xValue,
        yValue,
        highlighted,
        ...format
      });
    });
    return getShapeStyle(overrides, fillGradientDefaults, fillPatternDefaults, fillImageDefaults);
  }
  updateDatumNodes(opts) {
    const { shadow } = this.properties;
    const categoryAlongX = this.getCategoryDirection() === "x" /* X */;
    const style = this.getItemBaseStyle(opts.isHighlight);
    const fillBBox = this.getShapeFillBBox();
    opts.datumSelection.each((rect, datum) => {
      const overrides = this.getItemStyleOverrides(
        String(datum.datumIndex),
        datum.datum,
        datum.xValue,
        datum.yValue,
        style,
        opts.isHighlight
      );
      rect.opacity = datum.opacity ?? 0;
      applyShapeStyle(rect, style, overrides, fillBBox);
      const cornerRadius = overrides?.cornerRadius ?? style.cornerRadius;
      rect.topLeftCornerRadius = datum.topLeftCornerRadius ? cornerRadius : 0;
      rect.topRightCornerRadius = datum.topRightCornerRadius ? cornerRadius : 0;
      rect.bottomRightCornerRadius = datum.bottomRightCornerRadius ? cornerRadius : 0;
      rect.bottomLeftCornerRadius = datum.bottomLeftCornerRadius ? cornerRadius : 0;
      rect.visible = categoryAlongX ? (datum.clipBBox?.width ?? datum.width) > 0 : (datum.clipBBox?.height ?? datum.height) > 0;
      rect.crisp = datum.crisp;
      rect.fillShadow = shadow;
    });
  }
  updateLabelSelection(opts) {
    const data = this.isLabelEnabled() ? opts.labelData : [];
    return opts.labelSelection.update(data, (text) => {
      text.pointerEvents = 1 /* None */;
    });
  }
  updateLabelNodes(opts) {
    opts.labelSelection.each((textNode, datum) => {
      updateLabelNode(textNode, this.properties.label, datum.label);
    });
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, properties } = this;
    const { xKey, xName, yKey, yName, legendItemName, stackGroup, tooltip } = properties;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!dataModel || !processedData || !xAxis || !yAxis) {
      return;
    }
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const xValue = dataModel.resolveKeysById(this, `xValue`, processedData)[datumIndex];
    const yValue = dataModel.resolveColumnById(this, `yValue-raw`, processedData)[datumIndex];
    if (xValue == null)
      return;
    const format = this.getItemBaseStyle(false);
    Object.assign(format, this.getItemStyleOverrides(String(datumIndex), datum, xValue, yValue, format, false));
    return this.formatTooltipWithContext(
      tooltip,
      {
        heading: xAxis.formatDatum(xValue),
        symbol: this.legendItemSymbol(),
        data: [{ label: yName, fallbackLabel: yKey, value: yAxis.formatDatum(yValue) }]
      },
      {
        seriesId,
        datum,
        title: yName,
        xKey,
        xName,
        yKey,
        yName,
        legendItemName,
        stackGroup,
        ...format,
        ...this.getModuleTooltipParams()
      }
    );
  }
  legendItemSymbol() {
    const {
      fill,
      stroke: stroke2,
      strokeWidth,
      fillOpacity,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      fillGradientDefaults,
      fillPatternDefaults,
      fillImageDefaults
    } = this.properties;
    return {
      marker: getShapeStyle(
        {
          fill: fill ?? "rgba(0, 0, 0, 0)",
          stroke: stroke2 ?? "rgba(0, 0, 0, 0)",
          fillOpacity,
          strokeOpacity,
          strokeWidth,
          lineDash,
          lineDashOffset
        },
        fillGradientDefaults,
        fillPatternDefaults,
        fillImageDefaults
      )
    };
  }
  getLegendData(legendType) {
    const { showInLegend } = this.properties;
    if (legendType !== "category") {
      return [];
    }
    const {
      id: seriesId,
      ctx: { legendManager },
      visible
    } = this;
    const { yKey: itemId, yName, legendItemName } = this.properties;
    return [
      {
        legendType: "category",
        id: seriesId,
        itemId,
        seriesId,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId }),
        label: { text: legendItemName ?? yName ?? itemId },
        symbol: this.legendItemSymbol(),
        legendItemName,
        hideInLegend: !showInLegend
      }
    ];
  }
  animateEmptyUpdateReady({ datumSelection, labelSelection, annotationSelections }) {
    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, "normal"));
    fromToMotion(this.id, "nodes", this.ctx.animationManager, [datumSelection], fns);
    seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
    seriesLabelFadeInAnimation(this, "annotations", this.ctx.animationManager, ...annotationSelections);
  }
  animateWaitingUpdateReady(data) {
    const { datumSelection, labelSelection, annotationSelections, contextData, previousContextData } = data;
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    const dataDiff = calculateDataDiff(
      this.id,
      datumSelection,
      this.getDatumId.bind(this),
      data.contextData,
      previousContextData,
      this.processedData
    );
    const mode = previousContextData == null ? "fade" : "normal";
    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, mode));
    fromToMotion(
      this.id,
      "nodes",
      this.ctx.animationManager,
      [datumSelection],
      fns,
      (_, datum) => this.getDatumId(datum),
      dataDiff
    );
    if (dataDiff?.changed || !areScalingEqual(contextData.groupScale, previousContextData?.groupScale)) {
      seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
      seriesLabelFadeInAnimation(this, "annotations", this.ctx.animationManager, ...annotationSelections);
    }
  }
  getDatumId(datum) {
    return createDatumId(datum.xValue, datum.valueIndex, datum.phantom);
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  computeFocusBounds({ datumIndex }) {
    const datumBox = this.contextNodeData?.nodeData[datumIndex].clipBBox;
    return computeBarFocusBounds(this, datumBox);
  }
};
BarSeries.className = "BarSeries";
BarSeries.type = "bar";

// packages/ag-charts-community/src/chart/series/cartesian/barSeriesModule.ts
var NewBarSeriesModule = {
  type: "series",
  name: "bar",
  chartType: "cartesian",
  options: barSeriesOptionsDef,
  create: (ctx) => new BarSeries(ctx)
};

// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesProperties.ts
var BubbleSeriesMarker = class extends SeriesMarker {
  constructor() {
    super(...arguments);
    this.maxSize = 30;
  }
};
__decorateClass([
  Property,
  SceneChangeDetection()
], BubbleSeriesMarker.prototype, "maxSize", 2);
__decorateClass([
  Property,
  SceneArrayChangeDetection()
], BubbleSeriesMarker.prototype, "domain", 2);
var BubbleSeriesLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.placement = "top";
  }
};
__decorateClass([
  Property
], BubbleSeriesLabel.prototype, "placement", 2);
var BubbleSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.label = new BubbleSeriesLabel();
    this.tooltip = new SeriesTooltip();
    // No validation. Not a part of the options contract.
    this.marker = new BubbleSeriesMarker();
  }
};
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "sizeKey", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "labelKey", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "xFilterKey", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "yFilterKey", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "sizeFilterKey", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "sizeName", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "labelName", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "title", 2);
__decorateClass([
  ProxyProperty("marker.shape")
], BubbleSeriesProperties.prototype, "shape", 2);
__decorateClass([
  ProxyProperty("marker.size")
], BubbleSeriesProperties.prototype, "size", 2);
__decorateClass([
  ProxyProperty("marker.maxSize")
], BubbleSeriesProperties.prototype, "maxSize", 2);
__decorateClass([
  ProxyProperty("marker.domain")
], BubbleSeriesProperties.prototype, "domain", 2);
__decorateClass([
  ProxyProperty("marker.fillGradientDefaults")
], BubbleSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass([
  ProxyProperty("marker.fillPatternDefaults")
], BubbleSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass([
  ProxyProperty("marker.fillImageDefaults")
], BubbleSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass([
  ProxyProperty("marker.fill")
], BubbleSeriesProperties.prototype, "fill", 2);
__decorateClass([
  ProxyProperty("marker.fillOpacity")
], BubbleSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  ProxyProperty("marker.stroke")
], BubbleSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  ProxyProperty("marker.strokeWidth")
], BubbleSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  ProxyProperty("marker.strokeOpacity")
], BubbleSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  ProxyProperty("marker.lineDash")
], BubbleSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  ProxyProperty("marker.lineDashOffset")
], BubbleSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  ProxyProperty("marker.itemStyler")
], BubbleSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "label", 2);
__decorateClass([
  Property
], BubbleSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeries.ts
var BubbleSeriesNodeEvent = class extends CartesianSeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.sizeKey = series.properties.sizeKey;
  }
};
var BubbleSeries = class extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
      categoryKey: void 0,
      pickModes: [
        2 /* AXIS_ALIGNED */,
        1 /* NEAREST_NODE */,
        0 /* EXACT_SHAPE_MATCH */
      ],
      pathsPerSeries: [],
      hasMarkers: true,
      markerSelectionGarbageCollection: false,
      animationResetFns: {
        label: resetLabelFn,
        marker: resetMarkerFn
      },
      usesPlacedLabels: true,
      clipFocusBox: false
    });
    this.NodeEvent = BubbleSeriesNodeEvent;
    this.properties = new BubbleSeriesProperties();
    this.sizeScale = new LinearScale();
  }
  get pickModeAxis() {
    return "main-category";
  }
  async processData(dataController) {
    if (this.data == null || !this.visible)
      return;
    const xScale = this.axes["x" /* X */]?.scale;
    const yScale = this.axes["y" /* Y */]?.scale;
    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const sizeScaleType = this.sizeScale.type;
    const { xKey, yKey, sizeKey, xFilterKey, yFilterKey, sizeFilterKey, labelKey, marker } = this.properties;
    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {
      props: [
        valueProperty(xKey, xScaleType, { id: `xValue` }),
        valueProperty(yKey, yScaleType, { id: `yValue` }),
        ...xFilterKey != null ? [valueProperty(xFilterKey, xScaleType, { id: `xFilterValue` })] : [],
        ...yFilterKey != null ? [valueProperty(yFilterKey, yScaleType, { id: `yFilterValue` })] : [],
        ...sizeFilterKey != null ? [valueProperty(sizeFilterKey, sizeScaleType, { id: `sizeFilterValue` })] : [],
        valueProperty(sizeKey, sizeScaleType, { id: `sizeValue` }),
        ...labelKey ? [valueProperty(labelKey, "band", { id: `labelValue` })] : []
      ]
    });
    const sizeKeyIdx = dataModel.resolveProcessedDataIndexById(this, `sizeValue`);
    const mutableMarkerDomain = marker.domain ? [marker.domain[0], marker.domain[1]] : void 0;
    this.sizeScale.domain = mutableMarkerDomain ?? processedData.domain.values[sizeKeyIdx] ?? [];
    this.animationState.transition("updateData");
  }
  xCoordinateRange(xValue, pixelSize, index) {
    const { properties, sizeScale } = this;
    const { size, sizeKey } = properties;
    const x = this.axes["x" /* X */].scale.convert(xValue);
    const sizeValues = sizeKey != null ? this.dataModel.resolveColumnById(this, `sizeValue`, this.processedData) : void 0;
    const sizeValue = sizeValues != null ? sizeScale.convert(sizeValues[index]) : size;
    const r = 0.5 * sizeValue * pixelSize;
    return [x - r, x + r];
  }
  yCoordinateRange(yValues, pixelSize, index) {
    const { properties, sizeScale } = this;
    const { size, sizeKey } = properties;
    const y = this.axes["y" /* Y */].scale.convert(yValues[0]);
    const sizeValues = sizeKey != null ? this.dataModel.resolveColumnById(this, `sizeValue`, this.processedData) : void 0;
    const sizeValue = sizeValues != null ? sizeScale.convert(sizeValues[index]) : size;
    const r = 0.5 * sizeValue * pixelSize;
    return [y - r, y + r];
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!processedData || !dataModel)
      return [];
    const dataValues = {
      ["x" /* X */]: "xValue",
      ["y" /* Y */]: "yValue"
    };
    const id = dataValues[direction];
    const dataDef = dataModel.resolveProcessedDataDefById(this, id);
    const domain = dataModel.getDomain(this, id, "value", processedData);
    if (dataDef?.def.type === "value" && dataDef?.def.valueType === "category") {
      return domain;
    }
    const crossDirection = direction === "x" /* X */ ? "y" /* Y */ : "x" /* X */;
    const crossId = dataValues[crossDirection];
    const ext = this.domainForClippedRange(direction, [id], crossId, false);
    return fixNumericExtent(extent(ext));
  }
  getSeriesRange(_direction, visibleRange) {
    return this.domainForVisibleRange("y" /* Y */, ["yValue"], "xValue", visibleRange, false);
  }
  getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {
    return this.countVisibleItems("xValue", ["yValue"], xVisibleRange, yVisibleRange, minVisibleItems);
  }
  createNodeData() {
    const { axes, dataModel, processedData, sizeScale, visible } = this;
    const {
      xKey,
      yKey,
      sizeKey,
      xFilterKey,
      yFilterKey,
      sizeFilterKey,
      labelKey,
      xName,
      yName,
      sizeName,
      labelName,
      label,
      marker
    } = this.properties;
    const { placement } = label;
    const anchor = Marker.anchor(marker.shape);
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!(dataModel && processedData && visible && xAxis && yAxis)) {
      return;
    }
    const xDataValues = dataModel.resolveColumnById(this, `xValue`, processedData);
    const yDataValues = dataModel.resolveColumnById(this, `yValue`, processedData);
    const sizeDataValues = sizeKey != null ? dataModel.resolveColumnById(this, `sizeValue`, processedData) : void 0;
    const labelDataValues = labelKey != null ? dataModel.resolveColumnById(this, `labelValue`, processedData) : void 0;
    const xFilterDataValues = xFilterKey != null ? dataModel.resolveColumnById(this, `xFilterValue`, processedData) : void 0;
    const yFilterDataValues = yFilterKey != null ? dataModel.resolveColumnById(this, `yFilterValue`, processedData) : void 0;
    const sizeFilterDataValues = sizeFilterKey != null ? dataModel.resolveColumnById(this, `sizeFilterValue`, processedData) : void 0;
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    const xOffset = (xScale.bandwidth ?? 0) / 2;
    const yOffset = (yScale.bandwidth ?? 0) / 2;
    const nodeData = [];
    sizeScale.range = [marker.size, marker.maxSize];
    const font2 = label.getFont();
    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font: font2 });
    processedData.dataSources.get(this.id)?.forEach((datum, datumIndex) => {
      const xDatum = xDataValues[datumIndex];
      const yDatum = yDataValues[datumIndex];
      const sizeValue = sizeDataValues?.[datumIndex];
      const x = xScale.convert(xDatum) + xOffset;
      const y = yScale.convert(yDatum) + yOffset;
      let selected;
      if (xFilterDataValues != null && yFilterDataValues != null) {
        selected = xFilterDataValues[datumIndex] === xDatum && yFilterDataValues[datumIndex] === yDatum;
        if (sizeFilterDataValues != null) {
          selected && (selected = sizeFilterDataValues[datumIndex] === sizeValue);
        }
      }
      const labelText = this.getLabelText(label, {
        value: labelDataValues != null ? labelDataValues[datumIndex] : yDatum,
        datum,
        xKey,
        yKey,
        sizeKey,
        labelKey,
        xName,
        yName,
        sizeName,
        labelName
      });
      const size = textMeasurer.measureText(String(labelText));
      const markerSize = sizeValue != null ? sizeScale.convert(sizeValue) : marker.size;
      nodeData.push({
        series: this,
        itemId: yKey,
        yKey,
        xKey,
        datum,
        datumIndex,
        xValue: xDatum,
        yValue: yDatum,
        sizeValue,
        point: { x, y, size: markerSize },
        midPoint: { x, y },
        label: { text: labelText, ...size },
        anchor,
        placement,
        selected
      });
    });
    return {
      itemId: yKey,
      nodeData,
      labelData: nodeData,
      scales: this.calculateScaling(),
      visible: this.visible
    };
  }
  isPathOrSelectionDirty() {
    return this.properties.marker.isDirty();
  }
  getLabelData() {
    if (!this.isLabelEnabled())
      return [];
    return this.contextNodeData?.labelData ?? [];
  }
  updateMarkerSelection(opts) {
    const { nodeData, markerSelection } = opts;
    if (this.properties.marker.isDirty()) {
      markerSelection.clear();
      markerSelection.cleanup();
    }
    const data = this.properties.marker.enabled ? nodeData : [];
    return markerSelection.update(
      data,
      void 0,
      (datum) => createDatumId([datum.xValue, datum.yValue, datum.sizeValue, datum.label.text])
    );
  }
  updateMarkerNodes(opts) {
    const { markerSelection, isHighlight: highlighted } = opts;
    const { xKey, yKey, sizeKey, labelKey, marker } = this.properties;
    const baseStyle = mergeDefaults(highlighted && this.properties.highlightStyle.item, marker.getStyle());
    this.sizeScale.range = [marker.size, marker.maxSize];
    const fillBBox = this.getShapeFillBBox();
    markerSelection.each((node, datum) => {
      this.updateMarkerStyle(
        marker,
        node,
        datum.datum,
        datum.point,
        { xKey, yKey, sizeKey, labelKey },
        highlighted,
        baseStyle,
        fillBBox,
        { selected: datum.selected }
      );
    });
    if (!highlighted) {
      this.properties.marker.markClean();
    }
  }
  updatePlacedLabelData(labelData) {
    this.labelSelection.update(
      labelData.map((v) => ({
        ...v.datum,
        point: {
          x: v.x,
          y: v.y,
          size: v.datum.point.size
        }
      })),
      (text) => {
        text.pointerEvents = 1 /* None */;
      }
    );
    this.updateLabelNodes({ labelSelection: this.labelSelection });
  }
  updateLabelNodes(opts) {
    const { label } = this.properties;
    opts.labelSelection.each((text, datum) => {
      text.text = datum.label.text;
      text.fill = label.color;
      text.x = datum.point?.x ?? 0;
      text.y = datum.point?.y ?? 0;
      text.fontStyle = label.fontStyle;
      text.fontWeight = label.fontWeight;
      text.fontSize = label.fontSize;
      text.fontFamily = label.fontFamily;
      text.textAlign = "left";
      text.textBaseline = "top";
    });
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, axes, properties } = this;
    const { xKey, xName, yKey, yName, sizeKey, sizeName, labelKey, labelName, title, tooltip, marker } = properties;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!dataModel || !processedData || !xAxis || !yAxis)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const xValue = dataModel.resolveColumnById(this, `xValue`, processedData)[datumIndex];
    const yValue = dataModel.resolveColumnById(this, `yValue`, processedData)[datumIndex];
    const nodeDatum = this.contextNodeData?.nodeData[datumIndex];
    if (xValue == null || nodeDatum == null)
      return;
    const data = [
      { label: xName, fallbackLabel: xKey, value: xAxis.formatDatum(xValue) },
      { label: yName, fallbackLabel: yKey, value: yAxis.formatDatum(yValue) }
    ];
    if (sizeKey != null) {
      const sizeValue = dataModel.resolveColumnById(this, `sizeValue`, processedData)[datumIndex];
      data.push({ label: sizeName, fallbackLabel: sizeKey, value: String(sizeValue) });
    }
    const style = marker.getStyle();
    const activeStyle = this.getMarkerStyle(
      marker,
      datum,
      {
        xKey,
        yKey,
        sizeKey,
        labelKey,
        highlighted: true
      },
      false,
      void 0,
      style
    );
    return this.formatTooltipWithContext(
      tooltip,
      {
        title,
        symbol: this.legendItemSymbol(),
        data
      },
      {
        seriesId,
        datum,
        title: yKey,
        xKey,
        xName,
        yKey,
        yName,
        sizeKey,
        sizeName,
        labelKey,
        labelName,
        ...activeStyle,
        ...this.getModuleTooltipParams()
      }
    );
  }
  legendItemSymbol() {
    const marker = this.getMarkerStyle(this.properties.marker);
    return {
      marker
    };
  }
  getLegendData() {
    const {
      id: seriesId,
      ctx: { legendManager },
      visible
    } = this;
    const { yKey: itemId, yName, title } = this.properties;
    return [
      {
        legendType: "category",
        id: seriesId,
        itemId,
        seriesId,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId }),
        label: {
          text: title ?? yName ?? itemId
        },
        symbol: this.legendItemSymbol()
      }
    ];
  }
  animateEmptyUpdateReady({ markerSelection, labelSelection }) {
    markerScaleInAnimation(this, this.ctx.animationManager, markerSelection);
    seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  nodeFactory() {
    return new Group();
  }
  getFormattedMarkerStyle(datum) {
    const { xKey, yKey, sizeKey, labelKey, marker } = this.properties;
    return this.getMarkerStyle(marker, datum, { xKey, yKey, sizeKey, labelKey }, false, datum.point.size);
  }
  computeFocusBounds(opts) {
    return computeMarkerFocusBounds(this, opts);
  }
};
BubbleSeries.className = "BubbleSeries";
BubbleSeries.type = "bubble";

// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesOptionsDef.ts
var import_ag_charts_core135 = require("ag-charts-core");
var bubbleSeriesThemeableOptionsDef = {
  title: import_ag_charts_core135.string,
  domain: (0, import_ag_charts_core135.arrayOf)(import_ag_charts_core135.number),
  maxSize: import_ag_charts_core135.positiveNumber,
  showInMiniChart: import_ag_charts_core135.boolean,
  label: {
    placement: (0, import_ag_charts_core135.union)("top", "right", "bottom", "left"),
    ...seriesLabelOptionsDefs
  },
  tooltip: tooltipOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...without(markerOptionsDefs, ["enabled"])
};
var bubbleSeriesOptionsDef = {
  ...bubbleSeriesThemeableOptionsDef,
  ...commonSeriesOptionsDefs,
  type: (0, import_ag_charts_core135.required)((0, import_ag_charts_core135.constant)("bubble")),
  xKey: (0, import_ag_charts_core135.required)(import_ag_charts_core135.string),
  yKey: (0, import_ag_charts_core135.required)(import_ag_charts_core135.string),
  sizeKey: (0, import_ag_charts_core135.required)(import_ag_charts_core135.string),
  labelKey: import_ag_charts_core135.string,
  xName: import_ag_charts_core135.string,
  yName: import_ag_charts_core135.string,
  sizeName: import_ag_charts_core135.string,
  labelName: import_ag_charts_core135.string
};

// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesModule.ts
var BubbleSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "bubble",
  moduleFactory: (ctx) => new BubbleSeries(ctx),
  tooltipDefaults: { range: "nearest" },
  defaultAxes: [
    {
      type: "number" /* NUMBER */,
      position: "bottom" /* BOTTOM */
    },
    {
      type: "number" /* NUMBER */,
      position: "left" /* LEFT */
    }
  ],
  themeTemplate: {
    series: {
      shape: "circle",
      size: 7,
      maxSize: 30,
      fill: { $palette: "fill" },
      stroke: { $palette: "stroke" },
      // @ts-expect-error undocumented option
      fillGradientDefaults: {
        type: "gradient",
        gradient: "radial",
        bounds: "item",
        colorStops: { $palette: "gradient" },
        rotation: 0,
        reverse: true
      },
      fillPatternDefaults: FILL_PATTERN_DEFAULTS,
      fillImageDefaults: FILL_IMAGE_DEFAULTS,
      fillOpacity: 0.8,
      tooltip: { position: { _seriesOverrideType: "node" } },
      label: {
        enabled: false,
        fontSize: { $ref: "fontSize" },
        fontFamily: { $ref: "fontFamily" },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "textColor" }
      }
    }
  }
};
var NewBubbleSeriesModule = {
  type: "series",
  name: "bubble",
  chartType: "cartesian",
  options: bubbleSeriesOptionsDef,
  create: (ctx) => new BubbleSeries(ctx)
};

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeries.ts
var import_ag_charts_core136 = require("ag-charts-core");

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesProperties.ts
var HistogramSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.fillGradientDefaults = new FillGradientDefaults();
    this.fillPatternDefaults = new FillPatternDefaults();
    this.fillImageDefaults = new FillImageDefaults();
    this.fillOpacity = 1;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.areaPlot = false;
    this.aggregation = "sum";
    this.shadow = new DropShadow();
    this.label = new Label();
    this.tooltip = new SeriesTooltip();
  }
};
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "fill", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "areaPlot", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "bins", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "aggregation", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "binCount", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "label", 2);
__decorateClass([
  Property
], HistogramSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeries.ts
var defaultBinCount = 10;
var HistogramSeries = class extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
      categoryKey: void 0,
      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],
      datumSelectionGarbageCollection: false,
      animationResetFns: {
        datum: resetBarSelectionsFn,
        label: resetLabelFn
      }
    });
    this.properties = new HistogramSeriesProperties();
    this.calculatedBins = [];
  }
  // During processData phase, used to unify different ways of the user specifying
  // the bins. Returns bins in format[[min1, max1], [min2, max2], ... ].
  deriveBins(xDomain) {
    const binStarts = createTicks(xDomain[0], xDomain[1], defaultBinCount).ticks;
    const binSize = tickStep(xDomain[0], xDomain[1], defaultBinCount);
    const [firstBinEnd] = binStarts;
    const expandStartToBin = (n) => [n, n + binSize];
    return [[firstBinEnd - binSize, firstBinEnd], ...binStarts.map(expandStartToBin)];
  }
  calculateNiceBins(domain, binCount) {
    const startGuess = Math.floor(domain[0]);
    const stop = domain[1];
    const segments = binCount || 1;
    const { start: start2, binSize } = this.calculateNiceStart(startGuess, stop, segments);
    return this.getBins(start2, stop, binSize, segments);
  }
  getBins(start2, stop, step, count) {
    const bins = [];
    const precision = this.calculatePrecision(step);
    for (let i = 0; i < count; i++) {
      const a = Math.round((start2 + i * step) * precision) / precision;
      let b = Math.round((start2 + (i + 1) * step) * precision) / precision;
      if (i === count - 1) {
        b = Math.max(b, stop);
      }
      bins[i] = [a, b];
    }
    return bins;
  }
  calculatePrecision(step) {
    let precision = 10;
    if (isFinite(step) && step > 0) {
      while (step < 1) {
        precision *= 10;
        step *= 10;
      }
    }
    return precision;
  }
  calculateNiceStart(a, b, segments) {
    const binSize = Math.abs(b - a) / segments;
    const order = Math.floor(Math.log10(binSize));
    const magnitude = Math.pow(10, order);
    const start2 = Math.floor(a / magnitude) * magnitude;
    return {
      start: start2,
      binSize
    };
  }
  async processData(dataController) {
    if (!this.visible) {
      this.processedData = void 0;
      this.animationState.transition("updateData");
    }
    const { xKey, yKey, areaPlot, aggregation } = this.properties;
    const xScale = this.axes["x" /* X */]?.scale;
    const yScale = this.axes["y" /* Y */]?.scale;
    const { xScaleType, yScaleType } = this.getScaleInformation({ yScale, xScale });
    const props = [keyProperty(xKey, xScaleType), SORT_DOMAIN_GROUPS];
    if (yKey) {
      let aggProp = groupCount("groupAgg");
      if (aggregation === "count") {
      } else if (aggregation === "sum") {
        aggProp = groupSum("groupAgg");
      } else if (aggregation === "mean") {
        aggProp = groupAverage("groupAgg");
      }
      if (areaPlot) {
        aggProp = area("groupAgg", aggProp);
      }
      props.push(valueProperty(yKey, yScaleType, { invalidValue: void 0 }), aggProp);
    } else {
      props.push(rowCountProperty("count"));
      let aggProp = groupCount("groupAgg");
      if (areaPlot) {
        aggProp = area("groupAgg", aggProp);
      }
      props.push(aggProp);
    }
    const groupByFn = (dataSet) => {
      const xExtent = fixNumericExtent(dataSet.domain.keys[0]);
      if (xExtent.length === 0) {
        dataSet.domain.groups = [];
        return () => [];
      }
      const bins = (0, import_ag_charts_core136.isNumber)(this.properties.binCount) ? this.calculateNiceBins(xExtent, this.properties.binCount) : this.properties.bins ?? this.deriveBins(xExtent);
      const binCount = bins.length;
      this.calculatedBins = [...bins];
      return (keys) => {
        let xValue = keys[0];
        if ((0, import_ag_charts_core136.isDate)(xValue)) {
          xValue = xValue.getTime();
        }
        if (!(0, import_ag_charts_core136.isNumber)(xValue))
          return [];
        for (let i = 0; i < binCount; i++) {
          const nextBin = bins[i];
          if (xValue >= nextBin[0] && xValue < nextBin[1]) {
            return nextBin;
          }
          if (i === binCount - 1 && xValue <= nextBin[1]) {
            return nextBin;
          }
        }
        return [];
      };
    };
    if (!this.ctx.animationManager.isSkipped() && this.processedData) {
      props.push(diff(this.id, this.processedData, false));
    }
    await this.requestDataModel(dataController, this.data, {
      props,
      groupByFn
    });
    this.animationState.transition("updateData");
  }
  xCoordinateRange() {
    return [NaN, NaN];
  }
  yCoordinateRange() {
    return [NaN, NaN];
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel } = this;
    if (!processedData || !dataModel || !this.calculatedBins.length)
      return [];
    const yDomain = dataModel.getDomain(this, `groupAgg`, "aggregate", processedData);
    const xDomainMin = this.calculatedBins?.[0][0];
    const xDomainMax = this.calculatedBins?.[(this.calculatedBins?.length ?? 0) - 1][1];
    if (direction === "x" /* X */) {
      return fixNumericExtent([xDomainMin, xDomainMax]);
    }
    return fixNumericExtent(yDomain);
  }
  getSeriesRange(_direction, [r0, r1]) {
    const { dataModel, processedData } = this;
    if (!dataModel || processedData?.type !== "grouped")
      return [NaN, NaN];
    const xScale = this.axes["x" /* X */].scale;
    const yMin = 0;
    let yMax = -Infinity;
    processedData.groups.forEach(({ keys, aggregation }) => {
      const [[negativeAgg, positiveAgg] = [0, 0]] = aggregation;
      const [xDomainMin, xDomainMax] = keys;
      const [x0, x1] = findMinMax([xScale.convert(xDomainMin), xScale.convert(xDomainMax)]);
      if (x1 >= r0 && x0 <= r1) {
        const total = negativeAgg + positiveAgg;
        yMax = Math.max(yMax, total);
      }
    });
    if (yMin > yMax)
      return [NaN, NaN];
    return [yMin, yMax];
  }
  frequency(group) {
    return group.datumIndices.reduce((acc, datumIndices) => acc + datumIndices.length, 0);
  }
  createNodeData() {
    const { id: seriesId, axes, processedData, dataModel } = this;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!xAxis || !yAxis || !dataModel) {
      return;
    }
    const { scale: xScale } = xAxis;
    const { scale: yScale } = yAxis;
    const { xKey, yKey, xName, yName } = this.properties;
    const labelFormatter = this.properties.label.formatter;
    const nodeData = [];
    const context = {
      itemId: this.properties.yKey ?? this.id,
      nodeData,
      labelData: nodeData,
      scales: this.calculateScaling(),
      animationValid: true,
      visible: this.visible
    };
    if (!this.visible || processedData == null || processedData.type !== "grouped") {
      return context;
    }
    processedData.groups.forEach((group, groupIndex) => {
      const { keys, aggregation } = group;
      const [[negativeAgg, positiveAgg] = [0, 0]] = aggregation;
      const frequency = this.frequency(group);
      const domain = keys;
      const [xDomainMin, xDomainMax] = domain;
      const datum = [...dataModel.forEachDatum(this, processedData, group)];
      const xMinPx = xScale.convert(xDomainMin);
      const xMaxPx = xScale.convert(xDomainMax);
      const total = negativeAgg + positiveAgg;
      const yZeroPx = yScale.convert(0);
      const yMaxPx = yScale.convert(total);
      const w = Math.abs(xMaxPx - xMinPx);
      const h = Math.abs(yMaxPx - yZeroPx);
      const x = Math.min(xMinPx, xMaxPx);
      const y = Math.min(yZeroPx, yMaxPx);
      let selectionDatumLabel = void 0;
      if (total !== 0) {
        selectionDatumLabel = {
          x: x + w / 2,
          y: y + h / 2,
          text: this.cachedDatumCallback(
            createDatumId(groupIndex, "label"),
            () => labelFormatter?.({
              value: total,
              datum,
              seriesId,
              xKey,
              yKey,
              xName,
              yName
            })
          ) ?? yAxis.formatDatum(total)
        };
      }
      const nodeMidPoint = {
        x: x + w / 2,
        y: y + h / 2
      };
      const yAxisReversed = yAxis.isReversed();
      nodeData.push({
        series: this,
        datumIndex: groupIndex,
        datum,
        // required by SeriesNodeDatum, but might not make sense here
        // since each selection is an aggregation of multiple data.
        aggregatedValue: total,
        frequency,
        domain,
        yKey,
        xKey,
        x,
        y,
        xValue: xMinPx,
        yValue: yMaxPx,
        width: w,
        height: h,
        midPoint: nodeMidPoint,
        topLeftCornerRadius: !yAxisReversed,
        topRightCornerRadius: !yAxisReversed,
        bottomRightCornerRadius: yAxisReversed,
        bottomLeftCornerRadius: yAxisReversed,
        label: selectionDatumLabel,
        crisp: true
      });
    });
    nodeData.sort((a, b) => a.x - b.x);
    return context;
  }
  nodeFactory() {
    return new Rect();
  }
  updateDatumSelection(opts) {
    const { nodeData, datumSelection } = opts;
    return datumSelection.update(nodeData, void 0, (datum) => datum.domain.join("_"));
  }
  getItemBaseStyle(highlighted) {
    const { properties } = this;
    const highlightStyle = highlighted ? properties.highlightStyle.item : void 0;
    return getShapeStyle(
      {
        fill: highlightStyle?.fill ?? properties.fill,
        fillOpacity: highlightStyle?.fillOpacity ?? properties.fillOpacity,
        stroke: highlightStyle?.stroke ?? properties.stroke,
        strokeWidth: highlightStyle?.strokeWidth ?? this.getStrokeWidth(properties.strokeWidth),
        strokeOpacity: highlightStyle?.strokeOpacity ?? properties.strokeOpacity,
        lineDash: highlightStyle?.lineDash ?? properties.lineDash,
        lineDashOffset: highlightStyle?.lineDashOffset ?? properties.lineDashOffset,
        cornerRadius: properties.cornerRadius
      },
      properties.fillGradientDefaults,
      properties.fillPatternDefaults,
      properties.fillImageDefaults
    );
  }
  updateDatumNodes(opts) {
    const { isHighlight: isDatumHighlighted } = opts;
    const { shadow } = this.properties;
    const style = this.getItemBaseStyle(isDatumHighlighted);
    const fillBBox = this.getShapeFillBBox();
    opts.datumSelection.each((rect, datum) => {
      const { cornerRadius } = style;
      const { topLeftCornerRadius, topRightCornerRadius, bottomRightCornerRadius, bottomLeftCornerRadius } = datum;
      applyShapeStyle(rect, style, void 0, fillBBox);
      rect.topLeftCornerRadius = topLeftCornerRadius ? cornerRadius : 0;
      rect.topRightCornerRadius = topRightCornerRadius ? cornerRadius : 0;
      rect.bottomRightCornerRadius = bottomRightCornerRadius ? cornerRadius : 0;
      rect.bottomLeftCornerRadius = bottomLeftCornerRadius ? cornerRadius : 0;
      rect.crisp = datum.crisp;
      rect.fillShadow = shadow;
      rect.visible = datum.height > 0;
    });
  }
  updateLabelSelection(opts) {
    const { labelData, labelSelection } = opts;
    return labelSelection.update(labelData, (text) => {
      text.pointerEvents = 1 /* None */;
      text.textAlign = "center";
      text.textBaseline = "middle";
    });
  }
  updateLabelNodes(opts) {
    const { fontStyle, fontWeight, fontFamily, fontSize, color: color7 } = this.properties.label;
    const labelEnabled = this.isLabelEnabled();
    opts.labelSelection.each((text, datum) => {
      if (labelEnabled && datum?.label) {
        text.text = datum.label.text;
        text.x = datum.label.x;
        text.y = datum.label.y;
        text.fontStyle = fontStyle;
        text.fontWeight = fontWeight;
        text.fontFamily = fontFamily;
        text.fontSize = fontSize;
        text.fill = color7;
        text.visible = true;
      } else {
        text.visible = false;
      }
    });
  }
  initQuadTree(quadtree) {
    const { value: childNode } = this.contentGroup.children().next();
    if (childNode) {
      addHitTestersToQuadtree(quadtree, childNode.children());
    }
  }
  pickNodeClosestDatum(point) {
    return findQuadtreeMatch(this, point);
  }
  getTooltipContent(datumIndex) {
    const {
      id: seriesId,
      dataModel,
      processedData,
      axes,
      properties,
      ctx: { localeManager }
    } = this;
    const { xKey, xName, yKey, yName, tooltip } = properties;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!dataModel || processedData?.type !== "grouped" || !xAxis || !yAxis) {
      return;
    }
    const group = processedData.groups[datumIndex];
    const { aggregation, keys } = group;
    const [[negativeAgg, positiveAgg] = [0, 0]] = aggregation;
    const frequency = this.frequency(group);
    const domain = keys;
    const [rangeMin, rangeMax] = domain;
    const aggregatedValue = negativeAgg + positiveAgg;
    const datum = {
      data: [...dataModel.forEachDatum(this, processedData, group)],
      aggregatedValue,
      frequency,
      domain
    };
    const data = [
      {
        label: xName,
        fallbackLabel: xKey,
        value: `${xAxis.formatDatum(rangeMin)} - ${xAxis.formatDatum(rangeMax)}`
      },
      { label: localeManager.t("seriesHistogramTooltipFrequency"), value: yAxis.formatDatum(frequency) }
    ];
    if (yKey != null) {
      let label;
      switch (properties.aggregation) {
        case "sum":
          label = localeManager.t("seriesHistogramTooltipSum", { yName: yName ?? yKey });
          break;
        case "mean":
          label = localeManager.t("seriesHistogramTooltipMean", { yName: yName ?? yKey });
          break;
        case "count":
          label = localeManager.t("seriesHistogramTooltipCount", { yName: yName ?? yKey });
          break;
      }
      data.push({ label, value: yAxis.formatDatum(aggregatedValue) });
    }
    return this.formatTooltipWithContext(
      tooltip,
      {
        symbol: this.legendItemSymbol(),
        data
      },
      {
        seriesId,
        datum,
        title: yName,
        xKey,
        xName,
        yKey,
        yName,
        xRange: [rangeMin, rangeMax],
        frequency,
        ...this.getItemBaseStyle(false)
      }
    );
  }
  legendItemSymbol() {
    const {
      fill,
      fillOpacity,
      stroke: stroke2,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      fillGradientDefaults,
      fillPatternDefaults,
      fillImageDefaults
    } = this.properties;
    return {
      marker: getShapeStyle(
        {
          fill: fill ?? "rgba(0, 0, 0, 0)",
          stroke: stroke2 ?? "rgba(0, 0, 0, 0)",
          fillOpacity,
          strokeOpacity,
          strokeWidth,
          lineDash,
          lineDashOffset
        },
        fillGradientDefaults,
        fillPatternDefaults,
        fillImageDefaults
      )
    };
  }
  getLegendData(legendType) {
    if (legendType !== "category") {
      return [];
    }
    const {
      id: seriesId,
      ctx: { legendManager },
      visible
    } = this;
    const { xKey: itemId, yName, showInLegend } = this.properties;
    return [
      {
        legendType: "category",
        id: seriesId,
        itemId,
        seriesId,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId }),
        label: {
          text: yName ?? itemId ?? "Frequency"
        },
        symbol: this.legendItemSymbol(),
        hideInLegend: !showInLegend
      }
    ];
  }
  animateEmptyUpdateReady({ datumSelection, labelSelection }) {
    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, "normal"));
    fromToMotion(this.id, "datums", this.ctx.animationManager, [datumSelection], fns);
    seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
  }
  animateWaitingUpdateReady(data) {
    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, "normal"));
    const dataDiff = calculateDataDiff(
      this.id,
      data.datumSelection,
      (datum) => createDatumId(datum.domain),
      data.contextData,
      data.previousContextData,
      this.processedData
    );
    fromToMotion(
      this.id,
      "datums",
      this.ctx.animationManager,
      [data.datumSelection],
      fns,
      (_, datum) => createDatumId(datum.domain),
      dataDiff
    );
    if (dataDiff?.changed) {
      seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, data.labelSelection);
    }
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  computeFocusBounds({ datumIndex }) {
    return computeBarFocusBounds(this, this.contextNodeData?.nodeData[datumIndex]);
  }
};
HistogramSeries.className = "HistogramSeries";
HistogramSeries.type = "histogram";

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesOptionsDef.ts
var import_ag_charts_core137 = require("ag-charts-core");
var histogramSeriesThemeableOptionsDef = {
  showInMiniChart: import_ag_charts_core137.boolean,
  cornerRadius: import_ag_charts_core137.positiveNumber,
  label: seriesLabelOptionsDefs,
  tooltip: tooltipOptionsDefs,
  shadow: shadowOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...import_ag_charts_core137.fillOptionsDef,
  ...import_ag_charts_core137.strokeOptionsDef,
  ...import_ag_charts_core137.lineDashOptionsDef
};
var histogramSeriesOptionsDef = {
  ...histogramSeriesThemeableOptionsDef,
  ...commonSeriesOptionsDefs,
  type: (0, import_ag_charts_core137.required)((0, import_ag_charts_core137.constant)("histogram")),
  xKey: (0, import_ag_charts_core137.required)(import_ag_charts_core137.string),
  yKey: import_ag_charts_core137.string,
  xName: import_ag_charts_core137.string,
  yName: import_ag_charts_core137.string,
  areaPlot: import_ag_charts_core137.boolean,
  aggregation: (0, import_ag_charts_core137.union)("count", "sum", "mean"),
  bins: (0, import_ag_charts_core137.arrayOf)((0, import_ag_charts_core137.arrayOf)(import_ag_charts_core137.number)),
  binCount: import_ag_charts_core137.positiveNumber
};

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesModule.ts
var HistogramSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "histogram",
  moduleFactory: (ctx) => new HistogramSeries(ctx),
  tooltipDefaults: { range: "exact" },
  defaultAxes: [
    {
      type: "number" /* NUMBER */,
      position: "bottom" /* BOTTOM */
    },
    {
      type: "number" /* NUMBER */,
      position: "left" /* LEFT */
    }
  ],
  themeTemplate: {
    series: {
      fill: { $palette: "fill" },
      stroke: { $palette: "stroke" },
      // @ts-expect-error undocumented option
      fillGradientDefaults: {
        type: "gradient",
        gradient: "linear",
        bounds: "item",
        colorStops: { $palette: "gradient" },
        rotation: 0,
        reverse: false
      },
      fillPatternDefaults: FILL_PATTERN_DEFAULTS,
      fillImageDefaults: FILL_IMAGE_DEFAULTS,
      strokeWidth: 1,
      fillOpacity: 1,
      strokeOpacity: 1,
      lineDash: [0],
      lineDashOffset: 0,
      label: {
        enabled: false,
        fontSize: { $ref: "fontSize" },
        fontFamily: { $ref: "fontFamily" },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "backgroundColor" }
      },
      shadow: {
        enabled: false,
        color: DEFAULT_SHADOW_COLOUR,
        xOffset: 3,
        yOffset: 3,
        blur: 5
      }
    }
  }
};
var NewHistogramSeriesModule = {
  type: "series",
  name: "histogram",
  chartType: "cartesian",
  enterprise: true,
  options: histogramSeriesOptionsDef,
  create: (ctx) => new HistogramSeries(ctx)
};

// packages/ag-charts-community/src/chart/series/cartesian/lineSeries.ts
var import_ag_charts_core138 = require("ag-charts-core");

// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesProperties.ts
var LineSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.stroke = "#874349";
    this.strokeWidth = 2;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.interpolation = new InterpolationProperties();
    this.marker = new SeriesMarker();
    this.label = new Label();
    this.tooltip = new SeriesTooltip();
    this.connectMissingData = false;
    this.sparklineMode = false;
  }
};
__decorateClass([
  Property
], LineSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "yFilterKey", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "stackGroup", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "normalizedTo", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "title", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "interpolation", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "marker", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "label", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "tooltip", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "connectMissingData", 2);
__decorateClass([
  Property
], LineSeriesProperties.prototype, "sparklineMode", 2);

// packages/ag-charts-community/src/chart/series/cartesian/lineSeries.ts
var CROSS_FILTER_LINE_STROKE_OPACITY_FACTOR = 0.25;
var LineSeries = class extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
      categoryKey: "xValue",
      hasMarkers: true,
      pickModes: [
        2 /* AXIS_ALIGNED */,
        1 /* NEAREST_NODE */,
        0 /* EXACT_SHAPE_MATCH */
      ],
      markerSelectionGarbageCollection: false,
      animationResetFns: {
        path: buildResetPathFn({ getVisible: () => this.visible, getOpacity: () => this.getOpacity() }),
        label: resetLabelFn,
        marker: (node, datum) => ({ ...resetMarkerFn(node), ...resetMarkerPositionFn(node, datum) })
      },
      clipFocusBox: false
    });
    this.properties = new LineSeriesProperties();
    this.dataAggregationFilters = void 0;
  }
  get pickModeAxis() {
    return this.properties.sparklineMode ? "main" : "main-category";
  }
  async processData(dataController) {
    if (this.data == null)
      return;
    const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 0 } = {} } = this;
    const { xKey, yKey, yFilterKey, connectMissingData, normalizedTo } = this.properties;
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const xScale = this.axes["x" /* X */]?.scale;
    const yScale = this.axes["y" /* Y */]?.scale;
    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const stacked = stackCount >= 1 || normalizedTo != null;
    const common = { invalidValue: null };
    if (connectMissingData && stacked) {
      common.invalidValue = 0;
    }
    if (stacked && !visible) {
      common.forceValue = 0;
    }
    const props = [];
    if (!isContinuousX || stacked) {
      props.push(keyProperty(xKey, xScaleType, { id: "xKey" }));
    }
    props.push(
      valueProperty(xKey, xScaleType, { id: "xValue" }),
      valueProperty(yKey, yScaleType, {
        id: `yValueRaw`,
        ...common,
        invalidValue: void 0
      })
    );
    if (yFilterKey != null) {
      props.push(valueProperty(yFilterKey, yScaleType, { id: "yFilterRaw" }));
    }
    if (stacked) {
      const ids = [
        `line-stack-${groupIndex}-yValues`,
        `line-stack-${groupIndex}-yValues-trailing`,
        `line-stack-${groupIndex}-yValues-marker`
      ];
      props.push(
        ...groupAccumulativeValueProperty(
          yKey,
          "window",
          "current",
          { id: `yValueEnd`, ...common, groupId: ids[0] },
          yScaleType
        ),
        ...groupAccumulativeValueProperty(
          yKey,
          "window-trailing",
          "current",
          { id: `yValueStart`, ...common, groupId: ids[1] },
          yScaleType
        ),
        ...groupAccumulativeValueProperty(
          yKey,
          "normal",
          "current",
          { id: `yValueCumulative`, ...common, groupId: ids[2] },
          yScaleType
        )
      );
      if ((0, import_ag_charts_core138.isDefined)(normalizedTo)) {
        props.push(normaliseGroupTo([ids[0], ids[1], ids[2]], normalizedTo));
      }
    }
    if (animationEnabled) {
      props.push(animationValidation(isContinuousX ? ["xValue"] : void 0));
      if (this.processedData) {
        props.push(diff(this.id, this.processedData));
      }
    }
    const { dataModel, processedData } = await this.requestDataModel(dataController, data, {
      props,
      groupByKeys: stacked,
      groupByData: !stacked
    });
    this.dataAggregationFilters = this.aggregateData(dataModel, processedData);
    this.animationState.transition("updateData");
  }
  xCoordinateRange(xValue, pixelSize) {
    const { marker } = this.properties;
    const x = this.axes["x" /* X */].scale.convert(xValue);
    const r = marker.enabled ? 0.5 * marker.size * pixelSize : 0;
    return [x - r, x + r];
  }
  yCoordinateRange(yValues, pixelSize) {
    const { marker } = this.properties;
    const y = this.axes["y" /* Y */].scale.convert(yValues[0]);
    const r = marker.enabled ? 0.5 * marker.size * pixelSize : 0;
    return [y - r, y + r];
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData)
      return [];
    if (direction === "x" /* X */) {
      const xDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
      const domain = dataModel.getDomain(this, `xValue`, "value", processedData);
      if (xDef?.def.type === "value" && xDef.def.valueType === "category") {
        return domain;
      }
      return fixNumericExtent(extent(domain));
    }
    const yKey = this.dataModel?.hasColumnById(this, `yValueEnd`) ? "yValueEnd" : "yValueRaw";
    const yExtent = this.domainForClippedRange("y" /* Y */, [yKey], "xValue", true);
    return fixNumericExtent(yExtent);
  }
  getSeriesRange(_direction, visibleRange) {
    const yKey = this.dataModel?.hasColumnById(this, `yValueEnd`) ? "yValueEnd" : "yValueRaw";
    return this.domainForVisibleRange("y" /* Y */, [yKey], "xValue", visibleRange, true);
  }
  getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {
    const yKey = this.dataModel?.hasColumnById(this, `yValueEnd`) ? "yValueEnd" : "yValueRaw";
    return this.countVisibleItems("xValue", [yKey], xVisibleRange, yVisibleRange, minVisibleItems);
  }
  aggregateData(_dataModel, _processedData) {
    return;
  }
  createNodeData() {
    const { dataModel, processedData, axes, dataAggregationFilters } = this;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!dataModel || !processedData || !xAxis || !yAxis)
      return;
    const {
      xKey,
      yKey,
      yFilterKey,
      xName,
      yName,
      marker,
      label,
      connectMissingData,
      interpolation,
      legendItemName
    } = this.properties;
    const stacked = this.dataModel?.hasColumnById(this, `yValueEnd`);
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    const xOffset = (xScale.bandwidth ?? 0) / 2;
    const yOffset = (yScale.bandwidth ?? 0) / 2;
    const size = marker.enabled ? marker.size : 0;
    const rawData = processedData.dataSources.get(this.id) ?? [];
    const xValues = dataModel.resolveColumnById(this, `xValue`, processedData);
    const yValues = dataModel.resolveColumnById(this, `yValueRaw`, processedData);
    const yEndValues = stacked ? dataModel.resolveColumnById(this, `yValueEnd`, processedData) : void 0;
    const yCumulativeValues = stacked ? dataModel.resolveColumnById(this, `yValueCumulative`, processedData) : yValues;
    const selectionValues = yFilterKey != null ? dataModel.resolveColumnById(this, `yFilterRaw`, processedData) : void 0;
    const xPosition = (index) => xScale.convert(xValues[index]) + xOffset;
    const yPosition = (index) => yScale.convert(yCumulativeValues[index]) + yOffset;
    const capDefaults = {
      lengthRatioMultiplier: this.properties.marker.getDiameter(),
      lengthMax: Infinity
    };
    const nodeData = [];
    let spanPoints;
    const handleDatum = (datumIndex) => {
      const datum = rawData[datumIndex];
      const xDatum = xValues[datumIndex];
      const yDatum = yValues[datumIndex];
      const yEndDatum = yEndValues?.[datumIndex];
      const selected = selectionValues?.[datumIndex];
      const x = xPosition(datumIndex);
      const y = yPosition(datumIndex);
      if (!Number.isFinite(x))
        return;
      if (yDatum != null) {
        const labelText = label.enabled ? this.getLabelText(label, {
          value: yDatum,
          datum,
          xKey,
          yKey,
          xName,
          yName,
          legendItemName
        }) : void 0;
        nodeData.push({
          series: this,
          datum,
          datumIndex,
          yKey,
          xKey,
          point: { x, y, size },
          midPoint: { x, y },
          cumulativeValue: yEndDatum,
          yValue: yDatum,
          xValue: xDatum,
          capDefaults,
          labelText,
          selected
        });
      }
      if (spanPoints == null)
        return;
      const currentSpanPoints = spanPoints[spanPoints.length - 1];
      if (yDatum != null) {
        const spanPoint = {
          point: { x, y },
          xDatum,
          yDatum
        };
        if (Array.isArray(currentSpanPoints)) {
          currentSpanPoints.push(spanPoint);
        } else if (currentSpanPoints != null) {
          currentSpanPoints.skip += 1;
          spanPoints.push([spanPoint]);
        } else {
          spanPoints.push([spanPoint]);
        }
      } else if (!connectMissingData) {
        if (Array.isArray(currentSpanPoints) || currentSpanPoints == null) {
          spanPoints.push({ skip: 0 });
        } else {
          currentSpanPoints.skip += 1;
        }
      }
    };
    const [r0, r1] = xScale.range;
    const range3 = r1 - r0;
    const dataAggregationFilter = dataAggregationFilters?.find((f) => f.maxRange > range3);
    const indices = dataAggregationFilter?.indices;
    let [start2, end2] = this.visibleRange("xValue", xAxis.range, indices);
    start2 = Math.max(start2 - 1, 0);
    end2 = Math.min(end2 + 1, indices?.length ?? xValues.length);
    if (processedData.input.count < 1e3) {
      start2 = 0;
      end2 = processedData.input.count;
    }
    if (indices == null) {
      spanPoints = [];
    }
    for (let i = start2; i < end2; i += 1) {
      handleDatum(indices?.[i] ?? i);
    }
    const strokeSpans = spanPoints?.flatMap((p) => {
      return Array.isArray(p) ? interpolatePoints(p, interpolation) : [];
    });
    const strokeData = strokeSpans != null ? { itemId: yKey, spans: strokeSpans } : void 0;
    const crossFiltering = selectionValues?.some((selectionValue, index) => selectionValue === yValues[index]) ?? false;
    return {
      itemId: yKey,
      nodeData,
      labelData: nodeData,
      strokeData,
      scales: this.calculateScaling(),
      visible: this.visible,
      crossFiltering
    };
  }
  isPathOrSelectionDirty() {
    return this.properties.marker.isDirty();
  }
  updatePathNodes(opts) {
    const {
      paths: [lineNode],
      opacity,
      visible,
      animationEnabled
    } = opts;
    const crossFiltering = this.contextNodeData?.crossFiltering === true;
    lineNode.setProperties({
      fill: void 0,
      lineJoin: "round",
      pointerEvents: 1 /* None */,
      opacity,
      stroke: this.properties.stroke,
      strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),
      strokeOpacity: this.properties.strokeOpacity * (crossFiltering ? CROSS_FILTER_LINE_STROKE_OPACITY_FACTOR : 1),
      lineDash: this.properties.lineDash,
      lineDashOffset: this.properties.lineDashOffset
    });
    if (!animationEnabled) {
      lineNode.visible = visible;
    }
    updateClipPath(this, lineNode);
  }
  getMarkerItemBaseStyle(highlighted) {
    const { properties } = this;
    const { marker } = properties;
    const highlightStyle = highlighted ? properties.highlightStyle.item : void 0;
    return getShapeStyle(
      {
        size: marker.size,
        shape: marker.shape,
        fill: highlightStyle?.fill ?? marker.fill,
        fillOpacity: highlightStyle?.fillOpacity ?? marker.fillOpacity,
        stroke: highlightStyle?.stroke ?? marker.stroke,
        strokeWidth: highlightStyle?.strokeWidth ?? marker.strokeWidth,
        strokeOpacity: highlightStyle?.strokeOpacity ?? marker.strokeOpacity,
        lineDash: highlightStyle?.lineDash ?? marker.lineDash,
        lineDashOffset: highlightStyle?.lineDashOffset ?? marker.lineDashOffset
      },
      marker.fillGradientDefaults,
      marker.fillPatternDefaults,
      marker.fillImageDefaults
    );
  }
  getMarkerItemStyleOverrides(datumId, datum, format, highlighted) {
    const { id: seriesId, properties } = this;
    const { xKey, yKey, marker } = properties;
    const { itemStyler } = marker;
    if (itemStyler == null)
      return;
    return this.cachedDatumCallback(createDatumId(datumId, highlighted ? "highlight" : "node"), () => {
      const xDomain = this.getSeriesDomain("x" /* X */);
      const yDomain = this.getSeriesDomain("y" /* Y */);
      return this.callWithContext(itemStyler, {
        seriesId,
        ...datumStylerProperties(datum, xKey, yKey, xDomain, yDomain),
        datum,
        highlighted,
        ...format
      });
    });
  }
  updateMarkerSelection(opts) {
    let { nodeData } = opts;
    const { markerSelection } = opts;
    const markersEnabled = this.properties.marker.enabled || this.contextNodeData?.crossFiltering === true;
    nodeData = markersEnabled ? nodeData : [];
    if (this.properties.marker.isDirty()) {
      markerSelection.clear();
      markerSelection.cleanup();
    }
    return markerSelection.update(nodeData, void 0, (datum) => createDatumId(datum.xValue));
  }
  updateMarkerNodes(opts) {
    const { markerSelection, isHighlight: highlighted } = opts;
    const { xKey, yKey, stroke: stroke2, strokeWidth, strokeOpacity, marker, highlightStyle } = this.properties;
    const xDomain = this.getSeriesDomain("x" /* X */);
    const yDomain = this.getSeriesDomain("y" /* Y */);
    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle(), {
      stroke: stroke2,
      strokeWidth,
      strokeOpacity
    });
    const applyTranslation = this.ctx.animationManager.isSkipped();
    const fillBBox = this.getShapeFillBBox();
    markerSelection.each((node, datum) => {
      this.updateMarkerStyle(
        marker,
        node,
        datum.datum,
        datum.point,
        datumStylerProperties(datum, xKey, yKey, xDomain, yDomain),
        highlighted,
        baseStyle,
        fillBBox,
        { applyTranslation, selected: datum.selected }
      );
    });
    if (!highlighted) {
      marker.markClean();
    }
  }
  updateLabelSelection(opts) {
    return opts.labelSelection.update(this.isLabelEnabled() ? opts.labelData : []);
  }
  updateLabelNodes(opts) {
    const { enabled, fontStyle, fontWeight, fontSize, fontFamily, color: color7 } = this.properties.label;
    opts.labelSelection.each((text, datum) => {
      if (enabled && datum?.labelText) {
        text.fontStyle = fontStyle;
        text.fontWeight = fontWeight;
        text.fontSize = fontSize;
        text.fontFamily = fontFamily;
        text.textAlign = "center";
        text.textBaseline = "bottom";
        text.text = datum.labelText;
        text.x = datum.point.x;
        text.y = datum.point.y - 10;
        text.fill = color7;
        text.visible = true;
      } else {
        text.visible = false;
      }
    });
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, axes, properties } = this;
    const { xKey, xName, yKey, yName, tooltip } = properties;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!dataModel || !processedData || !xAxis || !yAxis) {
      return;
    }
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const xValue = dataModel.resolveColumnById(this, `xValue`, processedData)[datumIndex];
    const yValue = dataModel.resolveColumnById(this, `yValueRaw`, processedData)[datumIndex];
    if (xValue == null)
      return;
    const format = this.getMarkerItemBaseStyle(false);
    Object.assign(format, this.getMarkerItemStyleOverrides(String(datumIndex), datum, format, false));
    return this.formatTooltipWithContext(
      tooltip,
      {
        heading: xAxis.formatDatum(xValue),
        symbol: this.legendItemSymbol(),
        data: [{ label: yName, fallbackLabel: yKey, value: yAxis.formatDatum(yValue) }]
      },
      {
        seriesId,
        datum,
        title: yName,
        xKey,
        xName,
        yKey,
        yName,
        ...format,
        ...this.getModuleTooltipParams()
      }
    );
  }
  legendItemSymbol() {
    const color0 = "rgba(0, 0, 0, 0)";
    const { stroke: stroke2, strokeOpacity, strokeWidth, lineDash, marker } = this.properties;
    const markerStyle = this.getMarkerStyle(marker, void 0, void 0, false, void 0, {
      fill: marker.fill ?? color0,
      stroke: marker.stroke ?? stroke2 ?? color0
    });
    return {
      marker: {
        ...markerStyle,
        enabled: marker.enabled
      },
      line: {
        stroke: stroke2 ?? color0,
        strokeOpacity,
        strokeWidth,
        lineDash
      }
    };
  }
  getLegendData(legendType) {
    if (legendType !== "category") {
      return [];
    }
    const {
      id: seriesId,
      ctx: { legendManager },
      visible
    } = this;
    const { yKey: itemId, yName, title, legendItemName, showInLegend } = this.properties;
    return [
      {
        legendType: "category",
        id: seriesId,
        itemId,
        legendItemName,
        seriesId,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId }),
        label: {
          text: legendItemName ?? title ?? yName ?? itemId
        },
        symbol: this.legendItemSymbol(),
        hideInLegend: !showInLegend
      }
    ];
  }
  updatePaths(opts) {
    this.updateLinePaths(opts.paths, opts.contextData);
  }
  plotNodeDataPoints(path, nodeData) {
    if (nodeData.length === 0)
      return;
    const initialPoint = nodeData[0].point;
    path.moveTo(initialPoint.x, initialPoint.y);
    for (let i = 1; i < nodeData.length; i += 1) {
      const { x, y } = nodeData[i].point;
      path.lineTo(x, y);
    }
  }
  updateLinePaths(paths, contextData) {
    const spans = contextData.strokeData?.spans;
    const [lineNode] = paths;
    lineNode.path.clear();
    if (spans != null) {
      plotLinePathStroke(lineNode, spans);
    } else {
      this.plotNodeDataPoints(lineNode.path, contextData.nodeData);
    }
    lineNode.markDirty("LineSeries");
  }
  animateEmptyUpdateReady(animationData) {
    const { markerSelection, labelSelection, annotationSelections, contextData, paths } = animationData;
    const { animationManager } = this.ctx;
    this.updateLinePaths(paths, contextData);
    pathSwipeInAnimation(this, animationManager, ...paths);
    resetMotion([markerSelection], resetMarkerPositionFn);
    markerSwipeScaleInAnimation(this, animationManager, markerSelection);
    seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
    seriesLabelFadeInAnimation(this, "annotations", animationManager, ...annotationSelections);
  }
  animateReadyResize(animationData) {
    const { contextData, paths } = animationData;
    this.updateLinePaths(paths, contextData);
    super.animateReadyResize(animationData);
  }
  animateWaitingUpdateReady(animationData) {
    const { animationManager } = this.ctx;
    const {
      markerSelection: markerSelections,
      labelSelection: labelSelections,
      annotationSelections,
      contextData,
      paths,
      previousContextData
    } = animationData;
    const [path] = paths;
    this.resetMarkerAnimation(animationData);
    this.resetLabelAnimation(animationData);
    const update = () => {
      this.resetPathAnimation(animationData);
      this.updateLinePaths(paths, contextData);
    };
    const skip = () => {
      animationManager.skipCurrentBatch();
      update();
    };
    if (contextData == null || previousContextData == null) {
      update();
      markerFadeInAnimation(this, animationManager, "added", markerSelections);
      pathFadeInAnimation(this, "path_properties", animationManager, "add", path);
      seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelections);
      seriesLabelFadeInAnimation(this, "annotations", animationManager, ...annotationSelections);
      return;
    }
    if (contextData.crossFiltering !== previousContextData.crossFiltering) {
      skip();
      return;
    }
    const fns = prepareLinePathAnimation(
      contextData,
      previousContextData,
      this.processedData?.reduced?.diff?.[this.id]
    );
    if (fns === void 0) {
      skip();
      return;
    } else if (fns.status === "no-op") {
      return;
    }
    fromToMotion(this.id, "path_properties", animationManager, [path], fns.stroke.pathProperties);
    if (fns.status === "added") {
      this.updateLinePaths(paths, contextData);
    } else if (fns.status === "removed") {
      this.updateLinePaths(paths, previousContextData);
    } else {
      pathMotion(this.id, "path_update", animationManager, [path], fns.stroke.path);
    }
    if (fns.hasMotion) {
      markerFadeInAnimation(this, animationManager, void 0, markerSelections);
      seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelections);
      seriesLabelFadeInAnimation(this, "annotations", animationManager, ...annotationSelections);
    }
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  getBandScalePadding() {
    return { inner: 1, outer: 0.1 };
  }
  nodeFactory() {
    return new Group();
  }
  getFormattedMarkerStyle(datum) {
    const { xKey, yKey } = this.properties;
    const xDomain = this.getSeriesDomain("x" /* X */);
    const yDomain = this.getSeriesDomain("y" /* Y */);
    return this.getMarkerStyle(
      this.properties.marker,
      datum.datum,
      datumStylerProperties(datum, xKey, yKey, xDomain, yDomain),
      true
    );
  }
  computeFocusBounds(opts) {
    return computeMarkerFocusBounds(this, opts);
  }
};
LineSeries.className = "LineSeries";
LineSeries.type = "line";

// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesModule.ts
var LineSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "line",
  moduleFactory: (ctx) => new LineSeries(ctx),
  stackable: true,
  tooltipDefaults: { range: "nearest" },
  defaultAxes: [
    {
      type: "number" /* NUMBER */,
      position: "left" /* LEFT */
    },
    {
      type: "category" /* CATEGORY */,
      position: "bottom" /* BOTTOM */
    }
  ],
  themeTemplate: {
    series: {
      tooltip: { position: { _seriesOverrideType: "node" } },
      stroke: SAFE_STROKE_FILL_OPERATION,
      strokeWidth: 2,
      strokeOpacity: 1,
      lineDash: [0],
      lineDashOffset: 0,
      interpolation: {
        type: "linear"
      },
      marker: {
        shape: "circle",
        size: 7,
        strokeWidth: 0,
        fill: { $palette: "fill" },
        stroke: { $palette: "stroke" },
        // @ts-expect-error undocumented option
        fillGradientDefaults: {
          type: "gradient",
          gradient: "radial",
          bounds: "item",
          colorStops: { $palette: "gradient" },
          rotation: 0,
          reverse: true
        },
        fillPatternDefaults: FILL_PATTERN_DEFAULTS,
        fillImageDefaults: FILL_IMAGE_DEFAULTS
      },
      label: {
        enabled: false,
        fontSize: { $ref: "fontSize" },
        fontFamily: { $ref: "fontFamily" },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "textColor" }
      },
      errorBar: {
        cap: {
          lengthRatio: 1
        }
      }
    }
  }
};
var NewLineSeriesModule = {
  type: "series",
  name: "line",
  chartType: "cartesian",
  options: lineSeriesOptionsDef,
  create: (ctx) => new LineSeries(ctx)
};

// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesProperties.ts
var ScatterSeriesLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.placement = "top";
  }
};
__decorateClass([
  Property
], ScatterSeriesLabel.prototype, "placement", 2);
var ScatterSeriesProperties = class extends CartesianSeriesProperties {
  constructor() {
    super(...arguments);
    this.label = new ScatterSeriesLabel();
    this.tooltip = new SeriesTooltip();
    // No validation. Not a part of the options contract.
    this.marker = new SeriesMarker();
  }
};
__decorateClass([
  Property
], ScatterSeriesProperties.prototype, "xKey", 2);
__decorateClass([
  Property
], ScatterSeriesProperties.prototype, "yKey", 2);
__decorateClass([
  Property
], ScatterSeriesProperties.prototype, "labelKey", 2);
__decorateClass([
  Property
], ScatterSeriesProperties.prototype, "xFilterKey", 2);
__decorateClass([
  Property
], ScatterSeriesProperties.prototype, "yFilterKey", 2);
__decorateClass([
  Property
], ScatterSeriesProperties.prototype, "xName", 2);
__decorateClass([
  Property
], ScatterSeriesProperties.prototype, "yName", 2);
__decorateClass([
  Property
], ScatterSeriesProperties.prototype, "labelName", 2);
__decorateClass([
  Property
], ScatterSeriesProperties.prototype, "title", 2);
__decorateClass([
  ProxyProperty("marker.shape")
], ScatterSeriesProperties.prototype, "shape", 2);
__decorateClass([
  ProxyProperty("marker.size")
], ScatterSeriesProperties.prototype, "size", 2);
__decorateClass([
  ProxyProperty("marker.fill")
], ScatterSeriesProperties.prototype, "fill", 2);
__decorateClass([
  ProxyProperty("marker.fillGradientDefaults")
], ScatterSeriesProperties.prototype, "fillGradientDefaults", 2);
__decorateClass([
  ProxyProperty("marker.fillPatternDefaults")
], ScatterSeriesProperties.prototype, "fillPatternDefaults", 2);
__decorateClass([
  ProxyProperty("marker.fillImageDefaults")
], ScatterSeriesProperties.prototype, "fillImageDefaults", 2);
__decorateClass([
  ProxyProperty("marker.fillOpacity")
], ScatterSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  ProxyProperty("marker.stroke")
], ScatterSeriesProperties.prototype, "stroke", 2);
__decorateClass([
  ProxyProperty("marker.strokeWidth")
], ScatterSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  ProxyProperty("marker.strokeOpacity")
], ScatterSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  ProxyProperty("marker.lineDash")
], ScatterSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  ProxyProperty("marker.lineDashOffset")
], ScatterSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  ProxyProperty("marker.itemStyler")
], ScatterSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Property
], ScatterSeriesProperties.prototype, "label", 2);
__decorateClass([
  Property
], ScatterSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-community/src/chart/series/cartesian/scatterSeries.ts
var ScatterSeries = class extends CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
      categoryKey: void 0,
      pickModes: [
        2 /* AXIS_ALIGNED */,
        1 /* NEAREST_NODE */,
        0 /* EXACT_SHAPE_MATCH */
      ],
      pathsPerSeries: [],
      hasMarkers: true,
      markerSelectionGarbageCollection: false,
      animationResetFns: {
        marker: resetMarkerFn,
        label: resetLabelFn
      },
      usesPlacedLabels: true,
      clipFocusBox: false
    });
    this.properties = new ScatterSeriesProperties();
  }
  get pickModeAxis() {
    return "main-category";
  }
  async processData(dataController) {
    if (this.data == null || !this.visible)
      return;
    const xScale = this.axes["x" /* X */]?.scale;
    const yScale = this.axes["y" /* Y */]?.scale;
    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
    const { xKey, yKey, xFilterKey, yFilterKey, labelKey } = this.properties;
    await this.requestDataModel(dataController, this.data, {
      props: [
        valueProperty(xKey, xScaleType, { id: `xValue` }),
        valueProperty(yKey, yScaleType, { id: `yValue` }),
        ...xFilterKey != null ? [valueProperty(xFilterKey, xScaleType, { id: "xFilterValue" })] : [],
        ...yFilterKey != null ? [valueProperty(yFilterKey, yScaleType, { id: "yFilterValue" })] : [],
        ...labelKey ? [valueProperty(labelKey, "band", { id: `labelValue` })] : []
      ]
    });
    this.animationState.transition("updateData");
  }
  xCoordinateRange(xValue, pixelSize) {
    const x = this.axes["x" /* X */].scale.convert(xValue);
    const r = 0.5 * this.properties.size * pixelSize;
    return [x - r, x + r];
  }
  yCoordinateRange(yValues, pixelSize) {
    const y = this.axes["y" /* Y */].scale.convert(yValues[0]);
    const r = 0.5 * this.properties.size * pixelSize;
    return [y - r, y + r];
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!processedData || !dataModel)
      return [];
    const dataValues = {
      ["x" /* X */]: "xValue",
      ["y" /* Y */]: "yValue"
    };
    const id = dataValues[direction];
    const dataDef = dataModel.resolveProcessedDataDefById(this, id);
    const domain = dataModel.getDomain(this, id, "value", processedData);
    if (dataDef?.def.type === "value" && dataDef?.def.valueType === "category") {
      return domain;
    }
    const crossDirection = direction === "x" /* X */ ? "y" /* Y */ : "x" /* X */;
    const crossId = dataValues[crossDirection];
    const ext = this.domainForClippedRange(direction, [id], crossId, false);
    return fixNumericExtent(extent(ext));
  }
  getSeriesRange(_direction, visibleRange) {
    return this.domainForVisibleRange("y" /* Y */, ["yValue"], "xValue", visibleRange, false);
  }
  getVisibleItems(xVisibleRange, yVisibleRange, minVisibleItems) {
    return this.countVisibleItems("xValue", ["yValue"], xVisibleRange, yVisibleRange, minVisibleItems);
  }
  createNodeData() {
    const { axes, dataModel, processedData, visible } = this;
    const { xKey, yKey, xFilterKey, yFilterKey, labelKey, xName, yName, labelName, marker, label } = this.properties;
    const { placement } = label;
    const anchor = Marker.anchor(marker.shape);
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!(dataModel && processedData && visible && xAxis && yAxis))
      return;
    const xDataValues = dataModel.resolveColumnById(this, `xValue`, processedData);
    const yDataValues = dataModel.resolveColumnById(this, `yValue`, processedData);
    const labelDataValues = labelKey != null ? dataModel.resolveColumnById(this, `labelValue`, processedData) : void 0;
    const xFilterDataValues = xFilterKey != null ? dataModel.resolveColumnById(this, `xFilterValue`, processedData) : void 0;
    const yFilterDataValues = yFilterKey != null ? dataModel.resolveColumnById(this, `yFilterValue`, processedData) : void 0;
    const xScale = xAxis.scale;
    const yScale = yAxis.scale;
    const xOffset = (xScale.bandwidth ?? 0) / 2;
    const yOffset = (yScale.bandwidth ?? 0) / 2;
    const nodeData = [];
    const font2 = label.getFont();
    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font: font2 });
    const rawData = processedData.dataSources.get(this.id) ?? [];
    rawData.forEach((datum, datumIndex) => {
      const xDatum = xDataValues[datumIndex];
      const yDatum = yDataValues[datumIndex];
      const x = xScale.convert(xDatum) + xOffset;
      const y = yScale.convert(yDatum) + yOffset;
      const selected = xFilterDataValues != null && yFilterDataValues != null ? xFilterDataValues[datumIndex] === xDatum && yFilterDataValues[datumIndex] === yDatum : void 0;
      const labelText = this.getLabelText(label, {
        value: labelDataValues != null ? labelDataValues?.[datumIndex] : yDatum,
        datum,
        xKey,
        yKey,
        labelKey,
        xName,
        yName,
        labelName
      });
      const size = textMeasurer.measureText(labelText);
      nodeData.push({
        series: this,
        itemId: yKey,
        yKey,
        xKey,
        datum,
        datumIndex,
        xValue: xDatum,
        yValue: yDatum,
        capDefaults: { lengthRatioMultiplier: marker.getDiameter(), lengthMax: Infinity },
        point: { x, y, size: marker.size },
        midPoint: { x, y },
        label: { text: labelText, ...size },
        anchor,
        placement,
        selected
      });
    });
    return {
      itemId: yKey,
      nodeData,
      labelData: nodeData,
      scales: this.calculateScaling(),
      visible: this.visible
    };
  }
  isPathOrSelectionDirty() {
    return this.properties.marker.isDirty();
  }
  getLabelData() {
    if (!this.isLabelEnabled())
      return [];
    return this.contextNodeData?.labelData ?? [];
  }
  updateMarkerSelection(opts) {
    const { nodeData, markerSelection } = opts;
    if (this.properties.marker.isDirty()) {
      markerSelection.clear();
      markerSelection.cleanup();
    }
    return markerSelection.update(this.properties.marker.enabled ? nodeData : []);
  }
  updateMarkerNodes(opts) {
    const { markerSelection, isHighlight: highlighted } = opts;
    const { xKey, yKey, labelKey, marker, highlightStyle } = this.properties;
    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle());
    const fillBBox = this.getShapeFillBBox();
    markerSelection.each((node, datum) => {
      this.updateMarkerStyle(
        marker,
        node,
        datum.datum,
        datum.point,
        { xKey, yKey, labelKey },
        highlighted,
        baseStyle,
        fillBBox,
        { selected: datum.selected }
      );
    });
    if (!highlighted) {
      marker.markClean();
    }
  }
  updatePlacedLabelData(labelData) {
    this.labelSelection.update(
      labelData.map((v) => ({
        ...v.datum,
        point: {
          x: v.x,
          y: v.y,
          size: v.datum.point.size
        }
      })),
      (text) => {
        text.pointerEvents = 1 /* None */;
      }
    );
    this.updateLabelNodes({ labelSelection: this.labelSelection });
  }
  updateLabelNodes(opts) {
    const { label } = this.properties;
    opts.labelSelection.each((text, datum) => {
      text.text = datum.label.text;
      text.fill = label.color;
      text.x = datum.point?.x ?? 0;
      text.y = datum.point?.y ?? 0;
      text.fontStyle = label.fontStyle;
      text.fontWeight = label.fontWeight;
      text.fontSize = label.fontSize;
      text.fontFamily = label.fontFamily;
      text.textAlign = "left";
      text.textBaseline = "top";
    });
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, axes, properties } = this;
    const { xKey, xName, yKey, yName, labelKey, labelName, title, tooltip, marker } = properties;
    const xAxis = axes["x" /* X */];
    const yAxis = axes["y" /* Y */];
    if (!dataModel || !processedData || !xAxis || !yAxis) {
      return;
    }
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const xValue = dataModel.resolveColumnById(this, `xValue`, processedData)[datumIndex];
    const yValue = dataModel.resolveColumnById(this, `yValue`, processedData)[datumIndex];
    const nodeDatum = this.contextNodeData?.nodeData[datumIndex];
    if (xValue == null || nodeDatum == null)
      return;
    const activeStyle = this.getMarkerStyle(marker, nodeDatum.datum, {
      xKey,
      yKey,
      labelKey,
      highlighted: true
    });
    return this.formatTooltipWithContext(
      tooltip,
      {
        symbol: this.legendItemSymbol(),
        title,
        data: [
          { label: xName, fallbackLabel: xKey, value: xAxis.formatDatum(xValue) },
          { label: yName, fallbackLabel: yKey, value: yAxis.formatDatum(yValue) }
        ]
      },
      {
        seriesId,
        datum,
        title: yName,
        xKey,
        xName,
        yKey,
        yName,
        labelKey,
        labelName,
        ...activeStyle,
        ...this.getModuleTooltipParams()
      }
    );
  }
  legendItemSymbol() {
    const marker = this.getMarkerStyle(this.properties.marker);
    return {
      marker
    };
  }
  getLegendData(legendType) {
    if (legendType !== "category") {
      return [];
    }
    const { yKey: itemId, yName, title, showInLegend } = this.properties;
    const {
      id: seriesId,
      ctx: { legendManager },
      visible
    } = this;
    return [
      {
        legendType: "category",
        id: seriesId,
        itemId,
        seriesId,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId }),
        label: {
          text: title ?? yName ?? itemId
        },
        symbol: this.legendItemSymbol(),
        hideInLegend: !showInLegend
      }
    ];
  }
  animateEmptyUpdateReady(data) {
    const { markerSelection, labelSelection, annotationSelections } = data;
    markerScaleInAnimation(this, this.ctx.animationManager, markerSelection);
    seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
    seriesLabelFadeInAnimation(this, "annotations", this.ctx.animationManager, ...annotationSelections);
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  nodeFactory() {
    return new Group();
  }
  getFormattedMarkerStyle(datum) {
    const { xKey, yKey, labelKey } = this.properties;
    return this.getMarkerStyle(this.properties.marker, datum.datum, { xKey, yKey, labelKey }, true);
  }
  computeFocusBounds(opts) {
    return computeMarkerFocusBounds(this, opts);
  }
};
ScatterSeries.className = "ScatterSeries";
ScatterSeries.type = "scatter";

// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesOptionsDef.ts
var import_ag_charts_core139 = require("ag-charts-core");
var scatterSeriesThemeableOptionsDef = {
  title: import_ag_charts_core139.string,
  showInMiniChart: import_ag_charts_core139.boolean,
  label: {
    placement: (0, import_ag_charts_core139.union)("top", "right", "bottom", "left"),
    ...seriesLabelOptionsDefs
  },
  tooltip: tooltipOptionsDefs,
  errorBar: errorBarThemeableOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...without(markerOptionsDefs, ["enabled"])
};
var scatterSeriesOptionsDef = {
  ...scatterSeriesThemeableOptionsDef,
  ...commonSeriesOptionsDefs,
  type: (0, import_ag_charts_core139.required)((0, import_ag_charts_core139.constant)("scatter")),
  xKey: (0, import_ag_charts_core139.required)(import_ag_charts_core139.string),
  yKey: (0, import_ag_charts_core139.required)(import_ag_charts_core139.string),
  labelKey: import_ag_charts_core139.string,
  xName: import_ag_charts_core139.string,
  yName: import_ag_charts_core139.string,
  labelName: import_ag_charts_core139.string,
  errorBar: errorBarOptionsDefs
};

// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesModule.ts
var ScatterSeriesModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "community",
  chartTypes: ["cartesian"],
  identifier: "scatter",
  moduleFactory: (ctx) => new ScatterSeries(ctx),
  tooltipDefaults: { range: "nearest" },
  defaultAxes: [
    {
      type: "number" /* NUMBER */,
      position: "bottom" /* BOTTOM */
    },
    {
      type: "number" /* NUMBER */,
      position: "left" /* LEFT */
    }
  ],
  themeTemplate: {
    series: {
      shape: "circle",
      size: 7,
      fill: { $palette: "fill" },
      stroke: { $palette: "stroke" },
      // @ts-expect-error undocumented option
      fillGradientDefaults: {
        type: "gradient",
        gradient: "radial",
        bounds: "item",
        colorStops: { $palette: "gradient" },
        rotation: 0,
        reverse: true
      },
      fillPatternDefaults: FILL_PATTERN_DEFAULTS,
      fillImageDefaults: FILL_IMAGE_DEFAULTS,
      fillOpacity: 0.8,
      tooltip: { position: { _seriesOverrideType: "node" } },
      label: {
        enabled: false,
        fontSize: { $ref: "fontSize" },
        fontFamily: { $ref: "fontFamily" },
        fontWeight: { $ref: "fontWeight" },
        color: { $ref: "textColor" }
      },
      errorBar: {
        cap: {
          lengthRatio: 1
        }
      }
    }
  }
};
var NewScatterSeriesModule = {
  type: "series",
  name: "scatter",
  chartType: "cartesian",
  options: scatterSeriesOptionsDef,
  create: (ctx) => new ScatterSeries(ctx)
};

// packages/ag-charts-community/src/chart/series/polar/donutSeriesModule.ts
var import_ag_charts_core143 = require("ag-charts-core");

// packages/ag-charts-community/src/chart/series/polar/donutSeries.ts
var import_ag_charts_core140 = require("ag-charts-core");

// packages/ag-charts-community/src/scene/sectorBox.ts
var SectorBox = class _SectorBox {
  constructor(startAngle, endAngle, innerRadius, outerRadius) {
    this.startAngle = startAngle;
    this.endAngle = endAngle;
    this.innerRadius = innerRadius;
    this.outerRadius = outerRadius;
  }
  clone() {
    const { startAngle, endAngle, innerRadius, outerRadius } = this;
    return new _SectorBox(startAngle, endAngle, innerRadius, outerRadius);
  }
  equals(other) {
    return this.startAngle === other.startAngle && this.endAngle === other.endAngle && this.innerRadius === other.innerRadius && this.outerRadius === other.outerRadius;
  }
  [interpolate](other, d) {
    return new _SectorBox(
      this.startAngle * (1 - d) + other.startAngle * d,
      this.endAngle * (1 - d) + other.endAngle * d,
      this.innerRadius * (1 - d) + other.innerRadius * d,
      this.outerRadius * (1 - d) + other.outerRadius * d
    );
  }
};

// packages/ag-charts-community/src/scene/util/sector.ts
function sectorBox({ startAngle, endAngle, innerRadius, outerRadius }) {
  let x0 = Infinity;
  let y0 = Infinity;
  let x1 = -Infinity;
  let y1 = -Infinity;
  const addPoint = (x, y) => {
    x0 = Math.min(x, x0);
    y0 = Math.min(y, y0);
    x1 = Math.max(x, x1);
    y1 = Math.max(y, y1);
  };
  addPoint(innerRadius * Math.cos(startAngle), innerRadius * Math.sin(startAngle));
  addPoint(innerRadius * Math.cos(endAngle), innerRadius * Math.sin(endAngle));
  addPoint(outerRadius * Math.cos(startAngle), outerRadius * Math.sin(startAngle));
  addPoint(outerRadius * Math.cos(endAngle), outerRadius * Math.sin(endAngle));
  if (isBetweenAngles(0, startAngle, endAngle)) {
    addPoint(outerRadius, 0);
  }
  if (isBetweenAngles(Math.PI * 0.5, startAngle, endAngle)) {
    addPoint(0, outerRadius);
  }
  if (isBetweenAngles(Math.PI, startAngle, endAngle)) {
    addPoint(-outerRadius, 0);
  }
  if (isBetweenAngles(Math.PI * 1.5, startAngle, endAngle)) {
    addPoint(0, -outerRadius);
  }
  return new BBox(x0, y0, x1 - x0, y1 - y0);
}
function isPointInSector(x, y, sector) {
  const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
  const { innerRadius, outerRadius } = sector;
  if (sector.startAngle === sector.endAngle || radius < Math.min(innerRadius, outerRadius) || radius > Math.max(innerRadius, outerRadius)) {
    return false;
  }
  const startAngle = normalizeAngle180(sector.startAngle);
  const endAngle = normalizeAngle180(sector.endAngle);
  const angle = Math.atan2(y, x);
  return startAngle < endAngle ? angle <= endAngle && angle >= startAngle : angle <= endAngle && angle >= -Math.PI || angle >= startAngle && angle <= Math.PI;
}
function lineCollidesSector(line, sector) {
  const { startAngle, endAngle, innerRadius, outerRadius } = sector;
  const outerStart = { x: outerRadius * Math.cos(startAngle), y: outerRadius * Math.sin(startAngle) };
  const outerEnd = { x: outerRadius * Math.cos(endAngle), y: outerRadius * Math.sin(endAngle) };
  const innerStart = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(startAngle), y: innerRadius * Math.sin(startAngle) };
  const innerEnd = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(endAngle), y: innerRadius * Math.sin(endAngle) };
  return segmentIntersection(
    line.start.x,
    line.start.y,
    line.end.x,
    line.end.y,
    outerStart.x,
    outerStart.y,
    innerStart.x,
    innerStart.y
  ) || segmentIntersection(
    line.start.x,
    line.start.y,
    line.end.x,
    line.end.y,
    outerEnd.x,
    outerEnd.y,
    innerEnd.x,
    innerEnd.y
  ) || arcIntersections(
    0,
    0,
    outerRadius,
    startAngle,
    endAngle,
    true,
    line.start.x,
    line.start.y,
    line.end.x,
    line.end.y
  );
}
function boxCollidesSector(box, sector) {
  const topLeft = { x: box.x, y: box.y };
  const topRight = { x: box.x + box.width, y: box.y };
  const bottomLeft = { x: box.x, y: box.y + box.height };
  const bottomRight = { x: box.x + box.width, y: box.y + box.height };
  return lineCollidesSector({ start: topLeft, end: topRight }, sector) || lineCollidesSector({ start: bottomLeft, end: bottomRight }, sector);
}
function radiiScalingFactor(r, sweep, a, b) {
  if (a === 0 && b === 0)
    return 0;
  const fs1 = Math.asin(Math.abs(1 * a) / (r + 1 * a)) + Math.asin(Math.abs(1 * b) / (r + 1 * b)) - sweep;
  if (fs1 < 0)
    return 1;
  let start2 = 0;
  let end2 = 1;
  for (let i = 0; i < 8; i += 1) {
    const s = (start2 + end2) / 2;
    const fs = Math.asin(Math.abs(s * a) / (r + s * a)) + Math.asin(Math.abs(s * b) / (r + s * b)) - sweep;
    if (fs < 0) {
      start2 = s;
    } else {
      end2 = s;
    }
  }
  return start2;
}
var delta2 = 1e-6;
function clockwiseAngle(angle, relativeToStartAngle) {
  if (angleBetween(angle, relativeToStartAngle) < delta2) {
    return relativeToStartAngle;
  } else {
    return normalizeAngle360(angle - relativeToStartAngle) + relativeToStartAngle;
  }
}
function clockwiseAngles(startAngle, endAngle, relativeToStartAngle = 0) {
  const fullPie = Math.abs(endAngle - startAngle) >= 2 * Math.PI;
  const sweepAngle = fullPie ? 2 * Math.PI : normalizeAngle360(endAngle - startAngle);
  startAngle = clockwiseAngle(startAngle, relativeToStartAngle);
  endAngle = startAngle + sweepAngle;
  return { startAngle, endAngle };
}
function arcRadialLineIntersectionAngle(cx, cy, r, startAngle, endAngle, clipAngle) {
  const sinA = Math.sin(clipAngle);
  const cosA = Math.cos(clipAngle);
  const c = cx ** 2 + cy ** 2 - r ** 2;
  let p0x;
  let p0y;
  let p1x;
  let p1y;
  if (cosA > 0.5) {
    const tanA = sinA / cosA;
    const a = 1 + tanA ** 2;
    const b = -2 * (cx + cy * tanA);
    const d = b ** 2 - 4 * a * c;
    if (d < 0)
      return;
    const x0 = (-b + Math.sqrt(d)) / (2 * a);
    const x1 = (-b - Math.sqrt(d)) / (2 * a);
    p0x = x0;
    p0y = x0 * tanA;
    p1x = x1;
    p1y = x1 * tanA;
  } else {
    const cotA = cosA / sinA;
    const a = 1 + cotA ** 2;
    const b = -2 * (cy + cx * cotA);
    const d = b ** 2 - 4 * a * c;
    if (d < 0)
      return;
    const y0 = (-b + Math.sqrt(d)) / (2 * a);
    const y1 = (-b - Math.sqrt(d)) / (2 * a);
    p0x = y0 * cotA;
    p0y = y0;
    p1x = y1 * cotA;
    p1y = y1;
  }
  const normalisedX = cosA;
  const normalisedY = sinA;
  const p0DotNormalized = p0x * normalisedX + p0y * normalisedY;
  const p1DotNormalized = p1x * normalisedX + p1y * normalisedY;
  const a0 = p0DotNormalized > 0 ? clockwiseAngle(Math.atan2(p0y - cy, p0x - cx), startAngle) : NaN;
  const a1 = p1DotNormalized > 0 ? clockwiseAngle(Math.atan2(p1y - cy, p1x - cx), startAngle) : NaN;
  if (a0 >= startAngle && a0 <= endAngle) {
    return a0;
  } else if (a1 >= startAngle && a1 <= endAngle) {
    return a1;
  }
}
function arcCircleIntersectionAngle(cx, cy, r, startAngle, endAngle, circleR) {
  const d = Math.hypot(cx, cy);
  const d1 = (d ** 2 - r ** 2 + circleR ** 2) / (2 * d);
  const d2 = d - d1;
  const theta = Math.atan2(cy, cx);
  const deltaTheta = Math.acos(-d2 / r);
  const a0 = clockwiseAngle(theta + deltaTheta, startAngle);
  const a1 = clockwiseAngle(theta - deltaTheta, startAngle);
  if (a0 >= startAngle && a0 <= endAngle) {
    return a0;
  } else if (a1 >= startAngle && a1 <= endAngle) {
    return a1;
  }
}

// packages/ag-charts-community/src/scene/shape/sector.ts
var Arc = class {
  constructor(cx, cy, r, a0, a1) {
    this.cx = cx;
    this.cy = cy;
    this.r = r;
    this.a0 = a0;
    this.a1 = a1;
    if (this.a0 >= this.a1) {
      this.a0 = NaN;
      this.a1 = NaN;
    }
  }
  isValid() {
    return Number.isFinite(this.a0) && Number.isFinite(this.a1);
  }
  pointAt(a) {
    return {
      x: this.cx + this.r * Math.cos(a),
      y: this.cy + this.r * Math.sin(a)
    };
  }
  clipStart(a) {
    if (a == null || !this.isValid() || a < this.a0)
      return;
    this.a0 = a;
    if (Number.isNaN(a) || this.a0 >= this.a1) {
      this.a0 = NaN;
      this.a1 = NaN;
    }
  }
  clipEnd(a) {
    if (a == null || !this.isValid() || a > this.a1)
      return;
    this.a1 = a;
    if (Number.isNaN(a) || this.a0 >= this.a1) {
      this.a0 = NaN;
      this.a1 = NaN;
    }
  }
};
var Sector = class extends Path {
  constructor() {
    super(...arguments);
    this.centerX = 0;
    this.centerY = 0;
    this.innerRadius = 10;
    this.outerRadius = 20;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clipSector = void 0;
    this.concentricEdgeInset = 0;
    this.radialEdgeInset = 0;
    this.startOuterCornerRadius = 0;
    this.endOuterCornerRadius = 0;
    this.startInnerCornerRadius = 0;
    this.endInnerCornerRadius = 0;
  }
  set inset(value) {
    this.concentricEdgeInset = value;
    this.radialEdgeInset = value;
  }
  set cornerRadius(value) {
    this.startOuterCornerRadius = value;
    this.endOuterCornerRadius = value;
    this.startInnerCornerRadius = value;
    this.endInnerCornerRadius = value;
  }
  computeBBox() {
    return sectorBox(this).translate(this.centerX, this.centerY);
  }
  normalizedRadii() {
    const { concentricEdgeInset } = this;
    let { innerRadius, outerRadius } = this;
    innerRadius = innerRadius > 0 ? innerRadius + concentricEdgeInset : 0;
    outerRadius = Math.max(outerRadius - concentricEdgeInset, 0);
    return { innerRadius, outerRadius };
  }
  normalizedClipSector() {
    const { clipSector } = this;
    if (clipSector == null)
      return;
    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);
    const { innerRadius, outerRadius } = this.normalizedRadii();
    const clipAngles = clockwiseAngles(clipSector.startAngle, clipSector.endAngle, startAngle);
    return new SectorBox(
      Math.max(startAngle, clipAngles.startAngle),
      Math.min(endAngle, clipAngles.endAngle),
      Math.max(innerRadius, clipSector.innerRadius),
      Math.min(outerRadius, clipSector.outerRadius)
    );
  }
  getAngleOffset(radius) {
    return radius > 0 ? this.radialEdgeInset / radius : 0;
  }
  arc(r, angleSweep, a0, a1, outerArc, innerArc, start2, inner) {
    if (r <= 0)
      return;
    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);
    const { innerRadius, outerRadius } = this.normalizedRadii();
    const clipSector = this.normalizedClipSector();
    if (inner && innerRadius <= 0)
      return;
    const angleOffset = inner ? this.getAngleOffset(innerRadius + r) : this.getAngleOffset(outerRadius - r);
    const angle = start2 ? startAngle + angleOffset + angleSweep : endAngle - angleOffset - angleSweep;
    const radius = inner ? innerRadius + r : outerRadius - r;
    const cx = radius * Math.cos(angle);
    const cy = radius * Math.sin(angle);
    if (clipSector != null) {
      const delta3 = 1e-6;
      if (!start2 && !(angle >= startAngle - delta3 && angle <= clipSector.endAngle - delta3))
        return;
      if (start2 && !(angle >= clipSector.startAngle + delta3 && angle <= endAngle - delta3))
        return;
      if (inner && radius < clipSector.innerRadius - delta3)
        return;
      if (!inner && radius > clipSector.outerRadius + delta3)
        return;
    }
    const arc = new Arc(cx, cy, r, a0, a1);
    if (clipSector != null) {
      if (inner) {
        arc.clipStart(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle));
        arc.clipEnd(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle));
      } else {
        arc.clipStart(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle));
        arc.clipEnd(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle));
      }
      let circleClipStart;
      let circleClipEnd;
      if (start2) {
        circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);
        circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);
      } else {
        circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);
        circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);
      }
      arc.clipStart(circleClipStart);
      arc.clipEnd(circleClipEnd);
      if (circleClipStart != null) {
        const { x: x2, y: y2 } = arc.pointAt(circleClipStart);
        const theta2 = clockwiseAngle(Math.atan2(y2, x2), startAngle);
        if (start2) {
          innerArc?.clipStart(theta2);
        } else {
          outerArc.clipEnd(theta2);
        }
      }
      if (circleClipEnd != null) {
        const { x: x2, y: y2 } = arc.pointAt(circleClipEnd);
        const theta2 = clockwiseAngle(Math.atan2(y2, x2), startAngle);
        if (start2) {
          outerArc.clipStart(theta2);
        } else {
          innerArc?.clipEnd(theta2);
        }
      }
    }
    if (clipSector != null) {
      const { x: x2, y: y2 } = arc.pointAt((arc.a0 + arc.a1) / 2);
      if (!isPointInSector(x2, y2, clipSector))
        return;
    }
    const { x, y } = arc.pointAt(start2 === inner ? arc.a0 : arc.a1);
    const theta = clockwiseAngle(Math.atan2(y, x), startAngle);
    const radialArc = inner ? innerArc : outerArc;
    if (start2) {
      radialArc?.clipStart(theta);
    } else {
      radialArc?.clipEnd(theta);
    }
    return arc;
  }
  updatePath() {
    const delta3 = 1e-6;
    const { path, centerX, centerY, concentricEdgeInset, radialEdgeInset } = this;
    let { startOuterCornerRadius, endOuterCornerRadius, startInnerCornerRadius, endInnerCornerRadius } = this;
    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);
    const { innerRadius, outerRadius } = this.normalizedRadii();
    const clipSector = this.normalizedClipSector();
    const sweepAngle = endAngle - startAngle;
    const fullPie = sweepAngle >= 2 * Math.PI - delta3;
    path.clear();
    if (innerRadius === 0 && outerRadius === 0 || innerRadius > outerRadius) {
      return;
    } else if ((clipSector?.startAngle ?? startAngle) === (clipSector?.endAngle ?? endAngle)) {
      return;
    } else if (fullPie && this.clipSector == null && startOuterCornerRadius === 0 && endOuterCornerRadius === 0 && startInnerCornerRadius === 0 && endInnerCornerRadius === 0) {
      path.moveTo(centerX + outerRadius * Math.cos(startAngle), centerY + outerRadius * Math.sin(startAngle));
      path.arc(centerX, centerY, outerRadius, startAngle, endAngle);
      if (innerRadius > concentricEdgeInset) {
        path.moveTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));
        path.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);
      }
      path.closePath();
      return;
    } else if (this.clipSector == null && Math.abs(innerRadius - outerRadius) < 1e-6) {
      path.arc(centerX, centerY, outerRadius, startAngle, endAngle, false);
      path.arc(centerX, centerY, outerRadius, endAngle, startAngle, true);
      path.closePath();
      return;
    }
    const innerAngleOffset = this.getAngleOffset(innerRadius);
    const outerAngleOffset = this.getAngleOffset(outerRadius);
    const outerAngleExceeded = sweepAngle < 2 * outerAngleOffset;
    if (outerAngleExceeded)
      return;
    const hasInnerSweep = (clipSector?.innerRadius ?? innerRadius) > concentricEdgeInset;
    const innerAngleExceeded = innerRadius < concentricEdgeInset || sweepAngle < 2 * innerAngleOffset;
    const radialLength = outerRadius - innerRadius;
    const maxRadialLength = Math.max(
      startOuterCornerRadius,
      startInnerCornerRadius,
      endOuterCornerRadius,
      endInnerCornerRadius
    );
    const initialScalingFactor = maxRadialLength > 0 ? Math.min(radialLength / maxRadialLength, 1) : 1;
    startOuterCornerRadius *= initialScalingFactor;
    endOuterCornerRadius *= initialScalingFactor;
    startInnerCornerRadius *= initialScalingFactor;
    endInnerCornerRadius *= initialScalingFactor;
    const outerScalingFactor = radiiScalingFactor(
      outerRadius,
      sweepAngle - 2 * outerAngleOffset,
      -startOuterCornerRadius,
      -endOuterCornerRadius
    );
    startOuterCornerRadius *= outerScalingFactor;
    endOuterCornerRadius *= outerScalingFactor;
    if (!innerAngleExceeded && hasInnerSweep) {
      const innerScalingFactor = radiiScalingFactor(
        innerRadius,
        sweepAngle - 2 * innerAngleOffset,
        startInnerCornerRadius,
        endInnerCornerRadius
      );
      startInnerCornerRadius *= innerScalingFactor;
      endInnerCornerRadius *= innerScalingFactor;
    } else {
      startInnerCornerRadius = 0;
      endInnerCornerRadius = 0;
    }
    const maxCombinedRadialLength = Math.max(
      startOuterCornerRadius + startInnerCornerRadius,
      endOuterCornerRadius + endInnerCornerRadius
    );
    const edgesScalingFactor = maxCombinedRadialLength > 0 ? Math.min(radialLength / maxCombinedRadialLength, 1) : 1;
    startOuterCornerRadius *= edgesScalingFactor;
    endOuterCornerRadius *= edgesScalingFactor;
    startInnerCornerRadius *= edgesScalingFactor;
    endInnerCornerRadius *= edgesScalingFactor;
    let startOuterCornerRadiusAngleSweep = 0;
    let endOuterCornerRadiusAngleSweep = 0;
    const startOuterCornerRadiusSweep = startOuterCornerRadius / (outerRadius - startOuterCornerRadius);
    const endOuterCornerRadiusSweep = endOuterCornerRadius / (outerRadius - endOuterCornerRadius);
    if (startOuterCornerRadiusSweep >= 0 && startOuterCornerRadiusSweep < 1 - delta3) {
      startOuterCornerRadiusAngleSweep = Math.asin(startOuterCornerRadiusSweep);
    } else {
      startOuterCornerRadiusAngleSweep = sweepAngle / 2;
      const maxStartOuterCornerRadius = outerRadius / (1 / Math.sin(startOuterCornerRadiusAngleSweep) + 1);
      startOuterCornerRadius = Math.min(maxStartOuterCornerRadius, startOuterCornerRadius);
    }
    if (endOuterCornerRadiusSweep >= 0 && endOuterCornerRadiusSweep < 1 - delta3) {
      endOuterCornerRadiusAngleSweep = Math.asin(endOuterCornerRadiusSweep);
    } else {
      endOuterCornerRadiusAngleSweep = sweepAngle / 2;
      const maxEndOuterCornerRadius = outerRadius / (1 / Math.sin(endOuterCornerRadiusAngleSweep) + 1);
      endOuterCornerRadius = Math.min(maxEndOuterCornerRadius, endOuterCornerRadius);
    }
    const startInnerCornerRadiusAngleSweep = Math.asin(
      startInnerCornerRadius / (innerRadius + startInnerCornerRadius)
    );
    const endInnerCornerRadiusAngleSweep = Math.asin(endInnerCornerRadius / (innerRadius + endInnerCornerRadius));
    const outerArcRadius = clipSector?.outerRadius ?? outerRadius;
    const outerArcRadiusOffset = this.getAngleOffset(outerArcRadius);
    const outerArc = new Arc(
      0,
      0,
      outerArcRadius,
      startAngle + outerArcRadiusOffset,
      endAngle - outerArcRadiusOffset
    );
    const innerArcRadius = clipSector?.innerRadius ?? innerRadius;
    const innerArcRadiusOffset = this.getAngleOffset(innerArcRadius);
    const innerArc = hasInnerSweep ? new Arc(0, 0, innerArcRadius, startAngle + innerArcRadiusOffset, endAngle - innerArcRadiusOffset) : void 0;
    if (clipSector != null) {
      outerArc.clipStart(clipSector.startAngle);
      outerArc.clipEnd(clipSector.endAngle);
      innerArc?.clipStart(clipSector.startAngle);
      innerArc?.clipEnd(clipSector.endAngle);
    }
    const startOuterArc = this.arc(
      startOuterCornerRadius,
      startOuterCornerRadiusAngleSweep,
      startAngle - Math.PI * 0.5,
      startAngle + startOuterCornerRadiusAngleSweep,
      outerArc,
      innerArc,
      true,
      false
    );
    const endOuterArc = this.arc(
      endOuterCornerRadius,
      endOuterCornerRadiusAngleSweep,
      endAngle - endOuterCornerRadiusAngleSweep,
      endAngle + Math.PI * 0.5,
      outerArc,
      innerArc,
      false,
      false
    );
    const endInnerArc = this.arc(
      endInnerCornerRadius,
      endInnerCornerRadiusAngleSweep,
      endAngle + Math.PI * 0.5,
      endAngle + Math.PI - endInnerCornerRadiusAngleSweep,
      outerArc,
      innerArc,
      false,
      true
    );
    const startInnerArc = this.arc(
      startInnerCornerRadius,
      startInnerCornerRadiusAngleSweep,
      startAngle + Math.PI + startInnerCornerRadiusAngleSweep,
      startAngle + Math.PI * 1.5,
      outerArc,
      innerArc,
      true,
      true
    );
    if (innerAngleExceeded) {
      const x = sweepAngle < Math.PI * 0.5 ? radialEdgeInset * (1 + Math.cos(sweepAngle)) / Math.sin(sweepAngle) : NaN;
      let r;
      if (x > 0 && x < outerRadius) {
        r = Math.max(Math.hypot(radialEdgeInset, x), innerRadius);
      } else {
        r = radialEdgeInset;
      }
      r = Math.max(r, innerRadius);
      const midAngle = startAngle + sweepAngle * 0.5;
      path.moveTo(centerX + r * Math.cos(midAngle), centerY + r * Math.sin(midAngle));
    } else if (startInnerArc?.isValid() === true || innerArc?.isValid() === true) {
    } else {
      const midAngle = startAngle + sweepAngle / 2;
      const cx = innerRadius * Math.cos(midAngle);
      const cy = innerRadius * Math.sin(midAngle);
      path.moveTo(centerX + cx, centerY + cy);
    }
    if (startOuterArc?.isValid() === true) {
      const { cx, cy, r, a0, a1 } = startOuterArc;
      path.arc(centerX + cx, centerY + cy, r, a0, a1);
    }
    if (outerArc.isValid()) {
      const { r, a0, a1 } = outerArc;
      path.arc(centerX, centerY, r, a0, a1);
    }
    if (endOuterArc?.isValid() === true) {
      const { cx, cy, r, a0, a1 } = endOuterArc;
      path.arc(centerX + cx, centerY + cy, r, a0, a1);
    }
    if (!innerAngleExceeded) {
      if (endInnerArc?.isValid() === true) {
        const { cx, cy, r, a0, a1 } = endInnerArc;
        path.arc(centerX + cx, centerY + cy, r, a0, a1);
      }
      if (innerArc?.isValid() === true) {
        const { r, a0, a1 } = innerArc;
        path.arc(centerX, centerY, r, a1, a0, true);
      }
      if (startInnerArc?.isValid() === true) {
        const { cx, cy, r, a0, a1 } = startInnerArc;
        path.arc(centerX + cx, centerY + cy, r, a0, a1);
      }
    }
    path.closePath();
  }
  isPointInPath(x, y) {
    const { startAngle, endAngle, innerRadius, outerRadius } = this.clipSector ?? this;
    return isPointInSector(x - this.centerX, y - this.centerY, {
      startAngle,
      endAngle,
      innerRadius: Math.min(innerRadius, outerRadius),
      outerRadius: Math.max(innerRadius, outerRadius)
    });
  }
};
Sector.className = "Sector";
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "centerX", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "centerY", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "innerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "outerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "startAngle", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "endAngle", 2);
__decorateClass([
  SceneObjectChangeDetection({ equals: (lhs, rhs) => lhs.equals(rhs) })
], Sector.prototype, "clipSector", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "concentricEdgeInset", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "radialEdgeInset", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "startOuterCornerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "endOuterCornerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "startInnerCornerRadius", 2);
__decorateClass([
  SceneChangeDetection()
], Sector.prototype, "endInnerCornerRadius", 2);

// packages/ag-charts-community/src/chart/themes/defaultColors.ts
var DEFAULT_FILLS = {
  BLUE: "#5090dc",
  ORANGE: "#ffa03a",
  GREEN: "#459d55",
  CYAN: "#34bfe1",
  YELLOW: "#e1cc00",
  VIOLET: "#9669cb",
  GRAY: "#b5b5b5",
  MAGENTA: "#bd5aa7",
  BROWN: "#8a6224",
  RED: "#ef5452"
};
var DEFAULT_STROKES = {
  BLUE: "#2b5c95",
  ORANGE: "#cc6f10",
  GREEN: "#1e652e",
  CYAN: "#18859e",
  YELLOW: "#a69400",
  VIOLET: "#603c88",
  GRAY: "#575757",
  MAGENTA: "#7d2f6d",
  BROWN: "#4f3508",
  RED: "#a82529"
};

// packages/ag-charts-community/src/chart/series/polar/donutSeriesProperties.ts
var DonutTitle = class extends Caption {
  constructor() {
    super(...arguments);
    this.showInLegend = false;
  }
};
__decorateClass([
  Property
], DonutTitle.prototype, "showInLegend", 2);
var DonutInnerLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.spacing = 2;
  }
  set(properties, _reset) {
    return super.set(properties);
  }
};
__decorateClass([
  Property
], DonutInnerLabel.prototype, "text", 2);
__decorateClass([
  Property
], DonutInnerLabel.prototype, "spacing", 2);
var DonutInnerCircle = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.fill = "transparent";
    this.fillOpacity = 1;
  }
};
__decorateClass([
  Property
], DonutInnerCircle.prototype, "fill", 2);
__decorateClass([
  Property
], DonutInnerCircle.prototype, "fillOpacity", 2);
var DonutSeriesCalloutLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.offset = 3;
    this.minAngle = 0;
    this.minSpacing = 4;
    this.maxCollisionOffset = 50;
    this.avoidCollisions = true;
  }
};
__decorateClass([
  Property
], DonutSeriesCalloutLabel.prototype, "offset", 2);
__decorateClass([
  Property
], DonutSeriesCalloutLabel.prototype, "minAngle", 2);
__decorateClass([
  Property
], DonutSeriesCalloutLabel.prototype, "minSpacing", 2);
__decorateClass([
  Property
], DonutSeriesCalloutLabel.prototype, "maxCollisionOffset", 2);
__decorateClass([
  Property
], DonutSeriesCalloutLabel.prototype, "avoidCollisions", 2);
var DonutSeriesSectorLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.positionOffset = 0;
    this.positionRatio = 0.5;
  }
};
__decorateClass([
  Property
], DonutSeriesSectorLabel.prototype, "positionOffset", 2);
__decorateClass([
  Property
], DonutSeriesSectorLabel.prototype, "positionRatio", 2);
var DonutSeriesCalloutLine = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.length = 10;
    this.strokeWidth = 1;
  }
};
__decorateClass([
  Property
], DonutSeriesCalloutLine.prototype, "colors", 2);
__decorateClass([
  Property
], DonutSeriesCalloutLine.prototype, "length", 2);
__decorateClass([
  Property
], DonutSeriesCalloutLine.prototype, "strokeWidth", 2);
var DonutSeriesProperties = class extends SeriesProperties {
  constructor() {
    super(...arguments);
    this.defaultColorRange = [];
    this.defaultPatternFills = [];
    this.fills = Object.values(DEFAULT_FILLS);
    this.strokes = Object.values(DEFAULT_STROKES);
    this.fillOpacity = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.rotation = 0;
    this.outerRadiusOffset = 0;
    this.outerRadiusRatio = 1;
    this.strokeWidth = 1;
    this.sectorSpacing = 0;
    this.hideZeroValueSectorsInLegend = false;
    this.innerLabels = new PropertiesArray(DonutInnerLabel);
    this.title = new DonutTitle();
    this.innerCircle = new DonutInnerCircle();
    this.shadow = new DropShadow();
    this.calloutLabel = new DonutSeriesCalloutLabel();
    this.sectorLabel = new DonutSeriesSectorLabel();
    this.calloutLine = new DonutSeriesCalloutLine();
    this.tooltip = new SeriesTooltip();
  }
};
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "angleKey", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "angleName", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "angleFilterKey", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "radiusKey", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "radiusName", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "radiusMin", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "radiusMax", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "calloutLabelKey", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "calloutLabelName", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "sectorLabelKey", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "sectorLabelName", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "legendItemKey", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "defaultColorRange", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "defaultPatternFills", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "fills", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "strokes", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "rotation", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "outerRadiusOffset", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "outerRadiusRatio", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "innerRadiusOffset", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "innerRadiusRatio", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "sectorSpacing", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "hideZeroValueSectorsInLegend", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "innerLabels", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "title", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "innerCircle", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "calloutLabel", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "sectorLabel", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "calloutLine", 2);
__decorateClass([
  Property
], DonutSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-community/src/chart/series/polar/pieUtil.ts
function preparePieSeriesAnimationFunctions(initialLoad, rotationDegrees, scaleFn, oldScaleFn) {
  const scale2 = [scaleFn.convert(0), scaleFn.convert(1)];
  const oldScale = [oldScaleFn.convert(0), oldScaleFn.convert(1)];
  const rotation = Math.PI / -2 + toRadians(rotationDegrees);
  const phase = initialLoad ? "initial" : "update";
  const scaleToNewRadius = ({ radius }) => {
    return { innerRadius: scale2[0], outerRadius: scale2[0] + (scale2[1] - scale2[0]) * radius };
  };
  const scaleToOldRadius = ({ radius }) => {
    return { innerRadius: oldScale[0], outerRadius: oldScale[0] + (oldScale[1] - oldScale[0]) * radius };
  };
  const fromFn = (sect, datum, status, { prevFromProps }) => {
    let { startAngle, endAngle, innerRadius, outerRadius } = sect;
    let { fill, stroke: stroke2 } = datum.sectorFormat;
    if (status === "updated" && sect.previousDatum == null) {
      status = "added";
    }
    if (status === "unknown" || status === "added" && !prevFromProps) {
      startAngle = rotation;
      endAngle = rotation;
      innerRadius = datum.innerRadius;
      outerRadius = datum.outerRadius;
    } else if (status === "added" && prevFromProps) {
      startAngle = prevFromProps.endAngle ?? rotation;
      endAngle = prevFromProps.endAngle ?? rotation;
      innerRadius = prevFromProps.innerRadius ?? datum.innerRadius;
      outerRadius = prevFromProps.outerRadius ?? datum.outerRadius;
    }
    if (status === "added" && !initialLoad) {
      const radii = scaleToOldRadius(datum);
      innerRadius = radii.innerRadius;
      outerRadius = radii.outerRadius;
    }
    if (status === "updated") {
      fill = sect.fill ?? fill;
      stroke2 = (typeof sect.stroke === "string" ? sect.stroke : void 0) ?? stroke2;
    }
    return { startAngle, endAngle, innerRadius, outerRadius, fill, stroke: stroke2, phase };
  };
  const toFn = (_sect, datum, status, { prevLive }) => {
    let { startAngle, endAngle, innerRadius, outerRadius } = datum;
    const { stroke: stroke2, fill } = datum.sectorFormat;
    if (status === "removed" && prevLive) {
      startAngle = prevLive.datum?.endAngle;
      endAngle = prevLive.datum?.endAngle;
    } else if (status === "removed" && !prevLive) {
      startAngle = rotation;
      endAngle = rotation;
    }
    if (status === "removed") {
      const radii = scaleToNewRadius(datum);
      innerRadius = radii.innerRadius;
      outerRadius = radii.outerRadius;
    }
    return { startAngle, endAngle, outerRadius, innerRadius, stroke: stroke2, fill };
  };
  const innerCircleFromFn = (node, _) => {
    return { size: node.previousDatum?.radius ?? node.size ?? 0, phase };
  };
  const innerCircleToFn = (_, datum) => {
    return { size: datum.radius ?? 0 };
  };
  return { nodes: { toFn, fromFn }, innerCircle: { fromFn: innerCircleFromFn, toFn: innerCircleToFn } };
}
function resetPieSelectionsFn(_node, datum) {
  return {
    startAngle: datum.startAngle,
    endAngle: datum.endAngle,
    innerRadius: datum.innerRadius,
    outerRadius: datum.outerRadius,
    stroke: datum.sectorFormat.stroke
  };
}
function pickByMatchingAngle(series, point) {
  const dy = point.y - series.centerY;
  const dx = point.x - series.centerX;
  const angle = Math.atan2(dy, dx);
  const sectors = series.getItemNodes();
  for (const sector of sectors) {
    if (sector.datum.missing === true)
      continue;
    if (isBetweenAngles(angle, sector.startAngle, sector.endAngle)) {
      const radius = Math.sqrt(dx * dx + dy * dy);
      let distance = 0;
      if (radius < sector.innerRadius) {
        distance = sector.innerRadius - radius;
      } else if (radius > sector.outerRadius) {
        distance = radius - sector.outerRadius;
      }
      return { datum: sector.datum, distance };
    }
  }
  return void 0;
}

// packages/ag-charts-community/src/chart/series/polar/donutSeries.ts
var DonutSeriesNodeEvent = class extends SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.angleKey = series.properties.angleKey;
    this.radiusKey = series.properties.radiusKey;
    this.calloutLabelKey = series.properties.calloutLabelKey;
    this.sectorLabelKey = series.properties.sectorLabelKey;
  }
};
var DonutSeries = class extends PolarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      categoryKey: void 0,
      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],
      useLabelLayer: true,
      animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }
    });
    this.properties = new DonutSeriesProperties();
    this.phantomNodeData = void 0;
    this.backgroundGroup = new TranslatableGroup({
      name: `${this.id}-background`,
      zIndex: 0 /* BACKGROUND */
    });
    this.noVisibleData = false;
    this.previousRadiusScale = new LinearScale();
    this.radiusScale = new LinearScale();
    this.phantomGroup = this.backgroundGroup.appendChild(new Group({ name: "phantom" }));
    this.phantomSelection = Selection.select(
      this.phantomGroup,
      () => this.nodeFactory(),
      false
    );
    this.calloutLabelGroup = this.contentGroup.appendChild(new Group({ name: "pieCalloutLabels" }));
    this.calloutLabelSelection = new Selection(
      this.calloutLabelGroup,
      Group
    );
    // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.
    this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));
    this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Marker({ shape: "circle" }));
    this.zerosumInnerRing = this.zerosumRingsGroup.appendChild(new Marker({ shape: "circle" }));
    this.innerLabelsGroup = this.contentGroup.appendChild(new Group({ name: "innerLabels" }));
    this.innerCircleGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-innerCircle` }));
    this.innerLabelsSelection = Selection.select(this.innerLabelsGroup, Text);
    this.innerCircleSelection = Selection.select(
      this.innerCircleGroup,
      () => new Marker({ shape: "circle" })
    );
    this.surroundingRadius = void 0;
    this.NodeEvent = DonutSeriesNodeEvent;
    this.angleScale = new LinearScale();
    this.angleScale.domain = [0, 1];
    this.angleScale.range = [-Math.PI, Math.PI].map((angle) => angle + Math.PI / 2);
    this.phantomGroup.opacity = 0.2;
  }
  get calloutNodeData() {
    return this.phantomNodeData ?? this.nodeData;
  }
  attachSeries(seriesContentNode, seriesNode, annotationNode) {
    super.attachSeries(seriesContentNode, seriesNode, annotationNode);
    seriesContentNode?.appendChild(this.backgroundGroup);
  }
  detachSeries(seriesContentNode, seriesNode, annotationNode) {
    super.detachSeries(seriesContentNode, seriesNode, annotationNode);
    seriesContentNode?.removeChild(this.backgroundGroup);
  }
  setSeriesIndex(index) {
    if (!super.setSeriesIndex(index))
      return false;
    this.backgroundGroup.zIndex = [0 /* BACKGROUND */, index];
    return true;
  }
  nodeFactory() {
    return new Sector();
  }
  getSeriesDomain(direction) {
    if (direction === "angle" /* Angle */) {
      return this.angleScale.domain;
    } else {
      return this.radiusScale.domain;
    }
  }
  async processData(dataController) {
    if (this.data == null)
      return;
    const {
      visible,
      id: seriesId,
      ctx: { legendManager }
    } = this;
    const { angleKey, angleFilterKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
    const processor = () => (value, index) => {
      if (visible && legendManager.getItemEnabled({ seriesId, itemId: index })) {
        return value;
      }
      return 0;
    };
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const extraKeyProps = [];
    const extraProps = [];
    if (legendItemKey) {
      extraKeyProps.push(keyProperty(legendItemKey, "band", { id: `legendItemKey` }));
    } else if (calloutLabelKey) {
      extraKeyProps.push(keyProperty(calloutLabelKey, "band", { id: `calloutLabelKey` }));
    } else if (sectorLabelKey) {
      extraKeyProps.push(keyProperty(sectorLabelKey, "band", { id: `sectorLabelKey` }));
    }
    const radiusScaleType = this.radiusScale.type;
    const angleScaleType = this.angleScale.type;
    if (radiusKey) {
      extraProps.push(
        rangedValueProperty(radiusKey, {
          id: "radiusValue",
          min: this.properties.radiusMin ?? 0,
          max: this.properties.radiusMax,
          missingValue: this.properties.radiusMax ?? 1,
          processor
        }),
        valueProperty(radiusKey, radiusScaleType, { id: `radiusRaw`, processor }),
        // Raw value pass-through.
        normalisePropertyTo("radiusValue", [0, 1], 1, this.properties.radiusMin ?? 0, this.properties.radiusMax)
      );
    }
    if (calloutLabelKey) {
      extraProps.push(valueProperty(calloutLabelKey, "band", { id: `calloutLabelValue` }));
    }
    if (sectorLabelKey) {
      extraProps.push(valueProperty(sectorLabelKey, "band", { id: `sectorLabelValue` }));
    }
    if (legendItemKey) {
      extraProps.push(valueProperty(legendItemKey, "band", { id: `legendItemValue` }));
    }
    if (angleFilterKey) {
      extraProps.push(
        accumulativeValueProperty(angleFilterKey, angleScaleType, {
          id: `angleFilterValue`,
          onlyPositive: true,
          invalidValue: 0,
          processor
        }),
        valueProperty(angleFilterKey, angleScaleType, { id: `angleFilterRaw` }),
        normalisePropertyTo("angleFilterValue", [0, 1], 0, 0)
      );
    }
    if (animationEnabled && this.processedData && extraKeyProps.length > 0) {
      extraProps.push(diff(this.id, this.processedData));
    }
    extraProps.push(animationValidation());
    await this.requestDataModel(dataController, this.data, {
      props: [
        ...extraKeyProps,
        accumulativeValueProperty(angleKey, angleScaleType, {
          id: `angleValue`,
          onlyPositive: true,
          invalidValue: 0,
          processor
        }),
        valueProperty(angleKey, angleScaleType, { id: `angleRaw` }),
        // Raw value pass-through.
        normalisePropertyTo("angleValue", [0, 1], 0, 0),
        ...extraProps
      ]
    });
    for (const valueDef of this.processedData?.defs?.values ?? []) {
      const { id, missing, property } = valueDef;
      const missCount = getMissCount(this, missing);
      if (id !== "angleRaw" && missCount > 0) {
        import_ag_charts_core140.Logger.warnOnce(
          `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? "s" : ""}`
        );
      }
    }
    this.animationState.transition("updateData");
  }
  maybeRefreshNodeData() {
    if (!this.nodeDataRefresh)
      return;
    const { nodeData = [], phantomNodeData } = this.createNodeData() ?? {};
    this.nodeData = nodeData;
    this.phantomNodeData = phantomNodeData;
    this.nodeDataRefresh = false;
  }
  getProcessedDataValues(dataModel, processedData) {
    const angleValues = dataModel.resolveColumnById(this, `angleValue`, processedData);
    const angleRawValues = dataModel.resolveColumnById(this, `angleRaw`, processedData);
    const angleFilterValues = this.properties.angleFilterKey != null ? dataModel.resolveColumnById(this, `angleFilterValue`, processedData) : void 0;
    const angleFilterRawValues = this.properties.angleFilterKey != null ? dataModel.resolveColumnById(this, `angleFilterRaw`, processedData) : void 0;
    const radiusValues = this.properties.radiusKey ? dataModel.resolveColumnById(this, `radiusValue`, processedData) : void 0;
    const radiusRawValues = this.properties.radiusKey ? dataModel.resolveColumnById(this, `radiusRaw`, processedData) : void 0;
    const calloutLabelValues = this.properties.calloutLabelKey ? dataModel.resolveColumnById(this, `calloutLabelValue`, processedData) : void 0;
    const sectorLabelValues = this.properties.sectorLabelKey ? dataModel.resolveColumnById(this, `sectorLabelValue`, processedData) : void 0;
    const legendItemValues = this.properties.legendItemKey ? dataModel.resolveColumnById(this, `legendItemValue`, processedData) : void 0;
    return {
      angleValues,
      angleRawValues,
      angleFilterValues,
      angleFilterRawValues,
      radiusValues,
      radiusRawValues,
      calloutLabelValues,
      sectorLabelValues,
      legendItemValues
    };
  }
  createNodeData() {
    const {
      id: seriesId,
      processedData,
      dataModel,
      angleScale,
      ctx: { legendManager },
      visible
    } = this;
    const { rotation, innerRadiusRatio } = this.properties;
    if (!dataModel || processedData?.type !== "ungrouped")
      return;
    const {
      angleValues,
      angleRawValues,
      angleFilterValues,
      angleFilterRawValues,
      radiusValues,
      radiusRawValues,
      calloutLabelValues,
      sectorLabelValues,
      legendItemValues
    } = this.getProcessedDataValues(dataModel, processedData);
    const useFilterAngles = angleFilterRawValues?.some((filterRawValue, index) => {
      return filterRawValue > angleRawValues[index];
    }) ?? false;
    let currentStart = 0;
    let sum = 0;
    const nodes = [];
    const phantomNodes = angleFilterRawValues != null ? [] : void 0;
    const rawData = processedData.dataSources.get(this.id) ?? [];
    const invalidData = processedData.invalidData?.get(this.id);
    rawData.forEach((datum, datumIndex) => {
      if (invalidData?.[datumIndex] === true)
        return;
      const currentValue = useFilterAngles ? angleFilterValues[datumIndex] : angleValues[datumIndex];
      const crossFilterScale = angleFilterRawValues != null && !useFilterAngles ? Math.sqrt(angleFilterRawValues[datumIndex] / angleRawValues[datumIndex]) : 1;
      const startAngle = angleScale.convert(currentStart) + toRadians(rotation);
      currentStart = currentValue;
      sum += currentValue;
      const endAngle = angleScale.convert(currentStart) + toRadians(rotation);
      const span = Math.abs(endAngle - startAngle);
      const midAngle = startAngle + span / 2;
      const angleValue = angleRawValues[datumIndex];
      const radiusRaw = radiusValues?.[datumIndex] ?? 1;
      const radius = radiusRaw * crossFilterScale;
      const radiusValue = radiusRawValues?.[datumIndex];
      const legendItemValue = legendItemValues?.[datumIndex];
      const nodeLabels = this.getLabels(
        datum,
        midAngle,
        span,
        true,
        calloutLabelValues?.[datumIndex],
        sectorLabelValues?.[datumIndex],
        legendItemValue
      );
      const sectorFormat = this.getSectorFormat(datum, datumIndex, false);
      const node = {
        itemId: datumIndex,
        series: this,
        datum,
        datumIndex,
        angleValue,
        midAngle,
        midCos: Math.cos(midAngle),
        midSin: Math.sin(midAngle),
        startAngle,
        endAngle,
        radius,
        innerRadius: Math.max(this.radiusScale.convert(0), 0),
        outerRadius: Math.max(this.radiusScale.convert(radius), 0),
        sectorFormat,
        radiusValue,
        legendItemValue,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId: datumIndex }),
        focusable: true,
        ...nodeLabels
      };
      nodes.push(node);
      if (phantomNodes != null) {
        phantomNodes.push({
          ...node,
          radius: 1,
          innerRadius: Math.max(this.radiusScale.convert(0), 0),
          outerRadius: Math.max(this.radiusScale.convert(1), 0),
          focusable: false
        });
      }
    });
    this.zerosumOuterRing.visible = sum === 0;
    this.zerosumInnerRing.visible = sum === 0 && innerRadiusRatio != null && innerRadiusRatio !== 1 && innerRadiusRatio > 0;
    return {
      itemId: seriesId,
      nodeData: nodes,
      labelData: nodes,
      phantomNodeData: phantomNodes
    };
  }
  getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {
    const { calloutLabel, sectorLabel, legendItemKey } = this.properties;
    const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.properties.calloutLabelKey : void 0;
    const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.properties.sectorLabelKey : void 0;
    if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {
      return {};
    }
    const labelFormatterParams = {
      datum,
      angleKey: this.properties.angleKey,
      angleName: this.properties.angleName,
      radiusKey: this.properties.radiusKey,
      radiusName: this.properties.radiusName,
      calloutLabelKey: this.properties.calloutLabelKey,
      calloutLabelName: this.properties.calloutLabelName,
      sectorLabelKey: this.properties.sectorLabelKey,
      sectorLabelName: this.properties.sectorLabelName,
      legendItemKey: this.properties.legendItemKey
    };
    const result = {};
    if (calloutLabelKey && span >= toRadians(calloutLabel.minAngle)) {
      result.calloutLabel = {
        ...this.getTextAlignment(midAngle),
        text: this.getLabelText(calloutLabel, {
          ...labelFormatterParams,
          value: calloutLabelValue
        }),
        hidden: false,
        collisionTextAlign: void 0,
        collisionOffsetY: 0,
        box: void 0
      };
    }
    if (sectorLabelKey) {
      result.sectorLabel = {
        text: this.getLabelText(sectorLabel, {
          ...labelFormatterParams,
          value: sectorLabelValue
        })
      };
    }
    if (legendItemKey != null && legendItemValue != null) {
      result.legendItem = { key: legendItemKey, text: legendItemValue };
    }
    return result;
  }
  getTextAlignment(midAngle) {
    const quadrantTextOpts = [
      { textAlign: "center", textBaseline: "bottom" },
      { textAlign: "left", textBaseline: "middle" },
      { textAlign: "center", textBaseline: "hanging" },
      { textAlign: "right", textBaseline: "middle" }
    ];
    const midAngle180 = normalizeAngle180(midAngle);
    const quadrantStart = -0.75 * Math.PI;
    const quadrantOffset = midAngle180 - quadrantStart;
    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));
    const quadrantIndex = (0, import_ag_charts_core140.modulus)(quadrant, quadrantTextOpts.length);
    return quadrantTextOpts[quadrantIndex];
  }
  getNodeFill(fill, defaultColorRange, defaultPatternFill) {
    return getShapeFill(
      fill,
      {
        type: "gradient",
        bounds: "series",
        colorStops: defaultColorRange.map((color7) => ({ color: color7 })),
        gradient: "radial",
        rotation: 0,
        reverse: true
      },
      {
        type: "pattern",
        pattern: "forward-slanted-lines",
        fill: defaultPatternFill,
        fillOpacity: 1,
        backgroundFill: "none",
        backgroundFillOpacity: 1,
        stroke: defaultPatternFill,
        strokeOpacity: 1,
        strokeWidth: 4,
        rotation: 0
      },
      {
        type: "image",
        backgroundFill: defaultPatternFill,
        backgroundFillOpacity: 1,
        fit: "contain",
        repeat: "no-repeat",
        rotation: 0
      }
    );
  }
  getFillParams(fill, innerRadius, outerRadius) {
    if (!isGradientFill(fill) || fill.bounds === "item")
      return;
    return {
      centerX: 0,
      centerY: 0,
      innerRadius,
      outerRadius
    };
  }
  getSectorFormat(datum, datumIndex, highlighted) {
    const {
      angleKey,
      radiusKey,
      calloutLabelKey,
      sectorLabelKey,
      legendItemKey,
      fills,
      strokes,
      defaultColorRange,
      defaultPatternFills,
      itemStyler
    } = this.properties;
    const defaultStroke = strokes[datumIndex % strokes.length];
    const { fill, fillOpacity, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = mergeDefaults(
      highlighted && this.properties.highlightStyle.item,
      {
        fill: fills.length > 0 ? fills[datumIndex % fills.length] : void 0,
        stroke: defaultStroke,
        strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),
        strokeOpacity: this.getOpacity()
      },
      this.properties
    );
    const defaultColors = defaultColorRange[datumIndex % defaultColorRange.length];
    const defaultPatternFill = defaultPatternFills[datumIndex % defaultPatternFills.length];
    const sectorFill = fill ?? "black";
    let format;
    if (itemStyler) {
      format = this.cachedDatumCallback(
        this.getDatumId(datumIndex) + (highlighted ? "-highlight" : "-hide"),
        () => this.callWithContext(itemStyler, {
          datum,
          angleKey,
          radiusKey,
          calloutLabelKey,
          sectorLabelKey,
          legendItemKey,
          fill: this.getNodeFill(sectorFill, defaultColors, defaultPatternFill),
          fillOpacity,
          stroke: stroke2,
          strokeWidth,
          strokeOpacity,
          lineDash,
          lineDashOffset,
          cornerRadius,
          highlighted,
          seriesId: this.id
        })
      );
    }
    return {
      fill: this.getNodeFill(format?.fill ?? sectorFill, defaultColors, defaultPatternFill),
      fillOpacity: format?.fillOpacity ?? fillOpacity,
      stroke: format?.stroke ?? stroke2,
      strokeWidth: format?.strokeWidth ?? strokeWidth,
      strokeOpacity: format?.strokeOpacity ?? strokeOpacity,
      lineDash: format?.lineDash ?? lineDash,
      lineDashOffset: format?.lineDashOffset ?? lineDashOffset,
      cornerRadius: format?.cornerRadius ?? cornerRadius
    };
  }
  getInnerRadius() {
    const { radius } = this;
    const { innerRadiusRatio = 1, innerRadiusOffset = 0 } = this.properties;
    const innerRadius = radius * innerRadiusRatio + innerRadiusOffset;
    if (innerRadius === radius || innerRadius < 0) {
      return 0;
    }
    return innerRadius;
  }
  getOuterRadius() {
    const { outerRadiusRatio, outerRadiusOffset } = this.properties;
    return Math.max(this.radius * outerRadiusRatio + outerRadiusOffset, 0);
  }
  updateRadiusScale(resize) {
    const newRange = [this.getInnerRadius(), this.getOuterRadius()];
    this.radiusScale.range = newRange;
    if (resize) {
      this.previousRadiusScale.range = newRange;
    }
    const setRadii = (d) => ({
      ...d,
      innerRadius: Math.max(this.radiusScale.convert(0), 0),
      outerRadius: Math.max(this.radiusScale.convert(d.radius), 0)
    });
    this.nodeData = this.nodeData.map(setRadii);
    this.phantomNodeData = this.phantomNodeData?.map(setRadii);
  }
  getTitleTranslationY() {
    const outerRadius = Math.max(0, this.radiusScale.range[1]);
    if (outerRadius === 0) {
      return NaN;
    }
    const spacing = this.properties.title?.spacing ?? 0;
    const titleOffset = 2 + spacing;
    const dy = Math.max(0, -outerRadius);
    return -outerRadius - titleOffset - dy;
  }
  update({ seriesRect }) {
    const { title } = this.properties;
    const newNodeDataDependencies = {
      seriesRectWidth: seriesRect?.width,
      seriesRectHeight: seriesRect?.height
    };
    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;
    if (resize) {
      this._nodeDataDependencies = newNodeDataDependencies;
    }
    this.maybeRefreshNodeData();
    this.updateTitleNodes();
    this.updateRadiusScale(resize);
    this.contentGroup.translationX = this.centerX;
    this.contentGroup.translationY = this.centerY;
    this.highlightGroup.translationX = this.centerX;
    this.highlightGroup.translationY = this.centerY;
    this.backgroundGroup.translationX = this.centerX;
    this.backgroundGroup.translationY = this.centerY;
    if (this.labelGroup) {
      this.labelGroup.translationX = this.centerX;
      this.labelGroup.translationY = this.centerY;
    }
    if (title) {
      const dy = this.getTitleTranslationY();
      title.node.y = isFinite(dy) ? dy : 0;
      const titleBox = title.node.getBBox();
      title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox);
    }
    for (const circle of [this.zerosumInnerRing, this.zerosumOuterRing]) {
      circle.fillOpacity = 0;
      circle.stroke = this.properties.calloutLabel.color;
      circle.strokeWidth = 1;
      circle.strokeOpacity = 1;
    }
    this.updateNodeMidPoint();
    this.updateSelections();
    this.updateNodes(seriesRect);
  }
  updateTitleNodes() {
    const { oldTitle } = this;
    const { title } = this.properties;
    if (oldTitle !== title) {
      if (oldTitle) {
        this.labelGroup?.removeChild(oldTitle.node);
      }
      if (title) {
        title.node.textBaseline = "bottom";
        this.labelGroup?.appendChild(title.node);
      }
      this.oldTitle = title;
    }
  }
  updateNodeMidPoint() {
    const setMidPoint = (d) => {
      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;
      d.midPoint = {
        x: d.midCos * Math.max(0, radius),
        y: d.midSin * Math.max(0, radius)
      };
    };
    this.nodeData.forEach(setMidPoint);
    this.phantomNodeData?.forEach(setMidPoint);
  }
  updateSelections() {
    this.updateGroupSelection();
    this.updateInnerCircleSelection();
  }
  updateGroupSelection() {
    const {
      itemSelection,
      highlightSelection,
      phantomSelection,
      highlightLabelSelection,
      calloutLabelSelection,
      labelSelection,
      innerLabelsSelection
    } = this;
    const highlightedNodeData = this.nodeData.map((datum) => ({
      ...datum,
      // Allow mutable sectorFormat, so formatted sector styles can be updated and varied
      // between normal and highlighted cases.
      sectorFormat: { ...datum.sectorFormat }
    }));
    const update = (selection, nodeData) => {
      selection.update(nodeData, void 0, (datum) => this.getDatumId(datum.datumIndex));
      if (this.ctx.animationManager.isSkipped()) {
        selection.cleanup();
      }
    };
    update(itemSelection, this.nodeData);
    update(highlightSelection, highlightedNodeData);
    update(phantomSelection, this.phantomNodeData ?? []);
    calloutLabelSelection.update(this.calloutNodeData, (group) => {
      const line = new Line();
      line.tag = 0 /* Callout */;
      line.pointerEvents = 1 /* None */;
      group.appendChild(line);
      const text = new Text();
      text.tag = 1 /* Label */;
      text.pointerEvents = 1 /* None */;
      group.appendChild(text);
    });
    labelSelection.update(this.nodeData);
    highlightLabelSelection.update(highlightedNodeData);
    innerLabelsSelection.update(this.properties.innerLabels, (node) => {
      node.pointerEvents = 1 /* None */;
    });
  }
  updateInnerCircleSelection() {
    const { innerCircle } = this.properties;
    let radius = 0;
    const innerRadius = this.getInnerRadius();
    if (innerRadius > 0) {
      const circleRadius = Math.min(innerRadius, this.getOuterRadius());
      const antiAliasingPadding = 1;
      radius = Math.ceil(circleRadius * 2 + antiAliasingPadding);
    }
    const datums = innerCircle ? [{ radius }] : [];
    this.innerCircleSelection.update(datums);
  }
  updateNodes(seriesRect) {
    const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();
    const { visible } = this;
    this.backgroundGroup.visible = visible;
    this.contentGroup.visible = visible;
    this.highlightGroup.visible = visible && highlightedDatum?.series === this;
    this.highlightLabel.visible = visible && highlightedDatum?.series === this;
    this.labelGroup.visible = visible;
    this.contentGroup.opacity = this.getOpacity();
    this.innerCircleSelection.each((node, { radius }) => {
      node.setProperties({
        fill: this.getNodeFill(this.properties.innerCircle?.fill, ["black"], "black"),
        opacity: this.properties.innerCircle?.fillOpacity,
        size: radius
      });
    });
    const innerRadius = this.radiusScale.range[0];
    const outerRadius = this.radiusScale.range[1];
    const fillBBox = this.getShapeFillBBox();
    const animationDisabled = this.ctx.animationManager.isSkipped();
    const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {
      const format = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);
      datum.sectorFormat.fill = format.fill;
      datum.sectorFormat.stroke = format.stroke;
      if (animationDisabled) {
        sector.startAngle = datum.startAngle;
        sector.endAngle = datum.endAngle;
        sector.innerRadius = datum.innerRadius;
        sector.outerRadius = datum.outerRadius;
      }
      if (isDatumHighlighted || animationDisabled) {
        sector.fill = format.fill;
        sector.stroke = format.stroke;
      }
      const fillParams = this.getFillParams(format.fill, innerRadius, outerRadius);
      applyShapeFillBBox(sector, format.fill, fillBBox, fillParams);
      sector.strokeWidth = format.strokeWidth;
      sector.fillOpacity = format.fillOpacity;
      sector.strokeOpacity = format.strokeOpacity;
      sector.lineDash = format.lineDash;
      sector.lineDashOffset = format.lineDashOffset;
      sector.cornerRadius = format.cornerRadius;
      sector.fillShadow = this.properties.shadow;
      const inset = Math.max(
        (this.properties.sectorSpacing + (format.stroke != null ? format.strokeWidth : 0)) / 2,
        0
      );
      sector.inset = inset;
      sector.lineJoin = this.properties.sectorSpacing >= 0 || inset > 0 ? "miter" : "round";
    };
    this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));
    this.highlightSelection.each((node, datum, index) => {
      updateSectorFn(node, datum, index, true);
      node.visible = datum.itemId === highlightedDatum?.itemId;
    });
    this.phantomSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));
    this.updateCalloutLineNodes();
    this.updateCalloutLabelNodes(seriesRect);
    this.updateSectorLabelNodes();
    this.updateInnerLabelNodes();
    this.updateZerosumRings();
    this.animationState.transition("update");
  }
  updateCalloutLineNodes() {
    const {
      calloutLine: { length: calloutLength, strokeWidth, colors },
      strokes
    } = this.properties;
    const calloutStrokeWidth = strokeWidth;
    const calloutColors = isStringFillArray(colors) ? colors ?? this.properties.strokes : strokes;
    const { offset: offset4 } = this.properties.calloutLabel;
    this.calloutLabelSelection.selectByTag(0 /* Callout */).forEach((line) => {
      const datum = line.closestDatum();
      const { calloutLabel: label, outerRadius, datumIndex } = datum;
      if (label?.text && !label.hidden && outerRadius !== 0) {
        line.visible = true;
        line.strokeWidth = calloutStrokeWidth;
        line.stroke = calloutColors[datumIndex % calloutColors.length];
        line.fill = void 0;
        const x1 = datum.midCos * outerRadius;
        const y1 = datum.midSin * outerRadius;
        let x2 = datum.midCos * (outerRadius + calloutLength);
        let y2 = datum.midSin * (outerRadius + calloutLength);
        const isMoved = label.collisionTextAlign ?? label.collisionOffsetY !== 0;
        if (isMoved && label.box != null) {
          const box = label.box;
          let cx = x2;
          let cy = y2;
          if (x2 < box.x) {
            cx = box.x;
          } else if (x2 > box.x + box.width) {
            cx = box.x + box.width;
          }
          if (y2 < box.y) {
            cy = box.y;
          } else if (y2 > box.y + box.height) {
            cy = box.y + box.height;
          }
          const dx = cx - x2;
          const dy = cy - y2;
          const length = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
          const paddedLength = length - offset4;
          if (paddedLength > 0) {
            x2 = x2 + dx * paddedLength / length;
            y2 = y2 + dy * paddedLength / length;
          }
        }
        line.x1 = x1;
        line.y1 = y1;
        line.x2 = x2;
        line.y2 = y2;
      } else {
        line.visible = false;
      }
    });
  }
  getLabelOverflow(text, box, seriesRect) {
    const seriesLeft = -this.centerX;
    const seriesRight = seriesLeft + seriesRect.width;
    const seriesTop = -this.centerY;
    const seriesBottom = seriesTop + seriesRect.height;
    const errPx = 1;
    let visibleTextPart = 1;
    if (box.x + errPx < seriesLeft) {
      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;
    } else if (box.x + box.width - errPx > seriesRight) {
      visibleTextPart = (seriesRight - box.x) / box.width;
    }
    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;
    const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;
    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);
    return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };
  }
  bboxIntersectsSurroundingSeries(box) {
    const { surroundingRadius } = this;
    if (surroundingRadius == null) {
      return false;
    }
    const corners = [
      { x: box.x, y: box.y },
      { x: box.x + box.width, y: box.y },
      { x: box.x + box.width, y: box.y + box.height },
      { x: box.x, y: box.y + box.height }
    ];
    const sur2 = surroundingRadius ** 2;
    return corners.some((corner) => corner.x ** 2 + corner.y ** 2 > sur2);
  }
  computeCalloutLabelCollisionOffsets() {
    const { radiusScale } = this;
    const { calloutLabel, calloutLine } = this.properties;
    const { offset: offset4, minSpacing } = calloutLabel;
    const innerRadius = radiusScale.convert(0);
    const shouldSkip = (datum) => {
      const label = datum.calloutLabel;
      return !label || datum.outerRadius === 0;
    };
    const fullData = this.calloutNodeData;
    const data = fullData.filter((t) => !shouldSkip(t));
    data.forEach((datum) => {
      const label = datum.calloutLabel;
      if (label == null)
        return;
      label.hidden = false;
      label.collisionTextAlign = void 0;
      label.collisionOffsetY = 0;
    });
    if (data.length <= 1) {
      return;
    }
    const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);
    const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);
    const topLabels = data.filter((d) => d.midSin < 0 && d.calloutLabel?.textAlign === "center").sort((a, b) => a.midCos - b.midCos);
    const bottomLabels = data.filter((d) => d.midSin >= 0 && d.calloutLabel?.textAlign === "center").sort((a, b) => a.midCos - b.midCos);
    const getTextBBox = (datum) => {
      const label = datum.calloutLabel;
      if (label == null)
        return BBox.zero.clone();
      const labelRadius = datum.outerRadius + calloutLine.length + offset4;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      const textAlign = label.collisionTextAlign ?? label.textAlign;
      const textBaseline = label.textBaseline;
      return Text.computeBBox(label.text, x, y, {
        font: this.properties.calloutLabel,
        textAlign,
        textBaseline
      });
    };
    const avoidNeighbourYCollision = (label, next, direction) => {
      const box = getTextBBox(label).grow(minSpacing / 2);
      const other = getTextBBox(next).grow(minSpacing / 2);
      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === "to-top" ? box.y < other.y + other.height : box.y + box.height > other.y);
      if (collidesOrBehind) {
        next.calloutLabel.collisionOffsetY = direction === "to-top" ? box.y - other.y - other.height : box.y + box.height - other.y;
      }
    };
    const avoidYCollisions = (labels) => {
      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];
      const midIndex = labels.indexOf(midLabel);
      for (let i = midIndex - 1; i >= 0; i--) {
        const prev = labels[i + 1];
        const next = labels[i];
        avoidNeighbourYCollision(prev, next, "to-top");
      }
      for (let i = midIndex + 1; i < labels.length; i++) {
        const prev = labels[i - 1];
        const next = labels[i];
        avoidNeighbourYCollision(prev, next, "to-bottom");
      }
    };
    const avoidXCollisions = (labels) => {
      const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);
      const boxes = labels.map((label) => getTextBBox(label));
      const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));
      let labelsCollideLabelsByX = false;
      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {
        const box = paddedBoxes[i];
        for (let j = i + 1; j < labels.length; j++) {
          const other = paddedBoxes[j];
          if (box.collidesBBox(other)) {
            labelsCollideLabelsByX = true;
            break;
          }
        }
      }
      const sectors = fullData.map((datum) => {
        const { startAngle, endAngle, outerRadius } = datum;
        return { startAngle, endAngle, innerRadius, outerRadius };
      });
      const labelsCollideSectors = boxes.some((box) => {
        return sectors.some((sector) => boxCollidesSector(box, sector));
      });
      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {
        return;
      }
      labels.filter((d) => d.calloutLabel.textAlign === "center").forEach((d) => {
        const label = d.calloutLabel;
        if (d.midCos < 0) {
          label.collisionTextAlign = "right";
        } else if (d.midCos > 0) {
          label.collisionTextAlign = "left";
        } else {
          label.collisionTextAlign = "center";
        }
      });
    };
    avoidYCollisions(leftLabels);
    avoidYCollisions(rightLabels);
    avoidXCollisions(topLabels);
    avoidXCollisions(bottomLabels);
  }
  updateCalloutLabelNodes(seriesRect) {
    const { radiusScale } = this;
    const { calloutLabel, calloutLine } = this.properties;
    const calloutLength = calloutLine.length;
    const { offset: offset4, color: color7 } = calloutLabel;
    const tempTextNode = new Text();
    this.calloutLabelSelection.selectByTag(1 /* Label */).forEach((text) => {
      const datum = text.closestDatum();
      const label = datum.calloutLabel;
      const radius = radiusScale.convert(datum.radius);
      const outerRadius = Math.max(0, radius);
      if (!label?.text || outerRadius === 0 || label.hidden) {
        text.visible = false;
        return;
      }
      const labelRadius = outerRadius + calloutLength + offset4;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      const align2 = {
        textAlign: label.collisionTextAlign ?? label.textAlign,
        textBaseline: label.textBaseline
      };
      tempTextNode.text = label.text;
      tempTextNode.x = x;
      tempTextNode.y = y;
      tempTextNode.setFont(this.properties.calloutLabel);
      tempTextNode.setAlign(align2);
      const box = tempTextNode.getBBox();
      let displayText = label.text;
      let visible = true;
      if (calloutLabel.avoidCollisions) {
        const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);
        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\u2026`;
        visible = !hasVerticalOverflow;
      }
      text.text = displayText;
      text.x = x;
      text.y = y;
      text.setFont(this.properties.calloutLabel);
      text.setAlign(align2);
      text.fill = color7;
      text.visible = visible;
    });
  }
  computeLabelsBBox(options, seriesRect) {
    const { calloutLabel, calloutLine } = this.properties;
    const calloutLength = calloutLine.length;
    const { offset: offset4, maxCollisionOffset, minSpacing } = calloutLabel;
    if (!calloutLabel.avoidCollisions) {
      return null;
    }
    this.maybeRefreshNodeData();
    this.updateRadiusScale(false);
    this.computeCalloutLabelCollisionOffsets();
    const textBoxes = [];
    const text = new Text();
    let titleBox;
    const { title } = this.properties;
    if (title?.text && title.enabled) {
      const dy = this.getTitleTranslationY();
      if (isFinite(dy)) {
        text.text = title.text;
        text.x = 0;
        text.y = dy;
        text.setFont(title);
        text.setAlign({
          textBaseline: "bottom",
          textAlign: "center"
        });
        titleBox = text.getBBox();
        textBoxes.push(titleBox);
      }
    }
    this.calloutNodeData.forEach((datum) => {
      const label = datum.calloutLabel;
      if (!label || datum.outerRadius === 0) {
        return null;
      }
      const labelRadius = datum.outerRadius + calloutLength + offset4;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      text.text = label.text;
      text.x = x;
      text.y = y;
      text.setFont(this.properties.calloutLabel);
      text.setAlign({
        textAlign: label.collisionTextAlign ?? label.textAlign,
        textBaseline: label.textBaseline
      });
      const box = text.getBBox();
      label.box = box;
      if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {
        label.hidden = true;
        return;
      }
      if (titleBox) {
        const seriesTop = -this.centerY;
        const titleCleanArea = new BBox(
          titleBox.x - minSpacing,
          seriesTop,
          titleBox.width + 2 * minSpacing,
          titleBox.y + titleBox.height + minSpacing - seriesTop
        );
        if (box.collidesBBox(titleCleanArea)) {
          label.hidden = true;
          return;
        }
      }
      if (options.hideWhenNecessary) {
        const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(
          label.text,
          box,
          seriesRect
        );
        const isTooShort = label.text.length > 2 && textLength < 2;
        if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {
          label.hidden = true;
          return;
        }
      }
      label.hidden = false;
      textBoxes.push(box);
    });
    if (textBoxes.length === 0) {
      return null;
    }
    return BBox.merge(textBoxes);
  }
  updateSectorLabelNodes() {
    const { radiusScale } = this;
    const innerRadius = radiusScale.convert(0);
    const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color: color7 } = this.properties.sectorLabel;
    const updateSectorLabel = (text, datum) => {
      const { sectorLabel, outerRadius } = datum;
      let isTextVisible = false;
      if (sectorLabel && outerRadius !== 0) {
        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;
        text.fill = color7;
        text.fontStyle = fontStyle;
        text.fontWeight = fontWeight;
        text.fontSize = fontSize;
        text.fontFamily = fontFamily;
        text.text = sectorLabel.text;
        text.x = datum.midCos * labelRadius;
        text.y = datum.midSin * labelRadius;
        text.textAlign = "center";
        text.textBaseline = "middle";
        const bbox = text.getBBox();
        const corners = [
          [bbox.x, bbox.y],
          [bbox.x + bbox.width, bbox.y],
          [bbox.x + bbox.width, bbox.y + bbox.height],
          [bbox.x, bbox.y + bbox.height]
        ];
        const { startAngle, endAngle } = datum;
        const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };
        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {
          isTextVisible = true;
        }
      }
      text.visible = isTextVisible;
    };
    this.labelSelection.each(updateSectorLabel);
    this.highlightLabelSelection.each(updateSectorLabel);
  }
  updateInnerLabelNodes() {
    const textBBoxes = [];
    const margins = [];
    this.innerLabelsSelection.each((text, datum) => {
      const { fontStyle, fontWeight, fontSize, fontFamily, color: color7 } = datum;
      text.fontStyle = fontStyle;
      text.fontWeight = fontWeight;
      text.fontSize = fontSize;
      text.fontFamily = fontFamily;
      text.text = datum.text;
      text.x = 0;
      text.y = 0;
      text.fill = color7;
      text.textAlign = "center";
      text.textBaseline = "alphabetic";
      textBBoxes.push(text.getBBox());
      margins.push(datum.spacing);
    });
    const getMarginTop = (index) => index === 0 ? 0 : margins[index];
    const getMarginBottom = (index) => index === margins.length - 1 ? 0 : margins[index];
    const totalHeight = textBBoxes.reduce((sum, bbox, i) => {
      return sum + bbox.height + getMarginTop(i) + getMarginBottom(i);
    }, 0);
    const totalWidth = Math.max(...textBBoxes.map((bbox) => bbox.width));
    const innerRadius = this.getInnerRadius();
    const labelRadius = Math.sqrt(Math.pow(totalWidth / 2, 2) + Math.pow(totalHeight / 2, 2));
    const labelsVisible = labelRadius <= (innerRadius > 0 ? innerRadius : this.getOuterRadius());
    const textBottoms = [];
    for (let i = 0, prev = -totalHeight / 2; i < textBBoxes.length; i++) {
      const bbox = textBBoxes[i];
      const bottom = bbox.height + prev + getMarginTop(i);
      textBottoms.push(bottom);
      prev = bottom + getMarginBottom(i);
    }
    this.innerLabelsSelection.each((text, _datum, index) => {
      text.y = textBottoms[index];
      text.visible = labelsVisible;
    });
  }
  updateZerosumRings() {
    this.zerosumOuterRing.size = this.getOuterRadius() * 2;
    this.zerosumInnerRing.size = this.getInnerRadius() * 2;
  }
  pickNodeClosestDatum(point) {
    return pickByMatchingAngle(this, point);
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, properties } = this;
    const {
      legendItemKey,
      calloutLabelKey,
      calloutLabelName,
      sectorLabelKey,
      sectorLabelName,
      angleKey,
      angleName,
      radiusKey,
      radiusName,
      tooltip
    } = properties;
    const title = this.properties.title.text;
    if (!dataModel || !processedData)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const { angleRawValues, legendItemValues, calloutLabelValues, sectorLabelValues } = this.getProcessedDataValues(
      dataModel,
      processedData
    );
    const angleRawValue = angleRawValues[datumIndex];
    const label = legendItemValues?.[datumIndex] ?? (calloutLabelKey === angleKey ? void 0 : calloutLabelValues?.[datumIndex]) ?? (sectorLabelKey === angleKey ? void 0 : sectorLabelValues?.[datumIndex]) ?? angleName;
    return this.formatTooltipWithContext(
      tooltip,
      {
        title,
        symbol: this.legendItemSymbol(datumIndex),
        data: [
          {
            label,
            fallbackLabel: angleKey,
            value: formatValue(angleRawValue, 3)
          }
        ]
      },
      {
        seriesId,
        datum,
        title: angleName,
        legendItemKey,
        calloutLabelKey,
        calloutLabelName,
        sectorLabelKey,
        sectorLabelName,
        angleKey,
        angleName,
        radiusKey,
        radiusName,
        ...this.getSectorFormat(datum, datumIndex, false)
      }
    );
  }
  legendItemSymbol(datumIndex) {
    const datum = this.processedData?.dataSources.get(this.id)?.[datumIndex];
    const sectorFormat = this.getSectorFormat(datum, datumIndex, false);
    const { fillOpacity, strokeOpacity, strokeWidth, lineDash, lineDashOffset } = this.properties;
    let { fill } = sectorFormat;
    const { stroke: stroke2 } = sectorFormat;
    if (isGradientFill(fill)) {
      fill = { ...fill, gradient: "linear", rotation: 0, reverse: false };
    }
    return {
      marker: {
        fill,
        stroke: stroke2,
        fillOpacity,
        strokeOpacity,
        strokeWidth,
        lineDash,
        lineDashOffset
      }
    };
  }
  getLegendData(legendType) {
    const {
      visible,
      processedData,
      dataModel,
      id: seriesId,
      ctx: { legendManager }
    } = this;
    if (!dataModel || !processedData || legendType !== "category") {
      return [];
    }
    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey, showInLegend } = this.properties;
    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey))
      return [];
    const { angleRawValues, calloutLabelValues, sectorLabelValues, legendItemValues } = this.getProcessedDataValues(
      dataModel,
      processedData
    );
    const titleText = this.properties.title?.showInLegend && this.properties.title.text;
    const legendData = [];
    const hideZeros = this.properties.hideZeroValueSectorsInLegend;
    const rawData = processedData.dataSources.get(this.id);
    const invalidData = processedData.invalidData?.get(this.id);
    for (let datumIndex = 0; datumIndex < processedData.input.count; datumIndex++) {
      const datum = rawData?.[datumIndex];
      const angleRawValue = angleRawValues[datumIndex];
      if (invalidData?.[datumIndex] === true || hideZeros && angleRawValue === 0) {
        continue;
      }
      const labelParts = [];
      if (titleText) {
        labelParts.push(titleText);
      }
      const labels = this.getLabels(
        datum,
        2 * Math.PI,
        2 * Math.PI,
        false,
        calloutLabelValues?.[datumIndex],
        sectorLabelValues?.[datumIndex],
        legendItemValues?.[datumIndex]
      );
      if (legendItemKey && labels.legendItem !== void 0) {
        labelParts.push(labels.legendItem.text);
      } else if (calloutLabelKey && calloutLabelKey !== angleKey && labels.calloutLabel?.text !== void 0) {
        labelParts.push(labels.calloutLabel?.text);
      } else if (sectorLabelKey && sectorLabelKey !== angleKey && labels.sectorLabel?.text !== void 0) {
        labelParts.push(labels.sectorLabel?.text);
      }
      if (labelParts.length === 0)
        continue;
      legendData.push({
        legendType: "category",
        id: seriesId,
        datum,
        itemId: datumIndex,
        seriesId,
        hideToggleOtherSeries: true,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId: datumIndex }),
        label: {
          text: labelParts.join(" - ")
        },
        symbol: this.legendItemSymbol(datumIndex),
        legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0,
        hideInLegend: !showInLegend
      });
    }
    return legendData;
  }
  // Used for grid
  setLegendState(enabledItems) {
    const {
      id: seriesId,
      ctx: { legendManager, updateService }
    } = this;
    enabledItems.forEach((enabled, itemId) => legendManager.toggleItem(enabled, seriesId, itemId));
    legendManager.update();
    updateService.update(5 /* SERIES_UPDATE */);
  }
  animateEmptyUpdateReady(_data) {
    const { animationManager } = this.ctx;
    const fns = preparePieSeriesAnimationFunctions(
      true,
      this.properties.rotation,
      this.radiusScale,
      this.previousRadiusScale
    );
    fromToMotion(
      this.id,
      "nodes",
      animationManager,
      [this.itemSelection, this.highlightSelection, this.phantomSelection],
      fns.nodes,
      (_, datum) => this.getDatumId(datum.datumIndex)
    );
    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
    seriesLabelFadeInAnimation(this, "callout", animationManager, this.calloutLabelSelection);
    seriesLabelFadeInAnimation(this, "sector", animationManager, this.labelSelection);
    seriesLabelFadeInAnimation(this, "highlight", animationManager, this.highlightLabelSelection);
    seriesLabelFadeInAnimation(this, "inner", animationManager, this.innerLabelsSelection);
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  animateWaitingUpdateReady() {
    const { itemSelection, highlightSelection, phantomSelection, processedData, radiusScale, previousRadiusScale } = this;
    const { animationManager } = this.ctx;
    const dataDiff = processedData?.reduced?.diff?.[this.id];
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    const supportedDiff = (dataDiff?.moved.size ?? 0) === 0;
    const hasKeys = (processedData?.defs.keys.length ?? 0) > 0;
    const hasUniqueKeys = processedData?.reduced?.animationValidation?.uniqueKeys ?? true;
    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {
      this.ctx.animationManager.skipCurrentBatch();
    }
    const noVisibleData = !this.nodeData.some((n) => n.enabled);
    const fns = preparePieSeriesAnimationFunctions(
      false,
      this.properties.rotation,
      radiusScale,
      previousRadiusScale
    );
    fromToMotion(
      this.id,
      "nodes",
      animationManager,
      [itemSelection, highlightSelection, phantomSelection],
      fns.nodes,
      (_, datum) => this.getDatumId(datum.datumIndex),
      dataDiff
    );
    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
    seriesLabelFadeInAnimation(this, "callout", this.ctx.animationManager, this.calloutLabelSelection);
    seriesLabelFadeInAnimation(this, "sector", this.ctx.animationManager, this.labelSelection);
    seriesLabelFadeInAnimation(this, "highlight", this.ctx.animationManager, this.highlightLabelSelection);
    if (this.noVisibleData !== noVisibleData) {
      this.noVisibleData = noVisibleData;
      seriesLabelFadeInAnimation(this, "inner", this.ctx.animationManager, this.innerLabelsSelection);
    }
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  animateClearingUpdateEmpty() {
    const { itemSelection, highlightSelection, phantomSelection, radiusScale, previousRadiusScale } = this;
    const { animationManager } = this.ctx;
    const fns = preparePieSeriesAnimationFunctions(
      false,
      this.properties.rotation,
      radiusScale,
      previousRadiusScale
    );
    fromToMotion(
      this.id,
      "nodes",
      animationManager,
      [itemSelection, highlightSelection, phantomSelection],
      fns.nodes,
      (_, datum) => this.getDatumId(datum.datumIndex)
    );
    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
    seriesLabelFadeOutAnimation(this, "callout", this.ctx.animationManager, this.calloutLabelSelection);
    seriesLabelFadeOutAnimation(this, "sector", this.ctx.animationManager, this.labelSelection);
    seriesLabelFadeOutAnimation(this, "highlight", this.ctx.animationManager, this.highlightLabelSelection);
    seriesLabelFadeOutAnimation(this, "inner", this.ctx.animationManager, this.innerLabelsSelection);
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  getDatumId(datumIndex) {
    return `${datumIndex}`;
  }
};
DonutSeries.className = "DonutSeries";
DonutSeries.type = "donut";

// packages/ag-charts-community/src/chart/series/polar/donutSeriesOptionsDef.ts
var import_ag_charts_core142 = require("ag-charts-core");

// packages/ag-charts-community/src/chart/series/polar/pieSeriesOptionsDef.ts
var import_ag_charts_core141 = require("ag-charts-core");
var pieSeriesThemeableOptionsDef = {
  radiusMin: import_ag_charts_core141.positiveNumber,
  radiusMax: import_ag_charts_core141.positiveNumber,
  rotation: import_ag_charts_core141.number,
  outerRadiusOffset: import_ag_charts_core141.number,
  outerRadiusRatio: import_ag_charts_core141.ratio,
  hideZeroValueSectorsInLegend: import_ag_charts_core141.boolean,
  sectorSpacing: import_ag_charts_core141.positiveNumber,
  cornerRadius: import_ag_charts_core141.positiveNumber,
  itemStyler: (0, import_ag_charts_core141.callbackDefs)({
    ...import_ag_charts_core141.fillOptionsDef,
    ...import_ag_charts_core141.strokeOptionsDef,
    ...import_ag_charts_core141.lineDashOptionsDef,
    cornerRadius: import_ag_charts_core141.positiveNumber
  }),
  title: {
    enabled: import_ag_charts_core141.boolean,
    text: import_ag_charts_core141.string,
    showInLegend: import_ag_charts_core141.boolean,
    spacing: import_ag_charts_core141.positiveNumber,
    ...import_ag_charts_core141.fontOptionsDef
  },
  calloutLabel: {
    enabled: import_ag_charts_core141.boolean,
    offset: import_ag_charts_core141.number,
    minAngle: import_ag_charts_core141.positiveNumber,
    avoidCollisions: import_ag_charts_core141.boolean,
    formatter: import_ag_charts_core141.callback,
    ...import_ag_charts_core141.fontOptionsDef
  },
  sectorLabel: {
    enabled: import_ag_charts_core141.boolean,
    positionOffset: import_ag_charts_core141.number,
    positionRatio: import_ag_charts_core141.ratio,
    formatter: import_ag_charts_core141.callback,
    ...import_ag_charts_core141.fontOptionsDef
  },
  calloutLine: {
    colors: (0, import_ag_charts_core141.arrayOf)(import_ag_charts_core141.color),
    length: import_ag_charts_core141.positiveNumber,
    strokeWidth: import_ag_charts_core141.positiveNumber
  },
  fills: (0, import_ag_charts_core141.arrayOf)(import_ag_charts_core141.colorUnion),
  strokes: (0, import_ag_charts_core141.arrayOf)(import_ag_charts_core141.color),
  tooltip: tooltipOptionsDefs,
  shadow: shadowOptionsDefs,
  ...commonSeriesThemeableOptionsDefs,
  ...import_ag_charts_core141.lineDashOptionsDef,
  ...without(import_ag_charts_core141.fillOptionsDef, ["fill"]),
  ...without(import_ag_charts_core141.strokeOptionsDef, ["stroke"])
};
var pieSeriesOptionsDef = {
  ...pieSeriesThemeableOptionsDef,
  ...commonSeriesOptionsDefs,
  type: (0, import_ag_charts_core141.required)((0, import_ag_charts_core141.constant)("pie")),
  angleKey: (0, import_ag_charts_core141.required)(import_ag_charts_core141.string),
  radiusKey: import_ag_charts_core141.string,
  calloutLabelKey: import_ag_charts_core141.string,
  sectorLabelKey: import_ag_charts_core141.string,
  legendItemKey: import_ag_charts_core141.string,
  angleName: import_ag_charts_core141.string,
  radiusName: import_ag_charts_core141.string,
  calloutLabelName: import_ag_charts_core141.string,
  sectorLabelName: import_ag_charts_core141.string
};
pieSeriesOptionsDef.defaultColorRange = (0, import_ag_charts_core141.undocumented)((0, import_ag_charts_core141.arrayOf)((0, import_ag_charts_core141.arrayOf)(import_ag_charts_core141.color)));
pieSeriesOptionsDef.defaultPatternFills = (0, import_ag_charts_core141.undocumented)((0, import_ag_charts_core141.arrayOf)(import_ag_charts_core141.color));
pieSeriesOptionsDef.title._enabledFromTheme = (0, import_ag_charts_core141.undocumented)(import_ag_charts_core141.boolean);
pieSeriesOptionsDef.calloutLabel._enabledFromTheme = (0, import_ag_charts_core141.undocumented)(import_ag_charts_core141.boolean);
pieSeriesOptionsDef.sectorLabel._enabledFromTheme = (0, import_ag_charts_core141.undocumented)(import_ag_charts_core141.boolean);

// packages/ag-charts-community/src/chart/series/polar/donutSeriesOptionsDef.ts
var donutSeriesThemeableOptionsDef = {
  ...pieSeriesThemeableOptionsDef,
  innerRadiusOffset: import_ag_charts_core142.number,
  innerRadiusRatio: import_ag_charts_core142.ratio,
  innerCircle: {
    fill: import_ag_charts_core142.string,
    fillOpacity: import_ag_charts_core142.ratio
  },
  innerLabels: {
    spacing: import_ag_charts_core142.positiveNumber,
    ...import_ag_charts_core142.fontOptionsDef
  }
};
var donutSeriesOptionsDef = {
  ...donutSeriesThemeableOptionsDef,
  ...pieSeriesOptionsDef,
  type: (0, import_ag_charts_core142.required)((0, import_ag_charts_core142.constant)("donut")),
  innerLabels: (0, import_ag_charts_core142.arrayOfDefs)(
    {
      text: (0, import_ag_charts_core142.required)(import_ag_charts_core142.string),
      spacing: import_ag_charts_core142.positiveNumber,
      ...import_ag_charts_core142.fontOptionsDef
    },
    "inner label options array"
  )
};

// packages/ag-charts-community/src/chart/series/polar/donutSeriesModule.ts
var NewDonutSeriesModule = {
  type: "series",
  name: "donut",
  chartType: "polar",
  options: donutSeriesOptionsDef,
  create: (ctx) => new DonutSeries(ctx)
};

// packages/ag-charts-community/src/chart/series/polar/pieSeries.ts
var import_ag_charts_core144 = require("ag-charts-core");

// packages/ag-charts-community/src/chart/series/polar/pieSeriesProperties.ts
var PieTitle = class extends Caption {
  constructor() {
    super(...arguments);
    this.showInLegend = false;
  }
};
__decorateClass([
  Property
], PieTitle.prototype, "showInLegend", 2);
var PieSeriesCalloutLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.offset = 3;
    this.minAngle = 0;
    this.minSpacing = 4;
    this.maxCollisionOffset = 50;
    this.avoidCollisions = true;
  }
};
__decorateClass([
  Property
], PieSeriesCalloutLabel.prototype, "offset", 2);
__decorateClass([
  Property
], PieSeriesCalloutLabel.prototype, "minAngle", 2);
__decorateClass([
  Property
], PieSeriesCalloutLabel.prototype, "minSpacing", 2);
__decorateClass([
  Property
], PieSeriesCalloutLabel.prototype, "maxCollisionOffset", 2);
__decorateClass([
  Property
], PieSeriesCalloutLabel.prototype, "avoidCollisions", 2);
var PieSeriesSectorLabel = class extends Label {
  constructor() {
    super(...arguments);
    this.positionOffset = 0;
    this.positionRatio = 0.5;
  }
};
__decorateClass([
  Property
], PieSeriesSectorLabel.prototype, "positionOffset", 2);
__decorateClass([
  Property
], PieSeriesSectorLabel.prototype, "positionRatio", 2);
var PieSeriesCalloutLine = class extends BaseProperties {
  constructor() {
    super(...arguments);
    this.length = 10;
    this.strokeWidth = 1;
  }
};
__decorateClass([
  Property
], PieSeriesCalloutLine.prototype, "colors", 2);
__decorateClass([
  Property
], PieSeriesCalloutLine.prototype, "length", 2);
__decorateClass([
  Property
], PieSeriesCalloutLine.prototype, "strokeWidth", 2);
var PieSeriesProperties = class extends SeriesProperties {
  constructor() {
    super(...arguments);
    this.defaultColorRange = [];
    this.defaultPatternFills = [];
    this.fills = Object.values(DEFAULT_FILLS);
    this.strokes = Object.values(DEFAULT_STROKES);
    this.fillOpacity = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.rotation = 0;
    this.outerRadiusOffset = 0;
    this.outerRadiusRatio = 1;
    this.strokeWidth = 1;
    this.sectorSpacing = 0;
    this.hideZeroValueSectorsInLegend = false;
    this.title = new PieTitle();
    this.shadow = new DropShadow();
    this.calloutLabel = new PieSeriesCalloutLabel();
    this.sectorLabel = new PieSeriesSectorLabel();
    this.calloutLine = new PieSeriesCalloutLine();
    this.tooltip = new SeriesTooltip();
  }
};
__decorateClass([
  Property
], PieSeriesProperties.prototype, "angleKey", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "angleName", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "angleFilterKey", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "radiusKey", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "radiusName", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "radiusMin", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "radiusMax", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "calloutLabelKey", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "calloutLabelName", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "sectorLabelKey", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "sectorLabelName", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "legendItemKey", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "defaultColorRange", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "defaultPatternFills", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "fills", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "strokes", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "lineDash", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "itemStyler", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "rotation", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "outerRadiusOffset", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "outerRadiusRatio", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "sectorSpacing", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "hideZeroValueSectorsInLegend", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "title", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "shadow", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "calloutLabel", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "sectorLabel", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "calloutLine", 2);
__decorateClass([
  Property
], PieSeriesProperties.prototype, "tooltip", 2);

// packages/ag-charts-community/src/chart/series/polar/pieSeries.ts
var PieSeriesNodeEvent = class extends SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.angleKey = series.properties.angleKey;
    this.radiusKey = series.properties.radiusKey;
    this.calloutLabelKey = series.properties.calloutLabelKey;
    this.sectorLabelKey = series.properties.sectorLabelKey;
  }
};
var PieSeries = class extends PolarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      categoryKey: void 0,
      pickModes: [1 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],
      useLabelLayer: true,
      animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }
    });
    this.properties = new PieSeriesProperties();
    this.phantomNodeData = void 0;
    this.backgroundGroup = new TranslatableGroup({
      name: `${this.id}-background`,
      zIndex: 0 /* BACKGROUND */
    });
    this.previousRadiusScale = new LinearScale();
    this.radiusScale = new LinearScale();
    this.phantomGroup = this.backgroundGroup.appendChild(new Group({ name: "phantom" }));
    this.phantomSelection = Selection.select(
      this.phantomGroup,
      () => this.nodeFactory(),
      false
    );
    this.calloutLabelGroup = this.contentGroup.appendChild(new Group({ name: "pieCalloutLabels" }));
    this.calloutLabelSelection = new Selection(
      this.calloutLabelGroup,
      Group
    );
    // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.
    this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));
    this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Marker({ shape: "circle" }));
    this.surroundingRadius = void 0;
    this.NodeEvent = PieSeriesNodeEvent;
    this.angleScale = new LinearScale();
    this.angleScale.domain = [0, 1];
    this.angleScale.range = [-Math.PI, Math.PI].map((angle) => angle + Math.PI / 2);
    this.phantomGroup.opacity = 0.2;
  }
  get calloutNodeData() {
    return this.phantomNodeData ?? this.nodeData;
  }
  attachSeries(seriesContentNode, seriesNode, annotationNode) {
    super.attachSeries(seriesContentNode, seriesNode, annotationNode);
    seriesContentNode.appendChild(this.backgroundGroup);
  }
  detachSeries(seriesContentNode, seriesNode, annotationNode) {
    super.detachSeries(seriesContentNode, seriesNode, annotationNode);
    seriesContentNode?.removeChild(this.backgroundGroup);
  }
  setSeriesIndex(index) {
    if (!super.setSeriesIndex(index))
      return false;
    this.backgroundGroup.zIndex = [0 /* BACKGROUND */, index];
    return true;
  }
  nodeFactory() {
    const sector = new Sector();
    sector.miterLimit = 1e9;
    return sector;
  }
  getSeriesDomain(direction) {
    if (direction === "angle" /* Angle */) {
      return this.angleScale.domain;
    } else {
      return this.radiusScale.domain;
    }
  }
  async processData(dataController) {
    if (this.data == null)
      return;
    const {
      visible,
      id: seriesId,
      ctx: { legendManager }
    } = this;
    const { angleKey, angleFilterKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
    const processor = () => (value, index) => {
      if (visible && legendManager.getItemEnabled({ seriesId, itemId: index })) {
        return value;
      }
      return 0;
    };
    const animationEnabled = !this.ctx.animationManager.isSkipped();
    const extraKeyProps = [];
    const extraProps = [];
    if (legendItemKey) {
      extraKeyProps.push(keyProperty(legendItemKey, "band", { id: `legendItemKey` }));
    } else if (calloutLabelKey) {
      extraKeyProps.push(keyProperty(calloutLabelKey, "band", { id: `calloutLabelKey` }));
    } else if (sectorLabelKey) {
      extraKeyProps.push(keyProperty(sectorLabelKey, "band", { id: `sectorLabelKey` }));
    }
    const radiusScaleType = this.radiusScale.type;
    const angleScaleType = this.angleScale.type;
    if (radiusKey) {
      extraProps.push(
        rangedValueProperty(radiusKey, {
          id: "radiusValue",
          min: this.properties.radiusMin ?? 0,
          max: this.properties.radiusMax,
          missingValue: this.properties.radiusMax ?? 1,
          processor
        }),
        valueProperty(radiusKey, radiusScaleType, { id: `radiusRaw`, processor }),
        // Raw value pass-through.
        normalisePropertyTo("radiusValue", [0, 1], 1, this.properties.radiusMin ?? 0, this.properties.radiusMax)
      );
    }
    if (calloutLabelKey) {
      extraProps.push(valueProperty(calloutLabelKey, "band", { id: `calloutLabelValue` }));
    }
    if (sectorLabelKey) {
      extraProps.push(valueProperty(sectorLabelKey, "band", { id: `sectorLabelValue` }));
    }
    if (legendItemKey) {
      extraProps.push(valueProperty(legendItemKey, "band", { id: `legendItemValue` }));
    }
    if (angleFilterKey) {
      extraProps.push(
        accumulativeValueProperty(angleFilterKey, angleScaleType, {
          id: `angleFilterValue`,
          onlyPositive: true,
          invalidValue: 0,
          processor
        }),
        valueProperty(angleFilterKey, angleScaleType, { id: `angleFilterRaw` }),
        normalisePropertyTo("angleFilterValue", [0, 1], 0, 0)
      );
    }
    if (animationEnabled && this.processedData?.reduced?.animationValidation?.uniqueKeys && extraKeyProps.length > 0) {
      extraProps.push(diff(this.id, this.processedData));
    }
    extraProps.push(animationValidation());
    await this.requestDataModel(dataController, this.data, {
      props: [
        ...extraKeyProps,
        accumulativeValueProperty(angleKey, angleScaleType, {
          id: `angleValue`,
          onlyPositive: true,
          invalidValue: 0,
          processor
        }),
        valueProperty(angleKey, angleScaleType, { id: `angleRaw` }),
        // Raw value pass-through.
        normalisePropertyTo("angleValue", [0, 1], 0, 0),
        ...extraProps
      ]
    });
    for (const valueDef of this.processedData?.defs?.values ?? []) {
      const { id, missing, property } = valueDef;
      const missCount = getMissCount(this, missing);
      if (id !== "angleRaw" && missCount > 0) {
        import_ag_charts_core144.Logger.warnOnce(
          `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? "s" : ""}`
        );
      }
    }
    this.animationState.transition("updateData");
  }
  maybeRefreshNodeData() {
    if (!this.nodeDataRefresh)
      return;
    const { nodeData = [], phantomNodeData } = this.createNodeData() ?? {};
    this.nodeData = nodeData;
    this.phantomNodeData = phantomNodeData;
    this.nodeDataRefresh = false;
  }
  getProcessedDataValues(dataModel, processedData) {
    const angleValues = dataModel.resolveColumnById(this, `angleValue`, processedData);
    const angleRawValues = dataModel.resolveColumnById(this, `angleRaw`, processedData);
    const angleFilterValues = this.properties.angleFilterKey != null ? dataModel.resolveColumnById(this, `angleFilterValue`, processedData) : void 0;
    const angleFilterRawValues = this.properties.angleFilterKey != null ? dataModel.resolveColumnById(this, `angleFilterRaw`, processedData) : void 0;
    const radiusValues = this.properties.radiusKey ? dataModel.resolveColumnById(this, `radiusValue`, processedData) : void 0;
    const radiusRawValues = this.properties.radiusKey ? dataModel.resolveColumnById(this, `radiusRaw`, processedData) : void 0;
    const calloutLabelValues = this.properties.calloutLabelKey ? dataModel.resolveColumnById(this, `calloutLabelValue`, processedData) : void 0;
    const sectorLabelValues = this.properties.sectorLabelKey ? dataModel.resolveColumnById(this, `sectorLabelValue`, processedData) : void 0;
    const legendItemValues = this.properties.legendItemKey ? dataModel.resolveColumnById(this, `legendItemValue`, processedData) : void 0;
    return {
      angleValues,
      angleRawValues,
      angleFilterValues,
      angleFilterRawValues,
      radiusValues,
      radiusRawValues,
      calloutLabelValues,
      sectorLabelValues,
      legendItemValues
    };
  }
  createNodeData() {
    const {
      id: seriesId,
      processedData,
      dataModel,
      angleScale,
      ctx: { legendManager },
      visible
    } = this;
    const { rotation } = this.properties;
    if (!dataModel || processedData?.type !== "ungrouped")
      return;
    const {
      angleValues,
      angleRawValues,
      angleFilterValues,
      angleFilterRawValues,
      radiusValues,
      radiusRawValues,
      calloutLabelValues,
      sectorLabelValues,
      legendItemValues
    } = this.getProcessedDataValues(dataModel, processedData);
    const useFilterAngles = angleFilterRawValues?.some((filterRawValue, index) => {
      return filterRawValue > angleRawValues[index];
    }) ?? false;
    let currentStart = 0;
    let sum = 0;
    const nodes = [];
    const phantomNodes = angleFilterRawValues != null ? [] : void 0;
    const rawData = processedData.dataSources.get(this.id) ?? [];
    const invalidData = processedData.invalidData?.get(this.id);
    rawData.forEach((datum, datumIndex) => {
      if (invalidData?.[datumIndex] === true)
        return;
      const currentValue = useFilterAngles ? angleFilterValues[datumIndex] : angleValues[datumIndex];
      const crossFilterScale = angleFilterRawValues != null && !useFilterAngles ? Math.sqrt(angleFilterRawValues[datumIndex] / angleRawValues[datumIndex]) : 1;
      const startAngle = angleScale.convert(currentStart) + toRadians(rotation);
      currentStart = currentValue;
      sum += currentValue;
      const endAngle = angleScale.convert(currentStart) + toRadians(rotation);
      const span = Math.abs(endAngle - startAngle);
      const midAngle = startAngle + span / 2;
      const angleValue = angleRawValues[datumIndex];
      const radiusRaw = radiusValues?.[datumIndex] ?? 1;
      const radius = radiusRaw * crossFilterScale;
      const radiusValue = radiusRawValues?.[datumIndex];
      const legendItemValue = legendItemValues?.[datumIndex];
      const nodeLabels = this.getLabels(
        datum,
        midAngle,
        span,
        true,
        calloutLabelValues?.[datumIndex],
        sectorLabelValues?.[datumIndex],
        legendItemValue
      );
      const sectorFormat = this.getSectorFormat(datum, datumIndex, false);
      const node = {
        itemId: datumIndex,
        series: this,
        datum,
        datumIndex,
        angleValue,
        midAngle,
        midCos: Math.cos(midAngle),
        midSin: Math.sin(midAngle),
        startAngle,
        endAngle,
        radius,
        innerRadius: Math.max(this.radiusScale.convert(0), 0),
        outerRadius: Math.max(this.radiusScale.convert(radius), 0),
        sectorFormat,
        radiusValue,
        legendItemValue,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId: datumIndex }),
        ...nodeLabels
      };
      nodes.push(node);
      if (phantomNodes != null) {
        phantomNodes.push({
          ...node,
          radius: 1,
          innerRadius: Math.max(this.radiusScale.convert(0), 0),
          outerRadius: Math.max(this.radiusScale.convert(1), 0)
        });
      }
    });
    this.zerosumOuterRing.visible = sum === 0;
    return {
      itemId: seriesId,
      nodeData: nodes,
      labelData: nodes,
      phantomNodeData: phantomNodes
    };
  }
  getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {
    const { calloutLabel, sectorLabel, legendItemKey } = this.properties;
    const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.properties.calloutLabelKey : void 0;
    const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.properties.sectorLabelKey : void 0;
    if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {
      return {};
    }
    const labelFormatterParams = {
      datum,
      angleKey: this.properties.angleKey,
      angleName: this.properties.angleName,
      radiusKey: this.properties.radiusKey,
      radiusName: this.properties.radiusName,
      calloutLabelKey: this.properties.calloutLabelKey,
      calloutLabelName: this.properties.calloutLabelName,
      sectorLabelKey: this.properties.sectorLabelKey,
      sectorLabelName: this.properties.sectorLabelName,
      legendItemKey: this.properties.legendItemKey
    };
    const result = {};
    if (calloutLabelKey && span >= toRadians(calloutLabel.minAngle)) {
      result.calloutLabel = {
        ...this.getTextAlignment(midAngle),
        text: this.getLabelText(calloutLabel, {
          ...labelFormatterParams,
          value: calloutLabelValue
        }),
        hidden: false,
        collisionTextAlign: void 0,
        collisionOffsetY: 0,
        box: void 0
      };
    }
    if (sectorLabelKey) {
      result.sectorLabel = {
        text: this.getLabelText(sectorLabel, {
          ...labelFormatterParams,
          value: sectorLabelValue
        })
      };
    }
    if (legendItemKey != null && legendItemValue != null) {
      result.legendItem = { key: legendItemKey, text: legendItemValue };
    }
    return result;
  }
  getTextAlignment(midAngle) {
    const quadrantTextOpts = [
      { textAlign: "center", textBaseline: "bottom" },
      { textAlign: "left", textBaseline: "middle" },
      { textAlign: "center", textBaseline: "hanging" },
      { textAlign: "right", textBaseline: "middle" }
    ];
    const midAngle180 = normalizeAngle180(midAngle);
    const quadrantStart = -0.75 * Math.PI;
    const quadrantOffset = midAngle180 - quadrantStart;
    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));
    const quadrantIndex = (0, import_ag_charts_core144.modulus)(quadrant, quadrantTextOpts.length);
    return quadrantTextOpts[quadrantIndex];
  }
  getNodeFill(fill, defaultColorRange, defaultPatternFill) {
    return getShapeFill(
      fill,
      {
        type: "gradient",
        bounds: "series",
        colorStops: defaultColorRange.map((color7) => ({ color: color7 })),
        gradient: "radial",
        rotation: 0,
        reverse: true
      },
      {
        type: "pattern",
        pattern: "forward-slanted-lines",
        fill: defaultPatternFill,
        fillOpacity: 1,
        backgroundFill: "none",
        backgroundFillOpacity: 1,
        stroke: defaultPatternFill,
        strokeOpacity: 1,
        strokeWidth: 4,
        rotation: 0
      },
      {
        type: "image",
        backgroundFill: defaultPatternFill,
        backgroundFillOpacity: 1,
        fit: "contain",
        repeat: "no-repeat",
        rotation: 0
      }
    );
  }
  getFillParams(fill, innerRadius, outerRadius) {
    if (!isGradientFill(fill) || fill.bounds === "item")
      return;
    return {
      centerX: 0,
      centerY: 0,
      innerRadius,
      outerRadius
    };
  }
  getSectorFormat(datum, datumIndex, highlighted) {
    const {
      angleKey,
      radiusKey,
      calloutLabelKey,
      sectorLabelKey,
      legendItemKey,
      fills,
      strokes,
      defaultColorRange,
      defaultPatternFills,
      itemStyler
    } = this.properties;
    const defaultStroke = strokes[datumIndex % strokes.length];
    const { fill, fillOpacity, stroke: stroke2, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = mergeDefaults(
      highlighted && this.properties.highlightStyle.item,
      {
        fill: fills.length > 0 ? fills[datumIndex % fills.length] : void 0,
        stroke: defaultStroke,
        strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),
        strokeOpacity: this.getOpacity()
      },
      this.properties
    );
    const defaultColors = defaultColorRange[datumIndex % defaultColorRange.length];
    const defaultPatternFill = defaultPatternFills[datumIndex % defaultPatternFills.length];
    const sectorFill = fill ?? "black";
    let format;
    if (itemStyler) {
      format = this.cachedDatumCallback(
        this.getDatumId(datumIndex) + (highlighted ? "-highlight" : "-hide"),
        () => this.callWithContext(itemStyler, {
          datum,
          angleKey,
          radiusKey,
          calloutLabelKey,
          sectorLabelKey,
          legendItemKey,
          fill: this.getNodeFill(sectorFill, defaultColors, defaultPatternFill),
          strokeOpacity,
          stroke: stroke2,
          strokeWidth,
          fillOpacity,
          lineDash,
          lineDashOffset,
          cornerRadius,
          highlighted,
          seriesId: this.id
        })
      );
    }
    return {
      fill: this.getNodeFill(format?.fill ?? sectorFill, defaultColors, defaultPatternFill),
      fillOpacity: format?.fillOpacity ?? fillOpacity,
      stroke: format?.stroke ?? stroke2,
      strokeWidth: format?.strokeWidth ?? strokeWidth,
      strokeOpacity: format?.strokeOpacity ?? strokeOpacity,
      lineDash: format?.lineDash ?? lineDash,
      lineDashOffset: format?.lineDashOffset ?? lineDashOffset,
      cornerRadius: format?.cornerRadius ?? cornerRadius
    };
  }
  getOuterRadius() {
    return Math.max(this.radius * this.properties.outerRadiusRatio + this.properties.outerRadiusOffset, 0);
  }
  updateRadiusScale(resize) {
    const newRange = [0, this.getOuterRadius()];
    this.radiusScale.range = newRange;
    if (resize) {
      this.previousRadiusScale.range = newRange;
    }
    const setRadii = (d) => ({
      ...d,
      innerRadius: Math.max(this.radiusScale.convert(0), 0),
      outerRadius: Math.max(this.radiusScale.convert(d.radius), 0)
    });
    this.nodeData = this.nodeData.map(setRadii);
    this.phantomNodeData = this.phantomNodeData?.map(setRadii);
  }
  getTitleTranslationY() {
    const outerRadius = Math.max(0, this.radiusScale.range[1]);
    if (outerRadius === 0) {
      return NaN;
    }
    const spacing = this.properties.title?.spacing ?? 0;
    const titleOffset = 2 + spacing;
    const dy = Math.max(0, -outerRadius);
    return -outerRadius - titleOffset - dy;
  }
  update({ seriesRect }) {
    const { title } = this.properties;
    const newNodeDataDependencies = {
      seriesRectWidth: seriesRect?.width,
      seriesRectHeight: seriesRect?.height
    };
    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;
    if (resize) {
      this._nodeDataDependencies = newNodeDataDependencies;
    }
    this.maybeRefreshNodeData();
    this.updateTitleNodes();
    this.updateRadiusScale(resize);
    this.contentGroup.translationX = this.centerX;
    this.contentGroup.translationY = this.centerY;
    this.highlightGroup.translationX = this.centerX;
    this.highlightGroup.translationY = this.centerY;
    this.backgroundGroup.translationX = this.centerX;
    this.backgroundGroup.translationY = this.centerY;
    if (this.labelGroup) {
      this.labelGroup.translationX = this.centerX;
      this.labelGroup.translationY = this.centerY;
    }
    if (title) {
      const dy = this.getTitleTranslationY();
      title.node.y = isFinite(dy) ? dy : 0;
      const titleBox = title.node.getBBox();
      title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox);
    }
    this.zerosumOuterRing.fillOpacity = 0;
    this.zerosumOuterRing.stroke = this.properties.calloutLabel.color;
    this.zerosumOuterRing.strokeWidth = 1;
    this.zerosumOuterRing.strokeOpacity = 1;
    this.updateNodeMidPoint();
    this.updateSelections();
    this.updateNodes(seriesRect);
  }
  updateTitleNodes() {
    const { oldTitle } = this;
    const { title } = this.properties;
    if (oldTitle !== title) {
      if (oldTitle) {
        this.labelGroup?.removeChild(oldTitle.node);
      }
      if (title) {
        title.node.textBaseline = "bottom";
        this.labelGroup?.appendChild(title.node);
      }
      this.oldTitle = title;
    }
  }
  updateNodeMidPoint() {
    const setMidPoint = (d) => {
      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;
      d.midPoint = {
        x: d.midCos * Math.max(0, radius),
        y: d.midSin * Math.max(0, radius)
      };
    };
    this.nodeData.forEach(setMidPoint);
    this.phantomNodeData?.forEach(setMidPoint);
  }
  updateSelections() {
    const {
      itemSelection,
      highlightSelection,
      phantomSelection,
      highlightLabelSelection,
      calloutLabelSelection,
      labelSelection
    } = this;
    const highlightedNodeData = this.nodeData.map((datum) => ({
      ...datum,
      // Allow mutable sectorFormat, so formatted sector styles can be updated and varied
      // between normal and highlighted cases.
      sectorFormat: { ...datum.sectorFormat }
    }));
    const update = (selection, nodeData) => {
      selection.update(nodeData, void 0, (datum) => this.getDatumId(datum.datumIndex));
      if (this.ctx.animationManager.isSkipped()) {
        selection.cleanup();
      }
    };
    update(itemSelection, this.nodeData);
    update(highlightSelection, highlightedNodeData);
    update(phantomSelection, this.phantomNodeData ?? []);
    calloutLabelSelection.update(this.calloutNodeData, (group) => {
      const line = new Line();
      line.tag = 0 /* Callout */;
      line.pointerEvents = 1 /* None */;
      group.appendChild(line);
      const text = new Text();
      text.tag = 1 /* Label */;
      text.pointerEvents = 1 /* None */;
      group.appendChild(text);
    });
    labelSelection.update(this.nodeData);
    highlightLabelSelection.update(highlightedNodeData);
  }
  updateNodes(seriesRect) {
    const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();
    const { visible } = this;
    this.backgroundGroup.visible = visible;
    this.contentGroup.visible = visible;
    this.highlightGroup.visible = visible && highlightedDatum?.series === this;
    this.highlightLabel.visible = visible && highlightedDatum?.series === this;
    if (this.labelGroup) {
      this.labelGroup.visible = visible;
    }
    this.contentGroup.opacity = this.getOpacity();
    const innerRadius = this.radiusScale.range[0];
    const outerRadius = this.radiusScale.range[1];
    const fillBBox = this.getShapeFillBBox();
    const animationDisabled = this.ctx.animationManager.isSkipped();
    const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {
      const format = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);
      datum.sectorFormat.fill = format.fill;
      datum.sectorFormat.stroke = format.stroke;
      if (animationDisabled) {
        sector.startAngle = datum.startAngle;
        sector.endAngle = datum.endAngle;
        sector.innerRadius = datum.innerRadius;
        sector.outerRadius = datum.outerRadius;
      }
      if (isDatumHighlighted || animationDisabled) {
        sector.fill = format.fill;
        sector.stroke = format.stroke;
      }
      const fillParams = this.getFillParams(format.fill, innerRadius, outerRadius);
      applyShapeFillBBox(sector, format.fill, fillBBox, fillParams);
      sector.strokeWidth = format.strokeWidth;
      sector.fillOpacity = format.fillOpacity;
      sector.strokeOpacity = format.strokeOpacity;
      sector.lineDash = format.lineDash;
      sector.lineDashOffset = format.lineDashOffset;
      sector.cornerRadius = format.cornerRadius;
      sector.fillShadow = this.properties.shadow;
      const inset = Math.max(
        (this.properties.sectorSpacing + (format.stroke != null ? format.strokeWidth : 0)) / 2,
        0
      );
      sector.inset = inset;
      sector.lineJoin = this.properties.sectorSpacing >= 0 || inset > 0 ? "miter" : "round";
    };
    this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));
    this.highlightSelection.each((node, datum, index) => {
      updateSectorFn(node, datum, index, true);
      node.visible = datum.itemId === highlightedDatum?.itemId;
    });
    this.phantomSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));
    this.updateCalloutLineNodes();
    this.updateCalloutLabelNodes(seriesRect);
    this.updateSectorLabelNodes();
    this.updateZerosumRings();
    this.animationState.transition("update");
  }
  updateCalloutLineNodes() {
    const {
      calloutLine: { length: calloutLength, strokeWidth, colors },
      strokes
    } = this.properties;
    const calloutStrokeWidth = strokeWidth;
    const calloutColors = isStringFillArray(colors) ? colors : strokes;
    const { offset: offset4 } = this.properties.calloutLabel;
    this.calloutLabelSelection.selectByTag(0 /* Callout */).forEach((line) => {
      const datum = line.closestDatum();
      const { calloutLabel: label, outerRadius, datumIndex } = datum;
      if (label?.text && !label.hidden && outerRadius !== 0) {
        line.visible = true;
        line.strokeWidth = calloutStrokeWidth;
        line.stroke = calloutColors[datumIndex % calloutColors.length];
        line.fill = void 0;
        const x1 = datum.midCos * outerRadius;
        const y1 = datum.midSin * outerRadius;
        let x2 = datum.midCos * (outerRadius + calloutLength);
        let y2 = datum.midSin * (outerRadius + calloutLength);
        const isMoved = label.collisionTextAlign ?? label.collisionOffsetY !== 0;
        if (isMoved && label.box != null) {
          const box = label.box;
          let cx = x2;
          let cy = y2;
          if (x2 < box.x) {
            cx = box.x;
          } else if (x2 > box.x + box.width) {
            cx = box.x + box.width;
          }
          if (y2 < box.y) {
            cy = box.y;
          } else if (y2 > box.y + box.height) {
            cy = box.y + box.height;
          }
          const dx = cx - x2;
          const dy = cy - y2;
          const length = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
          const paddedLength = length - offset4;
          if (paddedLength > 0) {
            x2 = x2 + dx * paddedLength / length;
            y2 = y2 + dy * paddedLength / length;
          }
        }
        line.x1 = x1;
        line.y1 = y1;
        line.x2 = x2;
        line.y2 = y2;
      } else {
        line.visible = false;
      }
    });
  }
  getLabelOverflow(text, box, seriesRect) {
    const seriesLeft = -this.centerX;
    const seriesRight = seriesLeft + seriesRect.width;
    const seriesTop = -this.centerY;
    const seriesBottom = seriesTop + seriesRect.height;
    const errPx = 1;
    let visibleTextPart = 1;
    if (box.x + errPx < seriesLeft) {
      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;
    } else if (box.x + box.width - errPx > seriesRight) {
      visibleTextPart = (seriesRight - box.x) / box.width;
    }
    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;
    const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;
    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);
    return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };
  }
  bboxIntersectsSurroundingSeries(box) {
    const { surroundingRadius } = this;
    if (surroundingRadius == null) {
      return false;
    }
    const corners = [
      { x: box.x, y: box.y },
      { x: box.x + box.width, y: box.y },
      { x: box.x + box.width, y: box.y + box.height },
      { x: box.x, y: box.y + box.height }
    ];
    const sur2 = surroundingRadius ** 2;
    return corners.some((corner) => corner.x ** 2 + corner.y ** 2 > sur2);
  }
  computeCalloutLabelCollisionOffsets() {
    const { radiusScale } = this;
    const { calloutLabel, calloutLine } = this.properties;
    const { offset: offset4, minSpacing } = calloutLabel;
    const innerRadius = radiusScale.convert(0);
    const shouldSkip = (datum) => {
      const label = datum.calloutLabel;
      return !label || datum.outerRadius === 0;
    };
    const fullData = this.calloutNodeData;
    const data = fullData.filter((t) => !shouldSkip(t));
    data.forEach((datum) => {
      const label = datum.calloutLabel;
      if (label == null)
        return;
      label.hidden = false;
      label.collisionTextAlign = void 0;
      label.collisionOffsetY = 0;
    });
    if (data.length <= 1) {
      return;
    }
    const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);
    const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);
    const topLabels = data.filter((d) => d.midSin < 0 && d.calloutLabel?.textAlign === "center").sort((a, b) => a.midCos - b.midCos);
    const bottomLabels = data.filter((d) => d.midSin >= 0 && d.calloutLabel?.textAlign === "center").sort((a, b) => a.midCos - b.midCos);
    const getTextBBox = (datum) => {
      const label = datum.calloutLabel;
      if (label == null)
        return BBox.zero.clone();
      const labelRadius = datum.outerRadius + calloutLine.length + offset4;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      const textAlign = label.collisionTextAlign ?? label.textAlign;
      const textBaseline = label.textBaseline;
      return Text.computeBBox(label.text, x, y, {
        font: this.properties.calloutLabel,
        textAlign,
        textBaseline
      });
    };
    const avoidNeighbourYCollision = (label, next, direction) => {
      const box = getTextBBox(label).grow(minSpacing / 2);
      const other = getTextBBox(next).grow(minSpacing / 2);
      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === "to-top" ? box.y < other.y + other.height : box.y + box.height > other.y);
      if (collidesOrBehind) {
        next.calloutLabel.collisionOffsetY = direction === "to-top" ? box.y - other.y - other.height : box.y + box.height - other.y;
      }
    };
    const avoidYCollisions = (labels) => {
      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];
      const midIndex = labels.indexOf(midLabel);
      for (let i = midIndex - 1; i >= 0; i--) {
        const prev = labels[i + 1];
        const next = labels[i];
        avoidNeighbourYCollision(prev, next, "to-top");
      }
      for (let i = midIndex + 1; i < labels.length; i++) {
        const prev = labels[i - 1];
        const next = labels[i];
        avoidNeighbourYCollision(prev, next, "to-bottom");
      }
    };
    const avoidXCollisions = (labels) => {
      const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);
      const boxes = labels.map((label) => getTextBBox(label));
      const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));
      let labelsCollideLabelsByX = false;
      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {
        const box = paddedBoxes[i];
        for (let j = i + 1; j < labels.length; j++) {
          const other = paddedBoxes[j];
          if (box.collidesBBox(other)) {
            labelsCollideLabelsByX = true;
            break;
          }
        }
      }
      const sectors = fullData.map((datum) => {
        const { startAngle, endAngle, outerRadius } = datum;
        return { startAngle, endAngle, innerRadius, outerRadius };
      });
      const labelsCollideSectors = boxes.some((box) => {
        return sectors.some((sector) => boxCollidesSector(box, sector));
      });
      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {
        return;
      }
      labels.filter((d) => d.calloutLabel.textAlign === "center").forEach((d) => {
        const label = d.calloutLabel;
        if (d.midCos < 0) {
          label.collisionTextAlign = "right";
        } else if (d.midCos > 0) {
          label.collisionTextAlign = "left";
        } else {
          label.collisionTextAlign = "center";
        }
      });
    };
    avoidYCollisions(leftLabels);
    avoidYCollisions(rightLabels);
    avoidXCollisions(topLabels);
    avoidXCollisions(bottomLabels);
  }
  updateCalloutLabelNodes(seriesRect) {
    const { radiusScale } = this;
    const { calloutLabel, calloutLine } = this.properties;
    const calloutLength = calloutLine.length;
    const { offset: offset4, color: color7 } = calloutLabel;
    const tempTextNode = new Text();
    this.calloutLabelSelection.selectByTag(1 /* Label */).forEach((text) => {
      const datum = text.closestDatum();
      const label = datum.calloutLabel;
      const radius = radiusScale.convert(datum.radius);
      const outerRadius = Math.max(0, radius);
      if (!label?.text || outerRadius === 0 || label.hidden) {
        text.visible = false;
        return;
      }
      const labelRadius = outerRadius + calloutLength + offset4;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      const align2 = {
        textAlign: label.collisionTextAlign ?? label.textAlign,
        textBaseline: label.textBaseline
      };
      tempTextNode.text = label.text;
      tempTextNode.x = x;
      tempTextNode.y = y;
      tempTextNode.setFont(this.properties.calloutLabel);
      tempTextNode.setAlign(align2);
      const box = tempTextNode.getBBox();
      let displayText = label.text;
      let visible = true;
      if (calloutLabel.avoidCollisions) {
        const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);
        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\u2026`;
        visible = !hasVerticalOverflow;
      }
      text.text = displayText;
      text.x = x;
      text.y = y;
      text.setFont(this.properties.calloutLabel);
      text.setAlign(align2);
      text.fill = color7;
      text.visible = visible;
    });
  }
  computeLabelsBBox(options, seriesRect) {
    const { calloutLabel, calloutLine } = this.properties;
    const calloutLength = calloutLine.length;
    const { offset: offset4, maxCollisionOffset, minSpacing } = calloutLabel;
    if (!calloutLabel.avoidCollisions) {
      return null;
    }
    this.maybeRefreshNodeData();
    this.updateRadiusScale(false);
    this.computeCalloutLabelCollisionOffsets();
    const textBoxes = [];
    const text = new Text();
    let titleBox;
    const { title } = this.properties;
    if (title?.text && title.enabled) {
      const dy = this.getTitleTranslationY();
      if (isFinite(dy)) {
        text.text = title.text;
        text.x = 0;
        text.y = dy;
        text.setFont(title);
        text.setAlign({
          textBaseline: "bottom",
          textAlign: "center"
        });
        titleBox = text.getBBox();
        textBoxes.push(titleBox);
      }
    }
    this.calloutNodeData.forEach((datum) => {
      const label = datum.calloutLabel;
      if (!label || datum.outerRadius === 0) {
        return null;
      }
      const labelRadius = datum.outerRadius + calloutLength + offset4;
      const x = datum.midCos * labelRadius;
      const y = datum.midSin * labelRadius + label.collisionOffsetY;
      text.text = label.text;
      text.x = x;
      text.y = y;
      text.setFont(this.properties.calloutLabel);
      text.setAlign({
        textAlign: label.collisionTextAlign ?? label.textAlign,
        textBaseline: label.textBaseline
      });
      const box = text.getBBox();
      label.box = box;
      if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {
        label.hidden = true;
        return;
      }
      if (titleBox) {
        const seriesTop = -this.centerY;
        const titleCleanArea = new BBox(
          titleBox.x - minSpacing,
          seriesTop,
          titleBox.width + 2 * minSpacing,
          titleBox.y + titleBox.height + minSpacing - seriesTop
        );
        if (box.collidesBBox(titleCleanArea)) {
          label.hidden = true;
          return;
        }
      }
      if (options.hideWhenNecessary) {
        const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(
          label.text,
          box,
          seriesRect
        );
        const isTooShort = label.text.length > 2 && textLength < 2;
        if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {
          label.hidden = true;
          return;
        }
      }
      label.hidden = false;
      textBoxes.push(box);
    });
    if (textBoxes.length === 0) {
      return null;
    }
    return BBox.merge(textBoxes);
  }
  updateSectorLabelNodes() {
    const { radiusScale } = this;
    const innerRadius = radiusScale.convert(0);
    const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color: color7 } = this.properties.sectorLabel;
    const isDonut = innerRadius > 0;
    const singleVisibleSector = this.ctx.legendManager.getData(this.id)?.filter((d) => d.enabled).length === 1;
    const updateSectorLabel = (text, datum) => {
      const { sectorLabel, outerRadius, startAngle, endAngle } = datum;
      let isTextVisible = false;
      if (sectorLabel && outerRadius !== 0) {
        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;
        text.fill = color7;
        text.fontStyle = fontStyle;
        text.fontWeight = fontWeight;
        text.fontSize = fontSize;
        text.fontFamily = fontFamily;
        text.text = sectorLabel.text;
        const shouldPutTextInCenter = !isDonut && singleVisibleSector;
        if (shouldPutTextInCenter) {
          text.x = 0;
          text.y = 0;
        } else {
          text.x = datum.midCos * labelRadius;
          text.y = datum.midSin * labelRadius;
        }
        text.textAlign = "center";
        text.textBaseline = "middle";
        const bbox = text.getBBox();
        const corners = [
          [bbox.x, bbox.y],
          [bbox.x + bbox.width, bbox.y],
          [bbox.x + bbox.width, bbox.y + bbox.height],
          [bbox.x, bbox.y + bbox.height]
        ];
        const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };
        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {
          isTextVisible = true;
        }
      }
      text.visible = isTextVisible;
    };
    this.labelSelection.each(updateSectorLabel);
    this.highlightLabelSelection.each(updateSectorLabel);
  }
  updateZerosumRings() {
    this.zerosumOuterRing.size = this.getOuterRadius() * 2;
  }
  pickNodeClosestDatum(point) {
    return pickByMatchingAngle(this, point);
  }
  getTooltipContent(datumIndex) {
    const { id: seriesId, dataModel, processedData, properties } = this;
    const {
      legendItemKey,
      calloutLabelKey,
      calloutLabelName,
      sectorLabelKey,
      sectorLabelName,
      angleKey,
      angleName,
      radiusKey,
      radiusName,
      tooltip
    } = properties;
    const title = this.properties.title.text;
    if (!dataModel || !processedData)
      return;
    const datum = processedData.dataSources.get(this.id)?.[datumIndex];
    const { angleRawValues, legendItemValues, calloutLabelValues, sectorLabelValues } = this.getProcessedDataValues(
      dataModel,
      processedData
    );
    const angleRawValue = angleRawValues[datumIndex];
    const label = legendItemValues?.[datumIndex] ?? (calloutLabelKey === angleKey ? void 0 : calloutLabelValues?.[datumIndex]) ?? (sectorLabelKey === angleKey ? void 0 : sectorLabelValues?.[datumIndex]) ?? angleName;
    return this.formatTooltipWithContext(
      tooltip,
      {
        title,
        symbol: this.legendItemSymbol(datumIndex),
        data: [
          {
            label,
            fallbackLabel: angleKey,
            value: formatValue(angleRawValue, 3)
          }
        ]
      },
      {
        seriesId,
        datum,
        title: angleName,
        legendItemKey,
        calloutLabelKey,
        calloutLabelName,
        sectorLabelKey,
        sectorLabelName,
        angleKey,
        angleName,
        radiusKey,
        radiusName,
        ...this.getSectorFormat(datum, datumIndex, false)
      }
    );
  }
  legendItemSymbol(datumIndex) {
    const datum = this.processedData?.dataSources.get(this.id)?.[datumIndex];
    const sectorFormat = this.getSectorFormat(datum, datumIndex, false);
    const { fillOpacity, strokeOpacity, strokeWidth, lineDash, lineDashOffset } = this.properties;
    let { fill } = sectorFormat;
    const { stroke: stroke2 } = sectorFormat;
    if (isGradientFill(fill)) {
      fill = { ...fill, gradient: "linear", rotation: 0, reverse: false };
    }
    return {
      marker: {
        fill,
        stroke: stroke2,
        fillOpacity,
        strokeOpacity,
        strokeWidth,
        lineDash,
        lineDashOffset
      }
    };
  }
  getLegendData(legendType) {
    const {
      id: seriesId,
      visible,
      processedData,
      dataModel,
      ctx: { legendManager }
    } = this;
    if (!dataModel || !processedData || legendType !== "category") {
      return [];
    }
    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey, showInLegend } = this.properties;
    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey)) {
      return [];
    }
    const { calloutLabelValues, sectorLabelValues, legendItemValues, angleRawValues } = this.getProcessedDataValues(
      dataModel,
      processedData
    );
    const titleText = this.properties.title?.showInLegend && this.properties.title.text;
    const legendData = [];
    const hideZeros = this.properties.hideZeroValueSectorsInLegend;
    const rawData = processedData.dataSources.get(this.id);
    const invalidData = processedData.invalidData?.get(this.id);
    for (let datumIndex = 0; datumIndex < processedData.input.count; datumIndex++) {
      const datum = rawData?.[datumIndex];
      const angleRawValue = angleRawValues[datumIndex];
      if (invalidData?.[datumIndex] === true || hideZeros && angleRawValue === 0) {
        continue;
      }
      const labelParts = [];
      if (titleText) {
        labelParts.push(titleText);
      }
      const labels = this.getLabels(
        datum,
        2 * Math.PI,
        2 * Math.PI,
        false,
        calloutLabelValues?.[datumIndex],
        sectorLabelValues?.[datumIndex],
        legendItemValues?.[datumIndex]
      );
      if (legendItemKey && labels.legendItem !== void 0) {
        labelParts.push(labels.legendItem.text);
      } else if (calloutLabelKey && calloutLabelKey !== angleKey && labels.calloutLabel?.text !== void 0) {
        labelParts.push(labels.calloutLabel?.text);
      } else if (sectorLabelKey && sectorLabelKey !== angleKey && labels.sectorLabel?.text !== void 0) {
        labelParts.push(labels.sectorLabel?.text);
      }
      if (labelParts.length === 0)
        continue;
      legendData.push({
        legendType: "category",
        id: seriesId,
        datum,
        itemId: datumIndex,
        seriesId,
        hideToggleOtherSeries: true,
        enabled: visible && legendManager.getItemEnabled({ seriesId, itemId: datumIndex }),
        label: {
          text: labelParts.join(" - ")
        },
        symbol: this.legendItemSymbol(datumIndex),
        legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0,
        hideInLegend: !showInLegend
      });
    }
    return legendData;
  }
  // Used for grid
  setLegendState(enabledItems) {
    const {
      id: seriesId,
      ctx: { legendManager, updateService }
    } = this;
    enabledItems.forEach((enabled, itemId) => legendManager.toggleItem(enabled, seriesId, itemId));
    legendManager.update();
    updateService.update(5 /* SERIES_UPDATE */);
  }
  animateEmptyUpdateReady(_data) {
    const { animationManager } = this.ctx;
    const fns = preparePieSeriesAnimationFunctions(
      true,
      this.properties.rotation,
      this.radiusScale,
      this.previousRadiusScale
    );
    fromToMotion(
      this.id,
      "nodes",
      animationManager,
      [this.itemSelection, this.highlightSelection, this.phantomSelection],
      fns.nodes,
      (_, datum) => this.getDatumId(datum.datumIndex)
    );
    seriesLabelFadeInAnimation(this, "callout", animationManager, this.calloutLabelSelection);
    seriesLabelFadeInAnimation(this, "sector", animationManager, this.labelSelection);
    seriesLabelFadeInAnimation(this, "highlight", animationManager, this.highlightLabelSelection);
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  animateWaitingUpdateReady() {
    const { itemSelection, highlightSelection, phantomSelection, processedData, radiusScale, previousRadiusScale } = this;
    const { animationManager } = this.ctx;
    const dataDiff = processedData?.reduced?.diff?.[this.id];
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    const supportedDiff = (dataDiff?.moved.size ?? 0) === 0;
    const hasKeys = (processedData?.defs.keys.length ?? 0) > 0;
    const hasUniqueKeys = processedData?.reduced?.animationValidation?.uniqueKeys ?? true;
    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {
      this.ctx.animationManager.skipCurrentBatch();
    }
    const fns = preparePieSeriesAnimationFunctions(
      false,
      this.properties.rotation,
      radiusScale,
      previousRadiusScale
    );
    fromToMotion(
      this.id,
      "nodes",
      animationManager,
      [itemSelection, highlightSelection, phantomSelection],
      fns.nodes,
      (_, datum) => this.getDatumId(datum.datumIndex),
      dataDiff
    );
    seriesLabelFadeInAnimation(this, "callout", this.ctx.animationManager, this.calloutLabelSelection);
    seriesLabelFadeInAnimation(this, "sector", this.ctx.animationManager, this.labelSelection);
    seriesLabelFadeInAnimation(this, "highlight", this.ctx.animationManager, this.highlightLabelSelection);
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  animateClearingUpdateEmpty() {
    const { itemSelection, highlightSelection, phantomSelection, radiusScale, previousRadiusScale } = this;
    const { animationManager } = this.ctx;
    const fns = preparePieSeriesAnimationFunctions(
      false,
      this.properties.rotation,
      radiusScale,
      previousRadiusScale
    );
    fromToMotion(
      this.id,
      "nodes",
      animationManager,
      [itemSelection, highlightSelection, phantomSelection],
      fns.nodes,
      (_, datum) => this.getDatumId(datum.datumIndex)
    );
    seriesLabelFadeOutAnimation(this, "callout", this.ctx.animationManager, this.calloutLabelSelection);
    seriesLabelFadeOutAnimation(this, "sector", this.ctx.animationManager, this.labelSelection);
    seriesLabelFadeOutAnimation(this, "highlight", this.ctx.animationManager, this.highlightLabelSelection);
    this.previousRadiusScale.range = this.radiusScale.range;
  }
  getDatumId(datumIndex) {
    return `${datumIndex}`;
  }
};
PieSeries.className = "PieSeries";
PieSeries.type = "pie";

// packages/ag-charts-community/src/chart/series/polar/pieSeriesModule.ts
var NewPieSeriesModule = {
  type: "series",
  name: "pie",
  chartType: "polar",
  options: pieSeriesOptionsDef,
  create: (ctx) => new PieSeries(ctx)
};

// packages/ag-charts-community/src/module/axisModules.ts
var import_ag_charts_core145 = require("ag-charts-core");

// packages/ag-charts-community/src/chart/axis/unitTimeAxis.ts
var UnitTimeAxis = class extends CategoryAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new UnitTimeScale());
    this.parentLevel = new TimeAxisParentLevel();
    this.min = void 0;
    this.max = void 0;
  }
  get primaryLabel() {
    return this.parentLevel.enabled ? this.parentLevel.label : void 0;
  }
  get primaryTick() {
    return this.parentLevel.enabled ? this.parentLevel.tick : void 0;
  }
  updateScale() {
    super.updateScale();
    this.scale.interval = this.unit;
  }
  normaliseDataDomain(domain) {
    return normaliseTimeDataDomain(domain, this.min, this.max);
  }
};
UnitTimeAxis.className = "UnitTimeAxis";
UnitTimeAxis.type = "unit-time";
__decorateClass([
  Property
], UnitTimeAxis.prototype, "parentLevel", 2);
__decorateClass([
  Property
], UnitTimeAxis.prototype, "min", 2);
__decorateClass([
  Property
], UnitTimeAxis.prototype, "max", 2);
__decorateClass([
  Property
], UnitTimeAxis.prototype, "unit", 2);

// packages/ag-charts-community/src/module/axisModules.ts
var numberAxisOptionsDefs = {
  ...cartesianAxisOptionsDefs,
  ...continuousAxisOptions(import_ag_charts_core145.number),
  type: (0, import_ag_charts_core145.required)((0, import_ag_charts_core145.constant)("number")),
  label: cartesianNumericAxisLabel,
  crosshair: cartesianAxisCrosshairOptions(true)
};
var logAxisOptionsDefs = {
  ...cartesianAxisOptionsDefs,
  ...continuousAxisOptions(import_ag_charts_core145.number),
  type: (0, import_ag_charts_core145.required)((0, import_ag_charts_core145.constant)("log")),
  base: (0, import_ag_charts_core145.and)(
    import_ag_charts_core145.positiveNumberNonZero,
    (0, import_ag_charts_core145.attachDescription)((value) => value !== 1, "not equal to 1")
  ),
  label: cartesianNumericAxisLabel,
  crosshair: cartesianAxisCrosshairOptions(true)
};
var timeAxisOptionsDefs = {
  ...cartesianAxisOptionsDefs,
  ...continuousAxisOptions((0, import_ag_charts_core145.or)(import_ag_charts_core145.number, import_ag_charts_core145.date), true),
  type: (0, import_ag_charts_core145.required)((0, import_ag_charts_core145.constant)("time")),
  label: cartesianTimeAxisLabel,
  parentLevel: cartesianTimeAxisParentLevel,
  crosshair: cartesianAxisCrosshairOptions(true)
};
timeAxisOptionsDefs.paddingInner = import_ag_charts_core145.positiveNumber;
timeAxisOptionsDefs.paddingOuter = import_ag_charts_core145.positiveNumber;
timeAxisOptionsDefs.groupPaddingInner = import_ag_charts_core145.positiveNumber;
var categoryAxisOptionsDefs = {
  ...cartesianAxisOptionsDefs,
  type: (0, import_ag_charts_core145.required)((0, import_ag_charts_core145.constant)("category")),
  label: cartesianAxisLabelOptionsDefs,
  paddingInner: import_ag_charts_core145.ratio,
  paddingOuter: import_ag_charts_core145.ratio,
  groupPaddingInner: import_ag_charts_core145.ratio,
  crosshair: cartesianAxisCrosshairOptions()
};
var groupedCategoryAxisOptionsDefs = {
  ...cartesianAxisOptionsDefs,
  type: (0, import_ag_charts_core145.required)((0, import_ag_charts_core145.constant)("grouped-category")),
  label: cartesianAxisLabelOptionsDefs,
  crosshair: cartesianAxisCrosshairOptions(),
  paddingInner: import_ag_charts_core145.ratio,
  groupPaddingInner: import_ag_charts_core145.ratio,
  depthOptions: (0, import_ag_charts_core145.arrayOfDefs)(
    {
      label: {
        enabled: import_ag_charts_core145.boolean,
        avoidCollisions: import_ag_charts_core145.boolean,
        rotation: import_ag_charts_core145.number,
        spacing: import_ag_charts_core145.number,
        ...import_ag_charts_core145.fontOptionsDef
      },
      tick: {
        enabled: import_ag_charts_core145.boolean,
        stroke: import_ag_charts_core145.color,
        width: import_ag_charts_core145.positiveNumber
      }
    },
    "depth options objects array"
  )
};
var unitTimeAxisOptionsDefs = {
  ...cartesianAxisOptionsDefs,
  // @todo(AG-14472) - Remove nice
  // ...without(continuousAxisOptions(or(number, date), true), ['nice']),
  ...continuousAxisOptions((0, import_ag_charts_core145.or)(import_ag_charts_core145.number, import_ag_charts_core145.date), true),
  type: (0, import_ag_charts_core145.required)((0, import_ag_charts_core145.constant)("unit-time")),
  unit: (0, import_ag_charts_core145.or)((0, import_ag_charts_core145.instanceOf)(TimeInterval), timeIntervalUnit),
  label: cartesianTimeAxisLabel,
  parentLevel: cartesianTimeAxisParentLevel,
  paddingInner: import_ag_charts_core145.ratio,
  paddingOuter: import_ag_charts_core145.ratio,
  groupPaddingInner: import_ag_charts_core145.ratio,
  crosshair: cartesianAxisCrosshairOptions(true)
};
var mergeOptionsDefs = (a, b) => {
  const out = {};
  for (const key of /* @__PURE__ */ new Set([...Object.keys(a), ...Object.keys(b)])) {
    const aDef = a[key];
    const bDef = b[key];
    if ((0, import_ag_charts_core145.isPlainObject)(aDef) && (0, import_ag_charts_core145.isPlainObject)(bDef)) {
      out[key] = mergeOptionsDefs(aDef, bDef);
    } else if (aDef != null && bDef != null && aDef !== bDef) {
      out[key] = (0, import_ag_charts_core145.or)(aDef, bDef);
    } else {
      out[key] = aDef ?? bDef;
    }
  }
  return out;
};
var timeAxisOptionsCompatibilityDefs = mergeOptionsDefs(timeAxisOptionsDefs, unitTimeAxisOptionsDefs);
var NumberAxisModule = {
  type: "axis",
  name: "number",
  chartType: "cartesian",
  options: numberAxisOptionsDefs,
  create: (ctx) => new NumberAxis(ctx)
};
var LogAxisModule = {
  type: "axis",
  name: "log",
  chartType: "cartesian",
  options: logAxisOptionsDefs,
  create: (ctx) => new LogAxis(ctx)
};
var TimeAxisModule = {
  type: "axis",
  name: "time",
  chartType: "cartesian",
  // @todo(AG-14472) - Replace with timeAxisOptionsDefs,
  options: timeAxisOptionsCompatibilityDefs,
  create: (ctx) => new TimeAxis(ctx)
};
var CategoryAxisModule = {
  type: "axis",
  name: "category",
  chartType: "cartesian",
  options: categoryAxisOptionsDefs,
  create: (ctx) => new CategoryAxis(ctx)
};
var GroupedCategoryAxisModule = {
  type: "axis",
  name: "grouped-category",
  chartType: "cartesian",
  options: groupedCategoryAxisOptionsDefs,
  create: (ctx) => new GroupedCategoryAxis(ctx)
};
var UnitTimeAxisModule = {
  type: "axis",
  name: "unit-time",
  chartType: "cartesian",
  options: unitTimeAxisOptionsDefs,
  create: (ctx) => new UnitTimeAxis(ctx)
};

// packages/ag-charts-community/src/main-modules.ts
var import_ag_charts_core146 = require("ag-charts-core");
var AllCartesianCommunityModules = [
  CartesianChartModule,
  NumberAxisModule,
  LogAxisModule,
  TimeAxisModule,
  CategoryAxisModule,
  GroupedCategoryAxisModule,
  UnitTimeAxisModule,
  NewAreaSeriesModule,
  NewBarSeriesModule,
  NewBubbleSeriesModule,
  NewHistogramSeriesModule,
  NewLineSeriesModule,
  NewScatterSeriesModule
];
var AllPolarCommunityModules = [PolarChartModule, NewDonutSeriesModule, NewPieSeriesModule];
var AllCommunityModules = [
  ...AllCartesianCommunityModules,
  ...AllPolarCommunityModules,
  // Enterprise placeholders
  FlowProportionChartModule,
  GaugeChartModule,
  HierarchyChartModule,
  StandaloneChartModule,
  TopologyChartModule,
  // Presets
  PriceVolumePresetModule,
  GaugePresetModule,
  SparklinePresetModule
];
